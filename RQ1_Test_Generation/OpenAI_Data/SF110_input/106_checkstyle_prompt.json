[
	{
		"original_code": "// AllTests.java\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes;\n\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.blocks.AvoidNestedBlocksTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.blocks.NeedBracesTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.DefaultComesLastTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.EmptyStatementTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.FinalLocalVariableTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.MissingSwitchDefaultTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.StringLiteralEqualityTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.design.DesignForExtensionTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.design.FinalClassTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.misc.ArrayTypeStyleTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.misc.FinalParametersTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.misc.UncommentedMainTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.misc.UpperEllTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.modifier.ModifierOrderTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.modifier.RedundantModifierTest;\nimport junit.framework.Test;\nimport junit.framework.TestSuite;\n\npublic class AllTests {\n\n    public static Test suite() {\n        TestSuite suite = new TestSuite(\"Test for com.atlassw.tools.eclipse.checkstyle.quickfixes\");\n        // $JUnit-BEGIN$\n        // blocks\n        suite.addTestSuite(AvoidNestedBlocksTest.class);\n        suite.addTestSuite(NeedBracesTest.class);\n        // coding\n        suite.addTestSuite(DefaultComesLastTest.class);\n        suite.addTestSuite(EmptyStatementTest.class);\n        suite.addTestSuite(FinalLocalVariableTest.class);\n        suite.addTestSuite(MissingSwitchDefaultTest.class);\n        suite.addTestSuite(StringLiteralEqualityTest.class);\n        // design\n        suite.addTestSuite(DesignForExtensionTest.class);\n        suite.addTestSuite(FinalClassTest.class);\n        // misc\n        suite.addTestSuite(ArrayTypeStyleTest.class);\n        suite.addTestSuite(FinalParametersTest.class);\n        suite.addTestSuite(UncommentedMainTest.class);\n        suite.addTestSuite(UpperEllTest.class);\n        // modifier\n        suite.addTestSuite(ModifierOrderTest.class);\n        suite.addTestSuite(RedundantModifierTest.class);\n        // $JUnit-END$\n        return suite;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/removed-test/com/atlassw/tools/eclipse/checkstyle/quickfixes/AllTests.java",
		"test_prompt": "// AllTestsTest.java\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes;\n\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.blocks.AvoidNestedBlocksTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.blocks.NeedBracesTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.DefaultComesLastTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.EmptyStatementTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.FinalLocalVariableTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.MissingSwitchDefaultTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.coding.StringLiteralEqualityTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.design.DesignForExtensionTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.design.FinalClassTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.misc.ArrayTypeStyleTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.misc.FinalParametersTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.misc.UncommentedMainTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.misc.UpperEllTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.modifier.ModifierOrderTest;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.modifier.RedundantModifierTest;\nimport junit.framework.Test;\nimport junit.framework.TestSuite;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AllTests}.\n* It contains ten unit test cases for the {@link AllTests#suite()} method.\n*/\nclass AllTestsTest {"
	},
	{
		"original_code": "// CheckstylePreferencePage.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.preferences;\n\nimport java.util.Collection;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IEclipsePreferences;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport org.eclipse.core.runtime.preferences.InstanceScope;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.preference.PreferencePage;\nimport org.eclipse.jface.resource.ImageDescriptor;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Combo;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchPreferencePage;\nimport org.osgi.service.prefs.BackingStoreException;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckerFactory;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginImages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.SWTUtil;\n\n/**\n * This class represents a preference page that is contributed to the\n * Preferences dialog. By subclassing <samp>FieldEditorPreferencePage </samp>,\n * we can use the field support built into JFace that allows us to create a page\n * that is small and knows how to save, restore and apply itself.\n * <p>\n * This page is used to modify preferences only. They are stored in the\n * preference store that belongs to the main plug-in class. That way,\n * preferences can be accessed directly via the preference store.\n */\npublic class CheckstylePreferencePage extends PreferencePage implements IWorkbenchPreferencePage {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private Combo mRebuildIfNeeded;\n\n    private Button mPurgeCacheButton;\n\n    private Button mWarnBeforeLosingFilesets;\n\n    private Button mIncludeRuleNamesButton;\n\n    private Button mIncludeModuleIdButton;\n\n    private Button mLimitCheckstyleMarkers;\n\n    private Button mDisableClassloader;\n\n    private Text mTxtMarkerLimit;\n\n    private CheckConfigurationWorkingSetEditor mWorkingSetEditor;\n\n    private PageController mController = new PageController();\n\n    private boolean mRebuildAll = false;\n\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Constructor.\n     */\n    public CheckstylePreferencePage() {\n        super();\n        setPreferenceStore(CheckstylePlugin.getDefault().getPreferenceStore());\n        mWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        initializeDefaults();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Sets the default values of the preferences.\n     */\n    private void initializeDefaults() {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite ancestor) {\n        noDefaultAndApplyButton();\n        //\n        // Build the top level composite with one colume.\n        //\n        Composite parentComposite = new Composite(ancestor, SWT.NULL);\n        FormLayout layout = new FormLayout();\n        parentComposite.setLayout(layout);\n        //\n        // Create the general section of the screen.\n        //\n        Composite generalComposite = createGeneralContents(parentComposite);\n        FormData fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        generalComposite.setLayoutData(fd);\n        //\n        // Create the check configuration section of the screen.\n        //\n        Composite configComposite = createCheckConfigContents(parentComposite);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(generalComposite, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(100);\n        configComposite.setLayoutData(fd);\n        return parentComposite;\n    }\n\n    /**\n     * Create the area with the general preference settings.\n     *\n     * @param parent the parent composite\n     * @return the general area\n     */\n    private Composite createGeneralContents(Composite parent) {\n        //\n        // Build the composite for the general settings.\n        //\n        Group generalComposite = new Group(parent, SWT.NULL);\n        generalComposite.setText(Messages.CheckstylePreferencePage_lblGeneralSettings);\n        GridLayout gridLayout = new GridLayout();\n        gridLayout.numColumns = 1;\n        generalComposite.setLayout(gridLayout);\n        //\n        // Get the preferences.\n        //\n        IPreferencesService prefs = Platform.getPreferencesService();\n        //\n        // Create a combo with the rebuild options\n        //\n        Composite rebuildComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(3, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        rebuildComposite.setLayout(gridLayout);\n        rebuildComposite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        Label lblRebuild = new Label(rebuildComposite, SWT.NULL);\n        lblRebuild.setText(Messages.CheckstylePreferencePage_lblRebuild);\n        mRebuildIfNeeded = new Combo(rebuildComposite, SWT.READ_ONLY);\n        mRebuildIfNeeded.setItems(new String[] { MessageDialogWithToggle.PROMPT, MessageDialogWithToggle.ALWAYS, MessageDialogWithToggle.NEVER });\n        mRebuildIfNeeded.select(mRebuildIfNeeded.indexOf(prefs.getString(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_ASK_BEFORE_REBUILD, MessageDialogWithToggle.PROMPT, null)));\n        //\n        // Create button to purge the checker cache\n        //\n        mPurgeCacheButton = new Button(rebuildComposite, SWT.FLAT);\n        ImageDescriptor descriptor = CheckstylePlugin.imageDescriptorFromPlugin(CheckstylePlugin.PLUGIN_ID, //$NON-NLS-1$\n        \"icons/refresh.gif\");\n        mPurgeCacheButton.setImage(descriptor.createImage());\n        mPurgeCacheButton.setToolTipText(Messages.CheckstylePreferencePage_btnRefreshCheckerCache);\n        mPurgeCacheButton.addSelectionListener(mController);\n        GridData gd = new GridData();\n        gd.horizontalAlignment = GridData.END;\n        gd.grabExcessHorizontalSpace = true;\n        gd.heightHint = 20;\n        gd.widthHint = 20;\n        mPurgeCacheButton.setLayoutData(gd);\n        //\n        // Create the \"Fileset warning\" check box.\n        //\n        mWarnBeforeLosingFilesets = new Button(generalComposite, SWT.CHECK);\n        mWarnBeforeLosingFilesets.setText(Messages.CheckstylePreferencePage_lblWarnFilesets);\n        mWarnBeforeLosingFilesets.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_FILESET_WARNING, true, null));\n        //\n        // Create the \"Include rule name\" check box.\n        //\n        Composite includeRuleNamesComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(2, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        includeRuleNamesComposite.setLayout(gridLayout);\n        mIncludeRuleNamesButton = new Button(includeRuleNamesComposite, SWT.CHECK);\n        mIncludeRuleNamesButton.setText(Messages.CheckstylePreferencePage_lblIncludeRulenames);\n        mIncludeRuleNamesButton.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_INCLUDE_RULE_NAMES, false, null));\n        Label lblRebuildNote = new Label(includeRuleNamesComposite, SWT.NULL);\n        lblRebuildNote.setImage(CheckstylePluginImages.getImage(CheckstylePluginImages.HELP_ICON));\n        lblRebuildNote.setToolTipText(Messages.CheckstylePreferencePage_txtSuggestRebuild);\n        SWTUtil.addTooltipOnPressSupport(lblRebuildNote);\n        //\n        // Create the \"Include rule name\" check box.\n        //\n        Composite includeModuleIdComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(2, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        includeModuleIdComposite.setLayout(gridLayout);\n        mIncludeModuleIdButton = new Button(includeModuleIdComposite, SWT.CHECK);\n        mIncludeModuleIdButton.setText(Messages.CheckstylePreferencePage_lblIncludeModuleIds);\n        mIncludeModuleIdButton.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_INCLUDE_MODULE_IDS, false, null));\n        lblRebuildNote = new Label(includeModuleIdComposite, SWT.NULL);\n        lblRebuildNote.setImage(CheckstylePluginImages.getImage(CheckstylePluginImages.HELP_ICON));\n        lblRebuildNote.setToolTipText(Messages.CheckstylePreferencePage_txtSuggestRebuild);\n        SWTUtil.addTooltipOnPressSupport(lblRebuildNote);\n        //\n        // Create the \"limit markers\" check box and text field combination\n        //\n        Composite limitMarkersComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(3, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        limitMarkersComposite.setLayout(gridLayout);\n        mLimitCheckstyleMarkers = new Button(limitMarkersComposite, SWT.CHECK);\n        mLimitCheckstyleMarkers.setText(Messages.CheckstylePreferencePage_lblLimitMarker);\n        mLimitCheckstyleMarkers.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_LIMIT_MARKERS_PER_RESOURCE, false, null));\n        mTxtMarkerLimit = new Text(limitMarkersComposite, SWT.SINGLE | SWT.BORDER);\n        mTxtMarkerLimit.setTextLimit(5);\n        SWTUtil.addOnlyDigitInputSupport(mTxtMarkerLimit);\n        mTxtMarkerLimit.setText(Integer.toString(prefs.getInt(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_MARKER_AMOUNT_LIMIT, CheckstylePlugin.MARKER_LIMIT, null)));\n        gd = new GridData();\n        gd.widthHint = 30;\n        mTxtMarkerLimit.setLayoutData(gd);\n        lblRebuildNote = new Label(limitMarkersComposite, SWT.NULL);\n        lblRebuildNote.setImage(CheckstylePluginImages.getImage(CheckstylePluginImages.HELP_ICON));\n        lblRebuildNote.setToolTipText(Messages.CheckstylePreferencePage_txtSuggestRebuild);\n        SWTUtil.addTooltipOnPressSupport(lblRebuildNote);\n        //\n        // Create the \"disable classloader\" check box\n        //\n        Composite disableClassloaderComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(2, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        disableClassloaderComposite.setLayout(gridLayout);\n        mDisableClassloader = new Button(disableClassloaderComposite, SWT.CHECK);\n        mDisableClassloader.setText(Messages.CheckstylePreferencePage_lblDisableClassloader);\n        mDisableClassloader.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_DISABLE_PROJ_CLASSLOADER, false, null));\n        mDisableClassloader.setToolTipText(Messages.CheckstylePreferencePage_lblDisableClassloaderNote);\n        Label lblDisableClassloader = new Label(disableClassloaderComposite, SWT.NULL);\n        lblDisableClassloader.setImage(CheckstylePluginImages.getImage(CheckstylePluginImages.HELP_ICON));\n        lblDisableClassloader.setToolTipText(Messages.CheckstylePreferencePage_lblDisableClassloaderNote);\n        SWTUtil.addTooltipOnPressSupport(lblDisableClassloader);\n        return generalComposite;\n    }\n\n    /**\n     * Creates the content regarding the management of check configurations.\n     *\n     * @param parent the parent composite\n     * @return the configuration area\n     */\n    private Composite createCheckConfigContents(Composite parent) {\n        //\n        // Create the composite for configuring check configurations.\n        //\n        Group configComposite = new Group(parent, SWT.NULL);\n        configComposite.setText(Messages.CheckstylePreferencePage_titleCheckConfigs);\n        configComposite.setLayout(new FormLayout());\n        mWorkingSetEditor = new CheckConfigurationWorkingSetEditor(mWorkingSet, true);\n        Control editorControl = mWorkingSetEditor.createContents(configComposite);\n        FormData fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(100, -3);\n        fd.bottom = new FormAttachment(100, -3);\n        editorControl.setLayoutData(fd);\n        return configComposite;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void init(IWorkbench workbench) {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean performOk() {\n        try {\n            //\n            // Save the check configurations.\n            //\n            mWorkingSet.store();\n            //\n            // Save the general preferences.\n            //\n            IPreferencesService prefService = Platform.getPreferencesService();\n            IEclipsePreferences prefs = new InstanceScope().getNode(CheckstylePlugin.PLUGIN_ID);\n            prefs.put(CheckstylePlugin.PREF_ASK_BEFORE_REBUILD, mRebuildIfNeeded.getItem(mRebuildIfNeeded.getSelectionIndex()));\n            //\n            // Save the classloader preferences.\n            //\n            prefs.putBoolean(CheckstylePlugin.PREF_DISABLE_PROJ_CLASSLOADER, mDisableClassloader.getSelection());\n            //\n            // fileset warning preference\n            //\n            boolean warnFileSetsNow = mWarnBeforeLosingFilesets.getSelection();\n            prefs.putBoolean(CheckstylePlugin.PREF_FILESET_WARNING, warnFileSetsNow);\n            //\n            // Include rule names preference.\n            //\n            boolean includeRuleNamesNow = mIncludeRuleNamesButton.getSelection();\n            boolean includeRuleNamesOriginal = prefService.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_INCLUDE_RULE_NAMES, false, null);\n            prefs.putBoolean(CheckstylePlugin.PREF_INCLUDE_RULE_NAMES, includeRuleNamesNow);\n            //\n            // Include module id preference.\n            //\n            boolean includeModuleIdNow = mIncludeModuleIdButton.getSelection();\n            boolean includeModuleIdOriginal = prefService.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_INCLUDE_MODULE_IDS, false, null);\n            prefs.putBoolean(CheckstylePlugin.PREF_INCLUDE_MODULE_IDS, includeModuleIdNow);\n            //\n            // Limit markers preference\n            //\n            boolean limitMarkersNow = mLimitCheckstyleMarkers.getSelection();\n            boolean limitMarkersOriginal = prefService.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_LIMIT_MARKERS_PER_RESOURCE, false, null);\n            prefs.putBoolean(CheckstylePlugin.PREF_LIMIT_MARKERS_PER_RESOURCE, limitMarkersNow);\n            int markerLimitNow = Integer.parseInt(mTxtMarkerLimit.getText());\n            int markerLimitOriginal = prefService.getInt(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_MARKER_AMOUNT_LIMIT, CheckstylePlugin.MARKER_LIMIT, null);\n            prefs.putInt(CheckstylePlugin.PREF_MARKER_AMOUNT_LIMIT, markerLimitNow);\n            // save the preferences\n            prefs.flush();\n            // See if all projects need rebuild\n            boolean needRebuildAllProjects = (includeRuleNamesNow != includeRuleNamesOriginal) || (includeModuleIdNow != includeModuleIdOriginal) || (limitMarkersNow != limitMarkersOriginal) || (markerLimitNow != markerLimitOriginal) || mRebuildAll;\n            // Get projects that need rebuild considering the changes\n            Collection projectsToBuild = mWorkingSet.getAffectedProjects();\n            IPreferenceStore prefStore = CheckstylePlugin.getDefault().getPreferenceStore();\n            String promptRebuildPref = prefStore.getString(CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n            boolean rebuild = MessageDialogWithToggle.ALWAYS.equals(promptRebuildPref) && (needRebuildAllProjects || projectsToBuild.size() > 0);\n            //\n            // Prompt for rebuild\n            //\n            if (MessageDialogWithToggle.PROMPT.equals(promptRebuildPref) && (needRebuildAllProjects || projectsToBuild.size() > 0)) {\n                MessageDialogWithToggle dialog = MessageDialogWithToggle.openYesNoQuestion(getShell(), Messages.CheckstylePreferencePage_titleRebuild, Messages.CheckstylePreferencePage_msgRebuild, Messages.CheckstylePreferencePage_nagRebuild, false, prefStore, CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n                rebuild = dialog.getReturnCode() == IDialogConstants.YES_ID;\n            }\n            if (rebuild) {\n                try {\n                    if (needRebuildAllProjects) {\n                        CheckstyleBuilder.buildAllProjects();\n                    } else {\n                        CheckstyleBuilder.buildProjects(projectsToBuild);\n                    }\n                } catch (CheckstylePluginException e) {\n                    CheckstyleLog.errorDialog(getShell(), NLS.bind(ErrorMessages.errorFailedRebuild, e.getMessage()), e, true);\n                }\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), NLS.bind(ErrorMessages.errorFailedSavePreferences, e.getLocalizedMessage()), e, true);\n        } catch (BackingStoreException e) {\n            CheckstyleLog.errorDialog(getShell(), NLS.bind(ErrorMessages.errorFailedSavePreferences, e.getLocalizedMessage()), e, true);\n        }\n        return true;\n    }\n\n    /**\n     * Controller for this page.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class PageController extends SelectionAdapter {\n\n        /**\n         * {@inheritDoc}\n         */\n        public void widgetSelected(SelectionEvent e) {\n            if (mPurgeCacheButton == e.widget) {\n                CheckerFactory.cleanup();\n                MetadataFactory.refresh();\n                CustomLibrariesClassLoader.invalidate();\n                PackageNamesLoader.refresh();\n                mRebuildAll = true;\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/preferences/CheckstylePreferencePage_0Test.java",
		"test_prompt": "// CheckstylePreferencePage_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.preferences;\n\nimport java.util.Collection;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IEclipsePreferences;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport org.eclipse.core.runtime.preferences.InstanceScope;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.preference.PreferencePage;\nimport org.eclipse.jface.resource.ImageDescriptor;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Combo;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchPreferencePage;\nimport org.osgi.service.prefs.BackingStoreException;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckerFactory;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginImages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.SWTUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstylePreferencePage}.\n* It contains ten unit test cases for the {@link CheckstylePreferencePage#createContents(Composite)} method.\n*/\nclass CheckstylePreferencePage_0Test {"
	},
	{
		"original_code": "// CheckstylePreferencePage.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.preferences;\n\nimport java.util.Collection;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IEclipsePreferences;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport org.eclipse.core.runtime.preferences.InstanceScope;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.preference.PreferencePage;\nimport org.eclipse.jface.resource.ImageDescriptor;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Combo;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchPreferencePage;\nimport org.osgi.service.prefs.BackingStoreException;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckerFactory;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginImages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.SWTUtil;\n\n/**\n * This class represents a preference page that is contributed to the\n * Preferences dialog. By subclassing <samp>FieldEditorPreferencePage </samp>,\n * we can use the field support built into JFace that allows us to create a page\n * that is small and knows how to save, restore and apply itself.\n * <p>\n * This page is used to modify preferences only. They are stored in the\n * preference store that belongs to the main plug-in class. That way,\n * preferences can be accessed directly via the preference store.\n */\npublic class CheckstylePreferencePage extends PreferencePage implements IWorkbenchPreferencePage {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private Combo mRebuildIfNeeded;\n\n    private Button mPurgeCacheButton;\n\n    private Button mWarnBeforeLosingFilesets;\n\n    private Button mIncludeRuleNamesButton;\n\n    private Button mIncludeModuleIdButton;\n\n    private Button mLimitCheckstyleMarkers;\n\n    private Button mDisableClassloader;\n\n    private Text mTxtMarkerLimit;\n\n    private CheckConfigurationWorkingSetEditor mWorkingSetEditor;\n\n    private PageController mController = new PageController();\n\n    private boolean mRebuildAll = false;\n\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Constructor.\n     */\n    public CheckstylePreferencePage() {\n        super();\n        setPreferenceStore(CheckstylePlugin.getDefault().getPreferenceStore());\n        mWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        initializeDefaults();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Sets the default values of the preferences.\n     */\n    private void initializeDefaults() {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite ancestor) {\n        noDefaultAndApplyButton();\n        //\n        // Build the top level composite with one colume.\n        //\n        Composite parentComposite = new Composite(ancestor, SWT.NULL);\n        FormLayout layout = new FormLayout();\n        parentComposite.setLayout(layout);\n        //\n        // Create the general section of the screen.\n        //\n        Composite generalComposite = createGeneralContents(parentComposite);\n        FormData fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        generalComposite.setLayoutData(fd);\n        //\n        // Create the check configuration section of the screen.\n        //\n        Composite configComposite = createCheckConfigContents(parentComposite);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(generalComposite, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(100);\n        configComposite.setLayoutData(fd);\n        return parentComposite;\n    }\n\n    /**\n     * Create the area with the general preference settings.\n     *\n     * @param parent the parent composite\n     * @return the general area\n     */\n    private Composite createGeneralContents(Composite parent) {\n        //\n        // Build the composite for the general settings.\n        //\n        Group generalComposite = new Group(parent, SWT.NULL);\n        generalComposite.setText(Messages.CheckstylePreferencePage_lblGeneralSettings);\n        GridLayout gridLayout = new GridLayout();\n        gridLayout.numColumns = 1;\n        generalComposite.setLayout(gridLayout);\n        //\n        // Get the preferences.\n        //\n        IPreferencesService prefs = Platform.getPreferencesService();\n        //\n        // Create a combo with the rebuild options\n        //\n        Composite rebuildComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(3, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        rebuildComposite.setLayout(gridLayout);\n        rebuildComposite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        Label lblRebuild = new Label(rebuildComposite, SWT.NULL);\n        lblRebuild.setText(Messages.CheckstylePreferencePage_lblRebuild);\n        mRebuildIfNeeded = new Combo(rebuildComposite, SWT.READ_ONLY);\n        mRebuildIfNeeded.setItems(new String[] { MessageDialogWithToggle.PROMPT, MessageDialogWithToggle.ALWAYS, MessageDialogWithToggle.NEVER });\n        mRebuildIfNeeded.select(mRebuildIfNeeded.indexOf(prefs.getString(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_ASK_BEFORE_REBUILD, MessageDialogWithToggle.PROMPT, null)));\n        //\n        // Create button to purge the checker cache\n        //\n        mPurgeCacheButton = new Button(rebuildComposite, SWT.FLAT);\n        ImageDescriptor descriptor = CheckstylePlugin.imageDescriptorFromPlugin(CheckstylePlugin.PLUGIN_ID, //$NON-NLS-1$\n        \"icons/refresh.gif\");\n        mPurgeCacheButton.setImage(descriptor.createImage());\n        mPurgeCacheButton.setToolTipText(Messages.CheckstylePreferencePage_btnRefreshCheckerCache);\n        mPurgeCacheButton.addSelectionListener(mController);\n        GridData gd = new GridData();\n        gd.horizontalAlignment = GridData.END;\n        gd.grabExcessHorizontalSpace = true;\n        gd.heightHint = 20;\n        gd.widthHint = 20;\n        mPurgeCacheButton.setLayoutData(gd);\n        //\n        // Create the \"Fileset warning\" check box.\n        //\n        mWarnBeforeLosingFilesets = new Button(generalComposite, SWT.CHECK);\n        mWarnBeforeLosingFilesets.setText(Messages.CheckstylePreferencePage_lblWarnFilesets);\n        mWarnBeforeLosingFilesets.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_FILESET_WARNING, true, null));\n        //\n        // Create the \"Include rule name\" check box.\n        //\n        Composite includeRuleNamesComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(2, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        includeRuleNamesComposite.setLayout(gridLayout);\n        mIncludeRuleNamesButton = new Button(includeRuleNamesComposite, SWT.CHECK);\n        mIncludeRuleNamesButton.setText(Messages.CheckstylePreferencePage_lblIncludeRulenames);\n        mIncludeRuleNamesButton.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_INCLUDE_RULE_NAMES, false, null));\n        Label lblRebuildNote = new Label(includeRuleNamesComposite, SWT.NULL);\n        lblRebuildNote.setImage(CheckstylePluginImages.getImage(CheckstylePluginImages.HELP_ICON));\n        lblRebuildNote.setToolTipText(Messages.CheckstylePreferencePage_txtSuggestRebuild);\n        SWTUtil.addTooltipOnPressSupport(lblRebuildNote);\n        //\n        // Create the \"Include rule name\" check box.\n        //\n        Composite includeModuleIdComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(2, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        includeModuleIdComposite.setLayout(gridLayout);\n        mIncludeModuleIdButton = new Button(includeModuleIdComposite, SWT.CHECK);\n        mIncludeModuleIdButton.setText(Messages.CheckstylePreferencePage_lblIncludeModuleIds);\n        mIncludeModuleIdButton.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_INCLUDE_MODULE_IDS, false, null));\n        lblRebuildNote = new Label(includeModuleIdComposite, SWT.NULL);\n        lblRebuildNote.setImage(CheckstylePluginImages.getImage(CheckstylePluginImages.HELP_ICON));\n        lblRebuildNote.setToolTipText(Messages.CheckstylePreferencePage_txtSuggestRebuild);\n        SWTUtil.addTooltipOnPressSupport(lblRebuildNote);\n        //\n        // Create the \"limit markers\" check box and text field combination\n        //\n        Composite limitMarkersComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(3, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        limitMarkersComposite.setLayout(gridLayout);\n        mLimitCheckstyleMarkers = new Button(limitMarkersComposite, SWT.CHECK);\n        mLimitCheckstyleMarkers.setText(Messages.CheckstylePreferencePage_lblLimitMarker);\n        mLimitCheckstyleMarkers.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_LIMIT_MARKERS_PER_RESOURCE, false, null));\n        mTxtMarkerLimit = new Text(limitMarkersComposite, SWT.SINGLE | SWT.BORDER);\n        mTxtMarkerLimit.setTextLimit(5);\n        SWTUtil.addOnlyDigitInputSupport(mTxtMarkerLimit);\n        mTxtMarkerLimit.setText(Integer.toString(prefs.getInt(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_MARKER_AMOUNT_LIMIT, CheckstylePlugin.MARKER_LIMIT, null)));\n        gd = new GridData();\n        gd.widthHint = 30;\n        mTxtMarkerLimit.setLayoutData(gd);\n        lblRebuildNote = new Label(limitMarkersComposite, SWT.NULL);\n        lblRebuildNote.setImage(CheckstylePluginImages.getImage(CheckstylePluginImages.HELP_ICON));\n        lblRebuildNote.setToolTipText(Messages.CheckstylePreferencePage_txtSuggestRebuild);\n        SWTUtil.addTooltipOnPressSupport(lblRebuildNote);\n        //\n        // Create the \"disable classloader\" check box\n        //\n        Composite disableClassloaderComposite = new Composite(generalComposite, SWT.NULL);\n        gridLayout = new GridLayout(2, false);\n        gridLayout.marginHeight = 0;\n        gridLayout.marginWidth = 0;\n        disableClassloaderComposite.setLayout(gridLayout);\n        mDisableClassloader = new Button(disableClassloaderComposite, SWT.CHECK);\n        mDisableClassloader.setText(Messages.CheckstylePreferencePage_lblDisableClassloader);\n        mDisableClassloader.setSelection(prefs.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_DISABLE_PROJ_CLASSLOADER, false, null));\n        mDisableClassloader.setToolTipText(Messages.CheckstylePreferencePage_lblDisableClassloaderNote);\n        Label lblDisableClassloader = new Label(disableClassloaderComposite, SWT.NULL);\n        lblDisableClassloader.setImage(CheckstylePluginImages.getImage(CheckstylePluginImages.HELP_ICON));\n        lblDisableClassloader.setToolTipText(Messages.CheckstylePreferencePage_lblDisableClassloaderNote);\n        SWTUtil.addTooltipOnPressSupport(lblDisableClassloader);\n        return generalComposite;\n    }\n\n    /**\n     * Creates the content regarding the management of check configurations.\n     *\n     * @param parent the parent composite\n     * @return the configuration area\n     */\n    private Composite createCheckConfigContents(Composite parent) {\n        //\n        // Create the composite for configuring check configurations.\n        //\n        Group configComposite = new Group(parent, SWT.NULL);\n        configComposite.setText(Messages.CheckstylePreferencePage_titleCheckConfigs);\n        configComposite.setLayout(new FormLayout());\n        mWorkingSetEditor = new CheckConfigurationWorkingSetEditor(mWorkingSet, true);\n        Control editorControl = mWorkingSetEditor.createContents(configComposite);\n        FormData fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(100, -3);\n        fd.bottom = new FormAttachment(100, -3);\n        editorControl.setLayoutData(fd);\n        return configComposite;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void init(IWorkbench workbench) {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean performOk() {\n        try {\n            //\n            // Save the check configurations.\n            //\n            mWorkingSet.store();\n            //\n            // Save the general preferences.\n            //\n            IPreferencesService prefService = Platform.getPreferencesService();\n            IEclipsePreferences prefs = new InstanceScope().getNode(CheckstylePlugin.PLUGIN_ID);\n            prefs.put(CheckstylePlugin.PREF_ASK_BEFORE_REBUILD, mRebuildIfNeeded.getItem(mRebuildIfNeeded.getSelectionIndex()));\n            //\n            // Save the classloader preferences.\n            //\n            prefs.putBoolean(CheckstylePlugin.PREF_DISABLE_PROJ_CLASSLOADER, mDisableClassloader.getSelection());\n            //\n            // fileset warning preference\n            //\n            boolean warnFileSetsNow = mWarnBeforeLosingFilesets.getSelection();\n            prefs.putBoolean(CheckstylePlugin.PREF_FILESET_WARNING, warnFileSetsNow);\n            //\n            // Include rule names preference.\n            //\n            boolean includeRuleNamesNow = mIncludeRuleNamesButton.getSelection();\n            boolean includeRuleNamesOriginal = prefService.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_INCLUDE_RULE_NAMES, false, null);\n            prefs.putBoolean(CheckstylePlugin.PREF_INCLUDE_RULE_NAMES, includeRuleNamesNow);\n            //\n            // Include module id preference.\n            //\n            boolean includeModuleIdNow = mIncludeModuleIdButton.getSelection();\n            boolean includeModuleIdOriginal = prefService.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_INCLUDE_MODULE_IDS, false, null);\n            prefs.putBoolean(CheckstylePlugin.PREF_INCLUDE_MODULE_IDS, includeModuleIdNow);\n            //\n            // Limit markers preference\n            //\n            boolean limitMarkersNow = mLimitCheckstyleMarkers.getSelection();\n            boolean limitMarkersOriginal = prefService.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_LIMIT_MARKERS_PER_RESOURCE, false, null);\n            prefs.putBoolean(CheckstylePlugin.PREF_LIMIT_MARKERS_PER_RESOURCE, limitMarkersNow);\n            int markerLimitNow = Integer.parseInt(mTxtMarkerLimit.getText());\n            int markerLimitOriginal = prefService.getInt(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_MARKER_AMOUNT_LIMIT, CheckstylePlugin.MARKER_LIMIT, null);\n            prefs.putInt(CheckstylePlugin.PREF_MARKER_AMOUNT_LIMIT, markerLimitNow);\n            // save the preferences\n            prefs.flush();\n            // See if all projects need rebuild\n            boolean needRebuildAllProjects = (includeRuleNamesNow != includeRuleNamesOriginal) || (includeModuleIdNow != includeModuleIdOriginal) || (limitMarkersNow != limitMarkersOriginal) || (markerLimitNow != markerLimitOriginal) || mRebuildAll;\n            // Get projects that need rebuild considering the changes\n            Collection projectsToBuild = mWorkingSet.getAffectedProjects();\n            IPreferenceStore prefStore = CheckstylePlugin.getDefault().getPreferenceStore();\n            String promptRebuildPref = prefStore.getString(CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n            boolean rebuild = MessageDialogWithToggle.ALWAYS.equals(promptRebuildPref) && (needRebuildAllProjects || projectsToBuild.size() > 0);\n            //\n            // Prompt for rebuild\n            //\n            if (MessageDialogWithToggle.PROMPT.equals(promptRebuildPref) && (needRebuildAllProjects || projectsToBuild.size() > 0)) {\n                MessageDialogWithToggle dialog = MessageDialogWithToggle.openYesNoQuestion(getShell(), Messages.CheckstylePreferencePage_titleRebuild, Messages.CheckstylePreferencePage_msgRebuild, Messages.CheckstylePreferencePage_nagRebuild, false, prefStore, CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n                rebuild = dialog.getReturnCode() == IDialogConstants.YES_ID;\n            }\n            if (rebuild) {\n                try {\n                    if (needRebuildAllProjects) {\n                        CheckstyleBuilder.buildAllProjects();\n                    } else {\n                        CheckstyleBuilder.buildProjects(projectsToBuild);\n                    }\n                } catch (CheckstylePluginException e) {\n                    CheckstyleLog.errorDialog(getShell(), NLS.bind(ErrorMessages.errorFailedRebuild, e.getMessage()), e, true);\n                }\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), NLS.bind(ErrorMessages.errorFailedSavePreferences, e.getLocalizedMessage()), e, true);\n        } catch (BackingStoreException e) {\n            CheckstyleLog.errorDialog(getShell(), NLS.bind(ErrorMessages.errorFailedSavePreferences, e.getLocalizedMessage()), e, true);\n        }\n        return true;\n    }\n\n    /**\n     * Controller for this page.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class PageController extends SelectionAdapter {\n\n        /**\n         * {@inheritDoc}\n         */\n        public void widgetSelected(SelectionEvent e) {\n            if (mPurgeCacheButton == e.widget) {\n                CheckerFactory.cleanup();\n                MetadataFactory.refresh();\n                CustomLibrariesClassLoader.invalidate();\n                PackageNamesLoader.refresh();\n                mRebuildAll = true;\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/preferences/CheckstylePreferencePage_1Test.java",
		"test_prompt": "// CheckstylePreferencePage_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.preferences;\n\nimport java.util.Collection;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IEclipsePreferences;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport org.eclipse.core.runtime.preferences.InstanceScope;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.preference.PreferencePage;\nimport org.eclipse.jface.resource.ImageDescriptor;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Combo;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchPreferencePage;\nimport org.osgi.service.prefs.BackingStoreException;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckerFactory;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginImages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.SWTUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstylePreferencePage}.\n* It contains ten unit test cases for the {@link CheckstylePreferencePage#performOk()} method.\n*/\nclass CheckstylePreferencePage_1Test {"
	},
	{
		"original_code": "// CheckstyleMarkerResolutionGenerator.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport org.eclipse.core.resources.IMarker;\nimport org.eclipse.ui.IMarkerResolution;\nimport org.eclipse.ui.IMarkerResolutionGenerator2;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleMarker;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.RuleMetadata;\n\n/**\n * Profides marker resolutions (quickfixes) for Checkstyle markers.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckstyleMarkerResolutionGenerator implements IMarkerResolutionGenerator2 {\n\n    /**\n     * {@inheritDoc}\n     */\n    public IMarkerResolution[] getResolutions(IMarker marker) {\n        Collection fixes = new ArrayList();\n        // get all fixes that apply to this marker instance\n        String moduleName = marker.getAttribute(CheckstyleMarker.MODULE_NAME, null);\n        RuleMetadata metadata = MetadataFactory.getRuleMetadata(moduleName);\n        Collection quickfixes = metadata.getQuickfixes();\n        Iterator it = quickfixes.iterator();\n        while (it.hasNext()) {\n            ICheckstyleMarkerResolution fix = (ICheckstyleMarkerResolution) it.next();\n            if (fix.canFix(marker)) {\n                fixes.add(fix);\n            }\n        }\n        return (ICheckstyleMarkerResolution[]) fixes.toArray(new ICheckstyleMarkerResolution[fixes.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean hasResolutions(IMarker marker) {\n        boolean hasAtLeastOneFix = false;\n        // check if there is at least one fix that really applies to the module\n        String moduleName = marker.getAttribute(CheckstyleMarker.MODULE_NAME, null);\n        RuleMetadata metadata = MetadataFactory.getRuleMetadata(moduleName);\n        if (metadata != null) {\n            Collection quickfixes = metadata.getQuickfixes();\n            Iterator it = quickfixes.iterator();\n            while (it.hasNext()) {\n                ICheckstyleMarkerResolution fix = (ICheckstyleMarkerResolution) it.next();\n                if (fix.canFix(marker)) {\n                    hasAtLeastOneFix = true;\n                    break;\n                }\n            }\n        }\n        return hasAtLeastOneFix;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/quickfixes/CheckstyleMarkerResolutionGenerator.java",
		"test_prompt": "// CheckstyleMarkerResolutionGeneratorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport org.eclipse.core.resources.IMarker;\nimport org.eclipse.ui.IMarkerResolution;\nimport org.eclipse.ui.IMarkerResolutionGenerator2;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleMarker;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.RuleMetadata;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstyleMarkerResolutionGenerator}.\n* It contains ten unit test cases for the {@link CheckstyleMarkerResolutionGenerator#hasResolutions(IMarker)} method.\n*/\nclass CheckstyleMarkerResolutionGeneratorTest {"
	},
	{
		"original_code": "// ModifierOrderQuickfix.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes.modifier;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.jdt.core.dom.ASTNode;\nimport org.eclipse.jdt.core.dom.ASTVisitor;\nimport org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;\nimport org.eclipse.jdt.core.dom.BodyDeclaration;\nimport org.eclipse.jdt.core.dom.FieldDeclaration;\nimport org.eclipse.jdt.core.dom.MethodDeclaration;\nimport org.eclipse.jdt.core.dom.Modifier;\nimport org.eclipse.jdt.core.dom.TypeDeclaration;\nimport org.eclipse.jdt.core.dom.Modifier.ModifierKeyword;\nimport org.eclipse.jface.text.IRegion;\nimport org.eclipse.swt.graphics.Image;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.AbstractASTResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginImages;\n\n/**\n * Quickfix implementation that orders modifiers into the suggested order by the\n * JLS.\n *\n * @author Lars K�dderitzsch\n */\npublic class ModifierOrderQuickfix extends AbstractASTResolution {\n\n    /**\n     * List containing modifier keywords in the order proposed by Java Language\n     * specification, sections 8.1.1, 8.3.1 and 8.4.3.\n     */\n    private static final List MODIFIER_ORDER = Arrays.asList(new Object[] { ModifierKeyword.PUBLIC_KEYWORD, ModifierKeyword.PROTECTED_KEYWORD, ModifierKeyword.PRIVATE_KEYWORD, ModifierKeyword.ABSTRACT_KEYWORD, ModifierKeyword.STATIC_KEYWORD, ModifierKeyword.FINAL_KEYWORD, ModifierKeyword.TRANSIENT_KEYWORD, ModifierKeyword.VOLATILE_KEYWORD, ModifierKeyword.SYNCHRONIZED_KEYWORD, ModifierKeyword.NATIVE_KEYWORD, ModifierKeyword.STRICTFP_KEYWORD });\n\n    /**\n     * The length of the javadoc comment declaration.\n     */\n    private static final int JAVADOC_COMMENT_LENGTH = 6;\n\n    /**\n     * Reorders the given list of <code>Modifier</code> nodes into their\n     * suggested order by the JLS.\n     *\n     * @param modifiers the list of modifiers to reorder\n     * @return the reordered list of modifiers\n     */\n    public static List reOrderModifiers(List modifiers) {\n        List copies = new ArrayList();\n        Iterator it = modifiers.iterator();\n        while (it.hasNext()) {\n            ASTNode mod = (ASTNode) it.next();\n            copies.add(ASTNode.copySubtree(mod.getAST(), mod));\n        }\n        // oder modifiers to correct order\n        Collections.sort(copies, new Comparator() {\n\n            public int compare(Object arg0, Object arg1) {\n                if (!(arg0 instanceof Modifier) || !(arg1 instanceof Modifier)) {\n                    return 0;\n                }\n                Modifier m1 = (Modifier) arg0;\n                Modifier m2 = (Modifier) arg1;\n                int modifierIndex1 = MODIFIER_ORDER.indexOf(m1.getKeyword());\n                int modifierIndex2 = MODIFIER_ORDER.indexOf(m2.getKeyword());\n                return new Integer(modifierIndex1).compareTo(new Integer(modifierIndex2));\n            }\n        });\n        return copies;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected ASTVisitor handleGetCorrectingASTVisitor(final IRegion lineInfo, final int markerStartOffset) {\n        return new ASTVisitor() {\n\n            public boolean visit(TypeDeclaration node) {\n                return visitBodyDecl(node);\n            }\n\n            public boolean visit(MethodDeclaration node) {\n                return visitBodyDecl(node);\n            }\n\n            public boolean visit(FieldDeclaration node) {\n                return visitBodyDecl(node);\n            }\n\n            public boolean visit(AnnotationTypeMemberDeclaration node) {\n                return visitBodyDecl(node);\n            }\n\n            private boolean visitBodyDecl(BodyDeclaration node) {\n                // recalculate start position because optional javadoc is mixed\n                // into the original start position\n                int pos = node.getStartPosition() + (node.getJavadoc() != null ? node.getJavadoc().getLength() + JAVADOC_COMMENT_LENGTH : 0);\n                if (containsPosition(lineInfo, pos)) {\n                    List reorderedModifiers = reOrderModifiers(node.modifiers());\n                    node.modifiers().clear();\n                    node.modifiers().addAll(reorderedModifiers);\n                }\n                return true;\n            }\n        };\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return Messages.ModifierOrderQuickfix_description;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLabel() {\n        return Messages.ModifierOrderQuickfix_label;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Image getImage() {\n        return CheckstylePluginImages.getImage(CheckstylePluginImages.CORRECTION_CHANGE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/quickfixes/modifier/ModifierOrderQuickfix.java",
		"test_prompt": "// ModifierOrderQuickfixTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes.modifier;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.jdt.core.dom.ASTNode;\nimport org.eclipse.jdt.core.dom.ASTVisitor;\nimport org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;\nimport org.eclipse.jdt.core.dom.BodyDeclaration;\nimport org.eclipse.jdt.core.dom.FieldDeclaration;\nimport org.eclipse.jdt.core.dom.MethodDeclaration;\nimport org.eclipse.jdt.core.dom.Modifier;\nimport org.eclipse.jdt.core.dom.TypeDeclaration;\nimport org.eclipse.jdt.core.dom.Modifier.ModifierKeyword;\nimport org.eclipse.jface.text.IRegion;\nimport org.eclipse.swt.graphics.Image;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.AbstractASTResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginImages;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ModifierOrderQuickfix}.\n* It contains ten unit test cases for the {@link ModifierOrderQuickfix#reOrderModifiers(List)} method.\n*/\nclass ModifierOrderQuickfixTest {"
	},
	{
		"original_code": "// FixCheckstyleMarkersJob.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IMarker;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.ui.progress.UIJob;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleMarker;\n\n/**\n * Job implementation that tries to fix all Checkstyle markers in a file.\n *\n * @author Lars K�dderitzsch\n */\npublic class FixCheckstyleMarkersJob extends UIJob {\n\n    private IFile mFile;\n\n    /**\n     * Creates the job.\n     *\n     * @param file the file to fix\n     */\n    public FixCheckstyleMarkersJob(IFile file) {\n        super(Messages.FixCheckstyleMarkersJob_title);\n        this.mFile = file;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IStatus runInUIThread(IProgressMonitor monitor) {\n        try {\n            CheckstyleMarkerResolutionGenerator generator = new CheckstyleMarkerResolutionGenerator();\n            IMarker[] markers = mFile.findMarkers(CheckstyleMarker.MARKER_ID, true, IResource.DEPTH_INFINITE);\n            for (int i = 0, size = markers.length; i < size; i++) {\n                ICheckstyleMarkerResolution[] resolutions = (ICheckstyleMarkerResolution[]) generator.getResolutions(markers[i]);\n                for (int j = 0, size2 = resolutions.length; j < size2; j++) {\n                    resolutions[j].run(markers[i]);\n                    // stop after the first fix for this marker\n                    break;\n                }\n            }\n        } catch (CoreException e) {\n            return new Status(IStatus.ERROR, CheckstylePlugin.PLUGIN_ID, IStatus.OK, e.getMessage(), e);\n        }\n        return Status.OK_STATUS;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/quickfixes/FixCheckstyleMarkersJob.java",
		"test_prompt": "// FixCheckstyleMarkersJobTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IMarker;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.ui.progress.UIJob;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleMarker;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FixCheckstyleMarkersJob}.\n* It contains ten unit test cases for the {@link FixCheckstyleMarkersJob#runInUIThread(IProgressMonitor)} method.\n*/\nclass FixCheckstyleMarkersJobTest {"
	},
	{
		"original_code": "// FixCheckstyleMarkersHandler.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes;\n\nimport org.eclipse.core.commands.AbstractHandler;\nimport org.eclipse.core.commands.ExecutionEvent;\nimport org.eclipse.core.commands.ExecutionException;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.ui.IEditorInput;\nimport org.eclipse.ui.IEditorPart;\nimport org.eclipse.ui.IWorkbenchPage;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.PlatformUI;\nimport org.eclipse.ui.part.FileEditorInput;\nimport org.eclipse.ui.texteditor.ITextEditor;\n\n/**\n * Command handler to enable key-binding support for the \"Apply Checkstyle\n * fixes\" action.\n *\n * @author Lars K�dderitzsch\n */\npublic class FixCheckstyleMarkersHandler extends AbstractHandler {\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object execute(ExecutionEvent arg0) throws ExecutionException {\n        ITextEditor editor = getActiveEditor();\n        IEditorInput input = editor.getEditorInput();\n        if (input instanceof FileEditorInput) {\n            IFile file = ((FileEditorInput) input).getFile();\n            // call the fixing job\n            Job job = new FixCheckstyleMarkersJob(file);\n            job.setUser(true);\n            job.schedule();\n        }\n        return null;\n    }\n\n    private ITextEditor getActiveEditor() {\n        IWorkbenchWindow window = PlatformUI.getWorkbench().getActiveWorkbenchWindow();\n        if (window != null) {\n            IWorkbenchPage page = window.getActivePage();\n            if (page != null) {\n                IEditorPart editor = page.getActiveEditor();\n                if (editor instanceof ITextEditor) {\n                    return (ITextEditor) editor;\n                }\n            }\n        }\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/quickfixes/FixCheckstyleMarkersHandler.java",
		"test_prompt": "// FixCheckstyleMarkersHandlerTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.quickfixes;\n\nimport org.eclipse.core.commands.AbstractHandler;\nimport org.eclipse.core.commands.ExecutionEvent;\nimport org.eclipse.core.commands.ExecutionException;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.ui.IEditorInput;\nimport org.eclipse.ui.IEditorPart;\nimport org.eclipse.ui.IWorkbenchPage;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.PlatformUI;\nimport org.eclipse.ui.part.FileEditorInput;\nimport org.eclipse.ui.texteditor.ITextEditor;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FixCheckstyleMarkersHandler}.\n* It contains ten unit test cases for the {@link FixCheckstyleMarkersHandler#execute(ExecutionEvent)} method.\n*/\nclass FixCheckstyleMarkersHandlerTest {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_0Test.java",
		"test_prompt": "// XMLUtil_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#getChildNode(Node, String)} method.\n*/\nclass XMLUtil_0Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_1Test.java",
		"test_prompt": "// XMLUtil_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#getNodeTextValue(Node)} method.\n*/\nclass XMLUtil_1Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_2Test.java",
		"test_prompt": "// XMLUtil_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#getNodeAttributeValue(Node, String)} method.\n*/\nclass XMLUtil_2Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_3Test.java",
		"test_prompt": "// XMLUtil_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#addElementAndValue(Document, Element, String, String)} method.\n*/\nclass XMLUtil_3Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_4Test.java",
		"test_prompt": "// XMLUtil_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#addElement(Document, Element, String)} method.\n*/\nclass XMLUtil_4Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_5Test.java",
		"test_prompt": "// XMLUtil_5Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#newDocument()} method.\n*/\nclass XMLUtil_5Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_6Test.java",
		"test_prompt": "// XMLUtil_6Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#newDocument(String)} method.\n*/\nclass XMLUtil_6Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_7Test.java",
		"test_prompt": "// XMLUtil_7Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#newDocument(InputStream)} method.\n*/\nclass XMLUtil_7Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_8Test.java",
		"test_prompt": "// XMLUtil_8Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#serializeDocument(Document, boolean)} method.\n*/\nclass XMLUtil_8Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_9Test.java",
		"test_prompt": "// XMLUtil_9Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#serializeDocument(Document)} method.\n*/\nclass XMLUtil_9Test {"
	},
	{
		"original_code": "// XMLUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Provides utility methods for XML manipulations.\n */\npublic final class XMLUtil {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static Stack sDocBuilderCache = new Stack();\n\n    private static DocumentBuilderFactory sDocBuilderFactory = DocumentBuilderFactory.newInstance();\n\n    private static SAXParserFactory sSAXParserFactory = SAXParserFactory.newInstance();\n\n    private static TransformerFactory sTransformerFactory = TransformerFactory.newInstance();\n\n    private static final int MAX_DOC_BUILDER_CACHE = 10;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instances.\n     */\n    private XMLUtil() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a named child node. If there is more then one child node with the\n     * given name the child returned is undefined.\n     *\n     * @param parent The parent node.\n     * @param childName The node name of the child node.\n     * @return The requested child node or <code>null</code> if no child with\n     *         the requested name is found.\n     */\n    public static Node getChildNode(Node parent, String childName) {\n        Node result = null;\n        if (parent != null) {\n            NodeList childList = parent.getChildNodes();\n            int childCount = childList.getLength();\n            for (int i = 0; i < childCount; i++) {\n                Node child = childList.item(i);\n                String nodeName = child.getNodeName();\n                if (nodeName.equals(childName)) {\n                    result = child;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the value of the text node that is passed in.\n     *\n     * @param node The node to work on\n     * @return Text value of the tag element\n     */\n    public static String getNodeTextValue(Node node) {\n        String nodeValue = null;\n        if (node != null) {\n            NodeList childNodes = node.getChildNodes();\n            if (childNodes.getLength() > 0) {\n                Node childNode = childNodes.item(0);\n                if (childNode.getNodeType() == Node.TEXT_NODE || childNode.getNodeType() == Node.CDATA_SECTION_NODE) {\n                    nodeValue = childNode.getNodeValue();\n                }\n            }\n        }\n        return nodeValue;\n    }\n\n    /**\n     * Get the value of a node attribute.\n     *\n     * @param node The nade to get the attribute from.\n     * @param attrName Name of the attribute.\n     * @return Value of the attribute or <code>null</code> if the attribute\n     *         was not found.\n     */\n    public static String getNodeAttributeValue(Node node, String attrName) {\n        String result = null;\n        if (node == null) {\n            return result;\n        }\n        NamedNodeMap attrs = node.getAttributes();\n        Node attr = attrs.getNamedItem(attrName);\n        if (attr instanceof Attr) {\n            result = ((Attr) attr).getValue();\n        } else {\n            result = getNodeTextValue(attr);\n        }\n        return result;\n    }\n\n    /**\n     * Add a new Element and its value to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @param value Value of new Element\n     * @return Element Newly added Element\n     */\n    public static Element addElementAndValue(Document document, Element parent, String tagName, String value) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        Text text = document.createTextNode(value);\n        element.appendChild(text);\n        return element;\n    }\n\n    /**\n     * Add a new Element to an input Document.\n     *\n     * @param document Document to add to\n     * @param parent Parent element to add new element to\n     * @param tagName Element tag name to add\n     * @return Element Newly added Element\n     */\n    public static Element addElement(Document document, Element parent, String tagName) {\n        Element element = document.createElement(tagName);\n        parent.appendChild(element);\n        return element;\n    }\n\n    /**\n     * Create a new Document.\n     *\n     * @return Document Newly created Document\n     * @throws ParserConfigurationException error creating DOM parser\n     */\n    public static Document newDocument() throws ParserConfigurationException {\n        Document document = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        document = docBuilder.newDocument();\n        releaseDocumentBuilder(docBuilder);\n        return document;\n    }\n\n    /**\n     * Converts the specified String into an XML Document. If the String can't\n     * be parsed, then null is returned.\n     *\n     * @param xmlString The String to parse into an XML Document\n     * @return Document The parsed Docuement\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(String xmlString) throws ParserConfigurationException, IOException, SAXException {\n        //\n        // Parse the document.\n        //\n        Document document = null;\n        ByteArrayInputStream bs = new ByteArrayInputStream(xmlString.getBytes());\n        document = newDocument(bs);\n        return document;\n    }\n\n    /**\n     * Create a document from the contents of a stream.\n     *\n     * @param inStream Stream to read from.\n     * @return Resulting Document.\n     * @throws ParserConfigurationException error creating the DOM parser\n     * @throws IOException error reading from the input stream\n     * @throws SAXException error farsing the stream content\n     */\n    public static Document newDocument(InputStream inStream) throws ParserConfigurationException, IOException, SAXException {\n        Document result = null;\n        DocumentBuilder docBuilder = getDocumentBuilder();\n        result = docBuilder.parse(inStream);\n        releaseDocumentBuilder(docBuilder);\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep.\n     *\n     * @param doc - Document to be serialized\n     * @param indent - boolean indicating whether or not to indent tags\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc, boolean indent) throws TransformerException {\n        String result = null;\n        final StringWriter writer = new StringWriter();\n        Source theSource = new DOMSource(doc);\n        Result theResult = new StreamResult(writer);\n        // A transformer without stylesheet does identity transformation\n        Transformer transformer = sTransformerFactory.newTransformer();\n        //$NON-NLS-1$\n        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n        //$NON-NLS-1$ //$NON-NLS-2$\n        transformer.setOutputProperty(OutputKeys.INDENT, indent ? \"yes\" : \"no\");\n        transformer.transform(theSource, theResult);\n        result = writer.toString();\n        return result;\n    }\n\n    /**\n     * Serialize Document into String Rep, delegates to method with two\n     * arguments (indent set to false).\n     *\n     * @param doc - Document to be serialized\n     * @return String - Serialized string representation of doc\n     * @throws TransformerException error serializing the document\n     */\n    public static String serializeDocument(Document doc) throws TransformerException {\n        return serializeDocument(doc, false);\n    }\n\n    /**\n     * Parses an input stream with a sax parser using the given default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler) throws ParserConfigurationException, SAXException, IOException {\n        parseWithSAX(in, handler, false);\n    }\n\n    /**\n     * Validated and parses an input stream with a sax parser using the given\n     * default handler.\n     *\n     * @param in the input stream\n     * @param handler the default handler receiving the sax events\n     * @param validate <code>true</code> if the xml should be validated.\n     * @throws ParserConfigurationException error creating the sax parser\n     * @throws SAXException error parsing the input stream\n     * @throws IOException error reading the input stream\n     */\n    public static void parseWithSAX(InputStream in, DefaultHandler handler, boolean validate) throws ParserConfigurationException, SAXException, IOException {\n        sSAXParserFactory.setValidating(validate);\n        SAXParser parser = sSAXParserFactory.newSAXParser();\n        parser.parse(in, handler);\n    }\n\n    /**\n     * Creates a transformer handler that writes to the given output stream. You\n     * can send sax events to the transformer and receive a similar output.\n     *\n     * @param out the output stream the handler writes to\n     * @param doctypePublic the public doctype id or <code>null</code>\n     * @param doctypeSystem the system doctype id or <code>null</code>\n     * @return the transformer handler where sax events can be sent to.\n     * @throws TransformerConfigurationException error creating the transformer\n     */\n    public static TransformerHandler writeWithSax(OutputStream out, String doctypePublic, String doctypeSystem) throws TransformerConfigurationException {\n        SAXTransformerFactory saxFactory = (SAXTransformerFactory) sTransformerFactory;\n        Templates templates = null;\n        InputStream in = null;\n        try {\n            //$NON-NLS-1$\n            in = new BufferedInputStream(XMLUtil.class.getResourceAsStream(\"identity.xsl\"));\n            templates = saxFactory.newTemplates(new StreamSource(in));\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        StreamResult result = new StreamResult(out);\n        // uses identity transformation (in==out)\n        TransformerHandler handler = saxFactory.newTransformerHandler(templates);\n        if (doctypePublic != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n        }\n        if (doctypeSystem != null) {\n            handler.getTransformer().setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n        }\n        handler.setResult(result);\n        return handler;\n    }\n\n    private static DocumentBuilder getDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilder builder = null;\n        try {\n            builder = (DocumentBuilder) sDocBuilderCache.pop();\n        } catch (EmptyStackException e) {\n            builder = createDocumentBuilder();\n        }\n        return builder;\n    }\n\n    private static void releaseDocumentBuilder(DocumentBuilder builder) {\n        if (sDocBuilderCache.size() < MAX_DOC_BUILDER_CACHE) {\n            sDocBuilderCache.push(builder);\n        }\n    }\n\n    private static synchronized DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        return sDocBuilderFactory.newDocumentBuilder();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/XMLUtil_10Test.java",
		"test_prompt": "// XMLUtil_10Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.util.EmptyStackException;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Templates;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXTransformerFactory;\nimport javax.xml.transform.sax.TransformerHandler;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.io.IOUtils;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUtil}.\n* It contains ten unit test cases for the {@link XMLUtil#writeWithSax(OutputStream, String, String)} method.\n*/\nclass XMLUtil_10Test {"
	},
	{
		"original_code": "// RegExContentAssistProcessor.java\n/**\n * ****************************************************************************\n *  Copyright (c) 2000, 2004 IBM Corporation and others.\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  which accompanies this distribution, and is available at\n *  http://www.eclipse.org/legal/epl-v10.html\n *\n *  Contributors:\n *      IBM Corporation - initial API and implementation\n * *****************************************************************************\n */\npackage com.atlassw.tools.eclipse.checkstyle.util.regex;\n\nimport java.util.ArrayList;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\n\n/**\n * Content assist processor for regular expressions.\n *\n * @since 3.0\n */\npublic final class RegExContentAssistProcessor implements IContentAssistProcessor, ISubjectControlContentAssistProcessor {\n\n    /**\n     * Proposal computer.\n     */\n    private static class ProposalComputer {\n\n        /**\n         * The whole regular expression.\n         */\n        private final String fExpression;\n\n        /**\n         * The document offset.\n         */\n        private final int fDocumentOffset;\n\n        /**\n         * The high-priority proposals.\n         */\n        private final ArrayList fPriorityProposals;\n\n        /**\n         * The low-priority proposals.\n         */\n        private final ArrayList fProposals;\n\n        /**\n         * <code>true</code> iff <code>fExpression</code> ends with an open\n         * escape.\n         */\n        private final boolean fIsEscape;\n\n        /**\n         * Creates a new Proposal Computer.\n         *\n         * @param contentAssistSubjectControl the subject control\n         * @param documentOffset the offset\n         */\n        public ProposalComputer(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n            fExpression = contentAssistSubjectControl.getDocument().get();\n            fDocumentOffset = documentOffset;\n            fPriorityProposals = new ArrayList();\n            fProposals = new ArrayList();\n            boolean isEscape = false;\n            esc: for (int i = documentOffset - 1; i >= 0; i--) {\n                if (fExpression.charAt(i) == '\\\\')\n                    isEscape = !isEscape;\n                else\n                    break esc;\n            }\n            fIsEscape = isEscape;\n        }\n\n        /**\n         * Computes applicable proposals for the find field.\n         *\n         * @return the proposals\n         */\n        public ICompletionProposal[] computeFindProposals() {\n            //characters\n            addBsProposal(\"\\\\\\\\\", RegExMessages.displayString_bs_bs, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_bs);\n            addBracketProposal(\"\\\\0\", 2, RegExMessages.displayString_bs_0, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_0);\n            addBracketProposal(\"\\\\x\", 2, RegExMessages.displayString_bs_x, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_x);\n            addBracketProposal(\"\\\\u\", 2, RegExMessages.displayString_bs_u, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_u);\n            addBsProposal(\"\\\\t\", RegExMessages.displayString_bs_t, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_t);\n            addBsProposal(\"\\\\n\", RegExMessages.displayString_bs_n, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_n);\n            addBsProposal(\"\\\\r\", RegExMessages.displayString_bs_r, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_r);\n            addBsProposal(\"\\\\f\", RegExMessages.displayString_bs_f, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_f);\n            addBsProposal(\"\\\\a\", RegExMessages.displayString_bs_a, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_a);\n            addBsProposal(\"\\\\e\", RegExMessages.displayString_bs_e, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_e);\n            addBsProposal(\"\\\\c\", RegExMessages.displayString_bs_c, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_c);\n            if (!fIsEscape)\n                addBracketProposal(\".\", 1, RegExMessages.displayString_dot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dot);\n            addBsProposal(\"\\\\d\", RegExMessages.displayString_bs_d, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_d);\n            addBsProposal(\"\\\\D\", RegExMessages.displayString_bs_D, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_D);\n            addBsProposal(\"\\\\s\", RegExMessages.displayString_bs_s, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_s);\n            addBsProposal(\"\\\\S\", RegExMessages.displayString_bs_S, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_S);\n            addBsProposal(\"\\\\w\", RegExMessages.displayString_bs_w, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_w);\n            addBsProposal(\"\\\\W\", RegExMessages.displayString_bs_W, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_W);\n            // backreference\n            //$NON-NLS-1$\n            addBsProposal(\"\\\\\", RegExMessages.displayString_bs_i, RegExMessages.additionalInfo_bs_i);\n            //quoting\n            //$NON-NLS-1$\n            addBsProposal(\"\\\\\", RegExMessages.displayString_bs, RegExMessages.additionalInfo_bs);\n            addBsProposal(\"\\\\Q\", RegExMessages.displayString_bs_Q, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_Q);\n            addBsProposal(\"\\\\E\", RegExMessages.displayString_bs_E, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_E);\n            //character sets\n            if (!fIsEscape) {\n                addBracketProposal(\"[]\", 1, RegExMessages.displayString_set, //$NON-NLS-1$\n                RegExMessages.additionalInfo_set);\n                addBracketProposal(\"[^]\", 2, RegExMessages.displayString_setExcl, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setExcl);\n                addBracketProposal(\"[-]\", 1, RegExMessages.displayString_setRange, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setRange);\n                addProposal(\"&&\", RegExMessages.displayString_setInter, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setInter);\n            }\n            if (!fIsEscape && fDocumentOffset > 0 && fExpression.charAt(fDocumentOffset - 1) == '\\\\') {\n                addProposal(\"\\\\p{}\", 3, RegExMessages.displayString_posix, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posix);\n                addProposal(\"\\\\P{}\", 3, RegExMessages.displayString_posixNot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posixNot);\n            } else {\n                addBracketProposal(\"\\\\p{}\", 3, RegExMessages.displayString_posix, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posix);\n                addBracketProposal(\"\\\\P{}\", 3, RegExMessages.displayString_posixNot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posixNot);\n            }\n            //\t\t\taddBsProposal(\"\\\\p{Lower}\",\n            // RegExMessages.displayString_bs_p{Lower},\n            // RegExMessages.additionalInfo_bs_p{Lower}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Upper}\",\n            // RegExMessages.displayString_bs_p{Upper},\n            // RegExMessages.additionalInfo_bs_p{Upper}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{ASCII}\",\n            // RegExMessages.displayString_bs_p{ASCII},\n            // RegExMessages.additionalInfo_bs_p{ASCII}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Alpha}\",\n            // RegExMessages.displayString_bs_p{Alpha},\n            // RegExMessages.additionalInfo_bs_p{Alpha}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Digit}\",\n            // RegExMessages.displayString_bs_p{Digit},\n            // RegExMessages.additionalInfo_bs_p{Digit}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Alnum}\",\n            // RegExMessages.displayString_bs_p{Alnum},\n            // RegExMessages.additionalInfo_bs_p{Alnum}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Punct}\",\n            // RegExMessages.displayString_bs_p{Punct},\n            // RegExMessages.additionalInfo_bs_p{Punct}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Graph}\",\n            // RegExMessages.displayString_bs_p{Graph},\n            // RegExMessages.additionalInfo_bs_p{Graph}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Print}\",\n            // RegExMessages.displayString_bs_p{Print},\n            // RegExMessages.additionalInfo_bs_p{Print}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Blank}\",\n            // RegExMessages.displayString_bs_p{Blank},\n            // RegExMessages.additionalInfo_bs_p{Blank}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Cntrl}\",\n            // RegExMessages.displayString_bs_p{Cntrl},\n            // RegExMessages.additionalInfo_bs_p{Cntrl}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{XDigit}\",\n            // RegExMessages.displayString_bs_p{XDigit},\n            // RegExMessages.additionalInfo_bs_p{XDigit}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Space}\",\n            // RegExMessages.displayString_bs_p{Space},\n            // RegExMessages.additionalInfo_bs_p{Space}); //$NON-NLS-1$\n            //\n            //\t\t\taddBsProposal(\"\\\\p{InGreek}\",\n            // RegExMessages.displayString_bs_p{InGreek},\n            // RegExMessages.additionalInfo_bs_p{InGreek}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Lu}\", RegExMessages.displayString_bs_p{Lu},\n            // RegExMessages.additionalInfo_bs_p{Lu}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Sc}\", RegExMessages.displayString_bs_p{Sc},\n            // RegExMessages.additionalInfo_bs_p{Sc}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\P{InGreek}\",\n            // RegExMessages.displayString_bs_P{InGreek},\n            // RegExMessages.additionalInfo_bs_P{InGreek}); //$NON-NLS-1$\n            //boundary matchers\n            if (fDocumentOffset == 0) {\n                addPriorityProposal(\"^\", RegExMessages.displayString_start, //$NON-NLS-1$\n                RegExMessages.additionalInfo_start);\n            } else if (fDocumentOffset == 1 && fExpression.charAt(0) == '^') {\n                addBracketProposal(\"^\", 1, RegExMessages.displayString_start, //$NON-NLS-1$\n                RegExMessages.additionalInfo_start);\n            }\n            if (fDocumentOffset == fExpression.length()) {\n                //$NON-NLS-1$\n                addProposal(\"$\", RegExMessages.displayString_end, RegExMessages.additionalInfo_end);\n            }\n            addBsProposal(\"\\\\b\", RegExMessages.displayString_bs_b, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_b);\n            addBsProposal(\"\\\\B\", RegExMessages.displayString_bs_B, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_B);\n            addBsProposal(\"\\\\A\", RegExMessages.displayString_bs_A, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_A);\n            addBsProposal(\"\\\\G\", RegExMessages.displayString_bs_G, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_G);\n            addBsProposal(\"\\\\Z\", RegExMessages.displayString_bs_Z, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_Z);\n            addBsProposal(\"\\\\z\", RegExMessages.displayString_bs_z, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_z);\n            if (!fIsEscape) {\n                //capturing groups\n                addBracketProposal(\"()\", 1, RegExMessages.displayString_group, //$NON-NLS-1$\n                RegExMessages.additionalInfo_group);\n                //flags\n                addBracketProposal(\"(?)\", 2, RegExMessages.displayString_flag, //$NON-NLS-1$\n                RegExMessages.additionalInfo_flag);\n                addBracketProposal(\"(?:)\", 3, RegExMessages.displayString_flagExpr, //$NON-NLS-1$\n                RegExMessages.additionalInfo_flagExpr);\n                //noncapturing group\n                addBracketProposal(\"(?:)\", 3, RegExMessages.displayString_nonCap, //$NON-NLS-1$\n                RegExMessages.additionalInfo_nonCap);\n                addBracketProposal(\"(?>)\", 3, RegExMessages.displayString_atomicCap, //$NON-NLS-1$\n                RegExMessages.additionalInfo_atomicCap);\n                //lookaraound\n                addBracketProposal(\"(?=)\", 3, RegExMessages.displayString_posLookahead, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posLookahead);\n                addBracketProposal(\"(?!)\", 3, RegExMessages.displayString_negLookahead, //$NON-NLS-1$\n                RegExMessages.additionalInfo_negLookahead);\n                addBracketProposal(\"(?<=)\", 4, RegExMessages.displayString_posLookbehind, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posLookbehind);\n                addBracketProposal(\"(?<!)\", 4, RegExMessages.displayString_negLookbehind, //$NON-NLS-1$\n                RegExMessages.additionalInfo_negLookbehind);\n                //greedy quantifiers\n                addBracketProposal(\"?\", 1, RegExMessages.displayString_quest, //$NON-NLS-1$\n                RegExMessages.additionalInfo_quest);\n                addBracketProposal(\"*\", 1, RegExMessages.displayString_star, //$NON-NLS-1$\n                RegExMessages.additionalInfo_star);\n                addBracketProposal(\"+\", 1, RegExMessages.displayString_plus, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plus);\n                addBracketProposal(\"{}\", 1, RegExMessages.displayString_exact, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exact);\n                addBracketProposal(\"{,}\", 1, RegExMessages.displayString_least, //$NON-NLS-1$\n                RegExMessages.additionalInfo_least);\n                addBracketProposal(\"{,}\", 1, RegExMessages.displayString_count, //$NON-NLS-1$\n                RegExMessages.additionalInfo_count);\n                //lazy quantifiers\n                addBracketProposal(\"??\", 1, RegExMessages.displayString_questLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_questLazy);\n                addBracketProposal(\"*?\", 1, RegExMessages.displayString_starLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_starLazy);\n                addBracketProposal(\"+?\", 1, RegExMessages.displayString_plusLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plusLazy);\n                addBracketProposal(\"{}?\", 1, RegExMessages.displayString_exactLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exactLazy);\n                addBracketProposal(\"{,}?\", 1, RegExMessages.displayString_leastLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_leastLazy);\n                addBracketProposal(\"{,}?\", 1, RegExMessages.displayString_countLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_countLazy);\n                //possessive quantifiers\n                addBracketProposal(\"?+\", 1, RegExMessages.displayString_questPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_questPoss);\n                addBracketProposal(\"*+\", 1, RegExMessages.displayString_starPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_starPoss);\n                addBracketProposal(\"++\", 1, RegExMessages.displayString_plusPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plusPoss);\n                addBracketProposal(\"{}+\", 1, RegExMessages.displayString_exactPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exactPoss);\n                addBracketProposal(\"{,}+\", 1, RegExMessages.displayString_leastPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_leastPoss);\n                addBracketProposal(\"{,}+\", 1, RegExMessages.displayString_countPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_countPoss);\n                //alternative\n                addBracketProposal(\"|\", 1, RegExMessages.displayString_alt, //$NON-NLS-1$\n                RegExMessages.additionalInfo_alt);\n            }\n            fPriorityProposals.addAll(fProposals);\n            return (ICompletionProposal[]) fPriorityProposals.toArray(new ICompletionProposal[fProposals.size()]);\n        }\n\n        /**\n         * Computes applicable proposals for the replace field.\n         *\n         * @return the proposals\n         */\n        public ICompletionProposal[] computeReplaceProposals() {\n            if (fDocumentOffset > 0 && '$' == fExpression.charAt(fDocumentOffset - 1)) {\n                addProposal(\"\", RegExMessages.displayString_dollar, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dollar);\n            } else {\n                addProposal(\"$\", RegExMessages.displayString_dollar, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dollar);\n                addBsProposal(\"\\\\\", RegExMessages.displayString_replace_bs, //$NON-NLS-1$\n                RegExMessages.additionalInfo_replace_bs);\n                //$NON-NLS-1$\n                addProposal(\"\\t\", RegExMessages.displayString_tab, RegExMessages.additionalInfo_tab);\n                //$NON-NLS-1$\n                addProposal(\"\\n\", RegExMessages.displayString_nl, RegExMessages.additionalInfo_nl);\n                //$NON-NLS-1$\n                addProposal(\"\\r\", RegExMessages.displayString_cr, RegExMessages.additionalInfo_cr);\n            }\n            return (ICompletionProposal[]) fProposals.toArray(new ICompletionProposal[fProposals.size()]);\n        }\n\n        /**\n         * Adds a proposal.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addProposal(String proposal, String displayString, String additionalInfo) {\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, proposal.length(), null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal.\n         *\n         * @param proposal the string to be inserted\n         * @param cursorPosition the cursor position after insertion, relative\n         *            to the start of the proposal\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addProposal(String proposal, int cursorPosition, String displayString, String additionalInfo) {\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal to the priority proposals list.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addPriorityProposal(String proposal, String displayString, String additionalInfo) {\n            fPriorityProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, proposal.length(), null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal. Ensures that existing pre- and postfixes are not\n         * duplicated.\n         *\n         * @param proposal the string to be inserted\n         * @param cursorPosition the cursor position after insertion, relative\n         *            to the start of the proposal\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addBracketProposal(String proposal, int cursorPosition, String displayString, String additionalInfo) {\n            String prolog = fExpression.substring(0, fDocumentOffset);\n            if (!fIsEscape && prolog.endsWith(\"\\\\\") && proposal.startsWith(\"\\\\\")) {\n                //$NON-NLS-1$//$NON-NLS-2$\n                fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n                return;\n            }\n            for (int i = 1; i <= cursorPosition; i++) {\n                String prefix = proposal.substring(0, i);\n                if (prolog.endsWith(prefix)) {\n                    String postfix = proposal.substring(cursorPosition);\n                    String epilog = fExpression.substring(fDocumentOffset);\n                    if (epilog.startsWith(postfix)) {\n                        fPriorityProposals.add(new CompletionProposal(proposal.substring(i, cursorPosition), fDocumentOffset, 0, cursorPosition - i, null, displayString, null, additionalInfo));\n                    } else {\n                        fPriorityProposals.add(new CompletionProposal(proposal.substring(i), fDocumentOffset, 0, cursorPosition - i, null, displayString, null, additionalInfo));\n                    }\n                    return;\n                }\n            }\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal that starts with a backslash.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addBsProposal(String proposal, String displayString, String additionalInfo) {\n            if (fIsEscape) {\n                fPriorityProposals.add(new CompletionProposal(proposal.substring(1), fDocumentOffset, 0, proposal.length() - 1, null, displayString, null, additionalInfo));\n            } else {\n                addProposal(proposal, displayString, additionalInfo);\n            }\n        }\n    }\n\n    /**\n     * The context information validator.\n     */\n    private IContextInformationValidator fValidator = new SubjectControlContextInformationValidator(this);\n\n    /**\n     * <code>true</code> iff the processor is for the find field.\n     * <code>false</code> iff the processor is for the replace field.\n     */\n    private final boolean fIsFind;\n\n    public RegExContentAssistProcessor(boolean isFind) {\n        fIsFind = isFind;\n    }\n\n    /*\n     * @see IContentAssistProcessor#computeCompletionProposals(ITextViewer, int)\n     */\n    public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int documentOffset) {\n        return null;\n    }\n\n    /*\n     * @see IContentAssistProcessor#computeContextInformation(ITextViewer, int)\n     */\n    public IContextInformation[] computeContextInformation(ITextViewer viewer, int documentOffset) {\n        return null;\n    }\n\n    /*\n     * @see IContentAssistProcessor#getCompletionProposalAutoActivationCharacters()\n     */\n    public char[] getCompletionProposalAutoActivationCharacters() {\n        if (fIsFind)\n            return new char[] { '\\\\', '[', '(' };\n        return new char[] { '$' };\n    }\n\n    /*\n     * @see IContentAssistProcessor#getContextInformationAutoActivationCharacters()\n     */\n    public char[] getContextInformationAutoActivationCharacters() {\n        return new char[] {};\n    }\n\n    /*\n     * @see IContentAssistProcessor#getContextInformationValidator()\n     */\n    public IContextInformationValidator getContextInformationValidator() {\n        return fValidator;\n    }\n\n    /*\n     * @see IContentAssistProcessor#getErrorMessage()\n     */\n    public String getErrorMessage() {\n        return null;\n    }\n\n    /*\n     * @see ISubjectControlContentAssistProcessor#computeCompletionProposals(IContentAssistSubjectControl,\n     *      int)\n     */\n    public ICompletionProposal[] computeCompletionProposals(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        if (fIsFind)\n            return new ProposalComputer(contentAssistSubjectControl, documentOffset).computeFindProposals();\n        return new ProposalComputer(contentAssistSubjectControl, documentOffset).computeReplaceProposals();\n    }\n\n    /*\n     * @see ISubjectControlContentAssistProcessor#computeContextInformation(IContentAssistSubjectControl,\n     *      int)\n     */\n    public IContextInformation[] computeContextInformation(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/regex/RegExContentAssistProcessor_0Test.java",
		"test_prompt": "// RegExContentAssistProcessor_0Test.java\npackage com.atlassw.tools.eclipse.checkstyle.util.regex;\n\nimport java.util.ArrayList;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegExContentAssistProcessor}.\n* It contains ten unit test cases for the {@link RegExContentAssistProcessor#computeCompletionProposals(ITextViewer, int)} method.\n*/\nclass RegExContentAssistProcessor_0Test {"
	},
	{
		"original_code": "// RegExContentAssistProcessor.java\n/**\n * ****************************************************************************\n *  Copyright (c) 2000, 2004 IBM Corporation and others.\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  which accompanies this distribution, and is available at\n *  http://www.eclipse.org/legal/epl-v10.html\n *\n *  Contributors:\n *      IBM Corporation - initial API and implementation\n * *****************************************************************************\n */\npackage com.atlassw.tools.eclipse.checkstyle.util.regex;\n\nimport java.util.ArrayList;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\n\n/**\n * Content assist processor for regular expressions.\n *\n * @since 3.0\n */\npublic final class RegExContentAssistProcessor implements IContentAssistProcessor, ISubjectControlContentAssistProcessor {\n\n    /**\n     * Proposal computer.\n     */\n    private static class ProposalComputer {\n\n        /**\n         * The whole regular expression.\n         */\n        private final String fExpression;\n\n        /**\n         * The document offset.\n         */\n        private final int fDocumentOffset;\n\n        /**\n         * The high-priority proposals.\n         */\n        private final ArrayList fPriorityProposals;\n\n        /**\n         * The low-priority proposals.\n         */\n        private final ArrayList fProposals;\n\n        /**\n         * <code>true</code> iff <code>fExpression</code> ends with an open\n         * escape.\n         */\n        private final boolean fIsEscape;\n\n        /**\n         * Creates a new Proposal Computer.\n         *\n         * @param contentAssistSubjectControl the subject control\n         * @param documentOffset the offset\n         */\n        public ProposalComputer(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n            fExpression = contentAssistSubjectControl.getDocument().get();\n            fDocumentOffset = documentOffset;\n            fPriorityProposals = new ArrayList();\n            fProposals = new ArrayList();\n            boolean isEscape = false;\n            esc: for (int i = documentOffset - 1; i >= 0; i--) {\n                if (fExpression.charAt(i) == '\\\\')\n                    isEscape = !isEscape;\n                else\n                    break esc;\n            }\n            fIsEscape = isEscape;\n        }\n\n        /**\n         * Computes applicable proposals for the find field.\n         *\n         * @return the proposals\n         */\n        public ICompletionProposal[] computeFindProposals() {\n            //characters\n            addBsProposal(\"\\\\\\\\\", RegExMessages.displayString_bs_bs, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_bs);\n            addBracketProposal(\"\\\\0\", 2, RegExMessages.displayString_bs_0, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_0);\n            addBracketProposal(\"\\\\x\", 2, RegExMessages.displayString_bs_x, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_x);\n            addBracketProposal(\"\\\\u\", 2, RegExMessages.displayString_bs_u, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_u);\n            addBsProposal(\"\\\\t\", RegExMessages.displayString_bs_t, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_t);\n            addBsProposal(\"\\\\n\", RegExMessages.displayString_bs_n, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_n);\n            addBsProposal(\"\\\\r\", RegExMessages.displayString_bs_r, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_r);\n            addBsProposal(\"\\\\f\", RegExMessages.displayString_bs_f, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_f);\n            addBsProposal(\"\\\\a\", RegExMessages.displayString_bs_a, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_a);\n            addBsProposal(\"\\\\e\", RegExMessages.displayString_bs_e, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_e);\n            addBsProposal(\"\\\\c\", RegExMessages.displayString_bs_c, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_c);\n            if (!fIsEscape)\n                addBracketProposal(\".\", 1, RegExMessages.displayString_dot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dot);\n            addBsProposal(\"\\\\d\", RegExMessages.displayString_bs_d, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_d);\n            addBsProposal(\"\\\\D\", RegExMessages.displayString_bs_D, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_D);\n            addBsProposal(\"\\\\s\", RegExMessages.displayString_bs_s, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_s);\n            addBsProposal(\"\\\\S\", RegExMessages.displayString_bs_S, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_S);\n            addBsProposal(\"\\\\w\", RegExMessages.displayString_bs_w, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_w);\n            addBsProposal(\"\\\\W\", RegExMessages.displayString_bs_W, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_W);\n            // backreference\n            //$NON-NLS-1$\n            addBsProposal(\"\\\\\", RegExMessages.displayString_bs_i, RegExMessages.additionalInfo_bs_i);\n            //quoting\n            //$NON-NLS-1$\n            addBsProposal(\"\\\\\", RegExMessages.displayString_bs, RegExMessages.additionalInfo_bs);\n            addBsProposal(\"\\\\Q\", RegExMessages.displayString_bs_Q, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_Q);\n            addBsProposal(\"\\\\E\", RegExMessages.displayString_bs_E, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_E);\n            //character sets\n            if (!fIsEscape) {\n                addBracketProposal(\"[]\", 1, RegExMessages.displayString_set, //$NON-NLS-1$\n                RegExMessages.additionalInfo_set);\n                addBracketProposal(\"[^]\", 2, RegExMessages.displayString_setExcl, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setExcl);\n                addBracketProposal(\"[-]\", 1, RegExMessages.displayString_setRange, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setRange);\n                addProposal(\"&&\", RegExMessages.displayString_setInter, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setInter);\n            }\n            if (!fIsEscape && fDocumentOffset > 0 && fExpression.charAt(fDocumentOffset - 1) == '\\\\') {\n                addProposal(\"\\\\p{}\", 3, RegExMessages.displayString_posix, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posix);\n                addProposal(\"\\\\P{}\", 3, RegExMessages.displayString_posixNot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posixNot);\n            } else {\n                addBracketProposal(\"\\\\p{}\", 3, RegExMessages.displayString_posix, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posix);\n                addBracketProposal(\"\\\\P{}\", 3, RegExMessages.displayString_posixNot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posixNot);\n            }\n            //\t\t\taddBsProposal(\"\\\\p{Lower}\",\n            // RegExMessages.displayString_bs_p{Lower},\n            // RegExMessages.additionalInfo_bs_p{Lower}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Upper}\",\n            // RegExMessages.displayString_bs_p{Upper},\n            // RegExMessages.additionalInfo_bs_p{Upper}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{ASCII}\",\n            // RegExMessages.displayString_bs_p{ASCII},\n            // RegExMessages.additionalInfo_bs_p{ASCII}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Alpha}\",\n            // RegExMessages.displayString_bs_p{Alpha},\n            // RegExMessages.additionalInfo_bs_p{Alpha}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Digit}\",\n            // RegExMessages.displayString_bs_p{Digit},\n            // RegExMessages.additionalInfo_bs_p{Digit}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Alnum}\",\n            // RegExMessages.displayString_bs_p{Alnum},\n            // RegExMessages.additionalInfo_bs_p{Alnum}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Punct}\",\n            // RegExMessages.displayString_bs_p{Punct},\n            // RegExMessages.additionalInfo_bs_p{Punct}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Graph}\",\n            // RegExMessages.displayString_bs_p{Graph},\n            // RegExMessages.additionalInfo_bs_p{Graph}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Print}\",\n            // RegExMessages.displayString_bs_p{Print},\n            // RegExMessages.additionalInfo_bs_p{Print}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Blank}\",\n            // RegExMessages.displayString_bs_p{Blank},\n            // RegExMessages.additionalInfo_bs_p{Blank}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Cntrl}\",\n            // RegExMessages.displayString_bs_p{Cntrl},\n            // RegExMessages.additionalInfo_bs_p{Cntrl}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{XDigit}\",\n            // RegExMessages.displayString_bs_p{XDigit},\n            // RegExMessages.additionalInfo_bs_p{XDigit}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Space}\",\n            // RegExMessages.displayString_bs_p{Space},\n            // RegExMessages.additionalInfo_bs_p{Space}); //$NON-NLS-1$\n            //\n            //\t\t\taddBsProposal(\"\\\\p{InGreek}\",\n            // RegExMessages.displayString_bs_p{InGreek},\n            // RegExMessages.additionalInfo_bs_p{InGreek}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Lu}\", RegExMessages.displayString_bs_p{Lu},\n            // RegExMessages.additionalInfo_bs_p{Lu}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Sc}\", RegExMessages.displayString_bs_p{Sc},\n            // RegExMessages.additionalInfo_bs_p{Sc}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\P{InGreek}\",\n            // RegExMessages.displayString_bs_P{InGreek},\n            // RegExMessages.additionalInfo_bs_P{InGreek}); //$NON-NLS-1$\n            //boundary matchers\n            if (fDocumentOffset == 0) {\n                addPriorityProposal(\"^\", RegExMessages.displayString_start, //$NON-NLS-1$\n                RegExMessages.additionalInfo_start);\n            } else if (fDocumentOffset == 1 && fExpression.charAt(0) == '^') {\n                addBracketProposal(\"^\", 1, RegExMessages.displayString_start, //$NON-NLS-1$\n                RegExMessages.additionalInfo_start);\n            }\n            if (fDocumentOffset == fExpression.length()) {\n                //$NON-NLS-1$\n                addProposal(\"$\", RegExMessages.displayString_end, RegExMessages.additionalInfo_end);\n            }\n            addBsProposal(\"\\\\b\", RegExMessages.displayString_bs_b, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_b);\n            addBsProposal(\"\\\\B\", RegExMessages.displayString_bs_B, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_B);\n            addBsProposal(\"\\\\A\", RegExMessages.displayString_bs_A, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_A);\n            addBsProposal(\"\\\\G\", RegExMessages.displayString_bs_G, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_G);\n            addBsProposal(\"\\\\Z\", RegExMessages.displayString_bs_Z, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_Z);\n            addBsProposal(\"\\\\z\", RegExMessages.displayString_bs_z, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_z);\n            if (!fIsEscape) {\n                //capturing groups\n                addBracketProposal(\"()\", 1, RegExMessages.displayString_group, //$NON-NLS-1$\n                RegExMessages.additionalInfo_group);\n                //flags\n                addBracketProposal(\"(?)\", 2, RegExMessages.displayString_flag, //$NON-NLS-1$\n                RegExMessages.additionalInfo_flag);\n                addBracketProposal(\"(?:)\", 3, RegExMessages.displayString_flagExpr, //$NON-NLS-1$\n                RegExMessages.additionalInfo_flagExpr);\n                //noncapturing group\n                addBracketProposal(\"(?:)\", 3, RegExMessages.displayString_nonCap, //$NON-NLS-1$\n                RegExMessages.additionalInfo_nonCap);\n                addBracketProposal(\"(?>)\", 3, RegExMessages.displayString_atomicCap, //$NON-NLS-1$\n                RegExMessages.additionalInfo_atomicCap);\n                //lookaraound\n                addBracketProposal(\"(?=)\", 3, RegExMessages.displayString_posLookahead, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posLookahead);\n                addBracketProposal(\"(?!)\", 3, RegExMessages.displayString_negLookahead, //$NON-NLS-1$\n                RegExMessages.additionalInfo_negLookahead);\n                addBracketProposal(\"(?<=)\", 4, RegExMessages.displayString_posLookbehind, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posLookbehind);\n                addBracketProposal(\"(?<!)\", 4, RegExMessages.displayString_negLookbehind, //$NON-NLS-1$\n                RegExMessages.additionalInfo_negLookbehind);\n                //greedy quantifiers\n                addBracketProposal(\"?\", 1, RegExMessages.displayString_quest, //$NON-NLS-1$\n                RegExMessages.additionalInfo_quest);\n                addBracketProposal(\"*\", 1, RegExMessages.displayString_star, //$NON-NLS-1$\n                RegExMessages.additionalInfo_star);\n                addBracketProposal(\"+\", 1, RegExMessages.displayString_plus, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plus);\n                addBracketProposal(\"{}\", 1, RegExMessages.displayString_exact, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exact);\n                addBracketProposal(\"{,}\", 1, RegExMessages.displayString_least, //$NON-NLS-1$\n                RegExMessages.additionalInfo_least);\n                addBracketProposal(\"{,}\", 1, RegExMessages.displayString_count, //$NON-NLS-1$\n                RegExMessages.additionalInfo_count);\n                //lazy quantifiers\n                addBracketProposal(\"??\", 1, RegExMessages.displayString_questLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_questLazy);\n                addBracketProposal(\"*?\", 1, RegExMessages.displayString_starLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_starLazy);\n                addBracketProposal(\"+?\", 1, RegExMessages.displayString_plusLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plusLazy);\n                addBracketProposal(\"{}?\", 1, RegExMessages.displayString_exactLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exactLazy);\n                addBracketProposal(\"{,}?\", 1, RegExMessages.displayString_leastLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_leastLazy);\n                addBracketProposal(\"{,}?\", 1, RegExMessages.displayString_countLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_countLazy);\n                //possessive quantifiers\n                addBracketProposal(\"?+\", 1, RegExMessages.displayString_questPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_questPoss);\n                addBracketProposal(\"*+\", 1, RegExMessages.displayString_starPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_starPoss);\n                addBracketProposal(\"++\", 1, RegExMessages.displayString_plusPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plusPoss);\n                addBracketProposal(\"{}+\", 1, RegExMessages.displayString_exactPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exactPoss);\n                addBracketProposal(\"{,}+\", 1, RegExMessages.displayString_leastPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_leastPoss);\n                addBracketProposal(\"{,}+\", 1, RegExMessages.displayString_countPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_countPoss);\n                //alternative\n                addBracketProposal(\"|\", 1, RegExMessages.displayString_alt, //$NON-NLS-1$\n                RegExMessages.additionalInfo_alt);\n            }\n            fPriorityProposals.addAll(fProposals);\n            return (ICompletionProposal[]) fPriorityProposals.toArray(new ICompletionProposal[fProposals.size()]);\n        }\n\n        /**\n         * Computes applicable proposals for the replace field.\n         *\n         * @return the proposals\n         */\n        public ICompletionProposal[] computeReplaceProposals() {\n            if (fDocumentOffset > 0 && '$' == fExpression.charAt(fDocumentOffset - 1)) {\n                addProposal(\"\", RegExMessages.displayString_dollar, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dollar);\n            } else {\n                addProposal(\"$\", RegExMessages.displayString_dollar, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dollar);\n                addBsProposal(\"\\\\\", RegExMessages.displayString_replace_bs, //$NON-NLS-1$\n                RegExMessages.additionalInfo_replace_bs);\n                //$NON-NLS-1$\n                addProposal(\"\\t\", RegExMessages.displayString_tab, RegExMessages.additionalInfo_tab);\n                //$NON-NLS-1$\n                addProposal(\"\\n\", RegExMessages.displayString_nl, RegExMessages.additionalInfo_nl);\n                //$NON-NLS-1$\n                addProposal(\"\\r\", RegExMessages.displayString_cr, RegExMessages.additionalInfo_cr);\n            }\n            return (ICompletionProposal[]) fProposals.toArray(new ICompletionProposal[fProposals.size()]);\n        }\n\n        /**\n         * Adds a proposal.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addProposal(String proposal, String displayString, String additionalInfo) {\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, proposal.length(), null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal.\n         *\n         * @param proposal the string to be inserted\n         * @param cursorPosition the cursor position after insertion, relative\n         *            to the start of the proposal\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addProposal(String proposal, int cursorPosition, String displayString, String additionalInfo) {\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal to the priority proposals list.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addPriorityProposal(String proposal, String displayString, String additionalInfo) {\n            fPriorityProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, proposal.length(), null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal. Ensures that existing pre- and postfixes are not\n         * duplicated.\n         *\n         * @param proposal the string to be inserted\n         * @param cursorPosition the cursor position after insertion, relative\n         *            to the start of the proposal\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addBracketProposal(String proposal, int cursorPosition, String displayString, String additionalInfo) {\n            String prolog = fExpression.substring(0, fDocumentOffset);\n            if (!fIsEscape && prolog.endsWith(\"\\\\\") && proposal.startsWith(\"\\\\\")) {\n                //$NON-NLS-1$//$NON-NLS-2$\n                fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n                return;\n            }\n            for (int i = 1; i <= cursorPosition; i++) {\n                String prefix = proposal.substring(0, i);\n                if (prolog.endsWith(prefix)) {\n                    String postfix = proposal.substring(cursorPosition);\n                    String epilog = fExpression.substring(fDocumentOffset);\n                    if (epilog.startsWith(postfix)) {\n                        fPriorityProposals.add(new CompletionProposal(proposal.substring(i, cursorPosition), fDocumentOffset, 0, cursorPosition - i, null, displayString, null, additionalInfo));\n                    } else {\n                        fPriorityProposals.add(new CompletionProposal(proposal.substring(i), fDocumentOffset, 0, cursorPosition - i, null, displayString, null, additionalInfo));\n                    }\n                    return;\n                }\n            }\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal that starts with a backslash.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addBsProposal(String proposal, String displayString, String additionalInfo) {\n            if (fIsEscape) {\n                fPriorityProposals.add(new CompletionProposal(proposal.substring(1), fDocumentOffset, 0, proposal.length() - 1, null, displayString, null, additionalInfo));\n            } else {\n                addProposal(proposal, displayString, additionalInfo);\n            }\n        }\n    }\n\n    /**\n     * The context information validator.\n     */\n    private IContextInformationValidator fValidator = new SubjectControlContextInformationValidator(this);\n\n    /**\n     * <code>true</code> iff the processor is for the find field.\n     * <code>false</code> iff the processor is for the replace field.\n     */\n    private final boolean fIsFind;\n\n    public RegExContentAssistProcessor(boolean isFind) {\n        fIsFind = isFind;\n    }\n\n    /*\n     * @see IContentAssistProcessor#computeCompletionProposals(ITextViewer, int)\n     */\n    public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int documentOffset) {\n        return null;\n    }\n\n    /*\n     * @see IContentAssistProcessor#computeContextInformation(ITextViewer, int)\n     */\n    public IContextInformation[] computeContextInformation(ITextViewer viewer, int documentOffset) {\n        return null;\n    }\n\n    /*\n     * @see IContentAssistProcessor#getCompletionProposalAutoActivationCharacters()\n     */\n    public char[] getCompletionProposalAutoActivationCharacters() {\n        if (fIsFind)\n            return new char[] { '\\\\', '[', '(' };\n        return new char[] { '$' };\n    }\n\n    /*\n     * @see IContentAssistProcessor#getContextInformationAutoActivationCharacters()\n     */\n    public char[] getContextInformationAutoActivationCharacters() {\n        return new char[] {};\n    }\n\n    /*\n     * @see IContentAssistProcessor#getContextInformationValidator()\n     */\n    public IContextInformationValidator getContextInformationValidator() {\n        return fValidator;\n    }\n\n    /*\n     * @see IContentAssistProcessor#getErrorMessage()\n     */\n    public String getErrorMessage() {\n        return null;\n    }\n\n    /*\n     * @see ISubjectControlContentAssistProcessor#computeCompletionProposals(IContentAssistSubjectControl,\n     *      int)\n     */\n    public ICompletionProposal[] computeCompletionProposals(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        if (fIsFind)\n            return new ProposalComputer(contentAssistSubjectControl, documentOffset).computeFindProposals();\n        return new ProposalComputer(contentAssistSubjectControl, documentOffset).computeReplaceProposals();\n    }\n\n    /*\n     * @see ISubjectControlContentAssistProcessor#computeContextInformation(IContentAssistSubjectControl,\n     *      int)\n     */\n    public IContextInformation[] computeContextInformation(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/regex/RegExContentAssistProcessor_1Test.java",
		"test_prompt": "// RegExContentAssistProcessor_1Test.java\npackage com.atlassw.tools.eclipse.checkstyle.util.regex;\n\nimport java.util.ArrayList;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegExContentAssistProcessor}.\n* It contains ten unit test cases for the {@link RegExContentAssistProcessor#computeContextInformation(ITextViewer, int)} method.\n*/\nclass RegExContentAssistProcessor_1Test {"
	},
	{
		"original_code": "// RegExContentAssistProcessor.java\n/**\n * ****************************************************************************\n *  Copyright (c) 2000, 2004 IBM Corporation and others.\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  which accompanies this distribution, and is available at\n *  http://www.eclipse.org/legal/epl-v10.html\n *\n *  Contributors:\n *      IBM Corporation - initial API and implementation\n * *****************************************************************************\n */\npackage com.atlassw.tools.eclipse.checkstyle.util.regex;\n\nimport java.util.ArrayList;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\n\n/**\n * Content assist processor for regular expressions.\n *\n * @since 3.0\n */\npublic final class RegExContentAssistProcessor implements IContentAssistProcessor, ISubjectControlContentAssistProcessor {\n\n    /**\n     * Proposal computer.\n     */\n    private static class ProposalComputer {\n\n        /**\n         * The whole regular expression.\n         */\n        private final String fExpression;\n\n        /**\n         * The document offset.\n         */\n        private final int fDocumentOffset;\n\n        /**\n         * The high-priority proposals.\n         */\n        private final ArrayList fPriorityProposals;\n\n        /**\n         * The low-priority proposals.\n         */\n        private final ArrayList fProposals;\n\n        /**\n         * <code>true</code> iff <code>fExpression</code> ends with an open\n         * escape.\n         */\n        private final boolean fIsEscape;\n\n        /**\n         * Creates a new Proposal Computer.\n         *\n         * @param contentAssistSubjectControl the subject control\n         * @param documentOffset the offset\n         */\n        public ProposalComputer(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n            fExpression = contentAssistSubjectControl.getDocument().get();\n            fDocumentOffset = documentOffset;\n            fPriorityProposals = new ArrayList();\n            fProposals = new ArrayList();\n            boolean isEscape = false;\n            esc: for (int i = documentOffset - 1; i >= 0; i--) {\n                if (fExpression.charAt(i) == '\\\\')\n                    isEscape = !isEscape;\n                else\n                    break esc;\n            }\n            fIsEscape = isEscape;\n        }\n\n        /**\n         * Computes applicable proposals for the find field.\n         *\n         * @return the proposals\n         */\n        public ICompletionProposal[] computeFindProposals() {\n            //characters\n            addBsProposal(\"\\\\\\\\\", RegExMessages.displayString_bs_bs, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_bs);\n            addBracketProposal(\"\\\\0\", 2, RegExMessages.displayString_bs_0, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_0);\n            addBracketProposal(\"\\\\x\", 2, RegExMessages.displayString_bs_x, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_x);\n            addBracketProposal(\"\\\\u\", 2, RegExMessages.displayString_bs_u, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_u);\n            addBsProposal(\"\\\\t\", RegExMessages.displayString_bs_t, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_t);\n            addBsProposal(\"\\\\n\", RegExMessages.displayString_bs_n, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_n);\n            addBsProposal(\"\\\\r\", RegExMessages.displayString_bs_r, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_r);\n            addBsProposal(\"\\\\f\", RegExMessages.displayString_bs_f, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_f);\n            addBsProposal(\"\\\\a\", RegExMessages.displayString_bs_a, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_a);\n            addBsProposal(\"\\\\e\", RegExMessages.displayString_bs_e, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_e);\n            addBsProposal(\"\\\\c\", RegExMessages.displayString_bs_c, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_c);\n            if (!fIsEscape)\n                addBracketProposal(\".\", 1, RegExMessages.displayString_dot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dot);\n            addBsProposal(\"\\\\d\", RegExMessages.displayString_bs_d, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_d);\n            addBsProposal(\"\\\\D\", RegExMessages.displayString_bs_D, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_D);\n            addBsProposal(\"\\\\s\", RegExMessages.displayString_bs_s, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_s);\n            addBsProposal(\"\\\\S\", RegExMessages.displayString_bs_S, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_S);\n            addBsProposal(\"\\\\w\", RegExMessages.displayString_bs_w, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_w);\n            addBsProposal(\"\\\\W\", RegExMessages.displayString_bs_W, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_W);\n            // backreference\n            //$NON-NLS-1$\n            addBsProposal(\"\\\\\", RegExMessages.displayString_bs_i, RegExMessages.additionalInfo_bs_i);\n            //quoting\n            //$NON-NLS-1$\n            addBsProposal(\"\\\\\", RegExMessages.displayString_bs, RegExMessages.additionalInfo_bs);\n            addBsProposal(\"\\\\Q\", RegExMessages.displayString_bs_Q, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_Q);\n            addBsProposal(\"\\\\E\", RegExMessages.displayString_bs_E, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_E);\n            //character sets\n            if (!fIsEscape) {\n                addBracketProposal(\"[]\", 1, RegExMessages.displayString_set, //$NON-NLS-1$\n                RegExMessages.additionalInfo_set);\n                addBracketProposal(\"[^]\", 2, RegExMessages.displayString_setExcl, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setExcl);\n                addBracketProposal(\"[-]\", 1, RegExMessages.displayString_setRange, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setRange);\n                addProposal(\"&&\", RegExMessages.displayString_setInter, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setInter);\n            }\n            if (!fIsEscape && fDocumentOffset > 0 && fExpression.charAt(fDocumentOffset - 1) == '\\\\') {\n                addProposal(\"\\\\p{}\", 3, RegExMessages.displayString_posix, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posix);\n                addProposal(\"\\\\P{}\", 3, RegExMessages.displayString_posixNot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posixNot);\n            } else {\n                addBracketProposal(\"\\\\p{}\", 3, RegExMessages.displayString_posix, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posix);\n                addBracketProposal(\"\\\\P{}\", 3, RegExMessages.displayString_posixNot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posixNot);\n            }\n            //\t\t\taddBsProposal(\"\\\\p{Lower}\",\n            // RegExMessages.displayString_bs_p{Lower},\n            // RegExMessages.additionalInfo_bs_p{Lower}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Upper}\",\n            // RegExMessages.displayString_bs_p{Upper},\n            // RegExMessages.additionalInfo_bs_p{Upper}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{ASCII}\",\n            // RegExMessages.displayString_bs_p{ASCII},\n            // RegExMessages.additionalInfo_bs_p{ASCII}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Alpha}\",\n            // RegExMessages.displayString_bs_p{Alpha},\n            // RegExMessages.additionalInfo_bs_p{Alpha}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Digit}\",\n            // RegExMessages.displayString_bs_p{Digit},\n            // RegExMessages.additionalInfo_bs_p{Digit}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Alnum}\",\n            // RegExMessages.displayString_bs_p{Alnum},\n            // RegExMessages.additionalInfo_bs_p{Alnum}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Punct}\",\n            // RegExMessages.displayString_bs_p{Punct},\n            // RegExMessages.additionalInfo_bs_p{Punct}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Graph}\",\n            // RegExMessages.displayString_bs_p{Graph},\n            // RegExMessages.additionalInfo_bs_p{Graph}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Print}\",\n            // RegExMessages.displayString_bs_p{Print},\n            // RegExMessages.additionalInfo_bs_p{Print}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Blank}\",\n            // RegExMessages.displayString_bs_p{Blank},\n            // RegExMessages.additionalInfo_bs_p{Blank}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Cntrl}\",\n            // RegExMessages.displayString_bs_p{Cntrl},\n            // RegExMessages.additionalInfo_bs_p{Cntrl}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{XDigit}\",\n            // RegExMessages.displayString_bs_p{XDigit},\n            // RegExMessages.additionalInfo_bs_p{XDigit}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Space}\",\n            // RegExMessages.displayString_bs_p{Space},\n            // RegExMessages.additionalInfo_bs_p{Space}); //$NON-NLS-1$\n            //\n            //\t\t\taddBsProposal(\"\\\\p{InGreek}\",\n            // RegExMessages.displayString_bs_p{InGreek},\n            // RegExMessages.additionalInfo_bs_p{InGreek}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Lu}\", RegExMessages.displayString_bs_p{Lu},\n            // RegExMessages.additionalInfo_bs_p{Lu}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Sc}\", RegExMessages.displayString_bs_p{Sc},\n            // RegExMessages.additionalInfo_bs_p{Sc}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\P{InGreek}\",\n            // RegExMessages.displayString_bs_P{InGreek},\n            // RegExMessages.additionalInfo_bs_P{InGreek}); //$NON-NLS-1$\n            //boundary matchers\n            if (fDocumentOffset == 0) {\n                addPriorityProposal(\"^\", RegExMessages.displayString_start, //$NON-NLS-1$\n                RegExMessages.additionalInfo_start);\n            } else if (fDocumentOffset == 1 && fExpression.charAt(0) == '^') {\n                addBracketProposal(\"^\", 1, RegExMessages.displayString_start, //$NON-NLS-1$\n                RegExMessages.additionalInfo_start);\n            }\n            if (fDocumentOffset == fExpression.length()) {\n                //$NON-NLS-1$\n                addProposal(\"$\", RegExMessages.displayString_end, RegExMessages.additionalInfo_end);\n            }\n            addBsProposal(\"\\\\b\", RegExMessages.displayString_bs_b, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_b);\n            addBsProposal(\"\\\\B\", RegExMessages.displayString_bs_B, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_B);\n            addBsProposal(\"\\\\A\", RegExMessages.displayString_bs_A, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_A);\n            addBsProposal(\"\\\\G\", RegExMessages.displayString_bs_G, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_G);\n            addBsProposal(\"\\\\Z\", RegExMessages.displayString_bs_Z, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_Z);\n            addBsProposal(\"\\\\z\", RegExMessages.displayString_bs_z, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_z);\n            if (!fIsEscape) {\n                //capturing groups\n                addBracketProposal(\"()\", 1, RegExMessages.displayString_group, //$NON-NLS-1$\n                RegExMessages.additionalInfo_group);\n                //flags\n                addBracketProposal(\"(?)\", 2, RegExMessages.displayString_flag, //$NON-NLS-1$\n                RegExMessages.additionalInfo_flag);\n                addBracketProposal(\"(?:)\", 3, RegExMessages.displayString_flagExpr, //$NON-NLS-1$\n                RegExMessages.additionalInfo_flagExpr);\n                //noncapturing group\n                addBracketProposal(\"(?:)\", 3, RegExMessages.displayString_nonCap, //$NON-NLS-1$\n                RegExMessages.additionalInfo_nonCap);\n                addBracketProposal(\"(?>)\", 3, RegExMessages.displayString_atomicCap, //$NON-NLS-1$\n                RegExMessages.additionalInfo_atomicCap);\n                //lookaraound\n                addBracketProposal(\"(?=)\", 3, RegExMessages.displayString_posLookahead, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posLookahead);\n                addBracketProposal(\"(?!)\", 3, RegExMessages.displayString_negLookahead, //$NON-NLS-1$\n                RegExMessages.additionalInfo_negLookahead);\n                addBracketProposal(\"(?<=)\", 4, RegExMessages.displayString_posLookbehind, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posLookbehind);\n                addBracketProposal(\"(?<!)\", 4, RegExMessages.displayString_negLookbehind, //$NON-NLS-1$\n                RegExMessages.additionalInfo_negLookbehind);\n                //greedy quantifiers\n                addBracketProposal(\"?\", 1, RegExMessages.displayString_quest, //$NON-NLS-1$\n                RegExMessages.additionalInfo_quest);\n                addBracketProposal(\"*\", 1, RegExMessages.displayString_star, //$NON-NLS-1$\n                RegExMessages.additionalInfo_star);\n                addBracketProposal(\"+\", 1, RegExMessages.displayString_plus, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plus);\n                addBracketProposal(\"{}\", 1, RegExMessages.displayString_exact, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exact);\n                addBracketProposal(\"{,}\", 1, RegExMessages.displayString_least, //$NON-NLS-1$\n                RegExMessages.additionalInfo_least);\n                addBracketProposal(\"{,}\", 1, RegExMessages.displayString_count, //$NON-NLS-1$\n                RegExMessages.additionalInfo_count);\n                //lazy quantifiers\n                addBracketProposal(\"??\", 1, RegExMessages.displayString_questLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_questLazy);\n                addBracketProposal(\"*?\", 1, RegExMessages.displayString_starLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_starLazy);\n                addBracketProposal(\"+?\", 1, RegExMessages.displayString_plusLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plusLazy);\n                addBracketProposal(\"{}?\", 1, RegExMessages.displayString_exactLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exactLazy);\n                addBracketProposal(\"{,}?\", 1, RegExMessages.displayString_leastLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_leastLazy);\n                addBracketProposal(\"{,}?\", 1, RegExMessages.displayString_countLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_countLazy);\n                //possessive quantifiers\n                addBracketProposal(\"?+\", 1, RegExMessages.displayString_questPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_questPoss);\n                addBracketProposal(\"*+\", 1, RegExMessages.displayString_starPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_starPoss);\n                addBracketProposal(\"++\", 1, RegExMessages.displayString_plusPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plusPoss);\n                addBracketProposal(\"{}+\", 1, RegExMessages.displayString_exactPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exactPoss);\n                addBracketProposal(\"{,}+\", 1, RegExMessages.displayString_leastPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_leastPoss);\n                addBracketProposal(\"{,}+\", 1, RegExMessages.displayString_countPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_countPoss);\n                //alternative\n                addBracketProposal(\"|\", 1, RegExMessages.displayString_alt, //$NON-NLS-1$\n                RegExMessages.additionalInfo_alt);\n            }\n            fPriorityProposals.addAll(fProposals);\n            return (ICompletionProposal[]) fPriorityProposals.toArray(new ICompletionProposal[fProposals.size()]);\n        }\n\n        /**\n         * Computes applicable proposals for the replace field.\n         *\n         * @return the proposals\n         */\n        public ICompletionProposal[] computeReplaceProposals() {\n            if (fDocumentOffset > 0 && '$' == fExpression.charAt(fDocumentOffset - 1)) {\n                addProposal(\"\", RegExMessages.displayString_dollar, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dollar);\n            } else {\n                addProposal(\"$\", RegExMessages.displayString_dollar, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dollar);\n                addBsProposal(\"\\\\\", RegExMessages.displayString_replace_bs, //$NON-NLS-1$\n                RegExMessages.additionalInfo_replace_bs);\n                //$NON-NLS-1$\n                addProposal(\"\\t\", RegExMessages.displayString_tab, RegExMessages.additionalInfo_tab);\n                //$NON-NLS-1$\n                addProposal(\"\\n\", RegExMessages.displayString_nl, RegExMessages.additionalInfo_nl);\n                //$NON-NLS-1$\n                addProposal(\"\\r\", RegExMessages.displayString_cr, RegExMessages.additionalInfo_cr);\n            }\n            return (ICompletionProposal[]) fProposals.toArray(new ICompletionProposal[fProposals.size()]);\n        }\n\n        /**\n         * Adds a proposal.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addProposal(String proposal, String displayString, String additionalInfo) {\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, proposal.length(), null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal.\n         *\n         * @param proposal the string to be inserted\n         * @param cursorPosition the cursor position after insertion, relative\n         *            to the start of the proposal\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addProposal(String proposal, int cursorPosition, String displayString, String additionalInfo) {\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal to the priority proposals list.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addPriorityProposal(String proposal, String displayString, String additionalInfo) {\n            fPriorityProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, proposal.length(), null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal. Ensures that existing pre- and postfixes are not\n         * duplicated.\n         *\n         * @param proposal the string to be inserted\n         * @param cursorPosition the cursor position after insertion, relative\n         *            to the start of the proposal\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addBracketProposal(String proposal, int cursorPosition, String displayString, String additionalInfo) {\n            String prolog = fExpression.substring(0, fDocumentOffset);\n            if (!fIsEscape && prolog.endsWith(\"\\\\\") && proposal.startsWith(\"\\\\\")) {\n                //$NON-NLS-1$//$NON-NLS-2$\n                fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n                return;\n            }\n            for (int i = 1; i <= cursorPosition; i++) {\n                String prefix = proposal.substring(0, i);\n                if (prolog.endsWith(prefix)) {\n                    String postfix = proposal.substring(cursorPosition);\n                    String epilog = fExpression.substring(fDocumentOffset);\n                    if (epilog.startsWith(postfix)) {\n                        fPriorityProposals.add(new CompletionProposal(proposal.substring(i, cursorPosition), fDocumentOffset, 0, cursorPosition - i, null, displayString, null, additionalInfo));\n                    } else {\n                        fPriorityProposals.add(new CompletionProposal(proposal.substring(i), fDocumentOffset, 0, cursorPosition - i, null, displayString, null, additionalInfo));\n                    }\n                    return;\n                }\n            }\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal that starts with a backslash.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addBsProposal(String proposal, String displayString, String additionalInfo) {\n            if (fIsEscape) {\n                fPriorityProposals.add(new CompletionProposal(proposal.substring(1), fDocumentOffset, 0, proposal.length() - 1, null, displayString, null, additionalInfo));\n            } else {\n                addProposal(proposal, displayString, additionalInfo);\n            }\n        }\n    }\n\n    /**\n     * The context information validator.\n     */\n    private IContextInformationValidator fValidator = new SubjectControlContextInformationValidator(this);\n\n    /**\n     * <code>true</code> iff the processor is for the find field.\n     * <code>false</code> iff the processor is for the replace field.\n     */\n    private final boolean fIsFind;\n\n    public RegExContentAssistProcessor(boolean isFind) {\n        fIsFind = isFind;\n    }\n\n    /*\n     * @see IContentAssistProcessor#computeCompletionProposals(ITextViewer, int)\n     */\n    public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int documentOffset) {\n        return null;\n    }\n\n    /*\n     * @see IContentAssistProcessor#computeContextInformation(ITextViewer, int)\n     */\n    public IContextInformation[] computeContextInformation(ITextViewer viewer, int documentOffset) {\n        return null;\n    }\n\n    /*\n     * @see IContentAssistProcessor#getCompletionProposalAutoActivationCharacters()\n     */\n    public char[] getCompletionProposalAutoActivationCharacters() {\n        if (fIsFind)\n            return new char[] { '\\\\', '[', '(' };\n        return new char[] { '$' };\n    }\n\n    /*\n     * @see IContentAssistProcessor#getContextInformationAutoActivationCharacters()\n     */\n    public char[] getContextInformationAutoActivationCharacters() {\n        return new char[] {};\n    }\n\n    /*\n     * @see IContentAssistProcessor#getContextInformationValidator()\n     */\n    public IContextInformationValidator getContextInformationValidator() {\n        return fValidator;\n    }\n\n    /*\n     * @see IContentAssistProcessor#getErrorMessage()\n     */\n    public String getErrorMessage() {\n        return null;\n    }\n\n    /*\n     * @see ISubjectControlContentAssistProcessor#computeCompletionProposals(IContentAssistSubjectControl,\n     *      int)\n     */\n    public ICompletionProposal[] computeCompletionProposals(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        if (fIsFind)\n            return new ProposalComputer(contentAssistSubjectControl, documentOffset).computeFindProposals();\n        return new ProposalComputer(contentAssistSubjectControl, documentOffset).computeReplaceProposals();\n    }\n\n    /*\n     * @see ISubjectControlContentAssistProcessor#computeContextInformation(IContentAssistSubjectControl,\n     *      int)\n     */\n    public IContextInformation[] computeContextInformation(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/regex/RegExContentAssistProcessor_2Test.java",
		"test_prompt": "// RegExContentAssistProcessor_2Test.java\npackage com.atlassw.tools.eclipse.checkstyle.util.regex;\n\nimport java.util.ArrayList;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegExContentAssistProcessor}.\n* It contains ten unit test cases for the {@link RegExContentAssistProcessor#computeCompletionProposals(IContentAssistSubjectControl, int)} method.\n*/\nclass RegExContentAssistProcessor_2Test {"
	},
	{
		"original_code": "// RegExContentAssistProcessor.java\n/**\n * ****************************************************************************\n *  Copyright (c) 2000, 2004 IBM Corporation and others.\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  which accompanies this distribution, and is available at\n *  http://www.eclipse.org/legal/epl-v10.html\n *\n *  Contributors:\n *      IBM Corporation - initial API and implementation\n * *****************************************************************************\n */\npackage com.atlassw.tools.eclipse.checkstyle.util.regex;\n\nimport java.util.ArrayList;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\n\n/**\n * Content assist processor for regular expressions.\n *\n * @since 3.0\n */\npublic final class RegExContentAssistProcessor implements IContentAssistProcessor, ISubjectControlContentAssistProcessor {\n\n    /**\n     * Proposal computer.\n     */\n    private static class ProposalComputer {\n\n        /**\n         * The whole regular expression.\n         */\n        private final String fExpression;\n\n        /**\n         * The document offset.\n         */\n        private final int fDocumentOffset;\n\n        /**\n         * The high-priority proposals.\n         */\n        private final ArrayList fPriorityProposals;\n\n        /**\n         * The low-priority proposals.\n         */\n        private final ArrayList fProposals;\n\n        /**\n         * <code>true</code> iff <code>fExpression</code> ends with an open\n         * escape.\n         */\n        private final boolean fIsEscape;\n\n        /**\n         * Creates a new Proposal Computer.\n         *\n         * @param contentAssistSubjectControl the subject control\n         * @param documentOffset the offset\n         */\n        public ProposalComputer(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n            fExpression = contentAssistSubjectControl.getDocument().get();\n            fDocumentOffset = documentOffset;\n            fPriorityProposals = new ArrayList();\n            fProposals = new ArrayList();\n            boolean isEscape = false;\n            esc: for (int i = documentOffset - 1; i >= 0; i--) {\n                if (fExpression.charAt(i) == '\\\\')\n                    isEscape = !isEscape;\n                else\n                    break esc;\n            }\n            fIsEscape = isEscape;\n        }\n\n        /**\n         * Computes applicable proposals for the find field.\n         *\n         * @return the proposals\n         */\n        public ICompletionProposal[] computeFindProposals() {\n            //characters\n            addBsProposal(\"\\\\\\\\\", RegExMessages.displayString_bs_bs, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_bs);\n            addBracketProposal(\"\\\\0\", 2, RegExMessages.displayString_bs_0, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_0);\n            addBracketProposal(\"\\\\x\", 2, RegExMessages.displayString_bs_x, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_x);\n            addBracketProposal(\"\\\\u\", 2, RegExMessages.displayString_bs_u, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_u);\n            addBsProposal(\"\\\\t\", RegExMessages.displayString_bs_t, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_t);\n            addBsProposal(\"\\\\n\", RegExMessages.displayString_bs_n, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_n);\n            addBsProposal(\"\\\\r\", RegExMessages.displayString_bs_r, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_r);\n            addBsProposal(\"\\\\f\", RegExMessages.displayString_bs_f, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_f);\n            addBsProposal(\"\\\\a\", RegExMessages.displayString_bs_a, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_a);\n            addBsProposal(\"\\\\e\", RegExMessages.displayString_bs_e, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_e);\n            addBsProposal(\"\\\\c\", RegExMessages.displayString_bs_c, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_c);\n            if (!fIsEscape)\n                addBracketProposal(\".\", 1, RegExMessages.displayString_dot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dot);\n            addBsProposal(\"\\\\d\", RegExMessages.displayString_bs_d, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_d);\n            addBsProposal(\"\\\\D\", RegExMessages.displayString_bs_D, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_D);\n            addBsProposal(\"\\\\s\", RegExMessages.displayString_bs_s, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_s);\n            addBsProposal(\"\\\\S\", RegExMessages.displayString_bs_S, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_S);\n            addBsProposal(\"\\\\w\", RegExMessages.displayString_bs_w, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_w);\n            addBsProposal(\"\\\\W\", RegExMessages.displayString_bs_W, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_W);\n            // backreference\n            //$NON-NLS-1$\n            addBsProposal(\"\\\\\", RegExMessages.displayString_bs_i, RegExMessages.additionalInfo_bs_i);\n            //quoting\n            //$NON-NLS-1$\n            addBsProposal(\"\\\\\", RegExMessages.displayString_bs, RegExMessages.additionalInfo_bs);\n            addBsProposal(\"\\\\Q\", RegExMessages.displayString_bs_Q, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_Q);\n            addBsProposal(\"\\\\E\", RegExMessages.displayString_bs_E, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_E);\n            //character sets\n            if (!fIsEscape) {\n                addBracketProposal(\"[]\", 1, RegExMessages.displayString_set, //$NON-NLS-1$\n                RegExMessages.additionalInfo_set);\n                addBracketProposal(\"[^]\", 2, RegExMessages.displayString_setExcl, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setExcl);\n                addBracketProposal(\"[-]\", 1, RegExMessages.displayString_setRange, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setRange);\n                addProposal(\"&&\", RegExMessages.displayString_setInter, //$NON-NLS-1$\n                RegExMessages.additionalInfo_setInter);\n            }\n            if (!fIsEscape && fDocumentOffset > 0 && fExpression.charAt(fDocumentOffset - 1) == '\\\\') {\n                addProposal(\"\\\\p{}\", 3, RegExMessages.displayString_posix, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posix);\n                addProposal(\"\\\\P{}\", 3, RegExMessages.displayString_posixNot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posixNot);\n            } else {\n                addBracketProposal(\"\\\\p{}\", 3, RegExMessages.displayString_posix, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posix);\n                addBracketProposal(\"\\\\P{}\", 3, RegExMessages.displayString_posixNot, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posixNot);\n            }\n            //\t\t\taddBsProposal(\"\\\\p{Lower}\",\n            // RegExMessages.displayString_bs_p{Lower},\n            // RegExMessages.additionalInfo_bs_p{Lower}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Upper}\",\n            // RegExMessages.displayString_bs_p{Upper},\n            // RegExMessages.additionalInfo_bs_p{Upper}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{ASCII}\",\n            // RegExMessages.displayString_bs_p{ASCII},\n            // RegExMessages.additionalInfo_bs_p{ASCII}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Alpha}\",\n            // RegExMessages.displayString_bs_p{Alpha},\n            // RegExMessages.additionalInfo_bs_p{Alpha}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Digit}\",\n            // RegExMessages.displayString_bs_p{Digit},\n            // RegExMessages.additionalInfo_bs_p{Digit}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Alnum}\",\n            // RegExMessages.displayString_bs_p{Alnum},\n            // RegExMessages.additionalInfo_bs_p{Alnum}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Punct}\",\n            // RegExMessages.displayString_bs_p{Punct},\n            // RegExMessages.additionalInfo_bs_p{Punct}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Graph}\",\n            // RegExMessages.displayString_bs_p{Graph},\n            // RegExMessages.additionalInfo_bs_p{Graph}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Print}\",\n            // RegExMessages.displayString_bs_p{Print},\n            // RegExMessages.additionalInfo_bs_p{Print}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Blank}\",\n            // RegExMessages.displayString_bs_p{Blank},\n            // RegExMessages.additionalInfo_bs_p{Blank}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Cntrl}\",\n            // RegExMessages.displayString_bs_p{Cntrl},\n            // RegExMessages.additionalInfo_bs_p{Cntrl}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{XDigit}\",\n            // RegExMessages.displayString_bs_p{XDigit},\n            // RegExMessages.additionalInfo_bs_p{XDigit}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Space}\",\n            // RegExMessages.displayString_bs_p{Space},\n            // RegExMessages.additionalInfo_bs_p{Space}); //$NON-NLS-1$\n            //\n            //\t\t\taddBsProposal(\"\\\\p{InGreek}\",\n            // RegExMessages.displayString_bs_p{InGreek},\n            // RegExMessages.additionalInfo_bs_p{InGreek}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Lu}\", RegExMessages.displayString_bs_p{Lu},\n            // RegExMessages.additionalInfo_bs_p{Lu}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\p{Sc}\", RegExMessages.displayString_bs_p{Sc},\n            // RegExMessages.additionalInfo_bs_p{Sc}); //$NON-NLS-1$\n            //\t\t\taddBsProposal(\"\\\\P{InGreek}\",\n            // RegExMessages.displayString_bs_P{InGreek},\n            // RegExMessages.additionalInfo_bs_P{InGreek}); //$NON-NLS-1$\n            //boundary matchers\n            if (fDocumentOffset == 0) {\n                addPriorityProposal(\"^\", RegExMessages.displayString_start, //$NON-NLS-1$\n                RegExMessages.additionalInfo_start);\n            } else if (fDocumentOffset == 1 && fExpression.charAt(0) == '^') {\n                addBracketProposal(\"^\", 1, RegExMessages.displayString_start, //$NON-NLS-1$\n                RegExMessages.additionalInfo_start);\n            }\n            if (fDocumentOffset == fExpression.length()) {\n                //$NON-NLS-1$\n                addProposal(\"$\", RegExMessages.displayString_end, RegExMessages.additionalInfo_end);\n            }\n            addBsProposal(\"\\\\b\", RegExMessages.displayString_bs_b, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_b);\n            addBsProposal(\"\\\\B\", RegExMessages.displayString_bs_B, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_B);\n            addBsProposal(\"\\\\A\", RegExMessages.displayString_bs_A, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_A);\n            addBsProposal(\"\\\\G\", RegExMessages.displayString_bs_G, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_G);\n            addBsProposal(\"\\\\Z\", RegExMessages.displayString_bs_Z, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_Z);\n            addBsProposal(\"\\\\z\", RegExMessages.displayString_bs_z, //$NON-NLS-1$\n            RegExMessages.additionalInfo_bs_z);\n            if (!fIsEscape) {\n                //capturing groups\n                addBracketProposal(\"()\", 1, RegExMessages.displayString_group, //$NON-NLS-1$\n                RegExMessages.additionalInfo_group);\n                //flags\n                addBracketProposal(\"(?)\", 2, RegExMessages.displayString_flag, //$NON-NLS-1$\n                RegExMessages.additionalInfo_flag);\n                addBracketProposal(\"(?:)\", 3, RegExMessages.displayString_flagExpr, //$NON-NLS-1$\n                RegExMessages.additionalInfo_flagExpr);\n                //noncapturing group\n                addBracketProposal(\"(?:)\", 3, RegExMessages.displayString_nonCap, //$NON-NLS-1$\n                RegExMessages.additionalInfo_nonCap);\n                addBracketProposal(\"(?>)\", 3, RegExMessages.displayString_atomicCap, //$NON-NLS-1$\n                RegExMessages.additionalInfo_atomicCap);\n                //lookaraound\n                addBracketProposal(\"(?=)\", 3, RegExMessages.displayString_posLookahead, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posLookahead);\n                addBracketProposal(\"(?!)\", 3, RegExMessages.displayString_negLookahead, //$NON-NLS-1$\n                RegExMessages.additionalInfo_negLookahead);\n                addBracketProposal(\"(?<=)\", 4, RegExMessages.displayString_posLookbehind, //$NON-NLS-1$\n                RegExMessages.additionalInfo_posLookbehind);\n                addBracketProposal(\"(?<!)\", 4, RegExMessages.displayString_negLookbehind, //$NON-NLS-1$\n                RegExMessages.additionalInfo_negLookbehind);\n                //greedy quantifiers\n                addBracketProposal(\"?\", 1, RegExMessages.displayString_quest, //$NON-NLS-1$\n                RegExMessages.additionalInfo_quest);\n                addBracketProposal(\"*\", 1, RegExMessages.displayString_star, //$NON-NLS-1$\n                RegExMessages.additionalInfo_star);\n                addBracketProposal(\"+\", 1, RegExMessages.displayString_plus, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plus);\n                addBracketProposal(\"{}\", 1, RegExMessages.displayString_exact, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exact);\n                addBracketProposal(\"{,}\", 1, RegExMessages.displayString_least, //$NON-NLS-1$\n                RegExMessages.additionalInfo_least);\n                addBracketProposal(\"{,}\", 1, RegExMessages.displayString_count, //$NON-NLS-1$\n                RegExMessages.additionalInfo_count);\n                //lazy quantifiers\n                addBracketProposal(\"??\", 1, RegExMessages.displayString_questLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_questLazy);\n                addBracketProposal(\"*?\", 1, RegExMessages.displayString_starLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_starLazy);\n                addBracketProposal(\"+?\", 1, RegExMessages.displayString_plusLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plusLazy);\n                addBracketProposal(\"{}?\", 1, RegExMessages.displayString_exactLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exactLazy);\n                addBracketProposal(\"{,}?\", 1, RegExMessages.displayString_leastLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_leastLazy);\n                addBracketProposal(\"{,}?\", 1, RegExMessages.displayString_countLazy, //$NON-NLS-1$\n                RegExMessages.additionalInfo_countLazy);\n                //possessive quantifiers\n                addBracketProposal(\"?+\", 1, RegExMessages.displayString_questPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_questPoss);\n                addBracketProposal(\"*+\", 1, RegExMessages.displayString_starPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_starPoss);\n                addBracketProposal(\"++\", 1, RegExMessages.displayString_plusPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_plusPoss);\n                addBracketProposal(\"{}+\", 1, RegExMessages.displayString_exactPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_exactPoss);\n                addBracketProposal(\"{,}+\", 1, RegExMessages.displayString_leastPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_leastPoss);\n                addBracketProposal(\"{,}+\", 1, RegExMessages.displayString_countPoss, //$NON-NLS-1$\n                RegExMessages.additionalInfo_countPoss);\n                //alternative\n                addBracketProposal(\"|\", 1, RegExMessages.displayString_alt, //$NON-NLS-1$\n                RegExMessages.additionalInfo_alt);\n            }\n            fPriorityProposals.addAll(fProposals);\n            return (ICompletionProposal[]) fPriorityProposals.toArray(new ICompletionProposal[fProposals.size()]);\n        }\n\n        /**\n         * Computes applicable proposals for the replace field.\n         *\n         * @return the proposals\n         */\n        public ICompletionProposal[] computeReplaceProposals() {\n            if (fDocumentOffset > 0 && '$' == fExpression.charAt(fDocumentOffset - 1)) {\n                addProposal(\"\", RegExMessages.displayString_dollar, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dollar);\n            } else {\n                addProposal(\"$\", RegExMessages.displayString_dollar, //$NON-NLS-1$\n                RegExMessages.additionalInfo_dollar);\n                addBsProposal(\"\\\\\", RegExMessages.displayString_replace_bs, //$NON-NLS-1$\n                RegExMessages.additionalInfo_replace_bs);\n                //$NON-NLS-1$\n                addProposal(\"\\t\", RegExMessages.displayString_tab, RegExMessages.additionalInfo_tab);\n                //$NON-NLS-1$\n                addProposal(\"\\n\", RegExMessages.displayString_nl, RegExMessages.additionalInfo_nl);\n                //$NON-NLS-1$\n                addProposal(\"\\r\", RegExMessages.displayString_cr, RegExMessages.additionalInfo_cr);\n            }\n            return (ICompletionProposal[]) fProposals.toArray(new ICompletionProposal[fProposals.size()]);\n        }\n\n        /**\n         * Adds a proposal.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addProposal(String proposal, String displayString, String additionalInfo) {\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, proposal.length(), null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal.\n         *\n         * @param proposal the string to be inserted\n         * @param cursorPosition the cursor position after insertion, relative\n         *            to the start of the proposal\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addProposal(String proposal, int cursorPosition, String displayString, String additionalInfo) {\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal to the priority proposals list.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addPriorityProposal(String proposal, String displayString, String additionalInfo) {\n            fPriorityProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, proposal.length(), null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal. Ensures that existing pre- and postfixes are not\n         * duplicated.\n         *\n         * @param proposal the string to be inserted\n         * @param cursorPosition the cursor position after insertion, relative\n         *            to the start of the proposal\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addBracketProposal(String proposal, int cursorPosition, String displayString, String additionalInfo) {\n            String prolog = fExpression.substring(0, fDocumentOffset);\n            if (!fIsEscape && prolog.endsWith(\"\\\\\") && proposal.startsWith(\"\\\\\")) {\n                //$NON-NLS-1$//$NON-NLS-2$\n                fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n                return;\n            }\n            for (int i = 1; i <= cursorPosition; i++) {\n                String prefix = proposal.substring(0, i);\n                if (prolog.endsWith(prefix)) {\n                    String postfix = proposal.substring(cursorPosition);\n                    String epilog = fExpression.substring(fDocumentOffset);\n                    if (epilog.startsWith(postfix)) {\n                        fPriorityProposals.add(new CompletionProposal(proposal.substring(i, cursorPosition), fDocumentOffset, 0, cursorPosition - i, null, displayString, null, additionalInfo));\n                    } else {\n                        fPriorityProposals.add(new CompletionProposal(proposal.substring(i), fDocumentOffset, 0, cursorPosition - i, null, displayString, null, additionalInfo));\n                    }\n                    return;\n                }\n            }\n            fProposals.add(new CompletionProposal(proposal, fDocumentOffset, 0, cursorPosition, null, displayString, null, additionalInfo));\n        }\n\n        /**\n         * Adds a proposal that starts with a backslash.\n         *\n         * @param proposal the string to be inserted\n         * @param displayString the proposal's label\n         * @param additionalInfo the additional information\n         */\n        private void addBsProposal(String proposal, String displayString, String additionalInfo) {\n            if (fIsEscape) {\n                fPriorityProposals.add(new CompletionProposal(proposal.substring(1), fDocumentOffset, 0, proposal.length() - 1, null, displayString, null, additionalInfo));\n            } else {\n                addProposal(proposal, displayString, additionalInfo);\n            }\n        }\n    }\n\n    /**\n     * The context information validator.\n     */\n    private IContextInformationValidator fValidator = new SubjectControlContextInformationValidator(this);\n\n    /**\n     * <code>true</code> iff the processor is for the find field.\n     * <code>false</code> iff the processor is for the replace field.\n     */\n    private final boolean fIsFind;\n\n    public RegExContentAssistProcessor(boolean isFind) {\n        fIsFind = isFind;\n    }\n\n    /*\n     * @see IContentAssistProcessor#computeCompletionProposals(ITextViewer, int)\n     */\n    public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int documentOffset) {\n        return null;\n    }\n\n    /*\n     * @see IContentAssistProcessor#computeContextInformation(ITextViewer, int)\n     */\n    public IContextInformation[] computeContextInformation(ITextViewer viewer, int documentOffset) {\n        return null;\n    }\n\n    /*\n     * @see IContentAssistProcessor#getCompletionProposalAutoActivationCharacters()\n     */\n    public char[] getCompletionProposalAutoActivationCharacters() {\n        if (fIsFind)\n            return new char[] { '\\\\', '[', '(' };\n        return new char[] { '$' };\n    }\n\n    /*\n     * @see IContentAssistProcessor#getContextInformationAutoActivationCharacters()\n     */\n    public char[] getContextInformationAutoActivationCharacters() {\n        return new char[] {};\n    }\n\n    /*\n     * @see IContentAssistProcessor#getContextInformationValidator()\n     */\n    public IContextInformationValidator getContextInformationValidator() {\n        return fValidator;\n    }\n\n    /*\n     * @see IContentAssistProcessor#getErrorMessage()\n     */\n    public String getErrorMessage() {\n        return null;\n    }\n\n    /*\n     * @see ISubjectControlContentAssistProcessor#computeCompletionProposals(IContentAssistSubjectControl,\n     *      int)\n     */\n    public ICompletionProposal[] computeCompletionProposals(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        if (fIsFind)\n            return new ProposalComputer(contentAssistSubjectControl, documentOffset).computeFindProposals();\n        return new ProposalComputer(contentAssistSubjectControl, documentOffset).computeReplaceProposals();\n    }\n\n    /*\n     * @see ISubjectControlContentAssistProcessor#computeContextInformation(IContentAssistSubjectControl,\n     *      int)\n     */\n    public IContextInformation[] computeContextInformation(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/regex/RegExContentAssistProcessor_3Test.java",
		"test_prompt": "// RegExContentAssistProcessor_3Test.java\npackage com.atlassw.tools.eclipse.checkstyle.util.regex;\n\nimport java.util.ArrayList;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegExContentAssistProcessor}.\n* It contains ten unit test cases for the {@link RegExContentAssistProcessor#computeContextInformation(IContentAssistSubjectControl, int)} method.\n*/\nclass RegExContentAssistProcessor_3Test {"
	},
	{
		"original_code": "// EnhancedCheckBoxTableViewer.java\n/**\n * ****************************************************************************\n *  Copyright (c) 2000, 2005 IBM Corporation and others.\n *  All rights reserved. This program and the accompanying materials\n *  are made available under the terms of the Eclipse Public License v1.0\n *  which accompanies this distribution, and is available at\n *  http://www.eclipse.org/legal/epl-v10.html\n *\n *  Contributors:\n *      IBM Corporation - initial API and implementation\n * *****************************************************************************\n */\npackage com.atlassw.tools.eclipse.checkstyle.util.table;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport org.eclipse.jface.util.Assert;\nimport org.eclipse.jface.util.ListenerList;\nimport org.eclipse.jface.util.SafeRunnable;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.ColumnWeightData;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.ICheckable;\nimport org.eclipse.jface.viewers.IElementComparer;\nimport org.eclipse.jface.viewers.TableLayout;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Table;\nimport org.eclipse.swt.widgets.TableColumn;\nimport org.eclipse.swt.widgets.TableItem;\nimport org.eclipse.swt.widgets.Widget;\n\n/**\n * A concrete viewer based on an SWT <code>Table</code> control with\n * checkboxes on each node.\n * <p>\n * This class is not intended to be subclassed outside the viewer framework. It\n * is designed to be instantiated with a pre-existing SWT table control and\n * configured with a domain-specific content provider, label provider, element\n * filter (optional), and element sorter (optional).\n * </p>\n */\npublic class EnhancedCheckBoxTableViewer extends EnhancedTableViewer implements ICheckable {\n\n    // CHECKSTYLE:OFF\n    /**\n     * List of check state listeners (element type:\n     * <code>ICheckStateListener</code>).\n     */\n    private ListenerList checkStateListeners = new ListenerList(3);\n\n    /**\n     * Creates a table viewer on a newly-created table control under the given\n     * parent. The table control is created using the SWT style bits:\n     * <code>SWT.CHECK</code> and <code>SWT.BORDER</code>. The table has\n     * one column. The viewer has no input, no content provider, a default label\n     * provider, no sorter, and no filters.\n     * <p>\n     * This is equivalent to calling\n     * <code>new CheckboxTableViewer(parent, SWT.BORDER)</code>. See that\n     * constructor for more details.\n     * </p>\n     *\n     * @param parent the parent control\n     * @deprecated use newCheckList(Composite, int) or new\n     *             CheckboxTableViewer(Table) instead (see below for details)\n     */\n    public EnhancedCheckBoxTableViewer(Composite parent) {\n        this(parent, SWT.BORDER);\n    }\n\n    /**\n     * Creates a table viewer on a newly-created table control under the given\n     * parent. The table control is created using the given SWT style bits, plus\n     * the <code>SWT.CHECK</code> style bit. The table has one column. The\n     * viewer has no input, no content provider, a default label provider, no\n     * sorter, and no filters.\n     * <p>\n     * This also adds a <code>TableColumn</code> for the single column, and\n     * sets a <code>TableLayout</code> on the table which sizes the column to\n     * fill the table for its initial sizing, but does nothing on subsequent\n     * resizes.\n     * </p>\n     * <p>\n     * If the caller just needs to show a single column with no header, it is\n     * preferable to use the <code>newCheckList</code> factory method instead,\n     * since SWT properly handles the initial sizing and subsequent resizes in\n     * this case.\n     * </p>\n     * <p>\n     * If the caller adds its own columns, uses\n     * <code>Table.setHeadersVisible(true)</code>, or needs to handle dynamic\n     * resizing of the table, it is recommended to create the <code>Table</code>\n     * itself, specifying the <code>SWT.CHECK</code> style bit (along with any\n     * other style bits needed), and use\n     * <code>new CheckboxTableViewer(Table)</code> rather than this\n     * constructor.\n     * </p>\n     *\n     * @param parent the parent control\n     * @param style SWT style bits\n     * @deprecated use newCheckList(Composite, int) or new\n     *             CheckboxTableViewer(Table) instead (see above for details)\n     */\n    public EnhancedCheckBoxTableViewer(Composite parent, int style) {\n        this(createTable(parent, style));\n    }\n\n    /**\n     * Creates a table viewer on a newly-created table control under the given\n     * parent. The table control is created using the given SWT style bits, plus\n     * the <code>SWT.CHECK</code> style bit. The table shows its contents in a\n     * single column, with no header. The viewer has no input, no content\n     * provider, a default label provider, no sorter, and no filters.\n     * <p>\n     * No <code>TableColumn</code> is added. SWT does not require a\n     * <code>TableColumn</code> if showing only a single column with no\n     * header. SWT correctly handles the initial sizing and subsequent resizes\n     * in this case.\n     *\n     * @param parent the parent control\n     * @param style SWT style bits\n     * @since 2.0\n     */\n    public static EnhancedCheckBoxTableViewer newCheckList(Composite parent, int style) {\n        Table table = new Table(parent, SWT.CHECK | style);\n        return new EnhancedCheckBoxTableViewer(table);\n    }\n\n    /**\n     * Creates a table viewer on the given table control. The\n     * <code>SWT.CHECK</code> style bit must be set on the given table\n     * control. The viewer has no input, no content provider, a default label\n     * provider, no sorter, and no filters.\n     *\n     * @param table the table control\n     */\n    public EnhancedCheckBoxTableViewer(Table table) {\n        super(table);\n    }\n\n    /*\n     * (non-Javadoc) Method declared on ICheckable.\n     */\n    public void addCheckStateListener(ICheckStateListener listener) {\n        checkStateListeners.add(listener);\n    }\n\n    /**\n     * Creates a new table control with one column.\n     *\n     * @param parent the parent control\n     * @param style style bits\n     * @return a new table control\n     */\n    protected static Table createTable(Composite parent, int style) {\n        Table table = new Table(parent, SWT.CHECK | style);\n        // Although this table column is not needed, and can cause resize\n        // problems,\n        // it can't be removed since this would be a breaking change against\n        // R1.0.\n        // See bug 6643 for more details.\n        new TableColumn(table, SWT.NONE);\n        TableLayout layout = new TableLayout();\n        layout.addColumnData(new ColumnWeightData(100));\n        table.setLayout(layout);\n        return table;\n    }\n\n    /**\n     * Notifies any check state listeners that a check state changed has been\n     * received. Only listeners registered at the time this method is called are\n     * notified.\n     *\n     * @param event a check state changed event\n     * @see ICheckStateListener#checkStateChanged\n     */\n    private void fireCheckStateChanged(final CheckStateChangedEvent event) {\n        Object[] array = checkStateListeners.getListeners();\n        for (int i = 0; i < array.length; i++) {\n            final ICheckStateListener l = (ICheckStateListener) array[i];\n            SafeRunnable.run(new SafeRunnable() {\n\n                public void run() {\n                    l.checkStateChanged(event);\n                }\n            });\n        }\n    }\n\n    /*\n     * (non-Javadoc) Method declared on ICheckable.\n     */\n    public boolean getChecked(Object element) {\n        Widget widget = findItem(element);\n        if (widget instanceof TableItem) {\n            return ((TableItem) widget).getChecked();\n        }\n        return false;\n    }\n\n    /**\n     * Returns a list of elements corresponding to checked table items in this\n     * viewer.\n     * <p>\n     * This method is typically used when preserving the interesting state of a\n     * viewer; <code>setCheckedElements</code> is used during the restore.\n     * </p>\n     *\n     * @return the array of checked elements\n     * @see #setCheckedElements\n     */\n    public Object[] getCheckedElements() {\n        TableItem[] children = getTable().getItems();\n        ArrayList v = new ArrayList(children.length);\n        for (int i = 0; i < children.length; i++) {\n            TableItem item = children[i];\n            if (item.getChecked())\n                v.add(item.getData());\n        }\n        return v.toArray();\n    }\n\n    /**\n     * Returns the grayed state of the given element.\n     *\n     * @param element the element\n     * @return <code>true</code> if the element is grayed, and\n     *         <code>false</code> if not grayed\n     */\n    public boolean getGrayed(Object element) {\n        Widget widget = findItem(element);\n        if (widget instanceof TableItem) {\n            return ((TableItem) widget).getGrayed();\n        }\n        return false;\n    }\n\n    /**\n     * Returns a list of elements corresponding to grayed nodes in this viewer.\n     * <p>\n     * This method is typically used when preserving the interesting state of a\n     * viewer; <code>setGrayedElements</code> is used during the restore.\n     * </p>\n     *\n     * @return the array of grayed elements\n     * @see #setGrayedElements\n     */\n    public Object[] getGrayedElements() {\n        TableItem[] children = getTable().getItems();\n        List v = new ArrayList(children.length);\n        for (int i = 0; i < children.length; i++) {\n            TableItem item = children[i];\n            if (item.getGrayed())\n                v.add(item.getData());\n        }\n        return v.toArray();\n    }\n\n    /*\n     * (non-Javadoc) Method declared on StructuredViewer.\n     */\n    public void handleSelect(SelectionEvent event) {\n        if (event.detail == SWT.CHECK) {\n            // this will change the current\n            super.handleSelect(event);\n            // selection\n            TableItem item = (TableItem) event.item;\n            Object data = item.getData();\n            if (data != null) {\n                fireCheckStateChanged(new CheckStateChangedEvent(this, data, item.getChecked()));\n            }\n        } else\n            super.handleSelect(event);\n    }\n\n    /*\n     * (non-Javadoc) Method declared on Viewer.\n     */\n    protected void preservingSelection(Runnable updateCode) {\n        TableItem[] children = getTable().getItems();\n        CustomHashtable checked = newHashtable(children.length * 2 + 1);\n        CustomHashtable grayed = newHashtable(children.length * 2 + 1);\n        for (int i = 0; i < children.length; i++) {\n            TableItem item = children[i];\n            Object data = item.getData();\n            if (data != null) {\n                if (item.getChecked())\n                    checked.put(data, data);\n                if (item.getGrayed())\n                    grayed.put(data, data);\n            }\n        }\n        super.preservingSelection(updateCode);\n        children = getTable().getItems();\n        for (int i = 0; i < children.length; i++) {\n            TableItem item = children[i];\n            Object data = item.getData();\n            if (data != null) {\n                item.setChecked(checked.containsKey(data));\n                item.setGrayed(grayed.containsKey(data));\n            }\n        }\n    }\n\n    /*\n     * (non-Javadoc) Method declared on ICheckable.\n     */\n    public void removeCheckStateListener(ICheckStateListener listener) {\n        checkStateListeners.remove(listener);\n    }\n\n    /**\n     * Sets to the given value the checked state for all elements in this\n     * viewer.\n     *\n     * @param state <code>true</code> if the element should be checked, and\n     *            <code>false</code> if it should be unchecked\n     */\n    public void setAllChecked(boolean state) {\n        TableItem[] children = getTable().getItems();\n        for (int i = 0; i < children.length; i++) {\n            TableItem item = children[i];\n            item.setChecked(state);\n        }\n    }\n\n    /**\n     * Sets to the given value the grayed state for all elements in this viewer.\n     *\n     * @param state <code>true</code> if the element should be grayed, and\n     *            <code>false</code> if it should be ungrayed\n     */\n    public void setAllGrayed(boolean state) {\n        TableItem[] children = getTable().getItems();\n        for (int i = 0; i < children.length; i++) {\n            TableItem item = children[i];\n            item.setGrayed(state);\n        }\n    }\n\n    /*\n     * (non-Javadoc) Method declared on ICheckable.\n     */\n    public boolean setChecked(Object element, boolean state) {\n        Assert.isNotNull(element);\n        Widget widget = findItem(element);\n        if (widget instanceof TableItem) {\n            ((TableItem) widget).setChecked(state);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Sets which nodes are checked in this viewer. The given list contains the\n     * elements that are to be checked; all other nodes are to be unchecked.\n     * <p>\n     * This method is typically used when restoring the interesting state of a\n     * viewer captured by an earlier call to <code>getCheckedElements</code>.\n     * </p>\n     *\n     * @param elements the list of checked elements (element type:\n     *            <code>Object</code>)\n     * @see #getCheckedElements\n     */\n    public void setCheckedElements(Object[] elements) {\n        assertElementsNotNull(elements);\n        CustomHashtable set = newHashtable(elements.length * 2 + 1);\n        for (int i = 0; i < elements.length; ++i) {\n            set.put(elements[i], elements[i]);\n        }\n        TableItem[] items = getTable().getItems();\n        for (int i = 0; i < items.length; ++i) {\n            TableItem item = items[i];\n            Object element = item.getData();\n            if (element != null) {\n                boolean check = set.containsKey(element);\n                // only set if different, to avoid flicker\n                if (item.getChecked() != check) {\n                    item.setChecked(check);\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the grayed state for the given element in this viewer.\n     *\n     * @param element the element\n     * @param state <code>true</code> if the item should be grayed, and\n     *            <code>false</code> if it should be ungrayed\n     * @return <code>true</code> if the element is visible and the gray state\n     *         could be set, and <code>false</code> otherwise\n     */\n    public boolean setGrayed(Object element, boolean state) {\n        Assert.isNotNull(element);\n        Widget widget = findItem(element);\n        if (widget instanceof TableItem) {\n            ((TableItem) widget).setGrayed(state);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Sets which nodes are grayed in this viewer. The given list contains the\n     * elements that are to be grayed; all other nodes are to be ungrayed.\n     * <p>\n     * This method is typically used when restoring the interesting state of a\n     * viewer captured by an earlier call to <code>getGrayedElements</code>.\n     * </p>\n     *\n     * @param elements the array of grayed elements\n     * @see #getGrayedElements\n     */\n    public void setGrayedElements(Object[] elements) {\n        assertElementsNotNull(elements);\n        CustomHashtable set = newHashtable(elements.length * 2 + 1);\n        for (int i = 0; i < elements.length; ++i) {\n            set.put(elements[i], elements[i]);\n        }\n        TableItem[] items = getTable().getItems();\n        for (int i = 0; i < items.length; ++i) {\n            TableItem item = items[i];\n            Object element = item.getData();\n            if (element != null) {\n                boolean gray = set.containsKey(element);\n                // only set if different, to avoid flicker\n                if (item.getGrayed() != gray) {\n                    item.setGrayed(gray);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a new hashtable using the given capacity and this viewer's\n     * element comparer.\n     *\n     * @param capacity the initial capacity of the hashtable\n     * @return a new hashtable\n     * @since 3.0\n     */\n    CustomHashtable newHashtable(int capacity) {\n        return new CustomHashtable(capacity, getComparer());\n    }\n\n    final static class CustomHashtable {\n\n        /**\n         * HashMapEntry is an internal class which is used to hold the entries\n         * of a Hashtable.\n         */\n        private static class HashMapEntry {\n\n            Object key, value;\n\n            HashMapEntry next;\n\n            HashMapEntry(Object theKey, Object theValue) {\n                key = theKey;\n                value = theValue;\n            }\n        }\n\n        private static final class EmptyEnumerator implements Enumeration {\n\n            public boolean hasMoreElements() {\n                return false;\n            }\n\n            public Object nextElement() {\n                throw new NoSuchElementException();\n            }\n        }\n\n        private class HashEnumerator implements Enumeration {\n\n            boolean key;\n\n            int start;\n\n            HashMapEntry entry;\n\n            HashEnumerator(boolean isKey) {\n                key = isKey;\n                start = firstSlot;\n            }\n\n            public boolean hasMoreElements() {\n                if (entry != null)\n                    return true;\n                while (start <= lastSlot) if (elementData[start++] != null) {\n                    entry = elementData[start - 1];\n                    return true;\n                }\n                return false;\n            }\n\n            public Object nextElement() {\n                if (hasMoreElements()) {\n                    Object result = key ? entry.key : entry.value;\n                    entry = entry.next;\n                    return result;\n                } else\n                    throw new NoSuchElementException();\n            }\n        }\n\n        transient int elementCount;\n\n        transient HashMapEntry[] elementData;\n\n        private float loadFactor;\n\n        private int threshold;\n\n        transient int firstSlot = 0;\n\n        transient int lastSlot = -1;\n\n        transient private IElementComparer comparer;\n\n        private static final EmptyEnumerator emptyEnumerator = new EmptyEnumerator();\n\n        /**\n         * The default capacity used when not specified in the constructor.\n         */\n        public static final int DEFAULT_CAPACITY = 13;\n\n        /**\n         * Constructs a new Hashtable using the default capacity and load\n         * factor.\n         */\n        public CustomHashtable() {\n            this(13);\n        }\n\n        /**\n         * Constructs a new Hashtable using the specified capacity and the\n         * default load factor.\n         *\n         * @param capacity the initial capacity\n         */\n        public CustomHashtable(int capacity) {\n            this(capacity, null);\n        }\n\n        /**\n         * Constructs a new hash table with the default capacity and the given\n         * element comparer.\n         *\n         * @param comparer the element comparer to use to compare keys and\n         *            obtain hash codes for keys, or <code>null</code> to use\n         *            the normal <code>equals</code> and <code>hashCode</code>\n         *            methods\n         */\n        public CustomHashtable(IElementComparer comparer) {\n            this(DEFAULT_CAPACITY, comparer);\n        }\n\n        /**\n         * Constructs a new hash table with the given capacity and the given\n         * element comparer.\n         *\n         * @param capacity the maximum number of elements that can be added\n         *            without rehashing\n         * @param comparer the element comparer to use to compare keys and\n         *            obtain hash codes for keys, or <code>null</code> to use\n         *            the normal <code>equals</code> and <code>hashCode</code>\n         *            methods\n         */\n        public CustomHashtable(int capacity, IElementComparer comparer) {\n            if (capacity >= 0) {\n                elementCount = 0;\n                elementData = new HashMapEntry[capacity == 0 ? 1 : capacity];\n                firstSlot = elementData.length;\n                loadFactor = 0.75f;\n                computeMaxSize();\n            } else\n                throw new IllegalArgumentException();\n            this.comparer = comparer;\n        }\n\n        /**\n         * Constructs a new hash table with enough capacity to hold all keys in\n         * the given hash table, then adds all key/value pairs in the given hash\n         * table to the new one, using the given element comparer.\n         *\n         * @param capacity the maximum number of elements that can be added\n         *            without rehashing\n         * @param comparer the element comparer to use to compare keys and\n         *            obtain hash codes for keys, or <code>null</code> to use\n         *            the normal <code>equals</code> and <code>hashCode</code>\n         *            methods\n         */\n        public CustomHashtable(CustomHashtable table, IElementComparer comparer) {\n            this(table.size() * 2, comparer);\n            for (int i = table.elementData.length; --i >= 0; ) {\n                HashMapEntry entry = table.elementData[i];\n                while (entry != null) {\n                    put(entry.key, entry.value);\n                    entry = entry.next;\n                }\n            }\n        }\n\n        private void computeMaxSize() {\n            threshold = (int) (elementData.length * loadFactor);\n        }\n\n        /**\n         * Answers if this Hashtable contains the specified object as a key of\n         * one of the key/value pairs.\n         *\n         * @param key the object to look for as a key in this Hashtable\n         * @return true if object is a key in this Hashtable, false otherwise\n         */\n        public boolean containsKey(Object key) {\n            return getEntry(key) != null;\n        }\n\n        /**\n         * Answers an Enumeration on the values of this Hashtable. The results\n         * of the Enumeration may be affected if the contents of this Hashtable\n         * are modified.\n         *\n         * @return an Enumeration of the values of this Hashtable\n         */\n        public Enumeration elements() {\n            if (elementCount == 0)\n                return emptyEnumerator;\n            return new HashEnumerator(false);\n        }\n\n        /**\n         * Answers the value associated with the specified key in this\n         * Hashtable.\n         *\n         * @param key the key of the value returned\n         * @return the value associated with the specified key, null if the\n         *         specified key does not exist\n         */\n        public Object get(Object key) {\n            int index = (hashCode(key) & 0x7FFFFFFF) % elementData.length;\n            HashMapEntry entry = elementData[index];\n            while (entry != null) {\n                if (keyEquals(key, entry.key))\n                    return entry.value;\n                entry = entry.next;\n            }\n            return null;\n        }\n\n        private HashMapEntry getEntry(Object key) {\n            int index = (hashCode(key) & 0x7FFFFFFF) % elementData.length;\n            HashMapEntry entry = elementData[index];\n            while (entry != null) {\n                if (keyEquals(key, entry.key))\n                    return entry;\n                entry = entry.next;\n            }\n            return null;\n        }\n\n        /**\n         * Answers the hash code for the given key.\n         */\n        private int hashCode(Object key) {\n            if (comparer == null)\n                return key.hashCode();\n            else\n                return comparer.hashCode(key);\n        }\n\n        /**\n         * Compares two keys for equality.\n         */\n        private boolean keyEquals(Object a, Object b) {\n            if (comparer == null)\n                return a.equals(b);\n            else\n                return comparer.equals(a, b);\n        }\n\n        /**\n         * Answers an Enumeration on the keys of this Hashtable. The results of\n         * the Enumeration may be affected if the contents of this Hashtable are\n         * modified.\n         *\n         * @return an Enumeration of the keys of this Hashtable\n         */\n        public Enumeration keys() {\n            if (elementCount == 0)\n                return emptyEnumerator;\n            return new HashEnumerator(true);\n        }\n\n        /**\n         * Associate the specified value with the specified key in this\n         * Hashtable. If the key already exists, the old value is replaced. The\n         * key and value cannot be null.\n         *\n         * @param key the key to add\n         * @param value the value to add\n         * @return the old value associated with the specified key, null if the\n         *         key did not exist\n         */\n        public Object put(Object key, Object value) {\n            if (key != null && value != null) {\n                int index = (hashCode(key) & 0x7FFFFFFF) % elementData.length;\n                HashMapEntry entry = elementData[index];\n                while (entry != null && !keyEquals(key, entry.key)) entry = entry.next;\n                if (entry == null) {\n                    if (++elementCount > threshold) {\n                        rehash();\n                        index = (hashCode(key) & 0x7FFFFFFF) % elementData.length;\n                    }\n                    if (index < firstSlot)\n                        firstSlot = index;\n                    if (index > lastSlot)\n                        lastSlot = index;\n                    entry = new HashMapEntry(key, value);\n                    entry.next = elementData[index];\n                    elementData[index] = entry;\n                    return null;\n                }\n                Object result = entry.value;\n                // important to avoid hanging onto keys that\n                entry.key = key;\n                // are equal but \"old\" -- see bug 30607\n                entry.value = value;\n                return result;\n            } else\n                throw new NullPointerException();\n        }\n\n        /**\n         * Increases the capacity of this Hashtable. This method is sent when\n         * the size of this Hashtable exceeds the load factor.\n         */\n        private void rehash() {\n            int length = elementData.length << 1;\n            if (length == 0)\n                length = 1;\n            firstSlot = length;\n            lastSlot = -1;\n            HashMapEntry[] newData = new HashMapEntry[length];\n            for (int i = elementData.length; --i >= 0; ) {\n                HashMapEntry entry = elementData[i];\n                while (entry != null) {\n                    int index = (hashCode(entry.key) & 0x7FFFFFFF) % length;\n                    if (index < firstSlot)\n                        firstSlot = index;\n                    if (index > lastSlot)\n                        lastSlot = index;\n                    HashMapEntry next = entry.next;\n                    entry.next = newData[index];\n                    newData[index] = entry;\n                    entry = next;\n                }\n            }\n            elementData = newData;\n            computeMaxSize();\n        }\n\n        /**\n         * Remove the key/value pair with the specified key from this Hashtable.\n         *\n         * @param key the key to remove\n         * @return the value associated with the specified key, null if the\n         *         specified key did not exist\n         */\n        public Object remove(Object key) {\n            HashMapEntry last = null;\n            int index = (hashCode(key) & 0x7FFFFFFF) % elementData.length;\n            HashMapEntry entry = elementData[index];\n            while (entry != null && !keyEquals(key, entry.key)) {\n                last = entry;\n                entry = entry.next;\n            }\n            if (entry != null) {\n                if (last == null)\n                    elementData[index] = entry.next;\n                else\n                    last.next = entry.next;\n                elementCount--;\n                return entry.value;\n            }\n            return null;\n        }\n\n        /**\n         * Answers the number of key/value pairs in this Hashtable.\n         *\n         * @return the number of key/value pairs in this Hashtable\n         */\n        public int size() {\n            return elementCount;\n        }\n\n        /**\n         * Answers the string representation of this Hashtable.\n         *\n         * @return the string representation of this Hashtable\n         */\n        public String toString() {\n            if (size() == 0)\n                //$NON-NLS-1$\n                return \"{}\";\n            StringBuffer buffer = new StringBuffer();\n            buffer.append('{');\n            for (int i = elementData.length; --i >= 0; ) {\n                HashMapEntry entry = elementData[i];\n                while (entry != null) {\n                    buffer.append(entry.key);\n                    buffer.append('=');\n                    buffer.append(entry.value);\n                    //$NON-NLS-1$\n                    buffer.append(\", \");\n                    entry = entry.next;\n                }\n            }\n            // Remove the last \", \"\n            if (elementCount > 0)\n                buffer.setLength(buffer.length() - 2);\n            buffer.append('}');\n            return buffer.toString();\n        }\n    }\n    // CHECKSTYLE:ON\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/table/EnhancedCheckBoxTableViewer.java",
		"test_prompt": "// EnhancedCheckBoxTableViewerTest.java\npackage com.atlassw.tools.eclipse.checkstyle.util.table;\n\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport org.eclipse.jface.util.Assert;\nimport org.eclipse.jface.util.ListenerList;\nimport org.eclipse.jface.util.SafeRunnable;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.ColumnWeightData;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.ICheckable;\nimport org.eclipse.jface.viewers.IElementComparer;\nimport org.eclipse.jface.viewers.TableLayout;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Table;\nimport org.eclipse.swt.widgets.TableColumn;\nimport org.eclipse.swt.widgets.TableItem;\nimport org.eclipse.swt.widgets.Widget;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EnhancedCheckBoxTableViewer}.\n* It contains ten unit test cases for the {@link EnhancedCheckBoxTableViewer#newCheckList(Composite, int)} method.\n*/\nclass EnhancedCheckBoxTableViewerTest {"
	},
	{
		"original_code": "// CustomLibrariesClassLoader.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\n\n/**\n * This class constructs a classloader that is able to load from .jar archives\n * located in the extension-libraries folder inside the plugin directory.\n *\n * @author Lars K�dderitzsch\n */\npublic final class CustomLibrariesClassLoader {\n\n    //\n    // attributes\n    //\n    /**\n     * the internal classloader.\n     */\n    private static ClassLoader sLibrariesClassLoader;\n\n    //\n    // constructors\n    //\n    /**\n     * Hidden default constructor.\n     */\n    private CustomLibrariesClassLoader() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Invalidates the classloader. It will be reconstructed the next time it is\n     * requested.\n     */\n    public static synchronized void invalidate() {\n        sLibrariesClassLoader = null;\n    }\n\n    /**\n     * Returns the classloader used to load custom libraries.\n     *\n     * @return the classloader\n     * @throws CheckstylePluginException when accessing the content of the\n     *             extension-libraries directory\n     */\n    public static synchronized ClassLoader get() throws CheckstylePluginException {\n        if (sLibrariesClassLoader == null) {\n            try {\n                build();\n            } catch (IOException e) {\n                CheckstylePluginException.rethrow(e);\n            }\n        }\n        return sLibrariesClassLoader;\n    }\n\n    /**\n     * Builds the classloader used to load custom libraries.\n     */\n    private static void build() throws IOException {\n        ClassLoader contextClassloader = CustomLibrariesClassLoader.class.getClassLoader();\n        URL[] libraryURLs = getCustomLibraryURLs();\n        sLibrariesClassLoader = new URLClassLoader(libraryURLs, contextClassloader);\n    }\n\n    /**\n     * Locates the jar files inside the extension-libraries folder.\n     *\n     * @return the URLs to the extension libaries\n     * @throws IOException error accession the extension-libraries folder\n     */\n    private static URL[] getCustomLibraryURLs() throws IOException {\n        URL extensionLibsURL = CheckstylePlugin.getDefault().find(new Path(CheckstylePlugin.EXTENSION_LIBS_DIR));\n        extensionLibsURL = Platform.resolve(extensionLibsURL);\n        File extensionLibsDir = new File(extensionLibsURL.getFile());\n        File[] jarFiles = extensionLibsDir.listFiles(new JarFileFilter());\n        // this can happen on \"unexploded\" install\n        if (jarFiles == null) {\n            return new URL[0];\n        }\n        URL[] jarURLs = new URL[jarFiles.length];\n        for (int i = 0; i < jarFiles.length; i++) {\n            jarURLs[i] = jarFiles[i].toURL();\n        }\n        return jarURLs;\n    }\n\n    /**\n     * File filter that accepts .jar files.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class JarFileFilter implements FileFilter {\n\n        /**\n         * @see java.io.FileFilter#accept(java.io.File)\n         */\n        public boolean accept(File pathname) {\n            //$NON-NLS-1$\n            return pathname.getAbsolutePath().endsWith(\".jar\");\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/util/CustomLibrariesClassLoader.java",
		"test_prompt": "// CustomLibrariesClassLoaderTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.util;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CustomLibrariesClassLoader}.\n* It contains ten unit test cases for the {@link CustomLibrariesClassLoader#get()} method.\n*/\nclass CustomLibrariesClassLoaderTest {"
	},
	{
		"original_code": "// ConfigurationReader.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.RuleMetadata;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * Utitlity class to read a checkstyle configuration and transform to the\n * plugins module objects.\n *\n * @author Lars K�dderitzsch\n */\npublic final class ConfigurationReader {\n\n    //\n    // Mapping from public DTD to internal dtd resource.\n    // @see com.puppycrawl.tools.checkstyle.api.AbstractLoader\n    //\n    /**\n     * Map containing the public - internal DTD mapping.\n     */\n    private static final Map PUBLIC2INTERNAL_DTD_MAP = new HashMap();\n\n    static {\n        //$NON-NLS-1$\n        PUBLIC2INTERNAL_DTD_MAP.//$NON-NLS-1$\n        put(//$NON-NLS-1$\n        \"-//Puppy Crawl//DTD Check Configuration 1.0//EN\", //$NON-NLS-1$\n        \"com/puppycrawl/tools/checkstyle/configuration_1_0.dtd\");\n        //$NON-NLS-1$\n        PUBLIC2INTERNAL_DTD_MAP.//$NON-NLS-1$\n        put(//$NON-NLS-1$\n        \"-//Puppy Crawl//DTD Check Configuration 1.1//EN\", //$NON-NLS-1$\n        \"com/puppycrawl/tools/checkstyle/configuration_1_1.dtd\");\n        //$NON-NLS-1$\n        PUBLIC2INTERNAL_DTD_MAP.//$NON-NLS-1$\n        put(//$NON-NLS-1$\n        \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\", //$NON-NLS-1$\n        \"com/puppycrawl/tools/checkstyle/configuration_1_2.dtd\");\n    }\n\n    //\n    // constructors\n    //\n    /**\n     * Hidden default constructor to prevent instantiation.\n     */\n    private ConfigurationReader() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Reads the checkstyle configuration from the given stream an returs a list\n     * of all modules within this configuration.\n     *\n     * @param in the stream the configuration is loaded from\n     * @return the list of modules\n     * @throws CheckstylePluginException error while reading the configuration\n     */\n    public static List read(InputStream in) throws CheckstylePluginException {\n        List rules = null;\n        try {\n            ConfigurationHandler handler = new ConfigurationHandler();\n            XMLUtil.parseWithSAX(in, handler);\n            rules = handler.getRules();\n        } catch (SAXException se) {\n            Exception ex = se.getException() != null ? se.getException() : se;\n            CheckstylePluginException.rethrow(ex);\n        } catch (ParserConfigurationException pe) {\n            CheckstylePluginException.rethrow(pe);\n        } catch (IOException ioe) {\n            CheckstylePluginException.rethrow(ioe);\n        }\n        return rules != null ? rules : new ArrayList();\n    }\n\n    /**\n     * Gets additional data about the Checkstyle configuration. This data is\n     * used by the plugin for special purposes, like determining the correct\n     * offset of a checkstyle violation.\n     *\n     * @param in the input stream\n     * @return the additional configuration data\n     * @throws CheckstylePluginException error while reading the configuration\n     */\n    public static AdditionalConfigData getAdditionalConfigData(InputStream in) throws CheckstylePluginException {\n        List modules = read(in);\n        Map messages = new HashMap();\n        int tabWidth = 8;\n        Iterator it = modules.iterator();\n        while (it.hasNext()) {\n            Module module = (Module) it.next();\n            if (module.getCustomMessage() != null) {\n                String id = module.getId();\n                if (id == null && module.getMetaData() != null) {\n                    id = module.getMetaData().getInternalName();\n                }\n                if (id == null) {\n                    id = module.getName();\n                }\n                messages.put(id, module.getCustomMessage());\n            }\n            if (module.getMetaData() != null && module.getMetaData().getInternalName().equals(XMLTags.TREEWALKER_MODULE)) {\n                //$NON-NLS-1$\n                ConfigProperty prop = module.getProperty(\"tabWidth\");\n                String tabWidthProp = prop.getValue() != null ? prop.getValue() : prop.getMetaData().getDefaultValue();\n                try {\n                    tabWidth = Integer.parseInt(tabWidthProp);\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        }\n        return new AdditionalConfigData(tabWidth, messages);\n    }\n\n    /**\n     * SAX-Handler for parsing checkstyle configurations and building modules.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class ConfigurationHandler extends DefaultHandler {\n\n        /**\n         * The list of modules.\n         */\n        private List mRules = new ArrayList();\n\n        /**\n         * The current modules being built.\n         */\n        private Stack mCurrentStack = new Stack();\n\n        public List getRules() {\n            return mRules;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException {\n            if (PUBLIC2INTERNAL_DTD_MAP.containsKey(publicId)) {\n                final String dtdResourceName = (String) PUBLIC2INTERNAL_DTD_MAP.get(publicId);\n                final InputStream dtdIS = getClass().getClassLoader().getResourceAsStream(dtdResourceName);\n                if (dtdIS == null) {\n                    throw new SAXException(NLS.bind(ErrorMessages.msgErrorLoadingCheckstyleDTD, dtdResourceName));\n                }\n                return new InputSource(dtdIS);\n            }\n            // This is a hack to workaround problem with SAX\n            // DefaultHeader.resolveEntity():\n            // sometimes it throws SAX- and IO- exceptions\n            // sometime SAX only :(\n            try {\n                if (false) {\n                    //$NON-NLS-1$\n                    throw new IOException(\"\");\n                }\n                return super.resolveEntity(publicId, systemId);\n            } catch (IOException e) {\n                //$NON-NLS-1$\n                throw new SAXException(\"\" + e, e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            if (XMLTags.MODULE_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                RuleMetadata metadata = MetadataFactory.getRuleMetadata(name);\n                Module module = null;\n                if (metadata != null) {\n                    module = new Module(metadata, true);\n                } else {\n                    module = new Module(name);\n                }\n                mRules.add(module);\n                mCurrentStack.push(module);\n            } else if (XMLTags.PROPERTY_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                String value = attributes.getValue(XMLTags.VALUE_TAG);\n                Module module = (Module) mCurrentStack.peek();\n                if (name.equals(XMLTags.SEVERITY_TAG) && module.getMetaData() != null && module.getMetaData().hasSeverity()) {\n                    try {\n                        module.setSeverity(SeverityLevel.getInstance(value));\n                    } catch (IllegalArgumentException e) {\n                        module.setSeverity(SeverityLevel.WARNING);\n                    }\n                } else if (name.equals(XMLTags.ID_TAG)) {\n                    module.setId(StringUtils.trimToNull(value));\n                } else if (module.getMetaData() != null) {\n                    ConfigProperty property = module.getProperty(name);\n                    if (property != null) {\n                        property.setValue(value);\n                    }\n                    // properties that are not within the meta data are omitted\n                } else {\n                    // if module has no meta data defined create property\n                    ConfigProperty property = new ConfigProperty(name, value);\n                    module.getProperties().add(property);\n                }\n            } else if (XMLTags.METADATA_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                String value = attributes.getValue(XMLTags.VALUE_TAG);\n                Module module = (Module) mCurrentStack.peek();\n                if (XMLTags.COMMENT_ID.equals(name)) {\n                    module.setComment(value);\n                } else if (XMLTags.CUSTOM_MESSAGE_ID.equals(name)) {\n                    module.setCustomMessage(value);\n                } else if (XMLTags.LAST_ENABLED_SEVERITY_ID.equals(name)) {\n                    module.setLastEnabledSeverity(SeverityLevel.getInstance(value));\n                } else {\n                    module.getCustomMetaData().put(name, value);\n                }\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.MODULE_TAG.equals(qName)) {\n                // if the module has not metadata attached we create some\n                // generic metadata\n                Module module = (Module) mCurrentStack.pop();\n                if (module.getMetaData() == null) {\n                    MetadataFactory.createGenericMetadata(module);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holds additional data about the Checkstyle configuration file, for\n     * special uses.\n     *\n     * @author Lars Koedderitzsch\n     */\n    public static class AdditionalConfigData {\n\n        private int mTabWidth;\n\n        private Map mCustomMessages;\n\n        /**\n         * @param tabWidth the tab width setting of the Checkstyle configuration\n         * @param customMessages the custom messages defined in the\n         *            configuration\n         */\n        public AdditionalConfigData(int tabWidth, Map customMessages) {\n            super();\n            mTabWidth = tabWidth;\n            mCustomMessages = customMessages;\n        }\n\n        /**\n         * The tab width of the check configuration.\n         *\n         * @return the tab width setting\n         */\n        public int getTabWidth() {\n            return mTabWidth;\n        }\n\n        /**\n         * Returns the custom messages of the check configuration, keyed by\n         * module id or module name if no id is set.\n         *\n         * @return the custom messages\n         */\n        public Map getCustomMessages() {\n            return mCustomMessages;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/ConfigurationReader_0Test.java",
		"test_prompt": "// ConfigurationReader_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.RuleMetadata;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigurationReader}.\n* It contains ten unit test cases for the {@link ConfigurationReader#read(InputStream)} method.\n*/\nclass ConfigurationReader_0Test {"
	},
	{
		"original_code": "// ConfigurationReader.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.RuleMetadata;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * Utitlity class to read a checkstyle configuration and transform to the\n * plugins module objects.\n *\n * @author Lars K�dderitzsch\n */\npublic final class ConfigurationReader {\n\n    //\n    // Mapping from public DTD to internal dtd resource.\n    // @see com.puppycrawl.tools.checkstyle.api.AbstractLoader\n    //\n    /**\n     * Map containing the public - internal DTD mapping.\n     */\n    private static final Map PUBLIC2INTERNAL_DTD_MAP = new HashMap();\n\n    static {\n        //$NON-NLS-1$\n        PUBLIC2INTERNAL_DTD_MAP.//$NON-NLS-1$\n        put(//$NON-NLS-1$\n        \"-//Puppy Crawl//DTD Check Configuration 1.0//EN\", //$NON-NLS-1$\n        \"com/puppycrawl/tools/checkstyle/configuration_1_0.dtd\");\n        //$NON-NLS-1$\n        PUBLIC2INTERNAL_DTD_MAP.//$NON-NLS-1$\n        put(//$NON-NLS-1$\n        \"-//Puppy Crawl//DTD Check Configuration 1.1//EN\", //$NON-NLS-1$\n        \"com/puppycrawl/tools/checkstyle/configuration_1_1.dtd\");\n        //$NON-NLS-1$\n        PUBLIC2INTERNAL_DTD_MAP.//$NON-NLS-1$\n        put(//$NON-NLS-1$\n        \"-//Puppy Crawl//DTD Check Configuration 1.2//EN\", //$NON-NLS-1$\n        \"com/puppycrawl/tools/checkstyle/configuration_1_2.dtd\");\n    }\n\n    //\n    // constructors\n    //\n    /**\n     * Hidden default constructor to prevent instantiation.\n     */\n    private ConfigurationReader() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Reads the checkstyle configuration from the given stream an returs a list\n     * of all modules within this configuration.\n     *\n     * @param in the stream the configuration is loaded from\n     * @return the list of modules\n     * @throws CheckstylePluginException error while reading the configuration\n     */\n    public static List read(InputStream in) throws CheckstylePluginException {\n        List rules = null;\n        try {\n            ConfigurationHandler handler = new ConfigurationHandler();\n            XMLUtil.parseWithSAX(in, handler);\n            rules = handler.getRules();\n        } catch (SAXException se) {\n            Exception ex = se.getException() != null ? se.getException() : se;\n            CheckstylePluginException.rethrow(ex);\n        } catch (ParserConfigurationException pe) {\n            CheckstylePluginException.rethrow(pe);\n        } catch (IOException ioe) {\n            CheckstylePluginException.rethrow(ioe);\n        }\n        return rules != null ? rules : new ArrayList();\n    }\n\n    /**\n     * Gets additional data about the Checkstyle configuration. This data is\n     * used by the plugin for special purposes, like determining the correct\n     * offset of a checkstyle violation.\n     *\n     * @param in the input stream\n     * @return the additional configuration data\n     * @throws CheckstylePluginException error while reading the configuration\n     */\n    public static AdditionalConfigData getAdditionalConfigData(InputStream in) throws CheckstylePluginException {\n        List modules = read(in);\n        Map messages = new HashMap();\n        int tabWidth = 8;\n        Iterator it = modules.iterator();\n        while (it.hasNext()) {\n            Module module = (Module) it.next();\n            if (module.getCustomMessage() != null) {\n                String id = module.getId();\n                if (id == null && module.getMetaData() != null) {\n                    id = module.getMetaData().getInternalName();\n                }\n                if (id == null) {\n                    id = module.getName();\n                }\n                messages.put(id, module.getCustomMessage());\n            }\n            if (module.getMetaData() != null && module.getMetaData().getInternalName().equals(XMLTags.TREEWALKER_MODULE)) {\n                //$NON-NLS-1$\n                ConfigProperty prop = module.getProperty(\"tabWidth\");\n                String tabWidthProp = prop.getValue() != null ? prop.getValue() : prop.getMetaData().getDefaultValue();\n                try {\n                    tabWidth = Integer.parseInt(tabWidthProp);\n                } catch (Exception e) {\n                    // ignore\n                }\n            }\n        }\n        return new AdditionalConfigData(tabWidth, messages);\n    }\n\n    /**\n     * SAX-Handler for parsing checkstyle configurations and building modules.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class ConfigurationHandler extends DefaultHandler {\n\n        /**\n         * The list of modules.\n         */\n        private List mRules = new ArrayList();\n\n        /**\n         * The current modules being built.\n         */\n        private Stack mCurrentStack = new Stack();\n\n        public List getRules() {\n            return mRules;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException {\n            if (PUBLIC2INTERNAL_DTD_MAP.containsKey(publicId)) {\n                final String dtdResourceName = (String) PUBLIC2INTERNAL_DTD_MAP.get(publicId);\n                final InputStream dtdIS = getClass().getClassLoader().getResourceAsStream(dtdResourceName);\n                if (dtdIS == null) {\n                    throw new SAXException(NLS.bind(ErrorMessages.msgErrorLoadingCheckstyleDTD, dtdResourceName));\n                }\n                return new InputSource(dtdIS);\n            }\n            // This is a hack to workaround problem with SAX\n            // DefaultHeader.resolveEntity():\n            // sometimes it throws SAX- and IO- exceptions\n            // sometime SAX only :(\n            try {\n                if (false) {\n                    //$NON-NLS-1$\n                    throw new IOException(\"\");\n                }\n                return super.resolveEntity(publicId, systemId);\n            } catch (IOException e) {\n                //$NON-NLS-1$\n                throw new SAXException(\"\" + e, e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            if (XMLTags.MODULE_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                RuleMetadata metadata = MetadataFactory.getRuleMetadata(name);\n                Module module = null;\n                if (metadata != null) {\n                    module = new Module(metadata, true);\n                } else {\n                    module = new Module(name);\n                }\n                mRules.add(module);\n                mCurrentStack.push(module);\n            } else if (XMLTags.PROPERTY_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                String value = attributes.getValue(XMLTags.VALUE_TAG);\n                Module module = (Module) mCurrentStack.peek();\n                if (name.equals(XMLTags.SEVERITY_TAG) && module.getMetaData() != null && module.getMetaData().hasSeverity()) {\n                    try {\n                        module.setSeverity(SeverityLevel.getInstance(value));\n                    } catch (IllegalArgumentException e) {\n                        module.setSeverity(SeverityLevel.WARNING);\n                    }\n                } else if (name.equals(XMLTags.ID_TAG)) {\n                    module.setId(StringUtils.trimToNull(value));\n                } else if (module.getMetaData() != null) {\n                    ConfigProperty property = module.getProperty(name);\n                    if (property != null) {\n                        property.setValue(value);\n                    }\n                    // properties that are not within the meta data are omitted\n                } else {\n                    // if module has no meta data defined create property\n                    ConfigProperty property = new ConfigProperty(name, value);\n                    module.getProperties().add(property);\n                }\n            } else if (XMLTags.METADATA_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                String value = attributes.getValue(XMLTags.VALUE_TAG);\n                Module module = (Module) mCurrentStack.peek();\n                if (XMLTags.COMMENT_ID.equals(name)) {\n                    module.setComment(value);\n                } else if (XMLTags.CUSTOM_MESSAGE_ID.equals(name)) {\n                    module.setCustomMessage(value);\n                } else if (XMLTags.LAST_ENABLED_SEVERITY_ID.equals(name)) {\n                    module.setLastEnabledSeverity(SeverityLevel.getInstance(value));\n                } else {\n                    module.getCustomMetaData().put(name, value);\n                }\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.MODULE_TAG.equals(qName)) {\n                // if the module has not metadata attached we create some\n                // generic metadata\n                Module module = (Module) mCurrentStack.pop();\n                if (module.getMetaData() == null) {\n                    MetadataFactory.createGenericMetadata(module);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holds additional data about the Checkstyle configuration file, for\n     * special uses.\n     *\n     * @author Lars Koedderitzsch\n     */\n    public static class AdditionalConfigData {\n\n        private int mTabWidth;\n\n        private Map mCustomMessages;\n\n        /**\n         * @param tabWidth the tab width setting of the Checkstyle configuration\n         * @param customMessages the custom messages defined in the\n         *            configuration\n         */\n        public AdditionalConfigData(int tabWidth, Map customMessages) {\n            super();\n            mTabWidth = tabWidth;\n            mCustomMessages = customMessages;\n        }\n\n        /**\n         * The tab width of the check configuration.\n         *\n         * @return the tab width setting\n         */\n        public int getTabWidth() {\n            return mTabWidth;\n        }\n\n        /**\n         * Returns the custom messages of the check configuration, keyed by\n         * module id or module name if no id is set.\n         *\n         * @return the custom messages\n         */\n        public Map getCustomMessages() {\n            return mCustomMessages;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/ConfigurationReader_1Test.java",
		"test_prompt": "// ConfigurationReader_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.RuleMetadata;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigurationReader}.\n* It contains ten unit test cases for the {@link ConfigurationReader#getAdditionalConfigData(InputStream)} method.\n*/\nclass ConfigurationReader_1Test {"
	},
	{
		"original_code": "// ConfigProperty.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.ConfigPropertyMetadata;\n\n/**\n * A simple configuration consisting of a name/value pair.\n */\npublic class ConfigProperty implements Comparable, Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The name of the property.\n     */\n    private String mName;\n\n    /**\n     * The value of the property.\n     */\n    private String mValue;\n\n    /**\n     * The meta data of the property.\n     */\n    private ConfigPropertyMetadata mMetaData;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Constructor.\n     *\n     * @param metaData the property meta data\n     */\n    public ConfigProperty(ConfigPropertyMetadata metaData) {\n        this(metaData.getName(), metaData.getOverrideDefault() != null ? metaData.getOverrideDefault() : metaData.getDefaultValue());\n        setMetaData(metaData);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param name Property name.\n     * @param value Property value.\n     */\n    public ConfigProperty(String name, String value) {\n        setName(name);\n        setValue(value);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get the property's name.\n     *\n     * @return The name\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * Set the property's name.\n     *\n     * @param name The new name.\n     */\n    public void setName(String name) {\n        mName = name;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return String\n     */\n    public String getValue() {\n        return mValue;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value The value to set\n     */\n    public void setValue(String value) {\n        mValue = value;\n    }\n\n    /**\n     * Returns the meta data for this property.\n     *\n     * @return the meta data\n     */\n    public ConfigPropertyMetadata getMetaData() {\n        return mMetaData;\n    }\n\n    /**\n     * Sets the meta data for this property.\n     *\n     * @param metaData the meta data\n     */\n    public void setMetaData(ConfigPropertyMetadata metaData) {\n        mMetaData = metaData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compareTo(Object obj) {\n        return this.mName.compareTo(((ConfigProperty) obj).mName);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            Object clone = super.clone();\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // Should not happen\n            throw new InternalError();\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/ConfigProperty_0Test.java",
		"test_prompt": "// ConfigProperty_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.ConfigPropertyMetadata;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigProperty}.\n* It contains ten unit test cases for the {@link ConfigProperty#compareTo(Object)} method.\n*/\nclass ConfigProperty_0Test {"
	},
	{
		"original_code": "// ConfigProperty.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.ConfigPropertyMetadata;\n\n/**\n * A simple configuration consisting of a name/value pair.\n */\npublic class ConfigProperty implements Comparable, Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The name of the property.\n     */\n    private String mName;\n\n    /**\n     * The value of the property.\n     */\n    private String mValue;\n\n    /**\n     * The meta data of the property.\n     */\n    private ConfigPropertyMetadata mMetaData;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Constructor.\n     *\n     * @param metaData the property meta data\n     */\n    public ConfigProperty(ConfigPropertyMetadata metaData) {\n        this(metaData.getName(), metaData.getOverrideDefault() != null ? metaData.getOverrideDefault() : metaData.getDefaultValue());\n        setMetaData(metaData);\n    }\n\n    /**\n     * Constructor.\n     *\n     * @param name Property name.\n     * @param value Property value.\n     */\n    public ConfigProperty(String name, String value) {\n        setName(name);\n        setValue(value);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get the property's name.\n     *\n     * @return The name\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * Set the property's name.\n     *\n     * @param name The new name.\n     */\n    public void setName(String name) {\n        mName = name;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return String\n     */\n    public String getValue() {\n        return mValue;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value The value to set\n     */\n    public void setValue(String value) {\n        mValue = value;\n    }\n\n    /**\n     * Returns the meta data for this property.\n     *\n     * @return the meta data\n     */\n    public ConfigPropertyMetadata getMetaData() {\n        return mMetaData;\n    }\n\n    /**\n     * Sets the meta data for this property.\n     *\n     * @param metaData the meta data\n     */\n    public void setMetaData(ConfigPropertyMetadata metaData) {\n        mMetaData = metaData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int compareTo(Object obj) {\n        return this.mName.compareTo(((ConfigProperty) obj).mName);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            Object clone = super.clone();\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // Should not happen\n            throw new InternalError();\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/ConfigProperty_1Test.java",
		"test_prompt": "// ConfigProperty_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.ConfigPropertyMetadata;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigProperty}.\n* It contains ten unit test cases for the {@link ConfigProperty#clone()} method.\n*/\nclass ConfigProperty_1Test {"
	},
	{
		"original_code": "// Module.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.ConfigPropertyMetadata;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.RuleMetadata;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * Object representing a module from a checkstyle configuration. Can be\n * augumented with meta data.\n *\n * @author Lars K�dderitzsch\n */\npublic class Module implements Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * the name of the module.\n     */\n    private String mName;\n\n    /**\n     * the meta data associated with the module.\n     */\n    private RuleMetadata mMetaData;\n\n    /**\n     * the properties of the modules.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * the comment of the module.\n     */\n    private String mComment;\n\n    /**\n     * the id of the module.\n     */\n    private String mId;\n\n    /**\n     * the custom message for this module.\n     */\n    private String mCustomMessage;\n\n    /**\n     * the severity level.\n     */\n    private SeverityLevel mSeverityLevel;\n\n    /**\n     * the last severity level before setting to ignored.\n     */\n    private SeverityLevel mLastEnabledSeverity;\n\n    /**\n     * map containing unknown custom metadata of the module.\n     */\n    private Map mCustomMetaData = new HashMap();\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a module with the according meta data.\n     *\n     * @param metaData the meta data\n     * @param withDefaults determines if the properties should be initialized\n     *            with the Checkstyle default values\n     */\n    public Module(RuleMetadata metaData, boolean withDefaults) {\n        mMetaData = metaData;\n        if (metaData != null) {\n            // create the properties according to the meta data\n            List propMetas = metaData.getPropertyMetadata();\n            int size = propMetas != null ? propMetas.size() : 0;\n            for (int i = 0; i < size; i++) {\n                ConfigPropertyMetadata propMeta = (ConfigPropertyMetadata) propMetas.get(i);\n                ConfigProperty property = new ConfigProperty(propMeta);\n                getProperties().add(property);\n                if (withDefaults) {\n                    property.setValue(propMeta.getDefaultValue());\n                }\n            }\n        }\n    }\n\n    /**\n     * Create a module without meta data.\n     *\n     * @param name the name of the module\n     */\n    public Module(String name) {\n        mName = name;\n    }\n\n    /**\n     * Returns the name of the module.\n     *\n     * @return the name of the module\n     */\n    public String getName() {\n        return mMetaData != null ? mMetaData.getRuleName() : mName;\n    }\n\n    /**\n     * Returns the unique id of the module.\n     *\n     * @return the id\n     */\n    public String getId() {\n        return mId;\n    }\n\n    /**\n     * Sets the unique id of the module.\n     *\n     * @param id the id to set\n     */\n    public void setId(String id) {\n        mId = id;\n    }\n\n    /**\n     * Returns the custom message to display instead of Checkstyle's default\n     * message.\n     *\n     * @return the customMessage\n     */\n    public String getCustomMessage() {\n        return mCustomMessage;\n    }\n\n    /**\n     * Sets the custom message to display instead of Checkstyle's default\n     * message.\n     *\n     * @param customMessage the customMessage to set\n     */\n    public void setCustomMessage(String customMessage) {\n        mCustomMessage = customMessage;\n    }\n\n    /**\n     * Returns the meta data associated with the module.\n     *\n     * @return the meta data of the module\n     */\n    public RuleMetadata getMetaData() {\n        return mMetaData;\n    }\n\n    /**\n     * Sets the meta data of the module.\n     *\n     * @param metaData the meta data\n     */\n    public void setMetaData(RuleMetadata metaData) {\n        mMetaData = metaData;\n    }\n\n    /**\n     * Returns all properties of this module.\n     *\n     * @return the properties\n     */\n    public List getProperties() {\n        return mProperties;\n    }\n\n    /**\n     * Returns the property data for a given property name.\n     *\n     * @param property the property name\n     * @return the coresponding property or <code>null</code>\n     */\n    public ConfigProperty getProperty(String property) {\n        ConfigProperty propertyObj = null;\n        int size = mProperties != null ? mProperties.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigProperty tmp = (ConfigProperty) mProperties.get(i);\n            if (tmp.getName().equals(property)) {\n                propertyObj = tmp;\n                break;\n            }\n        }\n        return propertyObj;\n    }\n\n    /**\n     * Returns the user comment for this module.\n     *\n     * @return the comment\n     */\n    public String getComment() {\n        return mComment;\n    }\n\n    /**\n     * Sets the user comment for this module.\n     *\n     * @param comment the comment\n     */\n    public void setComment(String comment) {\n        mComment = comment;\n    }\n\n    /**\n     * Returns the severity level of this module.\n     *\n     * @return the severity level\n     */\n    public SeverityLevel getSeverity() {\n        if (mMetaData != null && mMetaData.hasSeverity()) {\n            return mSeverityLevel != null ? mSeverityLevel : getMetaData().getDefaultSeverityLevel();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the last severity level before the module was set to ignore.\n     *\n     * @return the last severity level\n     */\n    public SeverityLevel getLastEnabledSeverity() {\n        return mLastEnabledSeverity;\n    }\n\n    /**\n     * Sets the last enabled severity. This is used to restore the original\n     * severity setting after the module has been set to ignore.\n     *\n     * @param severity the severity\n     */\n    public void setLastEnabledSeverity(SeverityLevel severity) {\n        mLastEnabledSeverity = severity;\n    }\n\n    /**\n     * Sets the severity level.\n     *\n     * @param severityLevel the severity level to set\n     */\n    public void setSeverity(SeverityLevel severityLevel) {\n        SeverityLevel defaultLevel = null;\n        if (mMetaData != null && mMetaData.hasSeverity()) {\n            defaultLevel = getMetaData().getDefaultSeverityLevel();\n        } else if (mMetaData == null) {\n            defaultLevel = MetadataFactory.getDefaultSeverity();\n        }\n        if (defaultLevel != null) {\n            if (severityLevel.equals(defaultLevel)) {\n                mSeverityLevel = null;\n                setLastEnabledSeverity(null);\n            } else if (SeverityLevel.IGNORE.equals(severityLevel)) {\n                if (mSeverityLevel != null && !SeverityLevel.IGNORE.equals(mSeverityLevel)) {\n                    setLastEnabledSeverity(mSeverityLevel);\n                }\n                mSeverityLevel = severityLevel;\n            } else {\n                mSeverityLevel = severityLevel;\n            }\n        }\n    }\n\n    /**\n     * Return the map containing custom metadata for the module.\n     *\n     * @return the custom metadata\n     */\n    public Map getCustomMetaData() {\n        return mCustomMetaData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            Module clone = (Module) super.clone();\n            clone.mProperties = new ArrayList();\n            Iterator it = getProperties().iterator();\n            while (it.hasNext()) {\n                ConfigProperty prop = (ConfigProperty) it.next();\n                clone.getProperties().add(prop.clone());\n            }\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should not happen\n            throw new InternalError();\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/Module.java",
		"test_prompt": "// ModuleTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.ConfigPropertyMetadata;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.MetadataFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.RuleMetadata;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Module}.\n* It contains ten unit test cases for the {@link Module#clone()} method.\n*/\nclass ModuleTest {"
	},
	{
		"original_code": "// ConfigPropertyMetadata.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport java.util.ArrayList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\n\n/**\n * This class represents metadata about one of a rule's properties.\n */\npublic class ConfigPropertyMetadata {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The type of the property data.\n     */\n    private ConfigPropertyType mDatatype;\n\n    /**\n     * The name of the property.\n     */\n    private String mName;\n\n    /**\n     * The default value of the property.\n     */\n    private String mDefaultValue;\n\n    /**\n     * A differing default value from the Checkstyle core.\n     */\n    private String mOverrideDefaultValue;\n\n    /**\n     * The description of the property.\n     */\n    private String mDescription;\n\n    /**\n     * The list of possible property values.\n     */\n    private List mEnumeration = new ArrayList();\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates the property metadata.\n     *\n     * @param type the property type\n     * @param name the name of the property\n     * @param defaultValue the default value\n     * @param overrideDefaultValue a default value which overrides the\n     *            Checkstyle default\n     */\n    public ConfigPropertyMetadata(ConfigPropertyType type, String name, String defaultValue, String overrideDefaultValue) {\n        mDatatype = type;\n        mName = name;\n        mDefaultValue = defaultValue;\n        mOverrideDefaultValue = overrideDefaultValue;\n        mDescription = Messages.ConfigPropertyMetadata_txtNoDescription;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get the property's datatype.\n     *\n     * @return The datatype\n     */\n    public ConfigPropertyType getDatatype() {\n        return mDatatype;\n    }\n\n    /**\n     * Get the property's name.\n     *\n     * @return The name\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * Get the property's description.\n     *\n     * @return The description\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * Sets the description of this property.\n     *\n     * @param description the description\n     */\n    public void setDescription(String description) {\n        mDescription = description;\n    }\n\n    /**\n     * Get the default value.\n     *\n     * @return The default value\n     */\n    public String getDefaultValue() {\n        return mDefaultValue;\n    }\n\n    /**\n     * Returns a default value differing from the Checkstye default for this\n     * property.\n     *\n     * @return The differing checkstyle default value.\n     */\n    public String getOverrideDefault() {\n        return mOverrideDefaultValue;\n    }\n\n    /**\n     * Get the enumeration of allowable values.\n     *\n     * @return Enumeration of values\n     */\n    public List getPropertyEnumeration() {\n        return mEnumeration;\n    }\n\n    /**\n     * Returns the hidden.\n     *\n     * @return boolean\n     */\n    public boolean isHidden() {\n        return ConfigPropertyType.HIDDEN.equals(mDatatype);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/ConfigPropertyMetadata.java",
		"test_prompt": "// ConfigPropertyMetadataTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport java.util.ArrayList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigPropertyMetadata}.\n* It contains ten unit test cases for the {@link ConfigPropertyMetadata#isHidden()} method.\n*/\nclass ConfigPropertyMetadataTest {"
	},
	{
		"original_code": "// ConfigPropertyType.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n//=================================================\n// Imports from org namespace\n//=================================================\n/**\n * This represents the possible data types for a rule's configuration property.\n */\npublic final class ConfigPropertyType {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    /**\n     * A String.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType STRING = new ConfigPropertyType(10, \"String\");\n\n    /**\n     * An array of strings.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType STRING_ARRAY = new ConfigPropertyType(20, \"StringArray\");\n\n    /**\n     * An integer.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType INTEGER = new ConfigPropertyType(30, \"Integer\");\n\n    /**\n     * Select a single items from a list.\n     */\n    public static final ConfigPropertyType SINGLE_SELECT = new ConfigPropertyType(40, //$NON-NLS-1$\n    \"SingleSelect\");\n\n    /**\n     * Boolean value.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType BOOLEAN = new ConfigPropertyType(50, \"Boolean\");\n\n    /**\n     * Select multiple items from a set.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType MULTI_CHECK = new ConfigPropertyType(60, \"MultiCheck\");\n\n    /**\n     * A value that is not configured.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType HIDDEN = new ConfigPropertyType(70, \"Hidden\");\n\n    /**\n     * A value that contains a file name.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType FILE = new ConfigPropertyType(80, \"File\");\n\n    /**\n     * A value that contains a regular expression.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType REGEX = new ConfigPropertyType(90, \"Regex\");\n\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The string representation.\n     */\n    private String mLabel;\n\n    /**\n     * The internal value.\n     */\n    private int mValue;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private ConfigPropertyType(int value, String label) {\n        mValue = value;\n        mLabel = label;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * The equals method.\n     *\n     * @param obj The object to test against.\n     *\n     * @return <code>true</code> means equal, <code>false</code> means not\n     *         equal.\n     */\n    public boolean equals(Object obj) {\n        boolean result = false;\n        if ((obj instanceof ConfigPropertyType) && (((ConfigPropertyType) obj).mValue == this.mValue)) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * The hashCode method.\n     *\n     * @return has code for the object.\n     */\n    public int hashCode() {\n        return mValue;\n    }\n\n    /**\n     * Get the label string.\n     *\n     * @return The label.\n     */\n    public String getLabel() {\n        return mLabel;\n    }\n\n    /**\n     * Get a config property type from a type label string.\n     *\n     * @param label The label to look up.\n     *\n     * @return Matching config property type.\n     *\n     * @throws CheckstylePluginException The string did not match any known\n     *             types.\n     */\n    public static ConfigPropertyType getConfigPropertyType(String label) throws CheckstylePluginException {\n        ConfigPropertyType result = null;\n        if (label.equalsIgnoreCase(STRING.mLabel)) {\n            result = STRING;\n        } else if (label.equalsIgnoreCase(STRING_ARRAY.mLabel)) {\n            result = STRING_ARRAY;\n        } else if (label.equalsIgnoreCase(INTEGER.mLabel)) {\n            result = INTEGER;\n        } else if (label.equalsIgnoreCase(SINGLE_SELECT.mLabel)) {\n            result = SINGLE_SELECT;\n        } else if (label.equalsIgnoreCase(BOOLEAN.mLabel)) {\n            result = BOOLEAN;\n        } else if (label.equalsIgnoreCase(MULTI_CHECK.mLabel)) {\n            result = MULTI_CHECK;\n        } else if (label.equalsIgnoreCase(HIDDEN.mLabel)) {\n            result = HIDDEN;\n        } else if (label.equalsIgnoreCase(FILE.mLabel)) {\n            result = FILE;\n        } else if (label.equalsIgnoreCase(REGEX.mLabel)) {\n            result = REGEX;\n        } else {\n            throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorUnknownPropertyType, label));\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/ConfigPropertyType_0Test.java",
		"test_prompt": "// ConfigPropertyType_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigPropertyType}.\n* It contains ten unit test cases for the {@link ConfigPropertyType#equals(Object)} method.\n*/\nclass ConfigPropertyType_0Test {"
	},
	{
		"original_code": "// ConfigPropertyType.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n//=================================================\n// Imports from org namespace\n//=================================================\n/**\n * This represents the possible data types for a rule's configuration property.\n */\npublic final class ConfigPropertyType {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    /**\n     * A String.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType STRING = new ConfigPropertyType(10, \"String\");\n\n    /**\n     * An array of strings.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType STRING_ARRAY = new ConfigPropertyType(20, \"StringArray\");\n\n    /**\n     * An integer.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType INTEGER = new ConfigPropertyType(30, \"Integer\");\n\n    /**\n     * Select a single items from a list.\n     */\n    public static final ConfigPropertyType SINGLE_SELECT = new ConfigPropertyType(40, //$NON-NLS-1$\n    \"SingleSelect\");\n\n    /**\n     * Boolean value.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType BOOLEAN = new ConfigPropertyType(50, \"Boolean\");\n\n    /**\n     * Select multiple items from a set.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType MULTI_CHECK = new ConfigPropertyType(60, \"MultiCheck\");\n\n    /**\n     * A value that is not configured.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType HIDDEN = new ConfigPropertyType(70, \"Hidden\");\n\n    /**\n     * A value that contains a file name.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType FILE = new ConfigPropertyType(80, \"File\");\n\n    /**\n     * A value that contains a regular expression.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType REGEX = new ConfigPropertyType(90, \"Regex\");\n\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The string representation.\n     */\n    private String mLabel;\n\n    /**\n     * The internal value.\n     */\n    private int mValue;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private ConfigPropertyType(int value, String label) {\n        mValue = value;\n        mLabel = label;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * The equals method.\n     *\n     * @param obj The object to test against.\n     *\n     * @return <code>true</code> means equal, <code>false</code> means not\n     *         equal.\n     */\n    public boolean equals(Object obj) {\n        boolean result = false;\n        if ((obj instanceof ConfigPropertyType) && (((ConfigPropertyType) obj).mValue == this.mValue)) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * The hashCode method.\n     *\n     * @return has code for the object.\n     */\n    public int hashCode() {\n        return mValue;\n    }\n\n    /**\n     * Get the label string.\n     *\n     * @return The label.\n     */\n    public String getLabel() {\n        return mLabel;\n    }\n\n    /**\n     * Get a config property type from a type label string.\n     *\n     * @param label The label to look up.\n     *\n     * @return Matching config property type.\n     *\n     * @throws CheckstylePluginException The string did not match any known\n     *             types.\n     */\n    public static ConfigPropertyType getConfigPropertyType(String label) throws CheckstylePluginException {\n        ConfigPropertyType result = null;\n        if (label.equalsIgnoreCase(STRING.mLabel)) {\n            result = STRING;\n        } else if (label.equalsIgnoreCase(STRING_ARRAY.mLabel)) {\n            result = STRING_ARRAY;\n        } else if (label.equalsIgnoreCase(INTEGER.mLabel)) {\n            result = INTEGER;\n        } else if (label.equalsIgnoreCase(SINGLE_SELECT.mLabel)) {\n            result = SINGLE_SELECT;\n        } else if (label.equalsIgnoreCase(BOOLEAN.mLabel)) {\n            result = BOOLEAN;\n        } else if (label.equalsIgnoreCase(MULTI_CHECK.mLabel)) {\n            result = MULTI_CHECK;\n        } else if (label.equalsIgnoreCase(HIDDEN.mLabel)) {\n            result = HIDDEN;\n        } else if (label.equalsIgnoreCase(FILE.mLabel)) {\n            result = FILE;\n        } else if (label.equalsIgnoreCase(REGEX.mLabel)) {\n            result = REGEX;\n        } else {\n            throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorUnknownPropertyType, label));\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/ConfigPropertyType_1Test.java",
		"test_prompt": "// ConfigPropertyType_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigPropertyType}.\n* It contains ten unit test cases for the {@link ConfigPropertyType#hashCode()} method.\n*/\nclass ConfigPropertyType_1Test {"
	},
	{
		"original_code": "// ConfigPropertyType.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n//=================================================\n// Imports from org namespace\n//=================================================\n/**\n * This represents the possible data types for a rule's configuration property.\n */\npublic final class ConfigPropertyType {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    /**\n     * A String.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType STRING = new ConfigPropertyType(10, \"String\");\n\n    /**\n     * An array of strings.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType STRING_ARRAY = new ConfigPropertyType(20, \"StringArray\");\n\n    /**\n     * An integer.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType INTEGER = new ConfigPropertyType(30, \"Integer\");\n\n    /**\n     * Select a single items from a list.\n     */\n    public static final ConfigPropertyType SINGLE_SELECT = new ConfigPropertyType(40, //$NON-NLS-1$\n    \"SingleSelect\");\n\n    /**\n     * Boolean value.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType BOOLEAN = new ConfigPropertyType(50, \"Boolean\");\n\n    /**\n     * Select multiple items from a set.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType MULTI_CHECK = new ConfigPropertyType(60, \"MultiCheck\");\n\n    /**\n     * A value that is not configured.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType HIDDEN = new ConfigPropertyType(70, \"Hidden\");\n\n    /**\n     * A value that contains a file name.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType FILE = new ConfigPropertyType(80, \"File\");\n\n    /**\n     * A value that contains a regular expression.\n     */\n    //$NON-NLS-1$\n    public static final ConfigPropertyType REGEX = new ConfigPropertyType(90, \"Regex\");\n\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The string representation.\n     */\n    private String mLabel;\n\n    /**\n     * The internal value.\n     */\n    private int mValue;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private ConfigPropertyType(int value, String label) {\n        mValue = value;\n        mLabel = label;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * The equals method.\n     *\n     * @param obj The object to test against.\n     *\n     * @return <code>true</code> means equal, <code>false</code> means not\n     *         equal.\n     */\n    public boolean equals(Object obj) {\n        boolean result = false;\n        if ((obj instanceof ConfigPropertyType) && (((ConfigPropertyType) obj).mValue == this.mValue)) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * The hashCode method.\n     *\n     * @return has code for the object.\n     */\n    public int hashCode() {\n        return mValue;\n    }\n\n    /**\n     * Get the label string.\n     *\n     * @return The label.\n     */\n    public String getLabel() {\n        return mLabel;\n    }\n\n    /**\n     * Get a config property type from a type label string.\n     *\n     * @param label The label to look up.\n     *\n     * @return Matching config property type.\n     *\n     * @throws CheckstylePluginException The string did not match any known\n     *             types.\n     */\n    public static ConfigPropertyType getConfigPropertyType(String label) throws CheckstylePluginException {\n        ConfigPropertyType result = null;\n        if (label.equalsIgnoreCase(STRING.mLabel)) {\n            result = STRING;\n        } else if (label.equalsIgnoreCase(STRING_ARRAY.mLabel)) {\n            result = STRING_ARRAY;\n        } else if (label.equalsIgnoreCase(INTEGER.mLabel)) {\n            result = INTEGER;\n        } else if (label.equalsIgnoreCase(SINGLE_SELECT.mLabel)) {\n            result = SINGLE_SELECT;\n        } else if (label.equalsIgnoreCase(BOOLEAN.mLabel)) {\n            result = BOOLEAN;\n        } else if (label.equalsIgnoreCase(MULTI_CHECK.mLabel)) {\n            result = MULTI_CHECK;\n        } else if (label.equalsIgnoreCase(HIDDEN.mLabel)) {\n            result = HIDDEN;\n        } else if (label.equalsIgnoreCase(FILE.mLabel)) {\n            result = FILE;\n        } else if (label.equalsIgnoreCase(REGEX.mLabel)) {\n            result = REGEX;\n        } else {\n            throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorUnknownPropertyType, label));\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/ConfigPropertyType_2Test.java",
		"test_prompt": "// ConfigPropertyType_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigPropertyType}.\n* It contains ten unit test cases for the {@link ConfigPropertyType#getConfigPropertyType(String)} method.\n*/\nclass ConfigPropertyType_2Test {"
	},
	{
		"original_code": "// RuleMetadata.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class contains the metadata that describes a check rule.\n */\npublic class RuleMetadata {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The diplay name of the module.\n     */\n    private String mName;\n\n    /**\n     * The internal name of the module.\n     */\n    private String mInternalName;\n\n    /**\n     * The internal name of the parent module.\n     */\n    private String mParent;\n\n    /**\n     * The description of the module.\n     */\n    private String mDescription;\n\n    /**\n     * Determines if the module is hidden.\n     */\n    private boolean mIsHidden;\n\n    /**\n     * Determines if the module has a severity.\n     */\n    private boolean mHasSeverity;\n\n    /**\n     * Determines if the module can be deleted.\n     */\n    private boolean mIsDeletable;\n\n    /**\n     * The default severity.\n     */\n    private SeverityLevel mDefaultSeverityLevel;\n\n    /**\n     * The list of property metadata.\n     */\n    private List mConfigPropMetadata = new LinkedList();\n\n    /**\n     * The group.\n     */\n    private RuleGroupMetadata mGroup;\n\n    /**\n     * Alternative names, including the name of the Checkstyle checker class.\n     */\n    private Collection mAlternativeNames;\n\n    /**\n     * Collection fo quick fixes for this module.\n     */\n    private Collection mQuickfixes;\n\n    /**\n     * Determines if the module is a singleton.\n     */\n    private boolean mIsSingleton;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates a rule metadata.\n     *\n     * @param ruleName the name of the rule\n     * @param internalName the internal name of the rule\n     * @param parent the parent module name\n     * @param defaultSeverity the default severity level\n     * @param hidden <code>true</code> if the module should be hidden from the\n     *            user\n     * @param hasSeverity <code>true</code> if the module has a severity to\n     *            configure\n     * @param deletable <code>true</code> if the module has can be deleted\n     *            from the configuration\n     * @param isSingleton <code>true</code> if the module should occur only\n     *            once in a checkstyle configuration\n     * @param group the group the module belongs to\n     */\n    public RuleMetadata(String ruleName, String internalName, String parent, SeverityLevel defaultSeverity, boolean hidden, boolean hasSeverity, boolean deletable, boolean isSingleton, RuleGroupMetadata group) {\n        mName = ruleName;\n        mInternalName = internalName;\n        mParent = parent;\n        mDefaultSeverityLevel = defaultSeverity;\n        mIsHidden = hidden;\n        mHasSeverity = hasSeverity;\n        mIsDeletable = deletable;\n        mGroup = group;\n        mAlternativeNames = new ArrayList();\n        mQuickfixes = new ArrayList();\n        mIsSingleton = isSingleton;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Adds an alternative name for this rule.\n     *\n     * @param alternativeName an alternative name for this rule\n     */\n    public void addAlternativeName(String alternativeName) {\n        mAlternativeNames.add(alternativeName);\n    }\n\n    /**\n     * Returns the list of alternative names.\n     *\n     * @return a collection of String\n     */\n    public Collection getAlternativeNames() {\n        return mAlternativeNames;\n    }\n\n    /**\n     * Adds a quickfixfor this rule.\n     *\n     * @param quickfix the quickfix\n     */\n    public void addQuickfix(ICheckstyleMarkerResolution quickfix) {\n        mQuickfixes.add(quickfix);\n    }\n\n    /**\n     * Returns the list quickfixes for this module.\n     *\n     * @return a collection of ICheckstyleMarkerResolution\n     */\n    public Collection getQuickfixes() {\n        return mQuickfixes;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return The severity level.\n     */\n    public SeverityLevel getDefaultSeverityLevel() {\n        return mDefaultSeverityLevel;\n    }\n\n    /**\n     * Returns the rule's description.\n     *\n     * @return Rule description\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * Set the description for the rule.\n     *\n     * @param description the description\n     */\n    public void setDescription(String description) {\n        mDescription = description;\n    }\n\n    /**\n     * Returns the rule's name.\n     *\n     * @return String\n     */\n    public String getRuleName() {\n        return mName;\n    }\n\n    /**\n     * Returns the internal name of the module. The internal name is the name of\n     * the module inside the checkstyle configuration file.\n     *\n     * @return the internal module name\n     */\n    public String getInternalName() {\n        return mInternalName;\n    }\n\n    /**\n     * Determine if the module is to be hidden from the users sight.\n     *\n     * @return <code>true</code> if the module is hidden\n     */\n    public boolean isHidden() {\n        return mIsHidden;\n    }\n\n    /**\n     * Determine if the module has a severity to configure.\n     *\n     * @return <code>true</code> if the module has a severity\n     */\n    public boolean hasSeverity() {\n        return mHasSeverity;\n    }\n\n    /**\n     * Determine if the module can be removed from the configuration.\n     *\n     * @return <code>true</code> if the module can be removed\n     */\n    public boolean isDeletable() {\n        return mIsDeletable;\n    }\n\n    /**\n     * Determine if the module is a singleton inside a checkstyle configuration.\n     *\n     * @return <code>true</code> if the module is a singleton\n     */\n    public boolean isSingleton() {\n        return mIsSingleton;\n    }\n\n    /**\n     * Gets the name of the parent module.\n     *\n     * @return the parent module\n     */\n    public String getParentModule() {\n        return mParent;\n    }\n\n    /**\n     * Returns the configuration property metadata.\n     *\n     * @return A list of <code>ConfigPropertyMetadata</code> objects.\n     */\n    public List getPropertyMetadata() {\n        return mConfigPropMetadata;\n    }\n\n    /**\n     * Returns the property meta data for a given property name.\n     *\n     * @param property the property name\n     * @return the coresponding property meta data or <code>null</code>\n     */\n    public ConfigPropertyMetadata getPropertyMetadata(String property) {\n        ConfigPropertyMetadata propertyMeta = null;\n        int size = mConfigPropMetadata != null ? mConfigPropMetadata.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigPropertyMetadata tmp = (ConfigPropertyMetadata) mConfigPropMetadata.get(i);\n            if (tmp.getName().equals(property)) {\n                propertyMeta = tmp;\n                break;\n            }\n        }\n        return propertyMeta;\n    }\n\n    /**\n     * Returns the group this rule belongs to.\n     *\n     * @return the group\n     */\n    public RuleGroupMetadata getGroup() {\n        return mGroup;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/RuleMetadata_0Test.java",
		"test_prompt": "// RuleMetadata_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RuleMetadata}.\n* It contains ten unit test cases for the {@link RuleMetadata#isHidden()} method.\n*/\nclass RuleMetadata_0Test {"
	},
	{
		"original_code": "// RuleMetadata.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class contains the metadata that describes a check rule.\n */\npublic class RuleMetadata {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The diplay name of the module.\n     */\n    private String mName;\n\n    /**\n     * The internal name of the module.\n     */\n    private String mInternalName;\n\n    /**\n     * The internal name of the parent module.\n     */\n    private String mParent;\n\n    /**\n     * The description of the module.\n     */\n    private String mDescription;\n\n    /**\n     * Determines if the module is hidden.\n     */\n    private boolean mIsHidden;\n\n    /**\n     * Determines if the module has a severity.\n     */\n    private boolean mHasSeverity;\n\n    /**\n     * Determines if the module can be deleted.\n     */\n    private boolean mIsDeletable;\n\n    /**\n     * The default severity.\n     */\n    private SeverityLevel mDefaultSeverityLevel;\n\n    /**\n     * The list of property metadata.\n     */\n    private List mConfigPropMetadata = new LinkedList();\n\n    /**\n     * The group.\n     */\n    private RuleGroupMetadata mGroup;\n\n    /**\n     * Alternative names, including the name of the Checkstyle checker class.\n     */\n    private Collection mAlternativeNames;\n\n    /**\n     * Collection fo quick fixes for this module.\n     */\n    private Collection mQuickfixes;\n\n    /**\n     * Determines if the module is a singleton.\n     */\n    private boolean mIsSingleton;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates a rule metadata.\n     *\n     * @param ruleName the name of the rule\n     * @param internalName the internal name of the rule\n     * @param parent the parent module name\n     * @param defaultSeverity the default severity level\n     * @param hidden <code>true</code> if the module should be hidden from the\n     *            user\n     * @param hasSeverity <code>true</code> if the module has a severity to\n     *            configure\n     * @param deletable <code>true</code> if the module has can be deleted\n     *            from the configuration\n     * @param isSingleton <code>true</code> if the module should occur only\n     *            once in a checkstyle configuration\n     * @param group the group the module belongs to\n     */\n    public RuleMetadata(String ruleName, String internalName, String parent, SeverityLevel defaultSeverity, boolean hidden, boolean hasSeverity, boolean deletable, boolean isSingleton, RuleGroupMetadata group) {\n        mName = ruleName;\n        mInternalName = internalName;\n        mParent = parent;\n        mDefaultSeverityLevel = defaultSeverity;\n        mIsHidden = hidden;\n        mHasSeverity = hasSeverity;\n        mIsDeletable = deletable;\n        mGroup = group;\n        mAlternativeNames = new ArrayList();\n        mQuickfixes = new ArrayList();\n        mIsSingleton = isSingleton;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Adds an alternative name for this rule.\n     *\n     * @param alternativeName an alternative name for this rule\n     */\n    public void addAlternativeName(String alternativeName) {\n        mAlternativeNames.add(alternativeName);\n    }\n\n    /**\n     * Returns the list of alternative names.\n     *\n     * @return a collection of String\n     */\n    public Collection getAlternativeNames() {\n        return mAlternativeNames;\n    }\n\n    /**\n     * Adds a quickfixfor this rule.\n     *\n     * @param quickfix the quickfix\n     */\n    public void addQuickfix(ICheckstyleMarkerResolution quickfix) {\n        mQuickfixes.add(quickfix);\n    }\n\n    /**\n     * Returns the list quickfixes for this module.\n     *\n     * @return a collection of ICheckstyleMarkerResolution\n     */\n    public Collection getQuickfixes() {\n        return mQuickfixes;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return The severity level.\n     */\n    public SeverityLevel getDefaultSeverityLevel() {\n        return mDefaultSeverityLevel;\n    }\n\n    /**\n     * Returns the rule's description.\n     *\n     * @return Rule description\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * Set the description for the rule.\n     *\n     * @param description the description\n     */\n    public void setDescription(String description) {\n        mDescription = description;\n    }\n\n    /**\n     * Returns the rule's name.\n     *\n     * @return String\n     */\n    public String getRuleName() {\n        return mName;\n    }\n\n    /**\n     * Returns the internal name of the module. The internal name is the name of\n     * the module inside the checkstyle configuration file.\n     *\n     * @return the internal module name\n     */\n    public String getInternalName() {\n        return mInternalName;\n    }\n\n    /**\n     * Determine if the module is to be hidden from the users sight.\n     *\n     * @return <code>true</code> if the module is hidden\n     */\n    public boolean isHidden() {\n        return mIsHidden;\n    }\n\n    /**\n     * Determine if the module has a severity to configure.\n     *\n     * @return <code>true</code> if the module has a severity\n     */\n    public boolean hasSeverity() {\n        return mHasSeverity;\n    }\n\n    /**\n     * Determine if the module can be removed from the configuration.\n     *\n     * @return <code>true</code> if the module can be removed\n     */\n    public boolean isDeletable() {\n        return mIsDeletable;\n    }\n\n    /**\n     * Determine if the module is a singleton inside a checkstyle configuration.\n     *\n     * @return <code>true</code> if the module is a singleton\n     */\n    public boolean isSingleton() {\n        return mIsSingleton;\n    }\n\n    /**\n     * Gets the name of the parent module.\n     *\n     * @return the parent module\n     */\n    public String getParentModule() {\n        return mParent;\n    }\n\n    /**\n     * Returns the configuration property metadata.\n     *\n     * @return A list of <code>ConfigPropertyMetadata</code> objects.\n     */\n    public List getPropertyMetadata() {\n        return mConfigPropMetadata;\n    }\n\n    /**\n     * Returns the property meta data for a given property name.\n     *\n     * @param property the property name\n     * @return the coresponding property meta data or <code>null</code>\n     */\n    public ConfigPropertyMetadata getPropertyMetadata(String property) {\n        ConfigPropertyMetadata propertyMeta = null;\n        int size = mConfigPropMetadata != null ? mConfigPropMetadata.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigPropertyMetadata tmp = (ConfigPropertyMetadata) mConfigPropMetadata.get(i);\n            if (tmp.getName().equals(property)) {\n                propertyMeta = tmp;\n                break;\n            }\n        }\n        return propertyMeta;\n    }\n\n    /**\n     * Returns the group this rule belongs to.\n     *\n     * @return the group\n     */\n    public RuleGroupMetadata getGroup() {\n        return mGroup;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/RuleMetadata_1Test.java",
		"test_prompt": "// RuleMetadata_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RuleMetadata}.\n* It contains ten unit test cases for the {@link RuleMetadata#hasSeverity()} method.\n*/\nclass RuleMetadata_1Test {"
	},
	{
		"original_code": "// RuleMetadata.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class contains the metadata that describes a check rule.\n */\npublic class RuleMetadata {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The diplay name of the module.\n     */\n    private String mName;\n\n    /**\n     * The internal name of the module.\n     */\n    private String mInternalName;\n\n    /**\n     * The internal name of the parent module.\n     */\n    private String mParent;\n\n    /**\n     * The description of the module.\n     */\n    private String mDescription;\n\n    /**\n     * Determines if the module is hidden.\n     */\n    private boolean mIsHidden;\n\n    /**\n     * Determines if the module has a severity.\n     */\n    private boolean mHasSeverity;\n\n    /**\n     * Determines if the module can be deleted.\n     */\n    private boolean mIsDeletable;\n\n    /**\n     * The default severity.\n     */\n    private SeverityLevel mDefaultSeverityLevel;\n\n    /**\n     * The list of property metadata.\n     */\n    private List mConfigPropMetadata = new LinkedList();\n\n    /**\n     * The group.\n     */\n    private RuleGroupMetadata mGroup;\n\n    /**\n     * Alternative names, including the name of the Checkstyle checker class.\n     */\n    private Collection mAlternativeNames;\n\n    /**\n     * Collection fo quick fixes for this module.\n     */\n    private Collection mQuickfixes;\n\n    /**\n     * Determines if the module is a singleton.\n     */\n    private boolean mIsSingleton;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates a rule metadata.\n     *\n     * @param ruleName the name of the rule\n     * @param internalName the internal name of the rule\n     * @param parent the parent module name\n     * @param defaultSeverity the default severity level\n     * @param hidden <code>true</code> if the module should be hidden from the\n     *            user\n     * @param hasSeverity <code>true</code> if the module has a severity to\n     *            configure\n     * @param deletable <code>true</code> if the module has can be deleted\n     *            from the configuration\n     * @param isSingleton <code>true</code> if the module should occur only\n     *            once in a checkstyle configuration\n     * @param group the group the module belongs to\n     */\n    public RuleMetadata(String ruleName, String internalName, String parent, SeverityLevel defaultSeverity, boolean hidden, boolean hasSeverity, boolean deletable, boolean isSingleton, RuleGroupMetadata group) {\n        mName = ruleName;\n        mInternalName = internalName;\n        mParent = parent;\n        mDefaultSeverityLevel = defaultSeverity;\n        mIsHidden = hidden;\n        mHasSeverity = hasSeverity;\n        mIsDeletable = deletable;\n        mGroup = group;\n        mAlternativeNames = new ArrayList();\n        mQuickfixes = new ArrayList();\n        mIsSingleton = isSingleton;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Adds an alternative name for this rule.\n     *\n     * @param alternativeName an alternative name for this rule\n     */\n    public void addAlternativeName(String alternativeName) {\n        mAlternativeNames.add(alternativeName);\n    }\n\n    /**\n     * Returns the list of alternative names.\n     *\n     * @return a collection of String\n     */\n    public Collection getAlternativeNames() {\n        return mAlternativeNames;\n    }\n\n    /**\n     * Adds a quickfixfor this rule.\n     *\n     * @param quickfix the quickfix\n     */\n    public void addQuickfix(ICheckstyleMarkerResolution quickfix) {\n        mQuickfixes.add(quickfix);\n    }\n\n    /**\n     * Returns the list quickfixes for this module.\n     *\n     * @return a collection of ICheckstyleMarkerResolution\n     */\n    public Collection getQuickfixes() {\n        return mQuickfixes;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return The severity level.\n     */\n    public SeverityLevel getDefaultSeverityLevel() {\n        return mDefaultSeverityLevel;\n    }\n\n    /**\n     * Returns the rule's description.\n     *\n     * @return Rule description\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * Set the description for the rule.\n     *\n     * @param description the description\n     */\n    public void setDescription(String description) {\n        mDescription = description;\n    }\n\n    /**\n     * Returns the rule's name.\n     *\n     * @return String\n     */\n    public String getRuleName() {\n        return mName;\n    }\n\n    /**\n     * Returns the internal name of the module. The internal name is the name of\n     * the module inside the checkstyle configuration file.\n     *\n     * @return the internal module name\n     */\n    public String getInternalName() {\n        return mInternalName;\n    }\n\n    /**\n     * Determine if the module is to be hidden from the users sight.\n     *\n     * @return <code>true</code> if the module is hidden\n     */\n    public boolean isHidden() {\n        return mIsHidden;\n    }\n\n    /**\n     * Determine if the module has a severity to configure.\n     *\n     * @return <code>true</code> if the module has a severity\n     */\n    public boolean hasSeverity() {\n        return mHasSeverity;\n    }\n\n    /**\n     * Determine if the module can be removed from the configuration.\n     *\n     * @return <code>true</code> if the module can be removed\n     */\n    public boolean isDeletable() {\n        return mIsDeletable;\n    }\n\n    /**\n     * Determine if the module is a singleton inside a checkstyle configuration.\n     *\n     * @return <code>true</code> if the module is a singleton\n     */\n    public boolean isSingleton() {\n        return mIsSingleton;\n    }\n\n    /**\n     * Gets the name of the parent module.\n     *\n     * @return the parent module\n     */\n    public String getParentModule() {\n        return mParent;\n    }\n\n    /**\n     * Returns the configuration property metadata.\n     *\n     * @return A list of <code>ConfigPropertyMetadata</code> objects.\n     */\n    public List getPropertyMetadata() {\n        return mConfigPropMetadata;\n    }\n\n    /**\n     * Returns the property meta data for a given property name.\n     *\n     * @param property the property name\n     * @return the coresponding property meta data or <code>null</code>\n     */\n    public ConfigPropertyMetadata getPropertyMetadata(String property) {\n        ConfigPropertyMetadata propertyMeta = null;\n        int size = mConfigPropMetadata != null ? mConfigPropMetadata.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigPropertyMetadata tmp = (ConfigPropertyMetadata) mConfigPropMetadata.get(i);\n            if (tmp.getName().equals(property)) {\n                propertyMeta = tmp;\n                break;\n            }\n        }\n        return propertyMeta;\n    }\n\n    /**\n     * Returns the group this rule belongs to.\n     *\n     * @return the group\n     */\n    public RuleGroupMetadata getGroup() {\n        return mGroup;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/RuleMetadata_2Test.java",
		"test_prompt": "// RuleMetadata_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RuleMetadata}.\n* It contains ten unit test cases for the {@link RuleMetadata#isDeletable()} method.\n*/\nclass RuleMetadata_2Test {"
	},
	{
		"original_code": "// RuleMetadata.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class contains the metadata that describes a check rule.\n */\npublic class RuleMetadata {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The diplay name of the module.\n     */\n    private String mName;\n\n    /**\n     * The internal name of the module.\n     */\n    private String mInternalName;\n\n    /**\n     * The internal name of the parent module.\n     */\n    private String mParent;\n\n    /**\n     * The description of the module.\n     */\n    private String mDescription;\n\n    /**\n     * Determines if the module is hidden.\n     */\n    private boolean mIsHidden;\n\n    /**\n     * Determines if the module has a severity.\n     */\n    private boolean mHasSeverity;\n\n    /**\n     * Determines if the module can be deleted.\n     */\n    private boolean mIsDeletable;\n\n    /**\n     * The default severity.\n     */\n    private SeverityLevel mDefaultSeverityLevel;\n\n    /**\n     * The list of property metadata.\n     */\n    private List mConfigPropMetadata = new LinkedList();\n\n    /**\n     * The group.\n     */\n    private RuleGroupMetadata mGroup;\n\n    /**\n     * Alternative names, including the name of the Checkstyle checker class.\n     */\n    private Collection mAlternativeNames;\n\n    /**\n     * Collection fo quick fixes for this module.\n     */\n    private Collection mQuickfixes;\n\n    /**\n     * Determines if the module is a singleton.\n     */\n    private boolean mIsSingleton;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates a rule metadata.\n     *\n     * @param ruleName the name of the rule\n     * @param internalName the internal name of the rule\n     * @param parent the parent module name\n     * @param defaultSeverity the default severity level\n     * @param hidden <code>true</code> if the module should be hidden from the\n     *            user\n     * @param hasSeverity <code>true</code> if the module has a severity to\n     *            configure\n     * @param deletable <code>true</code> if the module has can be deleted\n     *            from the configuration\n     * @param isSingleton <code>true</code> if the module should occur only\n     *            once in a checkstyle configuration\n     * @param group the group the module belongs to\n     */\n    public RuleMetadata(String ruleName, String internalName, String parent, SeverityLevel defaultSeverity, boolean hidden, boolean hasSeverity, boolean deletable, boolean isSingleton, RuleGroupMetadata group) {\n        mName = ruleName;\n        mInternalName = internalName;\n        mParent = parent;\n        mDefaultSeverityLevel = defaultSeverity;\n        mIsHidden = hidden;\n        mHasSeverity = hasSeverity;\n        mIsDeletable = deletable;\n        mGroup = group;\n        mAlternativeNames = new ArrayList();\n        mQuickfixes = new ArrayList();\n        mIsSingleton = isSingleton;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Adds an alternative name for this rule.\n     *\n     * @param alternativeName an alternative name for this rule\n     */\n    public void addAlternativeName(String alternativeName) {\n        mAlternativeNames.add(alternativeName);\n    }\n\n    /**\n     * Returns the list of alternative names.\n     *\n     * @return a collection of String\n     */\n    public Collection getAlternativeNames() {\n        return mAlternativeNames;\n    }\n\n    /**\n     * Adds a quickfixfor this rule.\n     *\n     * @param quickfix the quickfix\n     */\n    public void addQuickfix(ICheckstyleMarkerResolution quickfix) {\n        mQuickfixes.add(quickfix);\n    }\n\n    /**\n     * Returns the list quickfixes for this module.\n     *\n     * @return a collection of ICheckstyleMarkerResolution\n     */\n    public Collection getQuickfixes() {\n        return mQuickfixes;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return The severity level.\n     */\n    public SeverityLevel getDefaultSeverityLevel() {\n        return mDefaultSeverityLevel;\n    }\n\n    /**\n     * Returns the rule's description.\n     *\n     * @return Rule description\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * Set the description for the rule.\n     *\n     * @param description the description\n     */\n    public void setDescription(String description) {\n        mDescription = description;\n    }\n\n    /**\n     * Returns the rule's name.\n     *\n     * @return String\n     */\n    public String getRuleName() {\n        return mName;\n    }\n\n    /**\n     * Returns the internal name of the module. The internal name is the name of\n     * the module inside the checkstyle configuration file.\n     *\n     * @return the internal module name\n     */\n    public String getInternalName() {\n        return mInternalName;\n    }\n\n    /**\n     * Determine if the module is to be hidden from the users sight.\n     *\n     * @return <code>true</code> if the module is hidden\n     */\n    public boolean isHidden() {\n        return mIsHidden;\n    }\n\n    /**\n     * Determine if the module has a severity to configure.\n     *\n     * @return <code>true</code> if the module has a severity\n     */\n    public boolean hasSeverity() {\n        return mHasSeverity;\n    }\n\n    /**\n     * Determine if the module can be removed from the configuration.\n     *\n     * @return <code>true</code> if the module can be removed\n     */\n    public boolean isDeletable() {\n        return mIsDeletable;\n    }\n\n    /**\n     * Determine if the module is a singleton inside a checkstyle configuration.\n     *\n     * @return <code>true</code> if the module is a singleton\n     */\n    public boolean isSingleton() {\n        return mIsSingleton;\n    }\n\n    /**\n     * Gets the name of the parent module.\n     *\n     * @return the parent module\n     */\n    public String getParentModule() {\n        return mParent;\n    }\n\n    /**\n     * Returns the configuration property metadata.\n     *\n     * @return A list of <code>ConfigPropertyMetadata</code> objects.\n     */\n    public List getPropertyMetadata() {\n        return mConfigPropMetadata;\n    }\n\n    /**\n     * Returns the property meta data for a given property name.\n     *\n     * @param property the property name\n     * @return the coresponding property meta data or <code>null</code>\n     */\n    public ConfigPropertyMetadata getPropertyMetadata(String property) {\n        ConfigPropertyMetadata propertyMeta = null;\n        int size = mConfigPropMetadata != null ? mConfigPropMetadata.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigPropertyMetadata tmp = (ConfigPropertyMetadata) mConfigPropMetadata.get(i);\n            if (tmp.getName().equals(property)) {\n                propertyMeta = tmp;\n                break;\n            }\n        }\n        return propertyMeta;\n    }\n\n    /**\n     * Returns the group this rule belongs to.\n     *\n     * @return the group\n     */\n    public RuleGroupMetadata getGroup() {\n        return mGroup;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/RuleMetadata_3Test.java",
		"test_prompt": "// RuleMetadata_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RuleMetadata}.\n* It contains ten unit test cases for the {@link RuleMetadata#isSingleton()} method.\n*/\nclass RuleMetadata_3Test {"
	},
	{
		"original_code": "// MetadataFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class is the factory for all Checkstyle rule metadata.\n */\npublic final class MetadataFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Metadata for the rule groups.\n     */\n    private static Map sRuleGroupMetadata;\n\n    /**\n     * Metadata for all rules, keyed by internal rule name.\n     */\n    private static Map sRuleMetadata;\n\n    /**\n     * Mapping for all rules, keyed by alternative rule names (full qualified,\n     * old full qualified).\n     */\n    private static Map sAlternativeNamesMap;\n\n    /**\n     * the default severity level.\n     */\n    private static SeverityLevel sDefaultSeverity = SeverityLevel.WARNING;\n\n    /**\n     * Name of the rules metadata XML file.\n     */\n    //$NON-NLS-1$\n    private static final String METADATA_FILENAME = \"checkstyle-metadata.xml\";\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private MetadataFactory() {\n    }\n\n    /**\n     * Static initializer.\n     */\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a list of metadata objects for all rule groups.\n     *\n     * @return List of <code>RuleGroupMetadata</code> objects.\n     */\n    public static List getRuleGroupMetadata() {\n        List groups = new ArrayList(sRuleGroupMetadata.values());\n        Collections.sort(groups, new Comparator() {\n\n            public int compare(Object arg0, Object arg1) {\n                int prio1 = ((RuleGroupMetadata) arg0).getPriority();\n                int prio2 = ((RuleGroupMetadata) arg1).getPriority();\n                return (prio1 < prio2 ? -1 : (prio1 == prio2 ? 0 : 1));\n            }\n        });\n        return groups;\n    }\n\n    /**\n     * Get metadata for a check rule.\n     *\n     * @param name The rule's name within the checkstyle configuration file.\n     * @return The metadata.\n     */\n    public static RuleMetadata getRuleMetadata(String name) {\n        RuleMetadata metadata = null;\n        // first try the internal name mapping\n        metadata = (RuleMetadata) sRuleMetadata.get(name);\n        // try the alternative names\n        if (metadata == null) {\n            metadata = (RuleMetadata) sAlternativeNamesMap.get(name);\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns the metadata for a rule group.\n     *\n     * @param name the group name\n     * @return the RuleGroupMetadata object or <code>null</code>\n     */\n    public static RuleGroupMetadata getRuleGroupMetadata(String name) {\n        return (RuleGroupMetadata) sRuleGroupMetadata.get(name);\n    }\n\n    /**\n     * Creates a set of generic metadata for a module that has no metadata\n     * delivered with the plugin.\n     *\n     * @param module the module\n     * @return the generic metadata built\n     */\n    public static RuleMetadata createGenericMetadata(Module module) {\n        String parent = null;\n        try {\n            Class checkClass = Class.forName(module.getName());\n            Object moduleInstance = checkClass.newInstance();\n            if (moduleInstance instanceof AbstractFileSetCheck) {\n                parent = XMLTags.CHECKER_MODULE;\n            } else {\n                parent = XMLTags.TREEWALKER_MODULE;\n            }\n        } catch (Exception e) {\n            // Ok we tried... default to TreeWalker\n            parent = XMLTags.TREEWALKER_MODULE;\n        }\n        RuleGroupMetadata otherGroup = getRuleGroupMetadata(XMLTags.OTHER_GROUP);\n        RuleMetadata ruleMeta = new RuleMetadata(module.getName(), module.getName(), parent, MetadataFactory.getDefaultSeverity(), false, true, true, false, otherGroup);\n        module.setMetaData(ruleMeta);\n        sRuleMetadata.put(ruleMeta.getInternalName(), ruleMeta);\n        List properties = module.getProperties();\n        int size = properties != null ? properties.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigProperty property = (ConfigProperty) properties.get(i);\n            ConfigPropertyMetadata meta = new ConfigPropertyMetadata(ConfigPropertyType.STRING, property.getName(), null, null);\n            property.setMetaData(meta);\n        }\n        return ruleMeta;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return the default severity.\n     */\n    public static SeverityLevel getDefaultSeverity() {\n        return sDefaultSeverity;\n    }\n\n    /**\n     * Refreshes the metadata.\n     */\n    public static synchronized void refresh() {\n        sRuleGroupMetadata = new TreeMap();\n        sRuleMetadata = new HashMap();\n        sAlternativeNamesMap = new HashMap();\n        try {\n            doInitialization();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Initializes the meta data from the xml file.\n     *\n     * @throws CheckstylePluginException error loading the meta data file\n     */\n    private static void doInitialization() throws CheckstylePluginException {\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            // get the classloader containing the extension libraries\n            ClassLoader customsLoader = CustomLibrariesClassLoader.get();\n            Thread.currentThread().setContextClassLoader(customsLoader);\n            Collection potentialMetadataFiles = getAllPotentialMetadataFiles();\n            Iterator it = potentialMetadataFiles.iterator();\n            while (it.hasNext()) {\n                String metadataFile = (String) it.next();\n                InputStream metadataStream = null;\n                try {\n                    metadataStream = customsLoader.getResourceAsStream(metadataFile);\n                    if (metadataStream != null) {\n                        MetaDataHandler metadataHandler = new MetaDataHandler(getMetadataI18NBundle(metadataFile));\n                        XMLUtil.parseWithSAX(metadataStream, metadataHandler, true);\n                    }\n                } catch (SAXParseException e) {\n                    CheckstyleLog.log(e, //$NON-NLS-1$\n                    NLS.//$NON-NLS-1$\n                    bind(//$NON-NLS-1$\n                    \"Could not parse metadata file {0} at {1}:{2}\", new Object[] { metadataFile, new Integer(e.getLineNumber()), new Integer(e.getColumnNumber()) }));\n                } catch (SAXException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (ParserConfigurationException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (IOException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } finally {\n                    IOUtils.closeQuietly(metadataStream);\n                }\n            }\n        } finally {\n            // restore the original classloader\n            Thread.currentThread().setContextClassLoader(contextClassLoader);\n        }\n    }\n\n    /**\n     * Helper method to get all potential metadata files using the\n     * checkstyle_packages.xml as base where to look. It is not guaranteed that\n     * the files returned acutally exist.\n     *\n     * @return the collection of potential metadata files.\n     * @throws CheckstylePluginException an unexpected exception ocurred\n     */\n    private static Collection getAllPotentialMetadataFiles() throws CheckstylePluginException {\n        Collection potentialMetadataFiles = new ArrayList();\n        List packages = PackageNamesLoader.getPackageNames(CustomLibrariesClassLoader.get());\n        for (int i = 0, size = packages.size(); i < size; i++) {\n            String packageName = (String) packages.get(i);\n            String metaFileLocation = packageName.replace('.', '/') + METADATA_FILENAME;\n            potentialMetadataFiles.add(metaFileLocation);\n        }\n        return potentialMetadataFiles;\n    }\n\n    /**\n     * Returns the ResourceBundle for the given meta data file contained i18n'ed\n     * names and descriptions.\n     *\n     * @param metadataFile\n     * @return the corresponding ResourceBundle for the metadata file or\n     *         <code>null</code> if none exists\n     */\n    private static ResourceBundle getMetadataI18NBundle(String metadataFile) {\n        String bundle = metadataFile.substring(0, metadataFile.length() - 4).replace('/', '.');\n        try {\n            return PropertyResourceBundle.getBundle(bundle);\n        } catch (MissingResourceException e) {\n            return null;\n        }\n    }\n\n    /**\n     * SAX-Handler for parsing of the metadata file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class MetaDataHandler extends DefaultHandler {\n\n        //$NON-NLS-1$\n        private static final String DTD_PUBLIC_ID = \"-//eclipse-cs//DTD Check Metadata 1.0//EN\";\n\n        //$NON-NLS-1$\n        private static final String DTD_RESOURCE_NAME = \"/com/puppycrawl/tools/checkstyle/checkstyle-metadata_1_0.dtd\";\n\n        /**\n         * the current rule group.\n         */\n        private RuleGroupMetadata mCurrentGroup;\n\n        /**\n         * the current rule meta data.\n         */\n        private RuleMetadata mCurrentRule;\n\n        /**\n         * the current property.\n         */\n        private ConfigPropertyMetadata mCurrentProperty;\n\n        /**\n         * flags if we're inside a description element.\n         */\n        private boolean mInDescriptionElement;\n\n        /**\n         * StringBuffer containing the description.\n         */\n        private StringBuffer mDescription;\n\n        private ResourceBundle mI18NBundle;\n\n        // /**\n        // * @see\n        // org.xml.sax.ext.EntityResolver2#getExternalSubset(java.lang.String,\n        // * java.lang.String)\n        // */\n        // public InputSource getExternalSubset(String name, String baseURI)\n        // throws SAXException,\n        // IOException\n        // {\n        //\n        // InputStream dtdIS =\n        // getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n        // return new InputSource(dtdIS);\n        // }\n        public MetaDataHandler(ResourceBundle i18nBundle) {\n            mI18NBundle = i18nBundle;\n        }\n\n        /*\n         * \n         */\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException {\n            if (DTD_PUBLIC_ID.equals(publicId)) {\n                final InputStream dtdIS = getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n                if (dtdIS == null) {\n                    //$NON-NLS-1$\n                    throw new SAXException(\"Unable to load internal dtd \" + DTD_RESOURCE_NAME);\n                }\n                return new InputSource(dtdIS);\n            }\n            // This is a hack to workaround problem with SAX\n            // DefaultHeader.resolveEntity():\n            // sometimes it throws SAX- and IO- exceptions\n            // sometime SAX only :(\n            try {\n                if (false) {\n                    //$NON-NLS-1$\n                    throw new IOException(\"\");\n                }\n                return super.resolveEntity(publicId, systemId);\n            } catch (IOException e) {\n                //$NON-NLS-1$\n                throw new SAXException(\"\" + e, e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,\n         *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            try {\n                if (XMLTags.RULE_GROUP_METADATA_TAG.equals(qName)) {\n                    String groupName = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    groupName = localize(groupName);\n                    mCurrentGroup = getRuleGroupMetadata(groupName);\n                    if (mCurrentGroup == null) {\n                        boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                        int priority = 0;\n                        try {\n                            priority = Integer.parseInt(attributes.getValue(XMLTags.PRIORITY_TAG));\n                        } catch (Exception e) {\n                            CheckstyleLog.log(e);\n                            priority = Integer.MAX_VALUE;\n                        }\n                        // Create the groups\n                        mCurrentGroup = new RuleGroupMetadata(groupName, hidden, priority);\n                        sRuleGroupMetadata.put(groupName, mCurrentGroup);\n                    }\n                } else if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                    // default severity\n                    String defaultSeverity = attributes.getValue(XMLTags.DEFAULT_SEVERITY_TAG);\n                    SeverityLevel severity = defaultSeverity == null || defaultSeverity.trim().length() == 0 ? sDefaultSeverity : SeverityLevel.getInstance(defaultSeverity);\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String internalName = attributes.getValue(XMLTags.INTERNAL_NAME_TAG).trim();\n                    String parentName = attributes.getValue(XMLTags.PARENT_TAG) != null ? attributes.getValue(XMLTags.PARENT_TAG).trim() : null;\n                    boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                    boolean hasSeverity = !\"false\".equals(//$NON-NLS-1$\n                    attributes.getValue(XMLTags.HAS_SEVERITY_TAG));\n                    //$NON-NLS-1$\n                    boolean deletable = !\"false\".equals(attributes.getValue(XMLTags.DELETABLE_TAG));\n                    boolean isSingleton = Boolean.valueOf(attributes.getValue(XMLTags.IS_SINGLETON_TAG)).booleanValue();\n                    // create rule metadata\n                    mCurrentRule = new RuleMetadata(localize(name), internalName, parentName, severity, hidden, hasSeverity, deletable, isSingleton, mCurrentGroup);\n                    mCurrentGroup.getRuleMetadata().add(mCurrentRule);\n                    // register internal name\n                    sRuleMetadata.put(internalName, mCurrentRule);\n                } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                    ConfigPropertyType type = ConfigPropertyType.getConfigPropertyType(attributes.getValue(XMLTags.DATATYPE_TAG));\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String defaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_TAG));\n                    String overrideDefaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_OVERRIDE_TAG));\n                    mCurrentProperty = new ConfigPropertyMetadata(type, name, defaultValue, overrideDefaultValue);\n                    // add to current rule\n                    mCurrentRule.getPropertyMetadata().add(mCurrentProperty);\n                } else if (XMLTags.ALTERNATIVE_NAME_TAG.equals(qName)) {\n                    // register alternative name\n                    sAlternativeNamesMap.put(attributes.getValue(XMLTags.INTERNAL_NAME_TAG), mCurrentRule);\n                    mCurrentRule.addAlternativeName(attributes.getValue(XMLTags.INTERNAL_NAME_TAG));\n                } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                    mInDescriptionElement = true;\n                    mDescription = new StringBuffer();\n                } else if (XMLTags.ENUMERATION_TAG.equals(qName)) {\n                    String optionProvider = attributes.getValue(XMLTags.OPTION_PROVIDER);\n                    if (optionProvider != null) {\n                        Class providerClass = Class.forName(optionProvider);\n                        IOptionProvider provider = (IOptionProvider) providerClass.newInstance();\n                        mCurrentProperty.getPropertyEnumeration().addAll(provider.getOptions());\n                    }\n                } else if (XMLTags.PROPERTY_VALUE_OPTIONS_TAG.equals(qName)) {\n                    mCurrentProperty.getPropertyEnumeration().add(attributes.getValue(XMLTags.VALUE_TAG));\n                } else if (XMLTags.QUCKFIX_TAG.equals(qName)) {\n                    String className = attributes.getValue(XMLTags.CLASSNAME_TAG);\n                    Class quickfixClass = Class.forName(className);\n                    ICheckstyleMarkerResolution quickfix = (ICheckstyleMarkerResolution) quickfixClass.newInstance();\n                    mCurrentRule.addQuickfix(quickfix);\n                }\n            } catch (CheckstylePluginException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (ClassNotFoundException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (InstantiationException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (IllegalAccessException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String,\n         *      java.lang.String, java.lang.String)\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                mCurrentRule = null;\n            } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                mCurrentProperty = null;\n            } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                mInDescriptionElement = false;\n                // Set the description to the current element\n                String description = mDescription.toString();\n                if (mCurrentProperty != null) {\n                    mCurrentProperty.setDescription(localize(description));\n                } else if (mCurrentRule != null) {\n                    mCurrentRule.setDescription(localize(description));\n                }\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)\n         */\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (mInDescriptionElement) {\n                mDescription.append(ch, start, length);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)\n         */\n        public void error(SAXParseException e) throws SAXException {\n            throw e;\n        }\n\n        private String localize(String localizationCandidate) {\n            if (mI18NBundle != null && localizationCandidate.startsWith(\"%\")) {\n                try {\n                    return mI18NBundle.getString(localizationCandidate.substring(1));\n                } catch (MissingResourceException e) {\n                    return localizationCandidate;\n                }\n            }\n            return localizationCandidate;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/MetadataFactory_0Test.java",
		"test_prompt": "// MetadataFactory_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataFactory}.\n* It contains ten unit test cases for the {@link MetadataFactory#getRuleGroupMetadata()} method.\n*/\nclass MetadataFactory_0Test {"
	},
	{
		"original_code": "// MetadataFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class is the factory for all Checkstyle rule metadata.\n */\npublic final class MetadataFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Metadata for the rule groups.\n     */\n    private static Map sRuleGroupMetadata;\n\n    /**\n     * Metadata for all rules, keyed by internal rule name.\n     */\n    private static Map sRuleMetadata;\n\n    /**\n     * Mapping for all rules, keyed by alternative rule names (full qualified,\n     * old full qualified).\n     */\n    private static Map sAlternativeNamesMap;\n\n    /**\n     * the default severity level.\n     */\n    private static SeverityLevel sDefaultSeverity = SeverityLevel.WARNING;\n\n    /**\n     * Name of the rules metadata XML file.\n     */\n    //$NON-NLS-1$\n    private static final String METADATA_FILENAME = \"checkstyle-metadata.xml\";\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private MetadataFactory() {\n    }\n\n    /**\n     * Static initializer.\n     */\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a list of metadata objects for all rule groups.\n     *\n     * @return List of <code>RuleGroupMetadata</code> objects.\n     */\n    public static List getRuleGroupMetadata() {\n        List groups = new ArrayList(sRuleGroupMetadata.values());\n        Collections.sort(groups, new Comparator() {\n\n            public int compare(Object arg0, Object arg1) {\n                int prio1 = ((RuleGroupMetadata) arg0).getPriority();\n                int prio2 = ((RuleGroupMetadata) arg1).getPriority();\n                return (prio1 < prio2 ? -1 : (prio1 == prio2 ? 0 : 1));\n            }\n        });\n        return groups;\n    }\n\n    /**\n     * Get metadata for a check rule.\n     *\n     * @param name The rule's name within the checkstyle configuration file.\n     * @return The metadata.\n     */\n    public static RuleMetadata getRuleMetadata(String name) {\n        RuleMetadata metadata = null;\n        // first try the internal name mapping\n        metadata = (RuleMetadata) sRuleMetadata.get(name);\n        // try the alternative names\n        if (metadata == null) {\n            metadata = (RuleMetadata) sAlternativeNamesMap.get(name);\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns the metadata for a rule group.\n     *\n     * @param name the group name\n     * @return the RuleGroupMetadata object or <code>null</code>\n     */\n    public static RuleGroupMetadata getRuleGroupMetadata(String name) {\n        return (RuleGroupMetadata) sRuleGroupMetadata.get(name);\n    }\n\n    /**\n     * Creates a set of generic metadata for a module that has no metadata\n     * delivered with the plugin.\n     *\n     * @param module the module\n     * @return the generic metadata built\n     */\n    public static RuleMetadata createGenericMetadata(Module module) {\n        String parent = null;\n        try {\n            Class checkClass = Class.forName(module.getName());\n            Object moduleInstance = checkClass.newInstance();\n            if (moduleInstance instanceof AbstractFileSetCheck) {\n                parent = XMLTags.CHECKER_MODULE;\n            } else {\n                parent = XMLTags.TREEWALKER_MODULE;\n            }\n        } catch (Exception e) {\n            // Ok we tried... default to TreeWalker\n            parent = XMLTags.TREEWALKER_MODULE;\n        }\n        RuleGroupMetadata otherGroup = getRuleGroupMetadata(XMLTags.OTHER_GROUP);\n        RuleMetadata ruleMeta = new RuleMetadata(module.getName(), module.getName(), parent, MetadataFactory.getDefaultSeverity(), false, true, true, false, otherGroup);\n        module.setMetaData(ruleMeta);\n        sRuleMetadata.put(ruleMeta.getInternalName(), ruleMeta);\n        List properties = module.getProperties();\n        int size = properties != null ? properties.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigProperty property = (ConfigProperty) properties.get(i);\n            ConfigPropertyMetadata meta = new ConfigPropertyMetadata(ConfigPropertyType.STRING, property.getName(), null, null);\n            property.setMetaData(meta);\n        }\n        return ruleMeta;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return the default severity.\n     */\n    public static SeverityLevel getDefaultSeverity() {\n        return sDefaultSeverity;\n    }\n\n    /**\n     * Refreshes the metadata.\n     */\n    public static synchronized void refresh() {\n        sRuleGroupMetadata = new TreeMap();\n        sRuleMetadata = new HashMap();\n        sAlternativeNamesMap = new HashMap();\n        try {\n            doInitialization();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Initializes the meta data from the xml file.\n     *\n     * @throws CheckstylePluginException error loading the meta data file\n     */\n    private static void doInitialization() throws CheckstylePluginException {\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            // get the classloader containing the extension libraries\n            ClassLoader customsLoader = CustomLibrariesClassLoader.get();\n            Thread.currentThread().setContextClassLoader(customsLoader);\n            Collection potentialMetadataFiles = getAllPotentialMetadataFiles();\n            Iterator it = potentialMetadataFiles.iterator();\n            while (it.hasNext()) {\n                String metadataFile = (String) it.next();\n                InputStream metadataStream = null;\n                try {\n                    metadataStream = customsLoader.getResourceAsStream(metadataFile);\n                    if (metadataStream != null) {\n                        MetaDataHandler metadataHandler = new MetaDataHandler(getMetadataI18NBundle(metadataFile));\n                        XMLUtil.parseWithSAX(metadataStream, metadataHandler, true);\n                    }\n                } catch (SAXParseException e) {\n                    CheckstyleLog.log(e, //$NON-NLS-1$\n                    NLS.//$NON-NLS-1$\n                    bind(//$NON-NLS-1$\n                    \"Could not parse metadata file {0} at {1}:{2}\", new Object[] { metadataFile, new Integer(e.getLineNumber()), new Integer(e.getColumnNumber()) }));\n                } catch (SAXException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (ParserConfigurationException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (IOException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } finally {\n                    IOUtils.closeQuietly(metadataStream);\n                }\n            }\n        } finally {\n            // restore the original classloader\n            Thread.currentThread().setContextClassLoader(contextClassLoader);\n        }\n    }\n\n    /**\n     * Helper method to get all potential metadata files using the\n     * checkstyle_packages.xml as base where to look. It is not guaranteed that\n     * the files returned acutally exist.\n     *\n     * @return the collection of potential metadata files.\n     * @throws CheckstylePluginException an unexpected exception ocurred\n     */\n    private static Collection getAllPotentialMetadataFiles() throws CheckstylePluginException {\n        Collection potentialMetadataFiles = new ArrayList();\n        List packages = PackageNamesLoader.getPackageNames(CustomLibrariesClassLoader.get());\n        for (int i = 0, size = packages.size(); i < size; i++) {\n            String packageName = (String) packages.get(i);\n            String metaFileLocation = packageName.replace('.', '/') + METADATA_FILENAME;\n            potentialMetadataFiles.add(metaFileLocation);\n        }\n        return potentialMetadataFiles;\n    }\n\n    /**\n     * Returns the ResourceBundle for the given meta data file contained i18n'ed\n     * names and descriptions.\n     *\n     * @param metadataFile\n     * @return the corresponding ResourceBundle for the metadata file or\n     *         <code>null</code> if none exists\n     */\n    private static ResourceBundle getMetadataI18NBundle(String metadataFile) {\n        String bundle = metadataFile.substring(0, metadataFile.length() - 4).replace('/', '.');\n        try {\n            return PropertyResourceBundle.getBundle(bundle);\n        } catch (MissingResourceException e) {\n            return null;\n        }\n    }\n\n    /**\n     * SAX-Handler for parsing of the metadata file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class MetaDataHandler extends DefaultHandler {\n\n        //$NON-NLS-1$\n        private static final String DTD_PUBLIC_ID = \"-//eclipse-cs//DTD Check Metadata 1.0//EN\";\n\n        //$NON-NLS-1$\n        private static final String DTD_RESOURCE_NAME = \"/com/puppycrawl/tools/checkstyle/checkstyle-metadata_1_0.dtd\";\n\n        /**\n         * the current rule group.\n         */\n        private RuleGroupMetadata mCurrentGroup;\n\n        /**\n         * the current rule meta data.\n         */\n        private RuleMetadata mCurrentRule;\n\n        /**\n         * the current property.\n         */\n        private ConfigPropertyMetadata mCurrentProperty;\n\n        /**\n         * flags if we're inside a description element.\n         */\n        private boolean mInDescriptionElement;\n\n        /**\n         * StringBuffer containing the description.\n         */\n        private StringBuffer mDescription;\n\n        private ResourceBundle mI18NBundle;\n\n        // /**\n        // * @see\n        // org.xml.sax.ext.EntityResolver2#getExternalSubset(java.lang.String,\n        // * java.lang.String)\n        // */\n        // public InputSource getExternalSubset(String name, String baseURI)\n        // throws SAXException,\n        // IOException\n        // {\n        //\n        // InputStream dtdIS =\n        // getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n        // return new InputSource(dtdIS);\n        // }\n        public MetaDataHandler(ResourceBundle i18nBundle) {\n            mI18NBundle = i18nBundle;\n        }\n\n        /*\n         * \n         */\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException {\n            if (DTD_PUBLIC_ID.equals(publicId)) {\n                final InputStream dtdIS = getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n                if (dtdIS == null) {\n                    //$NON-NLS-1$\n                    throw new SAXException(\"Unable to load internal dtd \" + DTD_RESOURCE_NAME);\n                }\n                return new InputSource(dtdIS);\n            }\n            // This is a hack to workaround problem with SAX\n            // DefaultHeader.resolveEntity():\n            // sometimes it throws SAX- and IO- exceptions\n            // sometime SAX only :(\n            try {\n                if (false) {\n                    //$NON-NLS-1$\n                    throw new IOException(\"\");\n                }\n                return super.resolveEntity(publicId, systemId);\n            } catch (IOException e) {\n                //$NON-NLS-1$\n                throw new SAXException(\"\" + e, e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,\n         *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            try {\n                if (XMLTags.RULE_GROUP_METADATA_TAG.equals(qName)) {\n                    String groupName = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    groupName = localize(groupName);\n                    mCurrentGroup = getRuleGroupMetadata(groupName);\n                    if (mCurrentGroup == null) {\n                        boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                        int priority = 0;\n                        try {\n                            priority = Integer.parseInt(attributes.getValue(XMLTags.PRIORITY_TAG));\n                        } catch (Exception e) {\n                            CheckstyleLog.log(e);\n                            priority = Integer.MAX_VALUE;\n                        }\n                        // Create the groups\n                        mCurrentGroup = new RuleGroupMetadata(groupName, hidden, priority);\n                        sRuleGroupMetadata.put(groupName, mCurrentGroup);\n                    }\n                } else if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                    // default severity\n                    String defaultSeverity = attributes.getValue(XMLTags.DEFAULT_SEVERITY_TAG);\n                    SeverityLevel severity = defaultSeverity == null || defaultSeverity.trim().length() == 0 ? sDefaultSeverity : SeverityLevel.getInstance(defaultSeverity);\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String internalName = attributes.getValue(XMLTags.INTERNAL_NAME_TAG).trim();\n                    String parentName = attributes.getValue(XMLTags.PARENT_TAG) != null ? attributes.getValue(XMLTags.PARENT_TAG).trim() : null;\n                    boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                    boolean hasSeverity = !\"false\".equals(//$NON-NLS-1$\n                    attributes.getValue(XMLTags.HAS_SEVERITY_TAG));\n                    //$NON-NLS-1$\n                    boolean deletable = !\"false\".equals(attributes.getValue(XMLTags.DELETABLE_TAG));\n                    boolean isSingleton = Boolean.valueOf(attributes.getValue(XMLTags.IS_SINGLETON_TAG)).booleanValue();\n                    // create rule metadata\n                    mCurrentRule = new RuleMetadata(localize(name), internalName, parentName, severity, hidden, hasSeverity, deletable, isSingleton, mCurrentGroup);\n                    mCurrentGroup.getRuleMetadata().add(mCurrentRule);\n                    // register internal name\n                    sRuleMetadata.put(internalName, mCurrentRule);\n                } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                    ConfigPropertyType type = ConfigPropertyType.getConfigPropertyType(attributes.getValue(XMLTags.DATATYPE_TAG));\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String defaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_TAG));\n                    String overrideDefaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_OVERRIDE_TAG));\n                    mCurrentProperty = new ConfigPropertyMetadata(type, name, defaultValue, overrideDefaultValue);\n                    // add to current rule\n                    mCurrentRule.getPropertyMetadata().add(mCurrentProperty);\n                } else if (XMLTags.ALTERNATIVE_NAME_TAG.equals(qName)) {\n                    // register alternative name\n                    sAlternativeNamesMap.put(attributes.getValue(XMLTags.INTERNAL_NAME_TAG), mCurrentRule);\n                    mCurrentRule.addAlternativeName(attributes.getValue(XMLTags.INTERNAL_NAME_TAG));\n                } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                    mInDescriptionElement = true;\n                    mDescription = new StringBuffer();\n                } else if (XMLTags.ENUMERATION_TAG.equals(qName)) {\n                    String optionProvider = attributes.getValue(XMLTags.OPTION_PROVIDER);\n                    if (optionProvider != null) {\n                        Class providerClass = Class.forName(optionProvider);\n                        IOptionProvider provider = (IOptionProvider) providerClass.newInstance();\n                        mCurrentProperty.getPropertyEnumeration().addAll(provider.getOptions());\n                    }\n                } else if (XMLTags.PROPERTY_VALUE_OPTIONS_TAG.equals(qName)) {\n                    mCurrentProperty.getPropertyEnumeration().add(attributes.getValue(XMLTags.VALUE_TAG));\n                } else if (XMLTags.QUCKFIX_TAG.equals(qName)) {\n                    String className = attributes.getValue(XMLTags.CLASSNAME_TAG);\n                    Class quickfixClass = Class.forName(className);\n                    ICheckstyleMarkerResolution quickfix = (ICheckstyleMarkerResolution) quickfixClass.newInstance();\n                    mCurrentRule.addQuickfix(quickfix);\n                }\n            } catch (CheckstylePluginException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (ClassNotFoundException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (InstantiationException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (IllegalAccessException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String,\n         *      java.lang.String, java.lang.String)\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                mCurrentRule = null;\n            } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                mCurrentProperty = null;\n            } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                mInDescriptionElement = false;\n                // Set the description to the current element\n                String description = mDescription.toString();\n                if (mCurrentProperty != null) {\n                    mCurrentProperty.setDescription(localize(description));\n                } else if (mCurrentRule != null) {\n                    mCurrentRule.setDescription(localize(description));\n                }\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)\n         */\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (mInDescriptionElement) {\n                mDescription.append(ch, start, length);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)\n         */\n        public void error(SAXParseException e) throws SAXException {\n            throw e;\n        }\n\n        private String localize(String localizationCandidate) {\n            if (mI18NBundle != null && localizationCandidate.startsWith(\"%\")) {\n                try {\n                    return mI18NBundle.getString(localizationCandidate.substring(1));\n                } catch (MissingResourceException e) {\n                    return localizationCandidate;\n                }\n            }\n            return localizationCandidate;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/MetadataFactory_1Test.java",
		"test_prompt": "// MetadataFactory_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataFactory}.\n* It contains ten unit test cases for the {@link MetadataFactory#getRuleMetadata(String)} method.\n*/\nclass MetadataFactory_1Test {"
	},
	{
		"original_code": "// MetadataFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class is the factory for all Checkstyle rule metadata.\n */\npublic final class MetadataFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Metadata for the rule groups.\n     */\n    private static Map sRuleGroupMetadata;\n\n    /**\n     * Metadata for all rules, keyed by internal rule name.\n     */\n    private static Map sRuleMetadata;\n\n    /**\n     * Mapping for all rules, keyed by alternative rule names (full qualified,\n     * old full qualified).\n     */\n    private static Map sAlternativeNamesMap;\n\n    /**\n     * the default severity level.\n     */\n    private static SeverityLevel sDefaultSeverity = SeverityLevel.WARNING;\n\n    /**\n     * Name of the rules metadata XML file.\n     */\n    //$NON-NLS-1$\n    private static final String METADATA_FILENAME = \"checkstyle-metadata.xml\";\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private MetadataFactory() {\n    }\n\n    /**\n     * Static initializer.\n     */\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a list of metadata objects for all rule groups.\n     *\n     * @return List of <code>RuleGroupMetadata</code> objects.\n     */\n    public static List getRuleGroupMetadata() {\n        List groups = new ArrayList(sRuleGroupMetadata.values());\n        Collections.sort(groups, new Comparator() {\n\n            public int compare(Object arg0, Object arg1) {\n                int prio1 = ((RuleGroupMetadata) arg0).getPriority();\n                int prio2 = ((RuleGroupMetadata) arg1).getPriority();\n                return (prio1 < prio2 ? -1 : (prio1 == prio2 ? 0 : 1));\n            }\n        });\n        return groups;\n    }\n\n    /**\n     * Get metadata for a check rule.\n     *\n     * @param name The rule's name within the checkstyle configuration file.\n     * @return The metadata.\n     */\n    public static RuleMetadata getRuleMetadata(String name) {\n        RuleMetadata metadata = null;\n        // first try the internal name mapping\n        metadata = (RuleMetadata) sRuleMetadata.get(name);\n        // try the alternative names\n        if (metadata == null) {\n            metadata = (RuleMetadata) sAlternativeNamesMap.get(name);\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns the metadata for a rule group.\n     *\n     * @param name the group name\n     * @return the RuleGroupMetadata object or <code>null</code>\n     */\n    public static RuleGroupMetadata getRuleGroupMetadata(String name) {\n        return (RuleGroupMetadata) sRuleGroupMetadata.get(name);\n    }\n\n    /**\n     * Creates a set of generic metadata for a module that has no metadata\n     * delivered with the plugin.\n     *\n     * @param module the module\n     * @return the generic metadata built\n     */\n    public static RuleMetadata createGenericMetadata(Module module) {\n        String parent = null;\n        try {\n            Class checkClass = Class.forName(module.getName());\n            Object moduleInstance = checkClass.newInstance();\n            if (moduleInstance instanceof AbstractFileSetCheck) {\n                parent = XMLTags.CHECKER_MODULE;\n            } else {\n                parent = XMLTags.TREEWALKER_MODULE;\n            }\n        } catch (Exception e) {\n            // Ok we tried... default to TreeWalker\n            parent = XMLTags.TREEWALKER_MODULE;\n        }\n        RuleGroupMetadata otherGroup = getRuleGroupMetadata(XMLTags.OTHER_GROUP);\n        RuleMetadata ruleMeta = new RuleMetadata(module.getName(), module.getName(), parent, MetadataFactory.getDefaultSeverity(), false, true, true, false, otherGroup);\n        module.setMetaData(ruleMeta);\n        sRuleMetadata.put(ruleMeta.getInternalName(), ruleMeta);\n        List properties = module.getProperties();\n        int size = properties != null ? properties.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigProperty property = (ConfigProperty) properties.get(i);\n            ConfigPropertyMetadata meta = new ConfigPropertyMetadata(ConfigPropertyType.STRING, property.getName(), null, null);\n            property.setMetaData(meta);\n        }\n        return ruleMeta;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return the default severity.\n     */\n    public static SeverityLevel getDefaultSeverity() {\n        return sDefaultSeverity;\n    }\n\n    /**\n     * Refreshes the metadata.\n     */\n    public static synchronized void refresh() {\n        sRuleGroupMetadata = new TreeMap();\n        sRuleMetadata = new HashMap();\n        sAlternativeNamesMap = new HashMap();\n        try {\n            doInitialization();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Initializes the meta data from the xml file.\n     *\n     * @throws CheckstylePluginException error loading the meta data file\n     */\n    private static void doInitialization() throws CheckstylePluginException {\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            // get the classloader containing the extension libraries\n            ClassLoader customsLoader = CustomLibrariesClassLoader.get();\n            Thread.currentThread().setContextClassLoader(customsLoader);\n            Collection potentialMetadataFiles = getAllPotentialMetadataFiles();\n            Iterator it = potentialMetadataFiles.iterator();\n            while (it.hasNext()) {\n                String metadataFile = (String) it.next();\n                InputStream metadataStream = null;\n                try {\n                    metadataStream = customsLoader.getResourceAsStream(metadataFile);\n                    if (metadataStream != null) {\n                        MetaDataHandler metadataHandler = new MetaDataHandler(getMetadataI18NBundle(metadataFile));\n                        XMLUtil.parseWithSAX(metadataStream, metadataHandler, true);\n                    }\n                } catch (SAXParseException e) {\n                    CheckstyleLog.log(e, //$NON-NLS-1$\n                    NLS.//$NON-NLS-1$\n                    bind(//$NON-NLS-1$\n                    \"Could not parse metadata file {0} at {1}:{2}\", new Object[] { metadataFile, new Integer(e.getLineNumber()), new Integer(e.getColumnNumber()) }));\n                } catch (SAXException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (ParserConfigurationException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (IOException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } finally {\n                    IOUtils.closeQuietly(metadataStream);\n                }\n            }\n        } finally {\n            // restore the original classloader\n            Thread.currentThread().setContextClassLoader(contextClassLoader);\n        }\n    }\n\n    /**\n     * Helper method to get all potential metadata files using the\n     * checkstyle_packages.xml as base where to look. It is not guaranteed that\n     * the files returned acutally exist.\n     *\n     * @return the collection of potential metadata files.\n     * @throws CheckstylePluginException an unexpected exception ocurred\n     */\n    private static Collection getAllPotentialMetadataFiles() throws CheckstylePluginException {\n        Collection potentialMetadataFiles = new ArrayList();\n        List packages = PackageNamesLoader.getPackageNames(CustomLibrariesClassLoader.get());\n        for (int i = 0, size = packages.size(); i < size; i++) {\n            String packageName = (String) packages.get(i);\n            String metaFileLocation = packageName.replace('.', '/') + METADATA_FILENAME;\n            potentialMetadataFiles.add(metaFileLocation);\n        }\n        return potentialMetadataFiles;\n    }\n\n    /**\n     * Returns the ResourceBundle for the given meta data file contained i18n'ed\n     * names and descriptions.\n     *\n     * @param metadataFile\n     * @return the corresponding ResourceBundle for the metadata file or\n     *         <code>null</code> if none exists\n     */\n    private static ResourceBundle getMetadataI18NBundle(String metadataFile) {\n        String bundle = metadataFile.substring(0, metadataFile.length() - 4).replace('/', '.');\n        try {\n            return PropertyResourceBundle.getBundle(bundle);\n        } catch (MissingResourceException e) {\n            return null;\n        }\n    }\n\n    /**\n     * SAX-Handler for parsing of the metadata file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class MetaDataHandler extends DefaultHandler {\n\n        //$NON-NLS-1$\n        private static final String DTD_PUBLIC_ID = \"-//eclipse-cs//DTD Check Metadata 1.0//EN\";\n\n        //$NON-NLS-1$\n        private static final String DTD_RESOURCE_NAME = \"/com/puppycrawl/tools/checkstyle/checkstyle-metadata_1_0.dtd\";\n\n        /**\n         * the current rule group.\n         */\n        private RuleGroupMetadata mCurrentGroup;\n\n        /**\n         * the current rule meta data.\n         */\n        private RuleMetadata mCurrentRule;\n\n        /**\n         * the current property.\n         */\n        private ConfigPropertyMetadata mCurrentProperty;\n\n        /**\n         * flags if we're inside a description element.\n         */\n        private boolean mInDescriptionElement;\n\n        /**\n         * StringBuffer containing the description.\n         */\n        private StringBuffer mDescription;\n\n        private ResourceBundle mI18NBundle;\n\n        // /**\n        // * @see\n        // org.xml.sax.ext.EntityResolver2#getExternalSubset(java.lang.String,\n        // * java.lang.String)\n        // */\n        // public InputSource getExternalSubset(String name, String baseURI)\n        // throws SAXException,\n        // IOException\n        // {\n        //\n        // InputStream dtdIS =\n        // getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n        // return new InputSource(dtdIS);\n        // }\n        public MetaDataHandler(ResourceBundle i18nBundle) {\n            mI18NBundle = i18nBundle;\n        }\n\n        /*\n         * \n         */\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException {\n            if (DTD_PUBLIC_ID.equals(publicId)) {\n                final InputStream dtdIS = getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n                if (dtdIS == null) {\n                    //$NON-NLS-1$\n                    throw new SAXException(\"Unable to load internal dtd \" + DTD_RESOURCE_NAME);\n                }\n                return new InputSource(dtdIS);\n            }\n            // This is a hack to workaround problem with SAX\n            // DefaultHeader.resolveEntity():\n            // sometimes it throws SAX- and IO- exceptions\n            // sometime SAX only :(\n            try {\n                if (false) {\n                    //$NON-NLS-1$\n                    throw new IOException(\"\");\n                }\n                return super.resolveEntity(publicId, systemId);\n            } catch (IOException e) {\n                //$NON-NLS-1$\n                throw new SAXException(\"\" + e, e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,\n         *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            try {\n                if (XMLTags.RULE_GROUP_METADATA_TAG.equals(qName)) {\n                    String groupName = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    groupName = localize(groupName);\n                    mCurrentGroup = getRuleGroupMetadata(groupName);\n                    if (mCurrentGroup == null) {\n                        boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                        int priority = 0;\n                        try {\n                            priority = Integer.parseInt(attributes.getValue(XMLTags.PRIORITY_TAG));\n                        } catch (Exception e) {\n                            CheckstyleLog.log(e);\n                            priority = Integer.MAX_VALUE;\n                        }\n                        // Create the groups\n                        mCurrentGroup = new RuleGroupMetadata(groupName, hidden, priority);\n                        sRuleGroupMetadata.put(groupName, mCurrentGroup);\n                    }\n                } else if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                    // default severity\n                    String defaultSeverity = attributes.getValue(XMLTags.DEFAULT_SEVERITY_TAG);\n                    SeverityLevel severity = defaultSeverity == null || defaultSeverity.trim().length() == 0 ? sDefaultSeverity : SeverityLevel.getInstance(defaultSeverity);\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String internalName = attributes.getValue(XMLTags.INTERNAL_NAME_TAG).trim();\n                    String parentName = attributes.getValue(XMLTags.PARENT_TAG) != null ? attributes.getValue(XMLTags.PARENT_TAG).trim() : null;\n                    boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                    boolean hasSeverity = !\"false\".equals(//$NON-NLS-1$\n                    attributes.getValue(XMLTags.HAS_SEVERITY_TAG));\n                    //$NON-NLS-1$\n                    boolean deletable = !\"false\".equals(attributes.getValue(XMLTags.DELETABLE_TAG));\n                    boolean isSingleton = Boolean.valueOf(attributes.getValue(XMLTags.IS_SINGLETON_TAG)).booleanValue();\n                    // create rule metadata\n                    mCurrentRule = new RuleMetadata(localize(name), internalName, parentName, severity, hidden, hasSeverity, deletable, isSingleton, mCurrentGroup);\n                    mCurrentGroup.getRuleMetadata().add(mCurrentRule);\n                    // register internal name\n                    sRuleMetadata.put(internalName, mCurrentRule);\n                } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                    ConfigPropertyType type = ConfigPropertyType.getConfigPropertyType(attributes.getValue(XMLTags.DATATYPE_TAG));\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String defaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_TAG));\n                    String overrideDefaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_OVERRIDE_TAG));\n                    mCurrentProperty = new ConfigPropertyMetadata(type, name, defaultValue, overrideDefaultValue);\n                    // add to current rule\n                    mCurrentRule.getPropertyMetadata().add(mCurrentProperty);\n                } else if (XMLTags.ALTERNATIVE_NAME_TAG.equals(qName)) {\n                    // register alternative name\n                    sAlternativeNamesMap.put(attributes.getValue(XMLTags.INTERNAL_NAME_TAG), mCurrentRule);\n                    mCurrentRule.addAlternativeName(attributes.getValue(XMLTags.INTERNAL_NAME_TAG));\n                } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                    mInDescriptionElement = true;\n                    mDescription = new StringBuffer();\n                } else if (XMLTags.ENUMERATION_TAG.equals(qName)) {\n                    String optionProvider = attributes.getValue(XMLTags.OPTION_PROVIDER);\n                    if (optionProvider != null) {\n                        Class providerClass = Class.forName(optionProvider);\n                        IOptionProvider provider = (IOptionProvider) providerClass.newInstance();\n                        mCurrentProperty.getPropertyEnumeration().addAll(provider.getOptions());\n                    }\n                } else if (XMLTags.PROPERTY_VALUE_OPTIONS_TAG.equals(qName)) {\n                    mCurrentProperty.getPropertyEnumeration().add(attributes.getValue(XMLTags.VALUE_TAG));\n                } else if (XMLTags.QUCKFIX_TAG.equals(qName)) {\n                    String className = attributes.getValue(XMLTags.CLASSNAME_TAG);\n                    Class quickfixClass = Class.forName(className);\n                    ICheckstyleMarkerResolution quickfix = (ICheckstyleMarkerResolution) quickfixClass.newInstance();\n                    mCurrentRule.addQuickfix(quickfix);\n                }\n            } catch (CheckstylePluginException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (ClassNotFoundException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (InstantiationException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (IllegalAccessException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String,\n         *      java.lang.String, java.lang.String)\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                mCurrentRule = null;\n            } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                mCurrentProperty = null;\n            } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                mInDescriptionElement = false;\n                // Set the description to the current element\n                String description = mDescription.toString();\n                if (mCurrentProperty != null) {\n                    mCurrentProperty.setDescription(localize(description));\n                } else if (mCurrentRule != null) {\n                    mCurrentRule.setDescription(localize(description));\n                }\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)\n         */\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (mInDescriptionElement) {\n                mDescription.append(ch, start, length);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)\n         */\n        public void error(SAXParseException e) throws SAXException {\n            throw e;\n        }\n\n        private String localize(String localizationCandidate) {\n            if (mI18NBundle != null && localizationCandidate.startsWith(\"%\")) {\n                try {\n                    return mI18NBundle.getString(localizationCandidate.substring(1));\n                } catch (MissingResourceException e) {\n                    return localizationCandidate;\n                }\n            }\n            return localizationCandidate;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/MetadataFactory_2Test.java",
		"test_prompt": "// MetadataFactory_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataFactory}.\n* It contains ten unit test cases for the {@link MetadataFactory#getRuleGroupMetadata(String)} method.\n*/\nclass MetadataFactory_2Test {"
	},
	{
		"original_code": "// MetadataFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class is the factory for all Checkstyle rule metadata.\n */\npublic final class MetadataFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Metadata for the rule groups.\n     */\n    private static Map sRuleGroupMetadata;\n\n    /**\n     * Metadata for all rules, keyed by internal rule name.\n     */\n    private static Map sRuleMetadata;\n\n    /**\n     * Mapping for all rules, keyed by alternative rule names (full qualified,\n     * old full qualified).\n     */\n    private static Map sAlternativeNamesMap;\n\n    /**\n     * the default severity level.\n     */\n    private static SeverityLevel sDefaultSeverity = SeverityLevel.WARNING;\n\n    /**\n     * Name of the rules metadata XML file.\n     */\n    //$NON-NLS-1$\n    private static final String METADATA_FILENAME = \"checkstyle-metadata.xml\";\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private MetadataFactory() {\n    }\n\n    /**\n     * Static initializer.\n     */\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a list of metadata objects for all rule groups.\n     *\n     * @return List of <code>RuleGroupMetadata</code> objects.\n     */\n    public static List getRuleGroupMetadata() {\n        List groups = new ArrayList(sRuleGroupMetadata.values());\n        Collections.sort(groups, new Comparator() {\n\n            public int compare(Object arg0, Object arg1) {\n                int prio1 = ((RuleGroupMetadata) arg0).getPriority();\n                int prio2 = ((RuleGroupMetadata) arg1).getPriority();\n                return (prio1 < prio2 ? -1 : (prio1 == prio2 ? 0 : 1));\n            }\n        });\n        return groups;\n    }\n\n    /**\n     * Get metadata for a check rule.\n     *\n     * @param name The rule's name within the checkstyle configuration file.\n     * @return The metadata.\n     */\n    public static RuleMetadata getRuleMetadata(String name) {\n        RuleMetadata metadata = null;\n        // first try the internal name mapping\n        metadata = (RuleMetadata) sRuleMetadata.get(name);\n        // try the alternative names\n        if (metadata == null) {\n            metadata = (RuleMetadata) sAlternativeNamesMap.get(name);\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns the metadata for a rule group.\n     *\n     * @param name the group name\n     * @return the RuleGroupMetadata object or <code>null</code>\n     */\n    public static RuleGroupMetadata getRuleGroupMetadata(String name) {\n        return (RuleGroupMetadata) sRuleGroupMetadata.get(name);\n    }\n\n    /**\n     * Creates a set of generic metadata for a module that has no metadata\n     * delivered with the plugin.\n     *\n     * @param module the module\n     * @return the generic metadata built\n     */\n    public static RuleMetadata createGenericMetadata(Module module) {\n        String parent = null;\n        try {\n            Class checkClass = Class.forName(module.getName());\n            Object moduleInstance = checkClass.newInstance();\n            if (moduleInstance instanceof AbstractFileSetCheck) {\n                parent = XMLTags.CHECKER_MODULE;\n            } else {\n                parent = XMLTags.TREEWALKER_MODULE;\n            }\n        } catch (Exception e) {\n            // Ok we tried... default to TreeWalker\n            parent = XMLTags.TREEWALKER_MODULE;\n        }\n        RuleGroupMetadata otherGroup = getRuleGroupMetadata(XMLTags.OTHER_GROUP);\n        RuleMetadata ruleMeta = new RuleMetadata(module.getName(), module.getName(), parent, MetadataFactory.getDefaultSeverity(), false, true, true, false, otherGroup);\n        module.setMetaData(ruleMeta);\n        sRuleMetadata.put(ruleMeta.getInternalName(), ruleMeta);\n        List properties = module.getProperties();\n        int size = properties != null ? properties.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigProperty property = (ConfigProperty) properties.get(i);\n            ConfigPropertyMetadata meta = new ConfigPropertyMetadata(ConfigPropertyType.STRING, property.getName(), null, null);\n            property.setMetaData(meta);\n        }\n        return ruleMeta;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return the default severity.\n     */\n    public static SeverityLevel getDefaultSeverity() {\n        return sDefaultSeverity;\n    }\n\n    /**\n     * Refreshes the metadata.\n     */\n    public static synchronized void refresh() {\n        sRuleGroupMetadata = new TreeMap();\n        sRuleMetadata = new HashMap();\n        sAlternativeNamesMap = new HashMap();\n        try {\n            doInitialization();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Initializes the meta data from the xml file.\n     *\n     * @throws CheckstylePluginException error loading the meta data file\n     */\n    private static void doInitialization() throws CheckstylePluginException {\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            // get the classloader containing the extension libraries\n            ClassLoader customsLoader = CustomLibrariesClassLoader.get();\n            Thread.currentThread().setContextClassLoader(customsLoader);\n            Collection potentialMetadataFiles = getAllPotentialMetadataFiles();\n            Iterator it = potentialMetadataFiles.iterator();\n            while (it.hasNext()) {\n                String metadataFile = (String) it.next();\n                InputStream metadataStream = null;\n                try {\n                    metadataStream = customsLoader.getResourceAsStream(metadataFile);\n                    if (metadataStream != null) {\n                        MetaDataHandler metadataHandler = new MetaDataHandler(getMetadataI18NBundle(metadataFile));\n                        XMLUtil.parseWithSAX(metadataStream, metadataHandler, true);\n                    }\n                } catch (SAXParseException e) {\n                    CheckstyleLog.log(e, //$NON-NLS-1$\n                    NLS.//$NON-NLS-1$\n                    bind(//$NON-NLS-1$\n                    \"Could not parse metadata file {0} at {1}:{2}\", new Object[] { metadataFile, new Integer(e.getLineNumber()), new Integer(e.getColumnNumber()) }));\n                } catch (SAXException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (ParserConfigurationException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (IOException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } finally {\n                    IOUtils.closeQuietly(metadataStream);\n                }\n            }\n        } finally {\n            // restore the original classloader\n            Thread.currentThread().setContextClassLoader(contextClassLoader);\n        }\n    }\n\n    /**\n     * Helper method to get all potential metadata files using the\n     * checkstyle_packages.xml as base where to look. It is not guaranteed that\n     * the files returned acutally exist.\n     *\n     * @return the collection of potential metadata files.\n     * @throws CheckstylePluginException an unexpected exception ocurred\n     */\n    private static Collection getAllPotentialMetadataFiles() throws CheckstylePluginException {\n        Collection potentialMetadataFiles = new ArrayList();\n        List packages = PackageNamesLoader.getPackageNames(CustomLibrariesClassLoader.get());\n        for (int i = 0, size = packages.size(); i < size; i++) {\n            String packageName = (String) packages.get(i);\n            String metaFileLocation = packageName.replace('.', '/') + METADATA_FILENAME;\n            potentialMetadataFiles.add(metaFileLocation);\n        }\n        return potentialMetadataFiles;\n    }\n\n    /**\n     * Returns the ResourceBundle for the given meta data file contained i18n'ed\n     * names and descriptions.\n     *\n     * @param metadataFile\n     * @return the corresponding ResourceBundle for the metadata file or\n     *         <code>null</code> if none exists\n     */\n    private static ResourceBundle getMetadataI18NBundle(String metadataFile) {\n        String bundle = metadataFile.substring(0, metadataFile.length() - 4).replace('/', '.');\n        try {\n            return PropertyResourceBundle.getBundle(bundle);\n        } catch (MissingResourceException e) {\n            return null;\n        }\n    }\n\n    /**\n     * SAX-Handler for parsing of the metadata file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class MetaDataHandler extends DefaultHandler {\n\n        //$NON-NLS-1$\n        private static final String DTD_PUBLIC_ID = \"-//eclipse-cs//DTD Check Metadata 1.0//EN\";\n\n        //$NON-NLS-1$\n        private static final String DTD_RESOURCE_NAME = \"/com/puppycrawl/tools/checkstyle/checkstyle-metadata_1_0.dtd\";\n\n        /**\n         * the current rule group.\n         */\n        private RuleGroupMetadata mCurrentGroup;\n\n        /**\n         * the current rule meta data.\n         */\n        private RuleMetadata mCurrentRule;\n\n        /**\n         * the current property.\n         */\n        private ConfigPropertyMetadata mCurrentProperty;\n\n        /**\n         * flags if we're inside a description element.\n         */\n        private boolean mInDescriptionElement;\n\n        /**\n         * StringBuffer containing the description.\n         */\n        private StringBuffer mDescription;\n\n        private ResourceBundle mI18NBundle;\n\n        // /**\n        // * @see\n        // org.xml.sax.ext.EntityResolver2#getExternalSubset(java.lang.String,\n        // * java.lang.String)\n        // */\n        // public InputSource getExternalSubset(String name, String baseURI)\n        // throws SAXException,\n        // IOException\n        // {\n        //\n        // InputStream dtdIS =\n        // getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n        // return new InputSource(dtdIS);\n        // }\n        public MetaDataHandler(ResourceBundle i18nBundle) {\n            mI18NBundle = i18nBundle;\n        }\n\n        /*\n         * \n         */\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException {\n            if (DTD_PUBLIC_ID.equals(publicId)) {\n                final InputStream dtdIS = getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n                if (dtdIS == null) {\n                    //$NON-NLS-1$\n                    throw new SAXException(\"Unable to load internal dtd \" + DTD_RESOURCE_NAME);\n                }\n                return new InputSource(dtdIS);\n            }\n            // This is a hack to workaround problem with SAX\n            // DefaultHeader.resolveEntity():\n            // sometimes it throws SAX- and IO- exceptions\n            // sometime SAX only :(\n            try {\n                if (false) {\n                    //$NON-NLS-1$\n                    throw new IOException(\"\");\n                }\n                return super.resolveEntity(publicId, systemId);\n            } catch (IOException e) {\n                //$NON-NLS-1$\n                throw new SAXException(\"\" + e, e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,\n         *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            try {\n                if (XMLTags.RULE_GROUP_METADATA_TAG.equals(qName)) {\n                    String groupName = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    groupName = localize(groupName);\n                    mCurrentGroup = getRuleGroupMetadata(groupName);\n                    if (mCurrentGroup == null) {\n                        boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                        int priority = 0;\n                        try {\n                            priority = Integer.parseInt(attributes.getValue(XMLTags.PRIORITY_TAG));\n                        } catch (Exception e) {\n                            CheckstyleLog.log(e);\n                            priority = Integer.MAX_VALUE;\n                        }\n                        // Create the groups\n                        mCurrentGroup = new RuleGroupMetadata(groupName, hidden, priority);\n                        sRuleGroupMetadata.put(groupName, mCurrentGroup);\n                    }\n                } else if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                    // default severity\n                    String defaultSeverity = attributes.getValue(XMLTags.DEFAULT_SEVERITY_TAG);\n                    SeverityLevel severity = defaultSeverity == null || defaultSeverity.trim().length() == 0 ? sDefaultSeverity : SeverityLevel.getInstance(defaultSeverity);\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String internalName = attributes.getValue(XMLTags.INTERNAL_NAME_TAG).trim();\n                    String parentName = attributes.getValue(XMLTags.PARENT_TAG) != null ? attributes.getValue(XMLTags.PARENT_TAG).trim() : null;\n                    boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                    boolean hasSeverity = !\"false\".equals(//$NON-NLS-1$\n                    attributes.getValue(XMLTags.HAS_SEVERITY_TAG));\n                    //$NON-NLS-1$\n                    boolean deletable = !\"false\".equals(attributes.getValue(XMLTags.DELETABLE_TAG));\n                    boolean isSingleton = Boolean.valueOf(attributes.getValue(XMLTags.IS_SINGLETON_TAG)).booleanValue();\n                    // create rule metadata\n                    mCurrentRule = new RuleMetadata(localize(name), internalName, parentName, severity, hidden, hasSeverity, deletable, isSingleton, mCurrentGroup);\n                    mCurrentGroup.getRuleMetadata().add(mCurrentRule);\n                    // register internal name\n                    sRuleMetadata.put(internalName, mCurrentRule);\n                } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                    ConfigPropertyType type = ConfigPropertyType.getConfigPropertyType(attributes.getValue(XMLTags.DATATYPE_TAG));\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String defaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_TAG));\n                    String overrideDefaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_OVERRIDE_TAG));\n                    mCurrentProperty = new ConfigPropertyMetadata(type, name, defaultValue, overrideDefaultValue);\n                    // add to current rule\n                    mCurrentRule.getPropertyMetadata().add(mCurrentProperty);\n                } else if (XMLTags.ALTERNATIVE_NAME_TAG.equals(qName)) {\n                    // register alternative name\n                    sAlternativeNamesMap.put(attributes.getValue(XMLTags.INTERNAL_NAME_TAG), mCurrentRule);\n                    mCurrentRule.addAlternativeName(attributes.getValue(XMLTags.INTERNAL_NAME_TAG));\n                } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                    mInDescriptionElement = true;\n                    mDescription = new StringBuffer();\n                } else if (XMLTags.ENUMERATION_TAG.equals(qName)) {\n                    String optionProvider = attributes.getValue(XMLTags.OPTION_PROVIDER);\n                    if (optionProvider != null) {\n                        Class providerClass = Class.forName(optionProvider);\n                        IOptionProvider provider = (IOptionProvider) providerClass.newInstance();\n                        mCurrentProperty.getPropertyEnumeration().addAll(provider.getOptions());\n                    }\n                } else if (XMLTags.PROPERTY_VALUE_OPTIONS_TAG.equals(qName)) {\n                    mCurrentProperty.getPropertyEnumeration().add(attributes.getValue(XMLTags.VALUE_TAG));\n                } else if (XMLTags.QUCKFIX_TAG.equals(qName)) {\n                    String className = attributes.getValue(XMLTags.CLASSNAME_TAG);\n                    Class quickfixClass = Class.forName(className);\n                    ICheckstyleMarkerResolution quickfix = (ICheckstyleMarkerResolution) quickfixClass.newInstance();\n                    mCurrentRule.addQuickfix(quickfix);\n                }\n            } catch (CheckstylePluginException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (ClassNotFoundException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (InstantiationException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (IllegalAccessException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String,\n         *      java.lang.String, java.lang.String)\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                mCurrentRule = null;\n            } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                mCurrentProperty = null;\n            } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                mInDescriptionElement = false;\n                // Set the description to the current element\n                String description = mDescription.toString();\n                if (mCurrentProperty != null) {\n                    mCurrentProperty.setDescription(localize(description));\n                } else if (mCurrentRule != null) {\n                    mCurrentRule.setDescription(localize(description));\n                }\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)\n         */\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (mInDescriptionElement) {\n                mDescription.append(ch, start, length);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)\n         */\n        public void error(SAXParseException e) throws SAXException {\n            throw e;\n        }\n\n        private String localize(String localizationCandidate) {\n            if (mI18NBundle != null && localizationCandidate.startsWith(\"%\")) {\n                try {\n                    return mI18NBundle.getString(localizationCandidate.substring(1));\n                } catch (MissingResourceException e) {\n                    return localizationCandidate;\n                }\n            }\n            return localizationCandidate;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/MetadataFactory_3Test.java",
		"test_prompt": "// MetadataFactory_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataFactory}.\n* It contains ten unit test cases for the {@link MetadataFactory#createGenericMetadata(Module)} method.\n*/\nclass MetadataFactory_3Test {"
	},
	{
		"original_code": "// MetadataFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\n\n/**\n * This class is the factory for all Checkstyle rule metadata.\n */\npublic final class MetadataFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Metadata for the rule groups.\n     */\n    private static Map sRuleGroupMetadata;\n\n    /**\n     * Metadata for all rules, keyed by internal rule name.\n     */\n    private static Map sRuleMetadata;\n\n    /**\n     * Mapping for all rules, keyed by alternative rule names (full qualified,\n     * old full qualified).\n     */\n    private static Map sAlternativeNamesMap;\n\n    /**\n     * the default severity level.\n     */\n    private static SeverityLevel sDefaultSeverity = SeverityLevel.WARNING;\n\n    /**\n     * Name of the rules metadata XML file.\n     */\n    //$NON-NLS-1$\n    private static final String METADATA_FILENAME = \"checkstyle-metadata.xml\";\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private MetadataFactory() {\n    }\n\n    /**\n     * Static initializer.\n     */\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get a list of metadata objects for all rule groups.\n     *\n     * @return List of <code>RuleGroupMetadata</code> objects.\n     */\n    public static List getRuleGroupMetadata() {\n        List groups = new ArrayList(sRuleGroupMetadata.values());\n        Collections.sort(groups, new Comparator() {\n\n            public int compare(Object arg0, Object arg1) {\n                int prio1 = ((RuleGroupMetadata) arg0).getPriority();\n                int prio2 = ((RuleGroupMetadata) arg1).getPriority();\n                return (prio1 < prio2 ? -1 : (prio1 == prio2 ? 0 : 1));\n            }\n        });\n        return groups;\n    }\n\n    /**\n     * Get metadata for a check rule.\n     *\n     * @param name The rule's name within the checkstyle configuration file.\n     * @return The metadata.\n     */\n    public static RuleMetadata getRuleMetadata(String name) {\n        RuleMetadata metadata = null;\n        // first try the internal name mapping\n        metadata = (RuleMetadata) sRuleMetadata.get(name);\n        // try the alternative names\n        if (metadata == null) {\n            metadata = (RuleMetadata) sAlternativeNamesMap.get(name);\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns the metadata for a rule group.\n     *\n     * @param name the group name\n     * @return the RuleGroupMetadata object or <code>null</code>\n     */\n    public static RuleGroupMetadata getRuleGroupMetadata(String name) {\n        return (RuleGroupMetadata) sRuleGroupMetadata.get(name);\n    }\n\n    /**\n     * Creates a set of generic metadata for a module that has no metadata\n     * delivered with the plugin.\n     *\n     * @param module the module\n     * @return the generic metadata built\n     */\n    public static RuleMetadata createGenericMetadata(Module module) {\n        String parent = null;\n        try {\n            Class checkClass = Class.forName(module.getName());\n            Object moduleInstance = checkClass.newInstance();\n            if (moduleInstance instanceof AbstractFileSetCheck) {\n                parent = XMLTags.CHECKER_MODULE;\n            } else {\n                parent = XMLTags.TREEWALKER_MODULE;\n            }\n        } catch (Exception e) {\n            // Ok we tried... default to TreeWalker\n            parent = XMLTags.TREEWALKER_MODULE;\n        }\n        RuleGroupMetadata otherGroup = getRuleGroupMetadata(XMLTags.OTHER_GROUP);\n        RuleMetadata ruleMeta = new RuleMetadata(module.getName(), module.getName(), parent, MetadataFactory.getDefaultSeverity(), false, true, true, false, otherGroup);\n        module.setMetaData(ruleMeta);\n        sRuleMetadata.put(ruleMeta.getInternalName(), ruleMeta);\n        List properties = module.getProperties();\n        int size = properties != null ? properties.size() : 0;\n        for (int i = 0; i < size; i++) {\n            ConfigProperty property = (ConfigProperty) properties.get(i);\n            ConfigPropertyMetadata meta = new ConfigPropertyMetadata(ConfigPropertyType.STRING, property.getName(), null, null);\n            property.setMetaData(meta);\n        }\n        return ruleMeta;\n    }\n\n    /**\n     * Returns the default severity level.\n     *\n     * @return the default severity.\n     */\n    public static SeverityLevel getDefaultSeverity() {\n        return sDefaultSeverity;\n    }\n\n    /**\n     * Refreshes the metadata.\n     */\n    public static synchronized void refresh() {\n        sRuleGroupMetadata = new TreeMap();\n        sRuleMetadata = new HashMap();\n        sAlternativeNamesMap = new HashMap();\n        try {\n            doInitialization();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Initializes the meta data from the xml file.\n     *\n     * @throws CheckstylePluginException error loading the meta data file\n     */\n    private static void doInitialization() throws CheckstylePluginException {\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            // get the classloader containing the extension libraries\n            ClassLoader customsLoader = CustomLibrariesClassLoader.get();\n            Thread.currentThread().setContextClassLoader(customsLoader);\n            Collection potentialMetadataFiles = getAllPotentialMetadataFiles();\n            Iterator it = potentialMetadataFiles.iterator();\n            while (it.hasNext()) {\n                String metadataFile = (String) it.next();\n                InputStream metadataStream = null;\n                try {\n                    metadataStream = customsLoader.getResourceAsStream(metadataFile);\n                    if (metadataStream != null) {\n                        MetaDataHandler metadataHandler = new MetaDataHandler(getMetadataI18NBundle(metadataFile));\n                        XMLUtil.parseWithSAX(metadataStream, metadataHandler, true);\n                    }\n                } catch (SAXParseException e) {\n                    CheckstyleLog.log(e, //$NON-NLS-1$\n                    NLS.//$NON-NLS-1$\n                    bind(//$NON-NLS-1$\n                    \"Could not parse metadata file {0} at {1}:{2}\", new Object[] { metadataFile, new Integer(e.getLineNumber()), new Integer(e.getColumnNumber()) }));\n                } catch (SAXException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (ParserConfigurationException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } catch (IOException e) {\n                    //$NON-NLS-1$\n                    CheckstyleLog.log(e, \"Could not read metadata \" + metadataFile);\n                } finally {\n                    IOUtils.closeQuietly(metadataStream);\n                }\n            }\n        } finally {\n            // restore the original classloader\n            Thread.currentThread().setContextClassLoader(contextClassLoader);\n        }\n    }\n\n    /**\n     * Helper method to get all potential metadata files using the\n     * checkstyle_packages.xml as base where to look. It is not guaranteed that\n     * the files returned acutally exist.\n     *\n     * @return the collection of potential metadata files.\n     * @throws CheckstylePluginException an unexpected exception ocurred\n     */\n    private static Collection getAllPotentialMetadataFiles() throws CheckstylePluginException {\n        Collection potentialMetadataFiles = new ArrayList();\n        List packages = PackageNamesLoader.getPackageNames(CustomLibrariesClassLoader.get());\n        for (int i = 0, size = packages.size(); i < size; i++) {\n            String packageName = (String) packages.get(i);\n            String metaFileLocation = packageName.replace('.', '/') + METADATA_FILENAME;\n            potentialMetadataFiles.add(metaFileLocation);\n        }\n        return potentialMetadataFiles;\n    }\n\n    /**\n     * Returns the ResourceBundle for the given meta data file contained i18n'ed\n     * names and descriptions.\n     *\n     * @param metadataFile\n     * @return the corresponding ResourceBundle for the metadata file or\n     *         <code>null</code> if none exists\n     */\n    private static ResourceBundle getMetadataI18NBundle(String metadataFile) {\n        String bundle = metadataFile.substring(0, metadataFile.length() - 4).replace('/', '.');\n        try {\n            return PropertyResourceBundle.getBundle(bundle);\n        } catch (MissingResourceException e) {\n            return null;\n        }\n    }\n\n    /**\n     * SAX-Handler for parsing of the metadata file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class MetaDataHandler extends DefaultHandler {\n\n        //$NON-NLS-1$\n        private static final String DTD_PUBLIC_ID = \"-//eclipse-cs//DTD Check Metadata 1.0//EN\";\n\n        //$NON-NLS-1$\n        private static final String DTD_RESOURCE_NAME = \"/com/puppycrawl/tools/checkstyle/checkstyle-metadata_1_0.dtd\";\n\n        /**\n         * the current rule group.\n         */\n        private RuleGroupMetadata mCurrentGroup;\n\n        /**\n         * the current rule meta data.\n         */\n        private RuleMetadata mCurrentRule;\n\n        /**\n         * the current property.\n         */\n        private ConfigPropertyMetadata mCurrentProperty;\n\n        /**\n         * flags if we're inside a description element.\n         */\n        private boolean mInDescriptionElement;\n\n        /**\n         * StringBuffer containing the description.\n         */\n        private StringBuffer mDescription;\n\n        private ResourceBundle mI18NBundle;\n\n        // /**\n        // * @see\n        // org.xml.sax.ext.EntityResolver2#getExternalSubset(java.lang.String,\n        // * java.lang.String)\n        // */\n        // public InputSource getExternalSubset(String name, String baseURI)\n        // throws SAXException,\n        // IOException\n        // {\n        //\n        // InputStream dtdIS =\n        // getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n        // return new InputSource(dtdIS);\n        // }\n        public MetaDataHandler(ResourceBundle i18nBundle) {\n            mI18NBundle = i18nBundle;\n        }\n\n        /*\n         * \n         */\n        public InputSource resolveEntity(String publicId, String systemId) throws SAXException {\n            if (DTD_PUBLIC_ID.equals(publicId)) {\n                final InputStream dtdIS = getClass().getClassLoader().getResourceAsStream(DTD_RESOURCE_NAME);\n                if (dtdIS == null) {\n                    //$NON-NLS-1$\n                    throw new SAXException(\"Unable to load internal dtd \" + DTD_RESOURCE_NAME);\n                }\n                return new InputSource(dtdIS);\n            }\n            // This is a hack to workaround problem with SAX\n            // DefaultHeader.resolveEntity():\n            // sometimes it throws SAX- and IO- exceptions\n            // sometime SAX only :(\n            try {\n                if (false) {\n                    //$NON-NLS-1$\n                    throw new IOException(\"\");\n                }\n                return super.resolveEntity(publicId, systemId);\n            } catch (IOException e) {\n                //$NON-NLS-1$\n                throw new SAXException(\"\" + e, e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,\n         *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            try {\n                if (XMLTags.RULE_GROUP_METADATA_TAG.equals(qName)) {\n                    String groupName = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    groupName = localize(groupName);\n                    mCurrentGroup = getRuleGroupMetadata(groupName);\n                    if (mCurrentGroup == null) {\n                        boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                        int priority = 0;\n                        try {\n                            priority = Integer.parseInt(attributes.getValue(XMLTags.PRIORITY_TAG));\n                        } catch (Exception e) {\n                            CheckstyleLog.log(e);\n                            priority = Integer.MAX_VALUE;\n                        }\n                        // Create the groups\n                        mCurrentGroup = new RuleGroupMetadata(groupName, hidden, priority);\n                        sRuleGroupMetadata.put(groupName, mCurrentGroup);\n                    }\n                } else if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                    // default severity\n                    String defaultSeverity = attributes.getValue(XMLTags.DEFAULT_SEVERITY_TAG);\n                    SeverityLevel severity = defaultSeverity == null || defaultSeverity.trim().length() == 0 ? sDefaultSeverity : SeverityLevel.getInstance(defaultSeverity);\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String internalName = attributes.getValue(XMLTags.INTERNAL_NAME_TAG).trim();\n                    String parentName = attributes.getValue(XMLTags.PARENT_TAG) != null ? attributes.getValue(XMLTags.PARENT_TAG).trim() : null;\n                    boolean hidden = Boolean.valueOf(attributes.getValue(XMLTags.HIDDEN_TAG)).booleanValue();\n                    boolean hasSeverity = !\"false\".equals(//$NON-NLS-1$\n                    attributes.getValue(XMLTags.HAS_SEVERITY_TAG));\n                    //$NON-NLS-1$\n                    boolean deletable = !\"false\".equals(attributes.getValue(XMLTags.DELETABLE_TAG));\n                    boolean isSingleton = Boolean.valueOf(attributes.getValue(XMLTags.IS_SINGLETON_TAG)).booleanValue();\n                    // create rule metadata\n                    mCurrentRule = new RuleMetadata(localize(name), internalName, parentName, severity, hidden, hasSeverity, deletable, isSingleton, mCurrentGroup);\n                    mCurrentGroup.getRuleMetadata().add(mCurrentRule);\n                    // register internal name\n                    sRuleMetadata.put(internalName, mCurrentRule);\n                } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                    ConfigPropertyType type = ConfigPropertyType.getConfigPropertyType(attributes.getValue(XMLTags.DATATYPE_TAG));\n                    String name = attributes.getValue(XMLTags.NAME_TAG).trim();\n                    String defaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_TAG));\n                    String overrideDefaultValue = StringUtils.trim(attributes.getValue(XMLTags.DEFAULT_VALUE_OVERRIDE_TAG));\n                    mCurrentProperty = new ConfigPropertyMetadata(type, name, defaultValue, overrideDefaultValue);\n                    // add to current rule\n                    mCurrentRule.getPropertyMetadata().add(mCurrentProperty);\n                } else if (XMLTags.ALTERNATIVE_NAME_TAG.equals(qName)) {\n                    // register alternative name\n                    sAlternativeNamesMap.put(attributes.getValue(XMLTags.INTERNAL_NAME_TAG), mCurrentRule);\n                    mCurrentRule.addAlternativeName(attributes.getValue(XMLTags.INTERNAL_NAME_TAG));\n                } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                    mInDescriptionElement = true;\n                    mDescription = new StringBuffer();\n                } else if (XMLTags.ENUMERATION_TAG.equals(qName)) {\n                    String optionProvider = attributes.getValue(XMLTags.OPTION_PROVIDER);\n                    if (optionProvider != null) {\n                        Class providerClass = Class.forName(optionProvider);\n                        IOptionProvider provider = (IOptionProvider) providerClass.newInstance();\n                        mCurrentProperty.getPropertyEnumeration().addAll(provider.getOptions());\n                    }\n                } else if (XMLTags.PROPERTY_VALUE_OPTIONS_TAG.equals(qName)) {\n                    mCurrentProperty.getPropertyEnumeration().add(attributes.getValue(XMLTags.VALUE_TAG));\n                } else if (XMLTags.QUCKFIX_TAG.equals(qName)) {\n                    String className = attributes.getValue(XMLTags.CLASSNAME_TAG);\n                    Class quickfixClass = Class.forName(className);\n                    ICheckstyleMarkerResolution quickfix = (ICheckstyleMarkerResolution) quickfixClass.newInstance();\n                    mCurrentRule.addQuickfix(quickfix);\n                }\n            } catch (CheckstylePluginException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (ClassNotFoundException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (InstantiationException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            } catch (IllegalAccessException e) {\n                throw new SAXException(e.getLocalizedMessage(), e);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String,\n         *      java.lang.String, java.lang.String)\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.RULE_METADATA_TAG.equals(qName)) {\n                mCurrentRule = null;\n            } else if (XMLTags.PROPERTY_METADATA_TAG.equals(qName)) {\n                mCurrentProperty = null;\n            } else if (XMLTags.DESCRIPTION_TAG.equals(qName)) {\n                mInDescriptionElement = false;\n                // Set the description to the current element\n                String description = mDescription.toString();\n                if (mCurrentProperty != null) {\n                    mCurrentProperty.setDescription(localize(description));\n                } else if (mCurrentRule != null) {\n                    mCurrentRule.setDescription(localize(description));\n                }\n            }\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)\n         */\n        public void characters(char[] ch, int start, int length) throws SAXException {\n            if (mInDescriptionElement) {\n                mDescription.append(ch, start, length);\n            }\n        }\n\n        /**\n         * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)\n         */\n        public void error(SAXParseException e) throws SAXException {\n            throw e;\n        }\n\n        private String localize(String localizationCandidate) {\n            if (mI18NBundle != null && localizationCandidate.startsWith(\"%\")) {\n                try {\n                    return mI18NBundle.getString(localizationCandidate.substring(1));\n                } catch (MissingResourceException e) {\n                    return localizationCandidate;\n                }\n            }\n            return localizationCandidate;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/MetadataFactory_4Test.java",
		"test_prompt": "// MetadataFactory_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\nimport java.util.TreeMap;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.Module;\nimport com.atlassw.tools.eclipse.checkstyle.config.XMLTags;\nimport com.atlassw.tools.eclipse.checkstyle.quickfixes.ICheckstyleMarkerResolution;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CustomLibrariesClassLoader;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.SeverityLevel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MetadataFactory}.\n* It contains ten unit test cases for the {@link MetadataFactory#getDefaultSeverity()} method.\n*/\nclass MetadataFactory_4Test {"
	},
	{
		"original_code": "// RuleGroupMetadata.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * This class describes a collection of check rules that are logicaly grouped\n * together.\n */\npublic class RuleGroupMetadata {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The name of the group.\n     */\n    private String mGroupName;\n\n    /**\n     * Determines if the group is hidden.\n     */\n    private boolean mIsHidden;\n\n    /**\n     * The priority of the group.\n     */\n    private int mPriority;\n\n    /**\n     * The list of modules belonging to the group.\n     */\n    private List mRuleMetadata = new LinkedList();\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    RuleGroupMetadata(String groupName, boolean hidden, int priority) {\n        mGroupName = groupName;\n        mIsHidden = hidden;\n        mPriority = priority;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns the group's name.\n     *\n     * @return Group name\n     */\n    public final String getGroupName() {\n        return mGroupName;\n    }\n\n    /**\n     * Determine if the module is to be hidden from the users sight.\n     *\n     * @return <code>true</code> if the module is hidden\n     */\n    public boolean isHidden() {\n        return mIsHidden;\n    }\n\n    /**\n     * Returns the priority of the group.\n     *\n     * @return the priority\n     */\n    public int getPriority() {\n        return mPriority;\n    }\n\n    /**\n     * Returns a list of the group's rule metadata.\n     *\n     * @return List of <code>RuleMetadata</code> objects.\n     */\n    public final List getRuleMetadata() {\n        return mRuleMetadata;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/meta/RuleGroupMetadata.java",
		"test_prompt": "// RuleGroupMetadataTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.meta;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RuleGroupMetadata}.\n* It contains ten unit test cases for the {@link RuleGroupMetadata#isHidden()} method.\n*/\nclass RuleGroupMetadataTest {"
	},
	{
		"original_code": "// GlobalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class GlobalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    /**\n     * The default check configuration to be used for unconfigured projects.\n     */\n    private CheckConfigurationWorkingCopy mDefaultCheckConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage global configurations.\n     *\n     * @param checkConfigs the list of global check configurations\n     * @param defaultConfig the defaul check configuration\n     */\n    GlobalCheckConfigurationWorkingSet(List checkConfigs, ICheckConfiguration defaultConfig) {\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n            if (cfg == defaultConfig) {\n                mDefaultCheckConfig = workingCopy;\n            }\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * Returns the default check configuration or <code>null</code> if none is\n     * set.\n     *\n     * @return the default check configuration\n     */\n    public CheckConfigurationWorkingCopy getDefaultCheckConfig() {\n        return mDefaultCheckConfig;\n    }\n\n    /**\n     * Sets the default check configuration.\n     *\n     * @param defaultCheckConfig the default check configuration\n     */\n    public void setDefaultCheckConfig(CheckConfigurationWorkingCopy defaultCheckConfig) {\n        this.mDefaultCheckConfig = defaultCheckConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean used = true;\n        try {\n            used = ProjectConfigurationFactory.isCheckConfigInUse(checkConfig.getSourceCheckConfiguration());\n            if (!used) {\n                mWorkingCopies.remove(checkConfig);\n                // reset default check config\n                if (mDefaultCheckConfig == checkConfig) {\n                    mDefaultCheckConfig = null;\n                }\n                mDeletedConfigurations.add(checkConfig);\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n        return !used;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        updateProjectConfigurations();\n        storeToPersistence();\n        notifyDeletedCheckConfigs();\n        CheckConfigurationFactory.refresh();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (!workingCopies[i].hasConfigurationChanged()) {\n                continue;\n            }\n            List usingProjects = ProjectConfigurationFactory.getProjectsUsingConfig(workingCopies[i]);\n            Iterator it2 = usingProjects.iterator();\n            while (it2.hasNext()) {\n                projects.add(it2.next());\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Updates the project configurations that use the changed check\n     * configurations.\n     *\n     * @param configurations the check configurations\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    private void updateProjectConfigurations() throws CheckstylePluginException {\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy checkConfig = (CheckConfigurationWorkingCopy) it.next();\n            ICheckConfiguration original = checkConfig.getSourceCheckConfiguration();\n            // only if the name of the check config differs from the original\n            if (original != null && original.getName() != null && !checkConfig.getName().equals(original.getName())) {\n                List projects = ProjectConfigurationFactory.getProjectsUsingConfig(checkConfig);\n                Iterator it2 = projects.iterator();\n                while (it2.hasNext()) {\n                    IProject project = (IProject) it2.next();\n                    IProjectConfiguration projectConfig = ProjectConfigurationFactory.getConfiguration(project);\n                    ProjectConfigurationWorkingCopy workingCopy = new ProjectConfigurationWorkingCopy(projectConfig);\n                    List fileSets = workingCopy.getFileSets();\n                    Iterator it3 = fileSets.iterator();\n                    while (it3.hasNext()) {\n                        FileSet fileSet = (FileSet) it3.next();\n                        // Check if the fileset uses the check config\n                        if (original.equals(fileSet.getCheckConfig())) {\n                            // set the new check configuration\n                            fileSet.setCheckConfig(checkConfig);\n                        }\n                    }\n                    // store the project configuration\n                    if (workingCopy.isDirty()) {\n                        workingCopy.store();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Store the check configurations to the persistent state storage.\n     */\n    private void storeToPersistence() throws CheckstylePluginException {\n        BufferedOutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CheckConfigurationFactory.CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            byteOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(byteOut, null, null);\n            writeConfigurations(xmlOut, mWorkingCopies, mDefaultCheckConfig);\n            // write to the file after the serialization was successful\n            // prevents corrupted files in case of error\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorWritingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n\n    /**\n     * Writes to check configurations through the transformer handler by passing\n     * SAX events to it.\n     *\n     * @param handler the transformer handler\n     * @throws SAXException error writing the configurations\n     */\n    private static void writeConfigurations(TransformerHandler handler, List configurations, CheckConfigurationWorkingCopy defaultConfig) throws SAXException {\n        String emptyString = new String();\n        handler.startDocument();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.VERSION_TAG, XMLTags.VERSION_TAG, emptyString, CheckConfigurationFactory.CURRENT_CONFIG_FILE_FORMAT_VERSION);\n        if (defaultConfig != null) {\n            attrs.addAttribute(emptyString, XMLTags.DEFAULT_CHECK_CONFIG_TAG, XMLTags.DEFAULT_CHECK_CONFIG_TAG, emptyString, defaultConfig.getName());\n        }\n        handler.startElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG, attrs);\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration config = (ICheckConfiguration) it.next();\n            // don't store built-in configurations to persistence or local\n            // configurations\n            if (config.getType() instanceof BuiltInConfigurationType || !config.isGlobal()) {\n                continue;\n            }\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, config.getName());\n            attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, config.getLocation());\n            attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, config.getType().getInternalName());\n            if (config.getDescription() != null) {\n                attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, config.getDescription());\n            }\n            handler.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n            // Write resolvable properties\n            Iterator propsIterator = config.getResolvableProperties().iterator();\n            while (propsIterator.hasNext()) {\n                ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n                handler.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n            }\n            // Additional data\n            Iterator addDataIterator = config.getAdditionalData().keySet().iterator();\n            while (addDataIterator.hasNext()) {\n                String key = (String) addDataIterator.next();\n                String value = (String) config.getAdditionalData().get(key);\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n                handler.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n            }\n            handler.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n        }\n        handler.endElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG);\n        handler.endDocument();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/GlobalCheckConfigurationWorkingSet_0Test.java",
		"test_prompt": "// GlobalCheckConfigurationWorkingSet_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GlobalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link GlobalCheckConfigurationWorkingSet#newWorkingCopy(ICheckConfiguration)} method.\n*/\nclass GlobalCheckConfigurationWorkingSet_0Test {"
	},
	{
		"original_code": "// GlobalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class GlobalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    /**\n     * The default check configuration to be used for unconfigured projects.\n     */\n    private CheckConfigurationWorkingCopy mDefaultCheckConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage global configurations.\n     *\n     * @param checkConfigs the list of global check configurations\n     * @param defaultConfig the defaul check configuration\n     */\n    GlobalCheckConfigurationWorkingSet(List checkConfigs, ICheckConfiguration defaultConfig) {\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n            if (cfg == defaultConfig) {\n                mDefaultCheckConfig = workingCopy;\n            }\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * Returns the default check configuration or <code>null</code> if none is\n     * set.\n     *\n     * @return the default check configuration\n     */\n    public CheckConfigurationWorkingCopy getDefaultCheckConfig() {\n        return mDefaultCheckConfig;\n    }\n\n    /**\n     * Sets the default check configuration.\n     *\n     * @param defaultCheckConfig the default check configuration\n     */\n    public void setDefaultCheckConfig(CheckConfigurationWorkingCopy defaultCheckConfig) {\n        this.mDefaultCheckConfig = defaultCheckConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean used = true;\n        try {\n            used = ProjectConfigurationFactory.isCheckConfigInUse(checkConfig.getSourceCheckConfiguration());\n            if (!used) {\n                mWorkingCopies.remove(checkConfig);\n                // reset default check config\n                if (mDefaultCheckConfig == checkConfig) {\n                    mDefaultCheckConfig = null;\n                }\n                mDeletedConfigurations.add(checkConfig);\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n        return !used;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        updateProjectConfigurations();\n        storeToPersistence();\n        notifyDeletedCheckConfigs();\n        CheckConfigurationFactory.refresh();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (!workingCopies[i].hasConfigurationChanged()) {\n                continue;\n            }\n            List usingProjects = ProjectConfigurationFactory.getProjectsUsingConfig(workingCopies[i]);\n            Iterator it2 = usingProjects.iterator();\n            while (it2.hasNext()) {\n                projects.add(it2.next());\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Updates the project configurations that use the changed check\n     * configurations.\n     *\n     * @param configurations the check configurations\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    private void updateProjectConfigurations() throws CheckstylePluginException {\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy checkConfig = (CheckConfigurationWorkingCopy) it.next();\n            ICheckConfiguration original = checkConfig.getSourceCheckConfiguration();\n            // only if the name of the check config differs from the original\n            if (original != null && original.getName() != null && !checkConfig.getName().equals(original.getName())) {\n                List projects = ProjectConfigurationFactory.getProjectsUsingConfig(checkConfig);\n                Iterator it2 = projects.iterator();\n                while (it2.hasNext()) {\n                    IProject project = (IProject) it2.next();\n                    IProjectConfiguration projectConfig = ProjectConfigurationFactory.getConfiguration(project);\n                    ProjectConfigurationWorkingCopy workingCopy = new ProjectConfigurationWorkingCopy(projectConfig);\n                    List fileSets = workingCopy.getFileSets();\n                    Iterator it3 = fileSets.iterator();\n                    while (it3.hasNext()) {\n                        FileSet fileSet = (FileSet) it3.next();\n                        // Check if the fileset uses the check config\n                        if (original.equals(fileSet.getCheckConfig())) {\n                            // set the new check configuration\n                            fileSet.setCheckConfig(checkConfig);\n                        }\n                    }\n                    // store the project configuration\n                    if (workingCopy.isDirty()) {\n                        workingCopy.store();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Store the check configurations to the persistent state storage.\n     */\n    private void storeToPersistence() throws CheckstylePluginException {\n        BufferedOutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CheckConfigurationFactory.CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            byteOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(byteOut, null, null);\n            writeConfigurations(xmlOut, mWorkingCopies, mDefaultCheckConfig);\n            // write to the file after the serialization was successful\n            // prevents corrupted files in case of error\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorWritingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n\n    /**\n     * Writes to check configurations through the transformer handler by passing\n     * SAX events to it.\n     *\n     * @param handler the transformer handler\n     * @throws SAXException error writing the configurations\n     */\n    private static void writeConfigurations(TransformerHandler handler, List configurations, CheckConfigurationWorkingCopy defaultConfig) throws SAXException {\n        String emptyString = new String();\n        handler.startDocument();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.VERSION_TAG, XMLTags.VERSION_TAG, emptyString, CheckConfigurationFactory.CURRENT_CONFIG_FILE_FORMAT_VERSION);\n        if (defaultConfig != null) {\n            attrs.addAttribute(emptyString, XMLTags.DEFAULT_CHECK_CONFIG_TAG, XMLTags.DEFAULT_CHECK_CONFIG_TAG, emptyString, defaultConfig.getName());\n        }\n        handler.startElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG, attrs);\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration config = (ICheckConfiguration) it.next();\n            // don't store built-in configurations to persistence or local\n            // configurations\n            if (config.getType() instanceof BuiltInConfigurationType || !config.isGlobal()) {\n                continue;\n            }\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, config.getName());\n            attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, config.getLocation());\n            attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, config.getType().getInternalName());\n            if (config.getDescription() != null) {\n                attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, config.getDescription());\n            }\n            handler.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n            // Write resolvable properties\n            Iterator propsIterator = config.getResolvableProperties().iterator();\n            while (propsIterator.hasNext()) {\n                ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n                handler.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n            }\n            // Additional data\n            Iterator addDataIterator = config.getAdditionalData().keySet().iterator();\n            while (addDataIterator.hasNext()) {\n                String key = (String) addDataIterator.next();\n                String value = (String) config.getAdditionalData().get(key);\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n                handler.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n            }\n            handler.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n        }\n        handler.endElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG);\n        handler.endDocument();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/GlobalCheckConfigurationWorkingSet_1Test.java",
		"test_prompt": "// GlobalCheckConfigurationWorkingSet_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GlobalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link GlobalCheckConfigurationWorkingSet#newWorkingCopy(IConfigurationType)} method.\n*/\nclass GlobalCheckConfigurationWorkingSet_1Test {"
	},
	{
		"original_code": "// GlobalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class GlobalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    /**\n     * The default check configuration to be used for unconfigured projects.\n     */\n    private CheckConfigurationWorkingCopy mDefaultCheckConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage global configurations.\n     *\n     * @param checkConfigs the list of global check configurations\n     * @param defaultConfig the defaul check configuration\n     */\n    GlobalCheckConfigurationWorkingSet(List checkConfigs, ICheckConfiguration defaultConfig) {\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n            if (cfg == defaultConfig) {\n                mDefaultCheckConfig = workingCopy;\n            }\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * Returns the default check configuration or <code>null</code> if none is\n     * set.\n     *\n     * @return the default check configuration\n     */\n    public CheckConfigurationWorkingCopy getDefaultCheckConfig() {\n        return mDefaultCheckConfig;\n    }\n\n    /**\n     * Sets the default check configuration.\n     *\n     * @param defaultCheckConfig the default check configuration\n     */\n    public void setDefaultCheckConfig(CheckConfigurationWorkingCopy defaultCheckConfig) {\n        this.mDefaultCheckConfig = defaultCheckConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean used = true;\n        try {\n            used = ProjectConfigurationFactory.isCheckConfigInUse(checkConfig.getSourceCheckConfiguration());\n            if (!used) {\n                mWorkingCopies.remove(checkConfig);\n                // reset default check config\n                if (mDefaultCheckConfig == checkConfig) {\n                    mDefaultCheckConfig = null;\n                }\n                mDeletedConfigurations.add(checkConfig);\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n        return !used;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        updateProjectConfigurations();\n        storeToPersistence();\n        notifyDeletedCheckConfigs();\n        CheckConfigurationFactory.refresh();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (!workingCopies[i].hasConfigurationChanged()) {\n                continue;\n            }\n            List usingProjects = ProjectConfigurationFactory.getProjectsUsingConfig(workingCopies[i]);\n            Iterator it2 = usingProjects.iterator();\n            while (it2.hasNext()) {\n                projects.add(it2.next());\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Updates the project configurations that use the changed check\n     * configurations.\n     *\n     * @param configurations the check configurations\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    private void updateProjectConfigurations() throws CheckstylePluginException {\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy checkConfig = (CheckConfigurationWorkingCopy) it.next();\n            ICheckConfiguration original = checkConfig.getSourceCheckConfiguration();\n            // only if the name of the check config differs from the original\n            if (original != null && original.getName() != null && !checkConfig.getName().equals(original.getName())) {\n                List projects = ProjectConfigurationFactory.getProjectsUsingConfig(checkConfig);\n                Iterator it2 = projects.iterator();\n                while (it2.hasNext()) {\n                    IProject project = (IProject) it2.next();\n                    IProjectConfiguration projectConfig = ProjectConfigurationFactory.getConfiguration(project);\n                    ProjectConfigurationWorkingCopy workingCopy = new ProjectConfigurationWorkingCopy(projectConfig);\n                    List fileSets = workingCopy.getFileSets();\n                    Iterator it3 = fileSets.iterator();\n                    while (it3.hasNext()) {\n                        FileSet fileSet = (FileSet) it3.next();\n                        // Check if the fileset uses the check config\n                        if (original.equals(fileSet.getCheckConfig())) {\n                            // set the new check configuration\n                            fileSet.setCheckConfig(checkConfig);\n                        }\n                    }\n                    // store the project configuration\n                    if (workingCopy.isDirty()) {\n                        workingCopy.store();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Store the check configurations to the persistent state storage.\n     */\n    private void storeToPersistence() throws CheckstylePluginException {\n        BufferedOutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CheckConfigurationFactory.CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            byteOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(byteOut, null, null);\n            writeConfigurations(xmlOut, mWorkingCopies, mDefaultCheckConfig);\n            // write to the file after the serialization was successful\n            // prevents corrupted files in case of error\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorWritingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n\n    /**\n     * Writes to check configurations through the transformer handler by passing\n     * SAX events to it.\n     *\n     * @param handler the transformer handler\n     * @throws SAXException error writing the configurations\n     */\n    private static void writeConfigurations(TransformerHandler handler, List configurations, CheckConfigurationWorkingCopy defaultConfig) throws SAXException {\n        String emptyString = new String();\n        handler.startDocument();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.VERSION_TAG, XMLTags.VERSION_TAG, emptyString, CheckConfigurationFactory.CURRENT_CONFIG_FILE_FORMAT_VERSION);\n        if (defaultConfig != null) {\n            attrs.addAttribute(emptyString, XMLTags.DEFAULT_CHECK_CONFIG_TAG, XMLTags.DEFAULT_CHECK_CONFIG_TAG, emptyString, defaultConfig.getName());\n        }\n        handler.startElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG, attrs);\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration config = (ICheckConfiguration) it.next();\n            // don't store built-in configurations to persistence or local\n            // configurations\n            if (config.getType() instanceof BuiltInConfigurationType || !config.isGlobal()) {\n                continue;\n            }\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, config.getName());\n            attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, config.getLocation());\n            attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, config.getType().getInternalName());\n            if (config.getDescription() != null) {\n                attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, config.getDescription());\n            }\n            handler.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n            // Write resolvable properties\n            Iterator propsIterator = config.getResolvableProperties().iterator();\n            while (propsIterator.hasNext()) {\n                ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n                handler.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n            }\n            // Additional data\n            Iterator addDataIterator = config.getAdditionalData().keySet().iterator();\n            while (addDataIterator.hasNext()) {\n                String key = (String) addDataIterator.next();\n                String value = (String) config.getAdditionalData().get(key);\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n                handler.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n            }\n            handler.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n        }\n        handler.endElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG);\n        handler.endDocument();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/GlobalCheckConfigurationWorkingSet_2Test.java",
		"test_prompt": "// GlobalCheckConfigurationWorkingSet_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GlobalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link GlobalCheckConfigurationWorkingSet#removeCheckConfiguration(CheckConfigurationWorkingCopy)} method.\n*/\nclass GlobalCheckConfigurationWorkingSet_2Test {"
	},
	{
		"original_code": "// GlobalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class GlobalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    /**\n     * The default check configuration to be used for unconfigured projects.\n     */\n    private CheckConfigurationWorkingCopy mDefaultCheckConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage global configurations.\n     *\n     * @param checkConfigs the list of global check configurations\n     * @param defaultConfig the defaul check configuration\n     */\n    GlobalCheckConfigurationWorkingSet(List checkConfigs, ICheckConfiguration defaultConfig) {\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n            if (cfg == defaultConfig) {\n                mDefaultCheckConfig = workingCopy;\n            }\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * Returns the default check configuration or <code>null</code> if none is\n     * set.\n     *\n     * @return the default check configuration\n     */\n    public CheckConfigurationWorkingCopy getDefaultCheckConfig() {\n        return mDefaultCheckConfig;\n    }\n\n    /**\n     * Sets the default check configuration.\n     *\n     * @param defaultCheckConfig the default check configuration\n     */\n    public void setDefaultCheckConfig(CheckConfigurationWorkingCopy defaultCheckConfig) {\n        this.mDefaultCheckConfig = defaultCheckConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean used = true;\n        try {\n            used = ProjectConfigurationFactory.isCheckConfigInUse(checkConfig.getSourceCheckConfiguration());\n            if (!used) {\n                mWorkingCopies.remove(checkConfig);\n                // reset default check config\n                if (mDefaultCheckConfig == checkConfig) {\n                    mDefaultCheckConfig = null;\n                }\n                mDeletedConfigurations.add(checkConfig);\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n        return !used;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        updateProjectConfigurations();\n        storeToPersistence();\n        notifyDeletedCheckConfigs();\n        CheckConfigurationFactory.refresh();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (!workingCopies[i].hasConfigurationChanged()) {\n                continue;\n            }\n            List usingProjects = ProjectConfigurationFactory.getProjectsUsingConfig(workingCopies[i]);\n            Iterator it2 = usingProjects.iterator();\n            while (it2.hasNext()) {\n                projects.add(it2.next());\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Updates the project configurations that use the changed check\n     * configurations.\n     *\n     * @param configurations the check configurations\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    private void updateProjectConfigurations() throws CheckstylePluginException {\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy checkConfig = (CheckConfigurationWorkingCopy) it.next();\n            ICheckConfiguration original = checkConfig.getSourceCheckConfiguration();\n            // only if the name of the check config differs from the original\n            if (original != null && original.getName() != null && !checkConfig.getName().equals(original.getName())) {\n                List projects = ProjectConfigurationFactory.getProjectsUsingConfig(checkConfig);\n                Iterator it2 = projects.iterator();\n                while (it2.hasNext()) {\n                    IProject project = (IProject) it2.next();\n                    IProjectConfiguration projectConfig = ProjectConfigurationFactory.getConfiguration(project);\n                    ProjectConfigurationWorkingCopy workingCopy = new ProjectConfigurationWorkingCopy(projectConfig);\n                    List fileSets = workingCopy.getFileSets();\n                    Iterator it3 = fileSets.iterator();\n                    while (it3.hasNext()) {\n                        FileSet fileSet = (FileSet) it3.next();\n                        // Check if the fileset uses the check config\n                        if (original.equals(fileSet.getCheckConfig())) {\n                            // set the new check configuration\n                            fileSet.setCheckConfig(checkConfig);\n                        }\n                    }\n                    // store the project configuration\n                    if (workingCopy.isDirty()) {\n                        workingCopy.store();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Store the check configurations to the persistent state storage.\n     */\n    private void storeToPersistence() throws CheckstylePluginException {\n        BufferedOutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CheckConfigurationFactory.CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            byteOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(byteOut, null, null);\n            writeConfigurations(xmlOut, mWorkingCopies, mDefaultCheckConfig);\n            // write to the file after the serialization was successful\n            // prevents corrupted files in case of error\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorWritingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n\n    /**\n     * Writes to check configurations through the transformer handler by passing\n     * SAX events to it.\n     *\n     * @param handler the transformer handler\n     * @throws SAXException error writing the configurations\n     */\n    private static void writeConfigurations(TransformerHandler handler, List configurations, CheckConfigurationWorkingCopy defaultConfig) throws SAXException {\n        String emptyString = new String();\n        handler.startDocument();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.VERSION_TAG, XMLTags.VERSION_TAG, emptyString, CheckConfigurationFactory.CURRENT_CONFIG_FILE_FORMAT_VERSION);\n        if (defaultConfig != null) {\n            attrs.addAttribute(emptyString, XMLTags.DEFAULT_CHECK_CONFIG_TAG, XMLTags.DEFAULT_CHECK_CONFIG_TAG, emptyString, defaultConfig.getName());\n        }\n        handler.startElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG, attrs);\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration config = (ICheckConfiguration) it.next();\n            // don't store built-in configurations to persistence or local\n            // configurations\n            if (config.getType() instanceof BuiltInConfigurationType || !config.isGlobal()) {\n                continue;\n            }\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, config.getName());\n            attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, config.getLocation());\n            attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, config.getType().getInternalName());\n            if (config.getDescription() != null) {\n                attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, config.getDescription());\n            }\n            handler.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n            // Write resolvable properties\n            Iterator propsIterator = config.getResolvableProperties().iterator();\n            while (propsIterator.hasNext()) {\n                ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n                handler.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n            }\n            // Additional data\n            Iterator addDataIterator = config.getAdditionalData().keySet().iterator();\n            while (addDataIterator.hasNext()) {\n                String key = (String) addDataIterator.next();\n                String value = (String) config.getAdditionalData().get(key);\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n                handler.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n            }\n            handler.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n        }\n        handler.endElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG);\n        handler.endDocument();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/GlobalCheckConfigurationWorkingSet_3Test.java",
		"test_prompt": "// GlobalCheckConfigurationWorkingSet_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GlobalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link GlobalCheckConfigurationWorkingSet#isDirty()} method.\n*/\nclass GlobalCheckConfigurationWorkingSet_3Test {"
	},
	{
		"original_code": "// GlobalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class GlobalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    /**\n     * The default check configuration to be used for unconfigured projects.\n     */\n    private CheckConfigurationWorkingCopy mDefaultCheckConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage global configurations.\n     *\n     * @param checkConfigs the list of global check configurations\n     * @param defaultConfig the defaul check configuration\n     */\n    GlobalCheckConfigurationWorkingSet(List checkConfigs, ICheckConfiguration defaultConfig) {\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n            if (cfg == defaultConfig) {\n                mDefaultCheckConfig = workingCopy;\n            }\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, true);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * Returns the default check configuration or <code>null</code> if none is\n     * set.\n     *\n     * @return the default check configuration\n     */\n    public CheckConfigurationWorkingCopy getDefaultCheckConfig() {\n        return mDefaultCheckConfig;\n    }\n\n    /**\n     * Sets the default check configuration.\n     *\n     * @param defaultCheckConfig the default check configuration\n     */\n    public void setDefaultCheckConfig(CheckConfigurationWorkingCopy defaultCheckConfig) {\n        this.mDefaultCheckConfig = defaultCheckConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean used = true;\n        try {\n            used = ProjectConfigurationFactory.isCheckConfigInUse(checkConfig.getSourceCheckConfiguration());\n            if (!used) {\n                mWorkingCopies.remove(checkConfig);\n                // reset default check config\n                if (mDefaultCheckConfig == checkConfig) {\n                    mDefaultCheckConfig = null;\n                }\n                mDeletedConfigurations.add(checkConfig);\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n        return !used;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        updateProjectConfigurations();\n        storeToPersistence();\n        notifyDeletedCheckConfigs();\n        CheckConfigurationFactory.refresh();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (!workingCopies[i].hasConfigurationChanged()) {\n                continue;\n            }\n            List usingProjects = ProjectConfigurationFactory.getProjectsUsingConfig(workingCopies[i]);\n            Iterator it2 = usingProjects.iterator();\n            while (it2.hasNext()) {\n                projects.add(it2.next());\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Updates the project configurations that use the changed check\n     * configurations.\n     *\n     * @param configurations the check configurations\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    private void updateProjectConfigurations() throws CheckstylePluginException {\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy checkConfig = (CheckConfigurationWorkingCopy) it.next();\n            ICheckConfiguration original = checkConfig.getSourceCheckConfiguration();\n            // only if the name of the check config differs from the original\n            if (original != null && original.getName() != null && !checkConfig.getName().equals(original.getName())) {\n                List projects = ProjectConfigurationFactory.getProjectsUsingConfig(checkConfig);\n                Iterator it2 = projects.iterator();\n                while (it2.hasNext()) {\n                    IProject project = (IProject) it2.next();\n                    IProjectConfiguration projectConfig = ProjectConfigurationFactory.getConfiguration(project);\n                    ProjectConfigurationWorkingCopy workingCopy = new ProjectConfigurationWorkingCopy(projectConfig);\n                    List fileSets = workingCopy.getFileSets();\n                    Iterator it3 = fileSets.iterator();\n                    while (it3.hasNext()) {\n                        FileSet fileSet = (FileSet) it3.next();\n                        // Check if the fileset uses the check config\n                        if (original.equals(fileSet.getCheckConfig())) {\n                            // set the new check configuration\n                            fileSet.setCheckConfig(checkConfig);\n                        }\n                    }\n                    // store the project configuration\n                    if (workingCopy.isDirty()) {\n                        workingCopy.store();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Store the check configurations to the persistent state storage.\n     */\n    private void storeToPersistence() throws CheckstylePluginException {\n        BufferedOutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CheckConfigurationFactory.CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            byteOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(byteOut, null, null);\n            writeConfigurations(xmlOut, mWorkingCopies, mDefaultCheckConfig);\n            // write to the file after the serialization was successful\n            // prevents corrupted files in case of error\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorWritingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n\n    /**\n     * Writes to check configurations through the transformer handler by passing\n     * SAX events to it.\n     *\n     * @param handler the transformer handler\n     * @throws SAXException error writing the configurations\n     */\n    private static void writeConfigurations(TransformerHandler handler, List configurations, CheckConfigurationWorkingCopy defaultConfig) throws SAXException {\n        String emptyString = new String();\n        handler.startDocument();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.VERSION_TAG, XMLTags.VERSION_TAG, emptyString, CheckConfigurationFactory.CURRENT_CONFIG_FILE_FORMAT_VERSION);\n        if (defaultConfig != null) {\n            attrs.addAttribute(emptyString, XMLTags.DEFAULT_CHECK_CONFIG_TAG, XMLTags.DEFAULT_CHECK_CONFIG_TAG, emptyString, defaultConfig.getName());\n        }\n        handler.startElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG, attrs);\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration config = (ICheckConfiguration) it.next();\n            // don't store built-in configurations to persistence or local\n            // configurations\n            if (config.getType() instanceof BuiltInConfigurationType || !config.isGlobal()) {\n                continue;\n            }\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, config.getName());\n            attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, config.getLocation());\n            attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, config.getType().getInternalName());\n            if (config.getDescription() != null) {\n                attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, config.getDescription());\n            }\n            handler.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n            // Write resolvable properties\n            Iterator propsIterator = config.getResolvableProperties().iterator();\n            while (propsIterator.hasNext()) {\n                ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n                handler.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n            }\n            // Additional data\n            Iterator addDataIterator = config.getAdditionalData().keySet().iterator();\n            while (addDataIterator.hasNext()) {\n                String key = (String) addDataIterator.next();\n                String value = (String) config.getAdditionalData().get(key);\n                attrs = new AttributesImpl();\n                attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n                attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n                handler.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n                handler.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n            }\n            handler.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n        }\n        handler.endElement(emptyString, XMLTags.CHECKSTYLE_ROOT_TAG, XMLTags.CHECKSTYLE_ROOT_TAG);\n        handler.endDocument();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/GlobalCheckConfigurationWorkingSet_4Test.java",
		"test_prompt": "// GlobalCheckConfigurationWorkingSet_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.IPath;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GlobalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link GlobalCheckConfigurationWorkingSet#isNameCollision(CheckConfigurationWorkingCopy)} method.\n*/\nclass GlobalCheckConfigurationWorkingSet_4Test {"
	},
	{
		"original_code": "// ResolvableProperty.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\n\n/**\n * Represents a configuration property who's value must be resolved.\n *\n * @author David Schneider\n * @author Lars K�dderitzsch\n */\npublic class ResolvableProperty implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The name of the property.\n     */\n    private String mPropertyName;\n\n    /**\n     * The property value.\n     */\n    private String mValue;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates a resolvable property.\n     *\n     * @param propertyName the name of the property\n     * @param value the value of the property\n     */\n    public ResolvableProperty(String propertyName, String value) {\n        setPropertyName(propertyName);\n        setValue(value);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * @return The value of the property.\n     */\n    public String getValue() {\n        return mValue;\n    }\n\n    /**\n     * @return The property's name.\n     */\n    public String getPropertyName() {\n        return mPropertyName;\n    }\n\n    /**\n     * @param string Value for the property.\n     */\n    public void setValue(String string) {\n        mValue = string;\n    }\n\n    /**\n     * @param string The property's name.\n     */\n    public void setPropertyName(String string) {\n        mPropertyName = string;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ResolvableProperty)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ResolvableProperty rhs = (ResolvableProperty) obj;\n        return new EqualsBuilder().append(mPropertyName, rhs.mPropertyName).append(mValue, rhs.mValue).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(32234343, 1000003).append(mPropertyName).append(mValue).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            ResolvableProperty clone = (ResolvableProperty) super.clone();\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/ResolvableProperty_0Test.java",
		"test_prompt": "// ResolvableProperty_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResolvableProperty}.\n* It contains ten unit test cases for the {@link ResolvableProperty#equals(Object)} method.\n*/\nclass ResolvableProperty_0Test {"
	},
	{
		"original_code": "// ResolvableProperty.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\n\n/**\n * Represents a configuration property who's value must be resolved.\n *\n * @author David Schneider\n * @author Lars K�dderitzsch\n */\npublic class ResolvableProperty implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The name of the property.\n     */\n    private String mPropertyName;\n\n    /**\n     * The property value.\n     */\n    private String mValue;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates a resolvable property.\n     *\n     * @param propertyName the name of the property\n     * @param value the value of the property\n     */\n    public ResolvableProperty(String propertyName, String value) {\n        setPropertyName(propertyName);\n        setValue(value);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * @return The value of the property.\n     */\n    public String getValue() {\n        return mValue;\n    }\n\n    /**\n     * @return The property's name.\n     */\n    public String getPropertyName() {\n        return mPropertyName;\n    }\n\n    /**\n     * @param string Value for the property.\n     */\n    public void setValue(String string) {\n        mValue = string;\n    }\n\n    /**\n     * @param string The property's name.\n     */\n    public void setPropertyName(String string) {\n        mPropertyName = string;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ResolvableProperty)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ResolvableProperty rhs = (ResolvableProperty) obj;\n        return new EqualsBuilder().append(mPropertyName, rhs.mPropertyName).append(mValue, rhs.mValue).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(32234343, 1000003).append(mPropertyName).append(mValue).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            ResolvableProperty clone = (ResolvableProperty) super.clone();\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/ResolvableProperty_1Test.java",
		"test_prompt": "// ResolvableProperty_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResolvableProperty}.\n* It contains ten unit test cases for the {@link ResolvableProperty#hashCode()} method.\n*/\nclass ResolvableProperty_1Test {"
	},
	{
		"original_code": "// ResolvableProperty.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\n\n/**\n * Represents a configuration property who's value must be resolved.\n *\n * @author David Schneider\n * @author Lars K�dderitzsch\n */\npublic class ResolvableProperty implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The name of the property.\n     */\n    private String mPropertyName;\n\n    /**\n     * The property value.\n     */\n    private String mValue;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates a resolvable property.\n     *\n     * @param propertyName the name of the property\n     * @param value the value of the property\n     */\n    public ResolvableProperty(String propertyName, String value) {\n        setPropertyName(propertyName);\n        setValue(value);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * @return The value of the property.\n     */\n    public String getValue() {\n        return mValue;\n    }\n\n    /**\n     * @return The property's name.\n     */\n    public String getPropertyName() {\n        return mPropertyName;\n    }\n\n    /**\n     * @param string Value for the property.\n     */\n    public void setValue(String string) {\n        mValue = string;\n    }\n\n    /**\n     * @param string The property's name.\n     */\n    public void setPropertyName(String string) {\n        mPropertyName = string;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ResolvableProperty)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ResolvableProperty rhs = (ResolvableProperty) obj;\n        return new EqualsBuilder().append(mPropertyName, rhs.mPropertyName).append(mValue, rhs.mValue).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(32234343, 1000003).append(mPropertyName).append(mValue).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            ResolvableProperty clone = (ResolvableProperty) super.clone();\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/ResolvableProperty_2Test.java",
		"test_prompt": "// ResolvableProperty_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResolvableProperty}.\n* It contains ten unit test cases for the {@link ResolvableProperty#clone()} method.\n*/\nclass ResolvableProperty_2Test {"
	},
	{
		"original_code": "// CheckConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Base implementation of a check configuration. Leaves the specific tasks to\n * the concrete subclasses.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfiguration implements ICheckConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * the displayable name of the configuration.\n     */\n    private String mName;\n\n    /**\n     * the location of the checkstyle configuration file.\n     */\n    private String mLocation;\n\n    /**\n     * the description of the configuration.\n     */\n    private String mDescription;\n\n    /**\n     * the configuration type.\n     */\n    private IConfigurationType mConfigType;\n\n    /**\n     * flags if the configuration is global.\n     */\n    private boolean mIsGlobal;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties;\n\n    /**\n     * Map containing additional data for this check configuration.\n     */\n    private Map mAdditionalData;\n\n    /**\n     * Cached data of the Checkstyle configuration file.\n     */\n    private CheckstyleConfigurationFile mCheckstyleConfigurationFile;\n\n    /**\n     * Time stamp when the cached configuration file data expires.\n     */\n    private long mExpirationTime = 0;\n\n    //\n    // methods\n    //\n    /**\n     * Creates a check configuration instance.\n     *\n     * @param name the name of the check configuration\n     * @param location the location of the check configuration\n     * @param description the description of the check configuration\n     * @param type the check configuration type\n     * @param global determines if the check configuration is a global\n     *            configuration\n     * @param properties the list of properties configured for this check\n     *            configuration\n     * @param additionalData a map of additional data for this configuration\n     */\n    public CheckConfiguration(String name, String location, String description, IConfigurationType type, boolean global, List properties, Map additionalData) {\n        mName = name;\n        mLocation = location;\n        mDescription = description;\n        mConfigType = type;\n        mIsGlobal = global;\n        if (additionalData != null) {\n            mAdditionalData = Collections.unmodifiableMap(additionalData);\n        } else {\n            mAdditionalData = Collections.unmodifiableMap(new HashMap());\n        }\n        mProperties = properties != null ? Collections.unmodifiableList(properties) : Collections.unmodifiableList(new ArrayList());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mLocation;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return mConfigType;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return mConfigType.isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return mConfigType.isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mIsGlobal;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        long currentTime = System.currentTimeMillis();\n        if (mCheckstyleConfigurationFile == null || currentTime > mExpirationTime) {\n            mCheckstyleConfigurationFile = getType().getCheckstyleConfiguration(this);\n            // 1 hour\n            mExpirationTime = currentTime + 1000 * 60 * 60;\n        }\n        return mCheckstyleConfigurationFile;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfiguration_0Test.java",
		"test_prompt": "// CheckConfiguration_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfiguration}.\n* It contains ten unit test cases for the {@link CheckConfiguration#isEditable()} method.\n*/\nclass CheckConfiguration_0Test {"
	},
	{
		"original_code": "// CheckConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Base implementation of a check configuration. Leaves the specific tasks to\n * the concrete subclasses.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfiguration implements ICheckConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * the displayable name of the configuration.\n     */\n    private String mName;\n\n    /**\n     * the location of the checkstyle configuration file.\n     */\n    private String mLocation;\n\n    /**\n     * the description of the configuration.\n     */\n    private String mDescription;\n\n    /**\n     * the configuration type.\n     */\n    private IConfigurationType mConfigType;\n\n    /**\n     * flags if the configuration is global.\n     */\n    private boolean mIsGlobal;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties;\n\n    /**\n     * Map containing additional data for this check configuration.\n     */\n    private Map mAdditionalData;\n\n    /**\n     * Cached data of the Checkstyle configuration file.\n     */\n    private CheckstyleConfigurationFile mCheckstyleConfigurationFile;\n\n    /**\n     * Time stamp when the cached configuration file data expires.\n     */\n    private long mExpirationTime = 0;\n\n    //\n    // methods\n    //\n    /**\n     * Creates a check configuration instance.\n     *\n     * @param name the name of the check configuration\n     * @param location the location of the check configuration\n     * @param description the description of the check configuration\n     * @param type the check configuration type\n     * @param global determines if the check configuration is a global\n     *            configuration\n     * @param properties the list of properties configured for this check\n     *            configuration\n     * @param additionalData a map of additional data for this configuration\n     */\n    public CheckConfiguration(String name, String location, String description, IConfigurationType type, boolean global, List properties, Map additionalData) {\n        mName = name;\n        mLocation = location;\n        mDescription = description;\n        mConfigType = type;\n        mIsGlobal = global;\n        if (additionalData != null) {\n            mAdditionalData = Collections.unmodifiableMap(additionalData);\n        } else {\n            mAdditionalData = Collections.unmodifiableMap(new HashMap());\n        }\n        mProperties = properties != null ? Collections.unmodifiableList(properties) : Collections.unmodifiableList(new ArrayList());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mLocation;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return mConfigType;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return mConfigType.isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return mConfigType.isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mIsGlobal;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        long currentTime = System.currentTimeMillis();\n        if (mCheckstyleConfigurationFile == null || currentTime > mExpirationTime) {\n            mCheckstyleConfigurationFile = getType().getCheckstyleConfiguration(this);\n            // 1 hour\n            mExpirationTime = currentTime + 1000 * 60 * 60;\n        }\n        return mCheckstyleConfigurationFile;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfiguration_1Test.java",
		"test_prompt": "// CheckConfiguration_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfiguration}.\n* It contains ten unit test cases for the {@link CheckConfiguration#isConfigurable()} method.\n*/\nclass CheckConfiguration_1Test {"
	},
	{
		"original_code": "// CheckConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Base implementation of a check configuration. Leaves the specific tasks to\n * the concrete subclasses.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfiguration implements ICheckConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * the displayable name of the configuration.\n     */\n    private String mName;\n\n    /**\n     * the location of the checkstyle configuration file.\n     */\n    private String mLocation;\n\n    /**\n     * the description of the configuration.\n     */\n    private String mDescription;\n\n    /**\n     * the configuration type.\n     */\n    private IConfigurationType mConfigType;\n\n    /**\n     * flags if the configuration is global.\n     */\n    private boolean mIsGlobal;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties;\n\n    /**\n     * Map containing additional data for this check configuration.\n     */\n    private Map mAdditionalData;\n\n    /**\n     * Cached data of the Checkstyle configuration file.\n     */\n    private CheckstyleConfigurationFile mCheckstyleConfigurationFile;\n\n    /**\n     * Time stamp when the cached configuration file data expires.\n     */\n    private long mExpirationTime = 0;\n\n    //\n    // methods\n    //\n    /**\n     * Creates a check configuration instance.\n     *\n     * @param name the name of the check configuration\n     * @param location the location of the check configuration\n     * @param description the description of the check configuration\n     * @param type the check configuration type\n     * @param global determines if the check configuration is a global\n     *            configuration\n     * @param properties the list of properties configured for this check\n     *            configuration\n     * @param additionalData a map of additional data for this configuration\n     */\n    public CheckConfiguration(String name, String location, String description, IConfigurationType type, boolean global, List properties, Map additionalData) {\n        mName = name;\n        mLocation = location;\n        mDescription = description;\n        mConfigType = type;\n        mIsGlobal = global;\n        if (additionalData != null) {\n            mAdditionalData = Collections.unmodifiableMap(additionalData);\n        } else {\n            mAdditionalData = Collections.unmodifiableMap(new HashMap());\n        }\n        mProperties = properties != null ? Collections.unmodifiableList(properties) : Collections.unmodifiableList(new ArrayList());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mLocation;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return mConfigType;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return mConfigType.isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return mConfigType.isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mIsGlobal;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        long currentTime = System.currentTimeMillis();\n        if (mCheckstyleConfigurationFile == null || currentTime > mExpirationTime) {\n            mCheckstyleConfigurationFile = getType().getCheckstyleConfiguration(this);\n            // 1 hour\n            mExpirationTime = currentTime + 1000 * 60 * 60;\n        }\n        return mCheckstyleConfigurationFile;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfiguration_2Test.java",
		"test_prompt": "// CheckConfiguration_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfiguration}.\n* It contains ten unit test cases for the {@link CheckConfiguration#isGlobal()} method.\n*/\nclass CheckConfiguration_2Test {"
	},
	{
		"original_code": "// CheckConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Base implementation of a check configuration. Leaves the specific tasks to\n * the concrete subclasses.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfiguration implements ICheckConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * the displayable name of the configuration.\n     */\n    private String mName;\n\n    /**\n     * the location of the checkstyle configuration file.\n     */\n    private String mLocation;\n\n    /**\n     * the description of the configuration.\n     */\n    private String mDescription;\n\n    /**\n     * the configuration type.\n     */\n    private IConfigurationType mConfigType;\n\n    /**\n     * flags if the configuration is global.\n     */\n    private boolean mIsGlobal;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties;\n\n    /**\n     * Map containing additional data for this check configuration.\n     */\n    private Map mAdditionalData;\n\n    /**\n     * Cached data of the Checkstyle configuration file.\n     */\n    private CheckstyleConfigurationFile mCheckstyleConfigurationFile;\n\n    /**\n     * Time stamp when the cached configuration file data expires.\n     */\n    private long mExpirationTime = 0;\n\n    //\n    // methods\n    //\n    /**\n     * Creates a check configuration instance.\n     *\n     * @param name the name of the check configuration\n     * @param location the location of the check configuration\n     * @param description the description of the check configuration\n     * @param type the check configuration type\n     * @param global determines if the check configuration is a global\n     *            configuration\n     * @param properties the list of properties configured for this check\n     *            configuration\n     * @param additionalData a map of additional data for this configuration\n     */\n    public CheckConfiguration(String name, String location, String description, IConfigurationType type, boolean global, List properties, Map additionalData) {\n        mName = name;\n        mLocation = location;\n        mDescription = description;\n        mConfigType = type;\n        mIsGlobal = global;\n        if (additionalData != null) {\n            mAdditionalData = Collections.unmodifiableMap(additionalData);\n        } else {\n            mAdditionalData = Collections.unmodifiableMap(new HashMap());\n        }\n        mProperties = properties != null ? Collections.unmodifiableList(properties) : Collections.unmodifiableList(new ArrayList());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mLocation;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return mConfigType;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return mConfigType.isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return mConfigType.isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mIsGlobal;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        long currentTime = System.currentTimeMillis();\n        if (mCheckstyleConfigurationFile == null || currentTime > mExpirationTime) {\n            mCheckstyleConfigurationFile = getType().getCheckstyleConfiguration(this);\n            // 1 hour\n            mExpirationTime = currentTime + 1000 * 60 * 60;\n        }\n        return mCheckstyleConfigurationFile;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfiguration_3Test.java",
		"test_prompt": "// CheckConfiguration_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfiguration}.\n* It contains ten unit test cases for the {@link CheckConfiguration#equals(Object)} method.\n*/\nclass CheckConfiguration_3Test {"
	},
	{
		"original_code": "// CheckConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Base implementation of a check configuration. Leaves the specific tasks to\n * the concrete subclasses.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfiguration implements ICheckConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * the displayable name of the configuration.\n     */\n    private String mName;\n\n    /**\n     * the location of the checkstyle configuration file.\n     */\n    private String mLocation;\n\n    /**\n     * the description of the configuration.\n     */\n    private String mDescription;\n\n    /**\n     * the configuration type.\n     */\n    private IConfigurationType mConfigType;\n\n    /**\n     * flags if the configuration is global.\n     */\n    private boolean mIsGlobal;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties;\n\n    /**\n     * Map containing additional data for this check configuration.\n     */\n    private Map mAdditionalData;\n\n    /**\n     * Cached data of the Checkstyle configuration file.\n     */\n    private CheckstyleConfigurationFile mCheckstyleConfigurationFile;\n\n    /**\n     * Time stamp when the cached configuration file data expires.\n     */\n    private long mExpirationTime = 0;\n\n    //\n    // methods\n    //\n    /**\n     * Creates a check configuration instance.\n     *\n     * @param name the name of the check configuration\n     * @param location the location of the check configuration\n     * @param description the description of the check configuration\n     * @param type the check configuration type\n     * @param global determines if the check configuration is a global\n     *            configuration\n     * @param properties the list of properties configured for this check\n     *            configuration\n     * @param additionalData a map of additional data for this configuration\n     */\n    public CheckConfiguration(String name, String location, String description, IConfigurationType type, boolean global, List properties, Map additionalData) {\n        mName = name;\n        mLocation = location;\n        mDescription = description;\n        mConfigType = type;\n        mIsGlobal = global;\n        if (additionalData != null) {\n            mAdditionalData = Collections.unmodifiableMap(additionalData);\n        } else {\n            mAdditionalData = Collections.unmodifiableMap(new HashMap());\n        }\n        mProperties = properties != null ? Collections.unmodifiableList(properties) : Collections.unmodifiableList(new ArrayList());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mLocation;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mDescription;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return mConfigType;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return mConfigType.isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return mConfigType.isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mIsGlobal;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        long currentTime = System.currentTimeMillis();\n        if (mCheckstyleConfigurationFile == null || currentTime > mExpirationTime) {\n            mCheckstyleConfigurationFile = getType().getCheckstyleConfiguration(this);\n            // 1 hour\n            mExpirationTime = currentTime + 1000 * 60 * 60;\n        }\n        return mCheckstyleConfigurationFile;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfiguration_4Test.java",
		"test_prompt": "// CheckConfiguration_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfiguration}.\n* It contains ten unit test cases for the {@link CheckConfiguration#hashCode()} method.\n*/\nclass CheckConfiguration_4Test {"
	},
	{
		"original_code": "// BuiltInConfigurationEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Implementation of a location editor with only a not editable text field. This\n * is used to just show the location.\n *\n * @author Lars K�dderitzsch\n */\npublic class BuiltInConfigurationEditor implements ICheckConfigurationEditor {\n\n    //\n    // attributes\n    //\n    /**\n     * the working copy this editor edits.\n     */\n    private CheckConfigurationWorkingCopy mWorkingCopy;\n\n    /**\n     * the text field containing the config name.\n     */\n    private Text mConfigName;\n\n    /**\n     * text field containing the location.\n     */\n    private Text mLocation;\n\n    /**\n     * the text containing the description.\n     */\n    private Text mDescription;\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public void initialize(CheckConfigurationWorkingCopy checkConfiguration, CheckConfigurationPropertiesDialog dialog) {\n        mWorkingCopy = checkConfiguration;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createEditorControl(Composite parent, final Shell shell) {\n        Composite contents = new Composite(parent, SWT.NULL);\n        contents.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        GridLayout layout = new GridLayout(2, false);\n        layout.marginWidth = 0;\n        layout.marginHeight = 0;\n        contents.setLayout(layout);\n        Label lblConfigName = new Label(contents, SWT.NULL);\n        lblConfigName.setText(Messages.CheckConfigurationPropertiesDialog_lblName);\n        GridData gd = new GridData();\n        lblConfigName.setLayoutData(gd);\n        mConfigName = new Text(contents, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        mConfigName.setEditable(false);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mConfigName.setLayoutData(gd);\n        Label lblConfigLocation = new Label(contents, SWT.NULL);\n        lblConfigLocation.setText(Messages.CheckConfigurationPropertiesDialog_lblLocation);\n        gd = new GridData();\n        gd.verticalAlignment = GridData.VERTICAL_ALIGN_BEGINNING;\n        lblConfigLocation.setLayoutData(gd);\n        mLocation = new Text(contents, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mLocation.setLayoutData(gd);\n        mLocation.setEditable(false);\n        Label lblDescription = new Label(contents, SWT.NULL);\n        lblDescription.setText(Messages.CheckConfigurationPropertiesDialog_lblDescription);\n        gd = new GridData();\n        gd.horizontalSpan = 2;\n        lblDescription.setLayoutData(gd);\n        mDescription = new Text(contents, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.BORDER | SWT.VERTICAL);\n        mDescription.setEditable(false);\n        gd = new GridData(GridData.FILL_BOTH);\n        gd.horizontalSpan = 2;\n        gd.widthHint = 300;\n        gd.heightHint = 100;\n        gd.grabExcessHorizontalSpace = true;\n        gd.grabExcessVerticalSpace = true;\n        mDescription.setLayoutData(gd);\n        if (mWorkingCopy.getName() != null) {\n            mConfigName.setText(mWorkingCopy.getName());\n        }\n        if (mWorkingCopy.getLocation() != null) {\n            mLocation.setText(mWorkingCopy.getLocation());\n        }\n        if (mWorkingCopy.getDescription() != null) {\n            mDescription.setText(mWorkingCopy.getDescription());\n        }\n        return contents;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy getEditedWorkingCopy() throws CheckstylePluginException {\n        return mWorkingCopy;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/BuiltInConfigurationEditor.java",
		"test_prompt": "// BuiltInConfigurationEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BuiltInConfigurationEditor}.\n* It contains ten unit test cases for the {@link BuiltInConfigurationEditor#createEditorControl(Composite, Shell)} method.\n*/\nclass BuiltInConfigurationEditorTest {"
	},
	{
		"original_code": "// SystemPropertyResolver.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Property resolver implementation that resolves system properties.\n *\n * @author Lars K�dderitzsch\n */\npublic class SystemPropertyResolver implements PropertyResolver {\n\n    /**\n     * {@inheritDoc}\n     */\n    public String resolve(String property) throws CheckstyleException {\n        // get the system property\n        return System.getProperty(property);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/SystemPropertyResolver.java",
		"test_prompt": "// SystemPropertyResolverTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SystemPropertyResolver}.\n* It contains ten unit test cases for the {@link SystemPropertyResolver#resolve(String)} method.\n*/\nclass SystemPropertyResolverTest {"
	},
	{
		"original_code": "// ExternalFileConfigurationType.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Implementation of a check configuration that uses an exteral checkstyle\n * configuration file.\n *\n * @author Lars K�dderitzsch\n */\npublic class ExternalFileConfigurationType extends ConfigurationType {\n\n    /**\n     * Key to access the information if the configuration is protected.\n     */\n    //$NON-NLS-1$\n    public static final String KEY_PROTECT_CONFIG = \"protect-config-file\";\n\n    /**\n     * Property resolver used to add dynamic location support.\n     */\n    private static final PropertyResolver DYNAMIC_LOC_RESOLVER;\n\n    static {\n        MultiPropertyResolver resolver = new MultiPropertyResolver();\n        resolver.addPropertyResolver(new ClasspathVariableResolver());\n        resolver.addPropertyResolver(new SystemPropertyResolver());\n        DYNAMIC_LOC_RESOLVER = resolver;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Tries to resolve a dynamic location into the real file path.\n     *\n     * @param location the probably unresolved location string\n     * @return the resolved location\n     * @throws CheckstylePluginException unexpected error while resolving the\n     *             dynamic properties\n     */\n    public static String resolveDynamicLocation(String location) throws CheckstylePluginException {\n        String newLocation = location;\n        try {\n            // support dynamic locations for external configurations\n            while (PropertyUtil.hasUnresolvedProperties(newLocation)) {\n                newLocation = PropertyUtil.replaceProperties(newLocation, DYNAMIC_LOC_RESOLVER);\n            }\n        } catch (CheckstyleException e) {\n            CheckstylePluginException.rethrow(e);\n        }\n        return newLocation;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected URL resolveLocation(ICheckConfiguration checkConfiguration) throws IOException {\n        String location = checkConfiguration.getLocation();\n        // support dynamic locations for external configurations\n        try {\n            location = resolveDynamicLocation(location);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n            throw new IOException(e.getMessage());\n        }\n        return new File(location).toURL();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable(ICheckConfiguration checkConfiguration) {\n        boolean isConfigurable = true;\n        boolean isProtected = Boolean.valueOf((String) checkConfiguration.getAdditionalData().get(KEY_PROTECT_CONFIG)).booleanValue();\n        isConfigurable = !isProtected;\n        if (!isProtected) {\n            String location = checkConfiguration.getLocation();\n            try {\n                // support dynamic locations for external configurations\n                location = resolveDynamicLocation(location);\n            } catch (CheckstylePluginException e) {\n                CheckstyleLog.log(e);\n                isConfigurable = false;\n            }\n            // The configuration can be changed when the external configuration\n            // file\n            // can is writable\n            isConfigurable = new File(location).canWrite();\n        }\n        return isConfigurable;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ExternalFileConfigurationType_0Test.java",
		"test_prompt": "// ExternalFileConfigurationType_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExternalFileConfigurationType}.\n* It contains ten unit test cases for the {@link ExternalFileConfigurationType#resolveDynamicLocation(String)} method.\n*/\nclass ExternalFileConfigurationType_0Test {"
	},
	{
		"original_code": "// ExternalFileConfigurationType.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Implementation of a check configuration that uses an exteral checkstyle\n * configuration file.\n *\n * @author Lars K�dderitzsch\n */\npublic class ExternalFileConfigurationType extends ConfigurationType {\n\n    /**\n     * Key to access the information if the configuration is protected.\n     */\n    //$NON-NLS-1$\n    public static final String KEY_PROTECT_CONFIG = \"protect-config-file\";\n\n    /**\n     * Property resolver used to add dynamic location support.\n     */\n    private static final PropertyResolver DYNAMIC_LOC_RESOLVER;\n\n    static {\n        MultiPropertyResolver resolver = new MultiPropertyResolver();\n        resolver.addPropertyResolver(new ClasspathVariableResolver());\n        resolver.addPropertyResolver(new SystemPropertyResolver());\n        DYNAMIC_LOC_RESOLVER = resolver;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Tries to resolve a dynamic location into the real file path.\n     *\n     * @param location the probably unresolved location string\n     * @return the resolved location\n     * @throws CheckstylePluginException unexpected error while resolving the\n     *             dynamic properties\n     */\n    public static String resolveDynamicLocation(String location) throws CheckstylePluginException {\n        String newLocation = location;\n        try {\n            // support dynamic locations for external configurations\n            while (PropertyUtil.hasUnresolvedProperties(newLocation)) {\n                newLocation = PropertyUtil.replaceProperties(newLocation, DYNAMIC_LOC_RESOLVER);\n            }\n        } catch (CheckstyleException e) {\n            CheckstylePluginException.rethrow(e);\n        }\n        return newLocation;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected URL resolveLocation(ICheckConfiguration checkConfiguration) throws IOException {\n        String location = checkConfiguration.getLocation();\n        // support dynamic locations for external configurations\n        try {\n            location = resolveDynamicLocation(location);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n            throw new IOException(e.getMessage());\n        }\n        return new File(location).toURL();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable(ICheckConfiguration checkConfiguration) {\n        boolean isConfigurable = true;\n        boolean isProtected = Boolean.valueOf((String) checkConfiguration.getAdditionalData().get(KEY_PROTECT_CONFIG)).booleanValue();\n        isConfigurable = !isProtected;\n        if (!isProtected) {\n            String location = checkConfiguration.getLocation();\n            try {\n                // support dynamic locations for external configurations\n                location = resolveDynamicLocation(location);\n            } catch (CheckstylePluginException e) {\n                CheckstyleLog.log(e);\n                isConfigurable = false;\n            }\n            // The configuration can be changed when the external configuration\n            // file\n            // can is writable\n            isConfigurable = new File(location).canWrite();\n        }\n        return isConfigurable;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ExternalFileConfigurationType_1Test.java",
		"test_prompt": "// ExternalFileConfigurationType_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExternalFileConfigurationType}.\n* It contains ten unit test cases for the {@link ExternalFileConfigurationType#isConfigurable(ICheckConfiguration)} method.\n*/\nclass ExternalFileConfigurationType_1Test {"
	},
	{
		"original_code": "// InternalConfigurationType.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport org.eclipse.core.runtime.IPath;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Implementation of the configuration type for a internal check configuration,\n * that is located inside the plugin.\n *\n * @author Lars K�dderitzsch\n */\npublic class InternalConfigurationType extends ConfigurationType {\n\n    /**\n     * Resolves the location inside the plugins workspace state location.\n     *\n     * @param location the location\n     * @return the resolved location in the workspace\n     */\n    public static String resolveLocationInWorkspace(String location) {\n        IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n        configPath = configPath.append(location);\n        return configPath.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    protected URL resolveLocation(ICheckConfiguration checkConfiguration) throws IOException {\n        String location = checkConfiguration.getLocation();\n        // resolve the location in the workspace\n        location = resolveLocationInWorkspace(location);\n        return new File(location).toURL();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void notifyCheckConfigRemoved(ICheckConfiguration checkConfiguration) throws CheckstylePluginException {\n        super.notifyCheckConfigRemoved(checkConfiguration);\n        // remove the configuration file from the workspace metadata\n        URL configFileURL = checkConfiguration.getResolvedConfigurationFileURL();\n        if (configFileURL != null) {\n            File configFile = new File(configFileURL.getFile());\n            configFile.delete();\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/InternalConfigurationType.java",
		"test_prompt": "// InternalConfigurationTypeTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport org.eclipse.core.runtime.IPath;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InternalConfigurationType}.\n* It contains ten unit test cases for the {@link InternalConfigurationType#resolveLocationInWorkspace(String)} method.\n*/\nclass InternalConfigurationTypeTest {"
	},
	{
		"original_code": "// StandardPropertyResolver.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Property resolver that resolves some eclipse standard variables.\n *\n * @author Lars K�dderitzsch\n */\npublic class StandardPropertyResolver implements PropertyResolver, IContextAware {\n\n    //\n    // constants\n    //\n    /**\n     * constant for the workspace_loc variable.\n     */\n    //$NON-NLS-1$\n    private static final String WORKSPACE_LOC = \"workspace_loc\";\n\n    /**\n     * constant for the project_loc variable.\n     */\n    //$NON-NLS-1$\n    private static final String PROJECT_LOC = \"project_loc\";\n\n    /**\n     * constant for the basedir variable.\n     */\n    //$NON-NLS-1$\n    private static final String BASEDIR_LOC = \"basedir\";\n\n    /**\n     * constant for the samedir variable.\n     */\n    //$NON-NLS-1$\n    private static final String SAMEDIR_LOC = \"samedir\";\n\n    /**\n     * constant for the config_loc variable.\n     */\n    //$NON-NLS-1$\n    private static final String CONFIG_LOC = \"config_loc\";\n\n    //\n    // attributes\n    //\n    /**\n     * the context project.\n     */\n    private IProject mProject;\n\n    /**\n     * the location of the configuration file.\n     */\n    private String mConfigLocation;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates the BuiltInPropertyResolver.\n     *\n     * @param configLocation the location of the checkstyle configuration file\n     */\n    public StandardPropertyResolver(String configLocation) {\n        mConfigLocation = configLocation;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public void setProjectContext(IProject project) {\n        mProject = project;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String resolve(String property) throws CheckstyleException {\n        String value = null;\n        if (WORKSPACE_LOC.equals(property)) {\n            value = ResourcesPlugin.getWorkspace().getRoot().getLocation().toOSString();\n        } else if ((PROJECT_LOC.equals(property) || BASEDIR_LOC.equals(property)) && mProject != null) {\n            value = mProject.getLocation().toOSString();\n        } else if ((SAMEDIR_LOC.equals(property) || CONFIG_LOC.equals(property)) && mConfigLocation != null) {\n            String configLocWOBackslashes = mConfigLocation.replace('\\\\', '/');\n            //$NON-NLS-1$\n            int lastSlash = configLocWOBackslashes.lastIndexOf(\"/\");\n            if (lastSlash > -1) {\n                //$NON-NLS-1$\n                value = configLocWOBackslashes.substring(0, lastSlash + 1);\n            }\n        }\n        return value;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/StandardPropertyResolver.java",
		"test_prompt": "// StandardPropertyResolverTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StandardPropertyResolver}.\n* It contains ten unit test cases for the {@link StandardPropertyResolver#resolve(String)} method.\n*/\nclass StandardPropertyResolverTest {"
	},
	{
		"original_code": "// ProjectConfigurationType.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URL;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Implementation of a check configuration that uses an exteral checkstyle\n * configuration file.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationType extends ConfigurationType {\n\n    /**\n     * Key to access the information if the configuration is protected.\n     */\n    //$NON-NLS-1$\n    public static final String KEY_PROTECT_CONFIG = \"protect-config-file\";\n\n    /**\n     * {@inheritDoc}\n     */\n    protected URL resolveLocation(ICheckConfiguration checkConfiguration) throws IOException {\n        IResource configFileResource = ResourcesPlugin.getWorkspace().getRoot().findMember(checkConfiguration.getLocation());\n        if (configFileResource != null) {\n            return configFileResource.getLocation().toFile().toURL();\n        } else {\n            throw new FileNotFoundException(NLS.bind(Messages.ProjectConfigurationType_msgFileNotFound, checkConfiguration.getLocation()));\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable(ICheckConfiguration checkConfiguration) {\n        boolean isConfigurable = true;\n        boolean isProtected = Boolean.valueOf((String) checkConfiguration.getAdditionalData().get(KEY_PROTECT_CONFIG)).booleanValue();\n        isConfigurable = !isProtected;\n        if (!isProtected) {\n            // The configuration can be changed when the external configuration\n            // file can is writable\n            try {\n                isConfigurable = new File(checkConfiguration.getResolvedConfigurationFileURL().getFile()).canWrite();\n            } catch (CheckstylePluginException e) {\n                CheckstyleLog.log(e);\n                isConfigurable = false;\n            }\n        }\n        return isConfigurable;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ProjectConfigurationType.java",
		"test_prompt": "// ProjectConfigurationTypeTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URL;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationType}.\n* It contains ten unit test cases for the {@link ProjectConfigurationType#isConfigurable(ICheckConfiguration)} method.\n*/\nclass ProjectConfigurationTypeTest {"
	},
	{
		"original_code": "// ConfigurationTypes.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Register for the configuration types thats use the\n * <i>com.atlassw.tools.eclipse.checkstyle.configurationtypes </i> extension\n * point.\n *\n * @author Lars K�dderitzsch\n */\npublic final class ConfigurationTypes {\n\n    //\n    // constants\n    //\n    /**\n     * constant for the extension point id.\n     */\n    private static final String CONFIGTYPES_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + //$NON-NLS-1$\n    \".configurationtypes\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_NAME = \"name\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_INTERNAL_NAME = \"internal-name\";\n\n    /**\n     * constant for the description attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_IMAGE = \"icon\";\n\n    /**\n     * constant for the class attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CLASS = \"class\";\n\n    /**\n     * constant for the editorClass attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITOR = \"editorClass\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CREATABLE = \"creatable\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITABLE = \"editable\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CONFIGURABLE = \"configurable\";\n\n    /**\n     * the configuration types configured to the extension point.\n     */\n    private static final Map CONFIGURATION_TYPES = new LinkedHashMap();\n\n    //\n    // Initializer\n    //\n    /**\n     * Initialize the configured to the filter extension point.\n     */\n    static {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(CONFIGTYPES_EXTENSION_POINT);\n        for (int i = 0; i < elements.length; i++) {\n            try {\n                String name = elements[i].getAttribute(ATTR_NAME);\n                String internalName = elements[i].getAttribute(ATTR_INTERNAL_NAME);\n                String icon = elements[i].getAttribute(ATTR_IMAGE);\n                Class editorClass = elements[i].getAttributeAsIs(ATTR_EDITOR) == null ? null : Class.forName(elements[i].getAttributeAsIs(ATTR_EDITOR));\n                Class implClass = Class.forName(elements[i].getAttributeAsIs(ATTR_CLASS));\n                String definingPluginId = elements[i].getDeclaringExtension().getNamespace();\n                boolean isCreatable = Boolean.valueOf(elements[i].getAttribute(ATTR_CREATABLE)).booleanValue();\n                boolean isEditable = Boolean.valueOf(elements[i].getAttribute(ATTR_EDITABLE)).booleanValue();\n                boolean isConfigurable = Boolean.valueOf(elements[i].getAttribute(ATTR_CONFIGURABLE)).booleanValue();\n                IConfigurationType configType = (IConfigurationType) implClass.newInstance();\n                configType.initialize(name, internalName, editorClass, icon, definingPluginId, isCreatable, isEditable, isConfigurable);\n                CONFIGURATION_TYPES.put(internalName, configType);\n            } catch (Exception e) {\n                CheckstyleLog.log(e);\n            }\n        }\n    }\n\n    //\n    // constructor\n    //\n    /**\n     * Hidden default constructor.\n     */\n    private ConfigurationTypes() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the available configuration types.\n     *\n     * @return the configuration types.\n     */\n    public static IConfigurationType[] getCreatableConfigTypes() {\n        List creatableTypes = new ArrayList();\n        Collection configurations = CONFIGURATION_TYPES.values();\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            IConfigurationType type = (IConfigurationType) it.next();\n            if (type.isCreatable()) {\n                creatableTypes.add(type);\n            }\n        }\n        return (IConfigurationType[]) creatableTypes.toArray(new IConfigurationType[creatableTypes.size()]);\n    }\n\n    /**\n     * Returns the available configuration types that can be configured, mean\n     * the configuration file can by principle be written as it lays in the\n     * local filesystem.\n     *\n     * @return the configurable configuration types.\n     */\n    public static IConfigurationType[] getConfigurableConfigTypes() {\n        List configurableTypes = new ArrayList();\n        configurableTypes.addAll(Arrays.asList(getCreatableConfigTypes()));\n        //$NON-NLS-1$\n        IConfigurationType remoteType = getByInternalName(\"remote\");\n        configurableTypes.remove(remoteType);\n        return (IConfigurationType[]) configurableTypes.toArray(new IConfigurationType[configurableTypes.size()]);\n    }\n\n    /**\n     * Gets the configuration type by its internal name.\n     *\n     * @param name the configuration type internal name\n     * @return the configuration type or <code>null</code>\n     */\n    public static IConfigurationType getByInternalName(String name) {\n        return (IConfigurationType) CONFIGURATION_TYPES.get(name);\n    }\n\n    /**\n     * Gets the configuration type by its name.\n     *\n     * @param name the configuration type name\n     * @return the configuration type or <code>null</code>\n     */\n    public static IConfigurationType getByName(String name) {\n        Collection configurations = CONFIGURATION_TYPES.values();\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            IConfigurationType type = (IConfigurationType) it.next();\n            if (type.getName().equals(name)) {\n                return type;\n            }\n        }\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ConfigurationTypes_0Test.java",
		"test_prompt": "// ConfigurationTypes_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigurationTypes}.\n* It contains ten unit test cases for the {@link ConfigurationTypes#getCreatableConfigTypes()} method.\n*/\nclass ConfigurationTypes_0Test {"
	},
	{
		"original_code": "// ConfigurationTypes.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Register for the configuration types thats use the\n * <i>com.atlassw.tools.eclipse.checkstyle.configurationtypes </i> extension\n * point.\n *\n * @author Lars K�dderitzsch\n */\npublic final class ConfigurationTypes {\n\n    //\n    // constants\n    //\n    /**\n     * constant for the extension point id.\n     */\n    private static final String CONFIGTYPES_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + //$NON-NLS-1$\n    \".configurationtypes\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_NAME = \"name\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_INTERNAL_NAME = \"internal-name\";\n\n    /**\n     * constant for the description attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_IMAGE = \"icon\";\n\n    /**\n     * constant for the class attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CLASS = \"class\";\n\n    /**\n     * constant for the editorClass attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITOR = \"editorClass\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CREATABLE = \"creatable\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITABLE = \"editable\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CONFIGURABLE = \"configurable\";\n\n    /**\n     * the configuration types configured to the extension point.\n     */\n    private static final Map CONFIGURATION_TYPES = new LinkedHashMap();\n\n    //\n    // Initializer\n    //\n    /**\n     * Initialize the configured to the filter extension point.\n     */\n    static {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(CONFIGTYPES_EXTENSION_POINT);\n        for (int i = 0; i < elements.length; i++) {\n            try {\n                String name = elements[i].getAttribute(ATTR_NAME);\n                String internalName = elements[i].getAttribute(ATTR_INTERNAL_NAME);\n                String icon = elements[i].getAttribute(ATTR_IMAGE);\n                Class editorClass = elements[i].getAttributeAsIs(ATTR_EDITOR) == null ? null : Class.forName(elements[i].getAttributeAsIs(ATTR_EDITOR));\n                Class implClass = Class.forName(elements[i].getAttributeAsIs(ATTR_CLASS));\n                String definingPluginId = elements[i].getDeclaringExtension().getNamespace();\n                boolean isCreatable = Boolean.valueOf(elements[i].getAttribute(ATTR_CREATABLE)).booleanValue();\n                boolean isEditable = Boolean.valueOf(elements[i].getAttribute(ATTR_EDITABLE)).booleanValue();\n                boolean isConfigurable = Boolean.valueOf(elements[i].getAttribute(ATTR_CONFIGURABLE)).booleanValue();\n                IConfigurationType configType = (IConfigurationType) implClass.newInstance();\n                configType.initialize(name, internalName, editorClass, icon, definingPluginId, isCreatable, isEditable, isConfigurable);\n                CONFIGURATION_TYPES.put(internalName, configType);\n            } catch (Exception e) {\n                CheckstyleLog.log(e);\n            }\n        }\n    }\n\n    //\n    // constructor\n    //\n    /**\n     * Hidden default constructor.\n     */\n    private ConfigurationTypes() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the available configuration types.\n     *\n     * @return the configuration types.\n     */\n    public static IConfigurationType[] getCreatableConfigTypes() {\n        List creatableTypes = new ArrayList();\n        Collection configurations = CONFIGURATION_TYPES.values();\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            IConfigurationType type = (IConfigurationType) it.next();\n            if (type.isCreatable()) {\n                creatableTypes.add(type);\n            }\n        }\n        return (IConfigurationType[]) creatableTypes.toArray(new IConfigurationType[creatableTypes.size()]);\n    }\n\n    /**\n     * Returns the available configuration types that can be configured, mean\n     * the configuration file can by principle be written as it lays in the\n     * local filesystem.\n     *\n     * @return the configurable configuration types.\n     */\n    public static IConfigurationType[] getConfigurableConfigTypes() {\n        List configurableTypes = new ArrayList();\n        configurableTypes.addAll(Arrays.asList(getCreatableConfigTypes()));\n        //$NON-NLS-1$\n        IConfigurationType remoteType = getByInternalName(\"remote\");\n        configurableTypes.remove(remoteType);\n        return (IConfigurationType[]) configurableTypes.toArray(new IConfigurationType[configurableTypes.size()]);\n    }\n\n    /**\n     * Gets the configuration type by its internal name.\n     *\n     * @param name the configuration type internal name\n     * @return the configuration type or <code>null</code>\n     */\n    public static IConfigurationType getByInternalName(String name) {\n        return (IConfigurationType) CONFIGURATION_TYPES.get(name);\n    }\n\n    /**\n     * Gets the configuration type by its name.\n     *\n     * @param name the configuration type name\n     * @return the configuration type or <code>null</code>\n     */\n    public static IConfigurationType getByName(String name) {\n        Collection configurations = CONFIGURATION_TYPES.values();\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            IConfigurationType type = (IConfigurationType) it.next();\n            if (type.getName().equals(name)) {\n                return type;\n            }\n        }\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ConfigurationTypes_1Test.java",
		"test_prompt": "// ConfigurationTypes_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigurationTypes}.\n* It contains ten unit test cases for the {@link ConfigurationTypes#getConfigurableConfigTypes()} method.\n*/\nclass ConfigurationTypes_1Test {"
	},
	{
		"original_code": "// ConfigurationTypes.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Register for the configuration types thats use the\n * <i>com.atlassw.tools.eclipse.checkstyle.configurationtypes </i> extension\n * point.\n *\n * @author Lars K�dderitzsch\n */\npublic final class ConfigurationTypes {\n\n    //\n    // constants\n    //\n    /**\n     * constant for the extension point id.\n     */\n    private static final String CONFIGTYPES_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + //$NON-NLS-1$\n    \".configurationtypes\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_NAME = \"name\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_INTERNAL_NAME = \"internal-name\";\n\n    /**\n     * constant for the description attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_IMAGE = \"icon\";\n\n    /**\n     * constant for the class attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CLASS = \"class\";\n\n    /**\n     * constant for the editorClass attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITOR = \"editorClass\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CREATABLE = \"creatable\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITABLE = \"editable\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CONFIGURABLE = \"configurable\";\n\n    /**\n     * the configuration types configured to the extension point.\n     */\n    private static final Map CONFIGURATION_TYPES = new LinkedHashMap();\n\n    //\n    // Initializer\n    //\n    /**\n     * Initialize the configured to the filter extension point.\n     */\n    static {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(CONFIGTYPES_EXTENSION_POINT);\n        for (int i = 0; i < elements.length; i++) {\n            try {\n                String name = elements[i].getAttribute(ATTR_NAME);\n                String internalName = elements[i].getAttribute(ATTR_INTERNAL_NAME);\n                String icon = elements[i].getAttribute(ATTR_IMAGE);\n                Class editorClass = elements[i].getAttributeAsIs(ATTR_EDITOR) == null ? null : Class.forName(elements[i].getAttributeAsIs(ATTR_EDITOR));\n                Class implClass = Class.forName(elements[i].getAttributeAsIs(ATTR_CLASS));\n                String definingPluginId = elements[i].getDeclaringExtension().getNamespace();\n                boolean isCreatable = Boolean.valueOf(elements[i].getAttribute(ATTR_CREATABLE)).booleanValue();\n                boolean isEditable = Boolean.valueOf(elements[i].getAttribute(ATTR_EDITABLE)).booleanValue();\n                boolean isConfigurable = Boolean.valueOf(elements[i].getAttribute(ATTR_CONFIGURABLE)).booleanValue();\n                IConfigurationType configType = (IConfigurationType) implClass.newInstance();\n                configType.initialize(name, internalName, editorClass, icon, definingPluginId, isCreatable, isEditable, isConfigurable);\n                CONFIGURATION_TYPES.put(internalName, configType);\n            } catch (Exception e) {\n                CheckstyleLog.log(e);\n            }\n        }\n    }\n\n    //\n    // constructor\n    //\n    /**\n     * Hidden default constructor.\n     */\n    private ConfigurationTypes() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the available configuration types.\n     *\n     * @return the configuration types.\n     */\n    public static IConfigurationType[] getCreatableConfigTypes() {\n        List creatableTypes = new ArrayList();\n        Collection configurations = CONFIGURATION_TYPES.values();\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            IConfigurationType type = (IConfigurationType) it.next();\n            if (type.isCreatable()) {\n                creatableTypes.add(type);\n            }\n        }\n        return (IConfigurationType[]) creatableTypes.toArray(new IConfigurationType[creatableTypes.size()]);\n    }\n\n    /**\n     * Returns the available configuration types that can be configured, mean\n     * the configuration file can by principle be written as it lays in the\n     * local filesystem.\n     *\n     * @return the configurable configuration types.\n     */\n    public static IConfigurationType[] getConfigurableConfigTypes() {\n        List configurableTypes = new ArrayList();\n        configurableTypes.addAll(Arrays.asList(getCreatableConfigTypes()));\n        //$NON-NLS-1$\n        IConfigurationType remoteType = getByInternalName(\"remote\");\n        configurableTypes.remove(remoteType);\n        return (IConfigurationType[]) configurableTypes.toArray(new IConfigurationType[configurableTypes.size()]);\n    }\n\n    /**\n     * Gets the configuration type by its internal name.\n     *\n     * @param name the configuration type internal name\n     * @return the configuration type or <code>null</code>\n     */\n    public static IConfigurationType getByInternalName(String name) {\n        return (IConfigurationType) CONFIGURATION_TYPES.get(name);\n    }\n\n    /**\n     * Gets the configuration type by its name.\n     *\n     * @param name the configuration type name\n     * @return the configuration type or <code>null</code>\n     */\n    public static IConfigurationType getByName(String name) {\n        Collection configurations = CONFIGURATION_TYPES.values();\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            IConfigurationType type = (IConfigurationType) it.next();\n            if (type.getName().equals(name)) {\n                return type;\n            }\n        }\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ConfigurationTypes_2Test.java",
		"test_prompt": "// ConfigurationTypes_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigurationTypes}.\n* It contains ten unit test cases for the {@link ConfigurationTypes#getByInternalName(String)} method.\n*/\nclass ConfigurationTypes_2Test {"
	},
	{
		"original_code": "// ConfigurationTypes.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Register for the configuration types thats use the\n * <i>com.atlassw.tools.eclipse.checkstyle.configurationtypes </i> extension\n * point.\n *\n * @author Lars K�dderitzsch\n */\npublic final class ConfigurationTypes {\n\n    //\n    // constants\n    //\n    /**\n     * constant for the extension point id.\n     */\n    private static final String CONFIGTYPES_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + //$NON-NLS-1$\n    \".configurationtypes\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_NAME = \"name\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_INTERNAL_NAME = \"internal-name\";\n\n    /**\n     * constant for the description attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_IMAGE = \"icon\";\n\n    /**\n     * constant for the class attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CLASS = \"class\";\n\n    /**\n     * constant for the editorClass attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITOR = \"editorClass\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CREATABLE = \"creatable\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITABLE = \"editable\";\n\n    /**\n     * constant for the creatable attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CONFIGURABLE = \"configurable\";\n\n    /**\n     * the configuration types configured to the extension point.\n     */\n    private static final Map CONFIGURATION_TYPES = new LinkedHashMap();\n\n    //\n    // Initializer\n    //\n    /**\n     * Initialize the configured to the filter extension point.\n     */\n    static {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(CONFIGTYPES_EXTENSION_POINT);\n        for (int i = 0; i < elements.length; i++) {\n            try {\n                String name = elements[i].getAttribute(ATTR_NAME);\n                String internalName = elements[i].getAttribute(ATTR_INTERNAL_NAME);\n                String icon = elements[i].getAttribute(ATTR_IMAGE);\n                Class editorClass = elements[i].getAttributeAsIs(ATTR_EDITOR) == null ? null : Class.forName(elements[i].getAttributeAsIs(ATTR_EDITOR));\n                Class implClass = Class.forName(elements[i].getAttributeAsIs(ATTR_CLASS));\n                String definingPluginId = elements[i].getDeclaringExtension().getNamespace();\n                boolean isCreatable = Boolean.valueOf(elements[i].getAttribute(ATTR_CREATABLE)).booleanValue();\n                boolean isEditable = Boolean.valueOf(elements[i].getAttribute(ATTR_EDITABLE)).booleanValue();\n                boolean isConfigurable = Boolean.valueOf(elements[i].getAttribute(ATTR_CONFIGURABLE)).booleanValue();\n                IConfigurationType configType = (IConfigurationType) implClass.newInstance();\n                configType.initialize(name, internalName, editorClass, icon, definingPluginId, isCreatable, isEditable, isConfigurable);\n                CONFIGURATION_TYPES.put(internalName, configType);\n            } catch (Exception e) {\n                CheckstyleLog.log(e);\n            }\n        }\n    }\n\n    //\n    // constructor\n    //\n    /**\n     * Hidden default constructor.\n     */\n    private ConfigurationTypes() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the available configuration types.\n     *\n     * @return the configuration types.\n     */\n    public static IConfigurationType[] getCreatableConfigTypes() {\n        List creatableTypes = new ArrayList();\n        Collection configurations = CONFIGURATION_TYPES.values();\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            IConfigurationType type = (IConfigurationType) it.next();\n            if (type.isCreatable()) {\n                creatableTypes.add(type);\n            }\n        }\n        return (IConfigurationType[]) creatableTypes.toArray(new IConfigurationType[creatableTypes.size()]);\n    }\n\n    /**\n     * Returns the available configuration types that can be configured, mean\n     * the configuration file can by principle be written as it lays in the\n     * local filesystem.\n     *\n     * @return the configurable configuration types.\n     */\n    public static IConfigurationType[] getConfigurableConfigTypes() {\n        List configurableTypes = new ArrayList();\n        configurableTypes.addAll(Arrays.asList(getCreatableConfigTypes()));\n        //$NON-NLS-1$\n        IConfigurationType remoteType = getByInternalName(\"remote\");\n        configurableTypes.remove(remoteType);\n        return (IConfigurationType[]) configurableTypes.toArray(new IConfigurationType[configurableTypes.size()]);\n    }\n\n    /**\n     * Gets the configuration type by its internal name.\n     *\n     * @param name the configuration type internal name\n     * @return the configuration type or <code>null</code>\n     */\n    public static IConfigurationType getByInternalName(String name) {\n        return (IConfigurationType) CONFIGURATION_TYPES.get(name);\n    }\n\n    /**\n     * Gets the configuration type by its name.\n     *\n     * @param name the configuration type name\n     * @return the configuration type or <code>null</code>\n     */\n    public static IConfigurationType getByName(String name) {\n        Collection configurations = CONFIGURATION_TYPES.values();\n        Iterator it = configurations.iterator();\n        while (it.hasNext()) {\n            IConfigurationType type = (IConfigurationType) it.next();\n            if (type.getName().equals(name)) {\n                return type;\n            }\n        }\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ConfigurationTypes_3Test.java",
		"test_prompt": "// ConfigurationTypes_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigurationTypes}.\n* It contains ten unit test cases for the {@link ConfigurationTypes#getByName(String)} method.\n*/\nclass ConfigurationTypes_3Test {"
	},
	{
		"original_code": "// ClasspathVariableResolver.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.jdt.core.JavaCore;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Property resolver that tries to resolve values from classpath variables.\n *\n * @author Lars K�dderitzsch\n */\npublic class ClasspathVariableResolver implements PropertyResolver {\n\n    /**\n     * {@inheritDoc}\n     */\n    public String resolve(String aName) throws CheckstyleException {\n        IPath var = JavaCore.getClasspathVariable(aName);\n        return var != null ? var.toOSString() : null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ClasspathVariableResolver.java",
		"test_prompt": "// ClasspathVariableResolverTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.jdt.core.JavaCore;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClasspathVariableResolver}.\n* It contains ten unit test cases for the {@link ClasspathVariableResolver#resolve(String)} method.\n*/\nclass ClasspathVariableResolverTest {"
	},
	{
		"original_code": "// ResolvablePropertyResolver.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Resolves properties set up with the check configuration.\n *\n * @author Lars K�dderitzsch\n */\npublic class ResolvablePropertyResolver implements PropertyResolver {\n\n    /**\n     * The check configuration to resolve from.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * Creates the resolver for the given check configuration.\n     *\n     * @param checkConfiguration the check configuration\n     */\n    public ResolvablePropertyResolver(ICheckConfiguration checkConfiguration) {\n        mCheckConfiguration = checkConfiguration;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String resolve(String aName) throws CheckstyleException {\n        String value = null;\n        List resolvableProperties = mCheckConfiguration.getResolvableProperties();\n        Iterator it = resolvableProperties.iterator();\n        while (it.hasNext()) {\n            ResolvableProperty prop = (ResolvableProperty) it.next();\n            if (aName.equals(prop.getPropertyName())) {\n                value = prop.getValue();\n                break;\n            }\n        }\n        return value;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ResolvablePropertyResolver.java",
		"test_prompt": "// ResolvablePropertyResolverTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResolvablePropertyResolver}.\n* It contains ten unit test cases for the {@link ResolvablePropertyResolver#resolve(String)} method.\n*/\nclass ResolvablePropertyResolverTest {"
	},
	{
		"original_code": "// InternalConfigurationEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.FileDialog;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationWriter;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Implementation of a location editor to input a remote location. Contains just\n * a text field to input the URL.\n *\n * @author Lars K�dderitzsch\n */\npublic class InternalConfigurationEditor implements ICheckConfigurationEditor {\n\n    //\n    // attributes\n    //\n    /**\n     * The properties dialog.\n     */\n    private CheckConfigurationPropertiesDialog mDialog;\n\n    /**\n     * the working copy this editor edits.\n     */\n    private CheckConfigurationWorkingCopy mWorkingCopy;\n\n    /**\n     * the text field containing the config name.\n     */\n    private Text mConfigName;\n\n    /**\n     * text field containing the location.\n     */\n    private Text mLocation;\n\n    /**\n     * the text containing the description.\n     */\n    private Text mDescription;\n\n    /**\n     * button to import an existing configuration.\n     */\n    private Button mBtnImport;\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public void initialize(CheckConfigurationWorkingCopy checkConfiguration, CheckConfigurationPropertiesDialog dialog) {\n        mWorkingCopy = checkConfiguration;\n        mDialog = dialog;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createEditorControl(Composite parent, final Shell shell) {\n        Composite contents = new Composite(parent, SWT.NULL);\n        contents.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        GridLayout layout = new GridLayout(2, false);\n        layout.marginWidth = 0;\n        layout.marginHeight = 0;\n        contents.setLayout(layout);\n        Label lblConfigName = new Label(contents, SWT.NULL);\n        lblConfigName.setText(Messages.CheckConfigurationPropertiesDialog_lblName);\n        GridData gd = new GridData();\n        lblConfigName.setLayoutData(gd);\n        mConfigName = new Text(contents, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mConfigName.setLayoutData(gd);\n        Label lblConfigLocation = new Label(contents, SWT.NULL);\n        lblConfigLocation.setText(Messages.CheckConfigurationPropertiesDialog_lblLocation);\n        gd = new GridData();\n        gd.verticalAlignment = GridData.VERTICAL_ALIGN_BEGINNING;\n        lblConfigLocation.setLayoutData(gd);\n        mLocation = new Text(contents, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        mLocation.setEditable(false);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mLocation.setLayoutData(gd);\n        Label lblDescription = new Label(contents, SWT.NULL);\n        lblDescription.setText(Messages.CheckConfigurationPropertiesDialog_lblDescription);\n        gd = new GridData();\n        gd.horizontalSpan = 2;\n        lblDescription.setLayoutData(gd);\n        mDescription = new Text(contents, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.BORDER | SWT.VERTICAL);\n        gd = new GridData(GridData.FILL_BOTH);\n        gd.horizontalSpan = 2;\n        gd.widthHint = 300;\n        gd.heightHint = 100;\n        gd.grabExcessHorizontalSpace = true;\n        gd.grabExcessVerticalSpace = true;\n        mDescription.setLayoutData(gd);\n        mBtnImport = new Button(contents, SWT.PUSH);\n        mBtnImport.setText(Messages.InternalConfigurationEditor_btnImport);\n        gd = new GridData();\n        gd.horizontalSpan = 2;\n        gd.horizontalAlignment = GridData.END;\n        mBtnImport.setLayoutData(gd);\n        mBtnImport.addSelectionListener(new SelectionListener() {\n\n            public void widgetSelected(SelectionEvent e) {\n                try {\n                    ICheckConfiguration targetConfig = getEditedWorkingCopy();\n                    FileDialog fileDialog = new FileDialog(mConfigName.getShell());\n                    fileDialog.setText(Messages.InternalConfigurationEditor_titleImportDialog);\n                    //$NON-NLS-1$ //$NON-NLS-2$\n                    fileDialog.setFilterExtensions(new String[] { \"*.xml\", \"*.*\" });\n                    String configFileString = fileDialog.open();\n                    if (configFileString != null && new File(configFileString).exists()) {\n                        ICheckConfiguration tmpSourceConfig = new CheckConfiguration(//$NON-NLS-1$\n                        \"dummy\", configFileString, null, new ExternalFileConfigurationType(), true, null, null);\n                        CheckConfigurationFactory.copyConfiguration(tmpSourceConfig, targetConfig);\n                    }\n                } catch (CheckstylePluginException ex) {\n                    mDialog.setErrorMessage(ex.getLocalizedMessage());\n                }\n            }\n\n            public void widgetDefaultSelected(SelectionEvent e) {\n                // NOOP\n            }\n        });\n        if (mWorkingCopy.getName() != null) {\n            mConfigName.setText(mWorkingCopy.getName());\n        }\n        if (mWorkingCopy.getLocation() != null) {\n            mLocation.setText(mWorkingCopy.getLocation());\n        }\n        if (mWorkingCopy.getDescription() != null) {\n            mDescription.setText(mWorkingCopy.getDescription());\n        }\n        return contents;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy getEditedWorkingCopy() throws CheckstylePluginException {\n        mWorkingCopy.setName(mConfigName.getText());\n        if (mWorkingCopy.getLocation() == null) {\n            //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n            String location = \"internal_config_\" + \"_\" + System.currentTimeMillis() + \".xml\";\n            try {\n                mWorkingCopy.setLocation(location);\n            } catch (CheckstylePluginException e) {\n                if (StringUtils.trimToNull(location) != null && ensureFileExists(location)) {\n                    mWorkingCopy.setLocation(location);\n                } else {\n                    throw e;\n                }\n            }\n        }\n        mWorkingCopy.setDescription(mDescription.getText());\n        return mWorkingCopy;\n    }\n\n    /**\n     * Helper method trying to ensure that the file location provided by the\n     * user exists. If that is not the case it prompts the user if an empty\n     * configuration file should be created.\n     *\n     * @param location the configuration file location\n     * @throws CheckstylePluginException error when trying to ensure the\n     *             location file existance\n     */\n    private boolean ensureFileExists(String location) throws CheckstylePluginException {\n        String resolvedLocation = InternalConfigurationType.resolveLocationInWorkspace(location);\n        File file = new File(resolvedLocation);\n        if (!file.exists()) {\n            OutputStream out = null;\n            try {\n                if (file.getParentFile() != null) {\n                    file.getParentFile().mkdirs();\n                }\n                out = new BufferedOutputStream(new FileOutputStream(file));\n                ConfigurationWriter.writeNewConfiguration(out, mWorkingCopy);\n            } catch (IOException ioe) {\n                CheckstylePluginException.rethrow(ioe);\n            } finally {\n                IOUtils.closeQuietly(out);\n            }\n            return true;\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/InternalConfigurationEditor.java",
		"test_prompt": "// InternalConfigurationEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.FileDialog;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationWriter;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InternalConfigurationEditor}.\n* It contains ten unit test cases for the {@link InternalConfigurationEditor#createEditorControl(Composite, Shell)} method.\n*/\nclass InternalConfigurationEditorTest {"
	},
	{
		"original_code": "// MultiPropertyResolver.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * This property resolver is able to aggregate a list of child property\n * resolvers, where each child resolver looks for different properties and may\n * have different ways of finding properties. The child resolvers are asked to\n * resolve the properties in the order they are added. This PropertyResolver\n * adds the property chaining feature, to allow properties within properties.\n *\n * @author Lars K�dderitzsch\n */\npublic class MultiPropertyResolver implements PropertyResolver, IContextAware {\n\n    //\n    // attributes\n    //\n    /**\n     * The list of PropertyResolvers.\n     */\n    private List mChildResolver = new ArrayList();\n\n    //\n    // methods\n    //\n    /**\n     * Adds a PropertyResolver to this aggregation property resolver.\n     *\n     * @param resolver the PropertyResolver to add\n     */\n    public void addPropertyResolver(PropertyResolver resolver) {\n        mChildResolver.add(resolver);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setProjectContext(IProject project) {\n        // propagate context to the childs\n        for (int i = 0, size = mChildResolver.size(); i < size; i++) {\n            PropertyResolver aChildResolver = (PropertyResolver) mChildResolver.get(i);\n            if (aChildResolver instanceof IContextAware) {\n                ((IContextAware) aChildResolver).setProjectContext(project);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String resolve(String property) throws CheckstyleException {\n        String value = null;\n        for (int i = 0, size = mChildResolver.size(); i < size; i++) {\n            PropertyResolver aChildResolver = (PropertyResolver) mChildResolver.get(i);\n            value = aChildResolver.resolve(property);\n            if (value != null) {\n                break;\n            }\n        }\n        // property chaining - might recurse internally\n        while (PropertyUtil.hasUnresolvedProperties(value)) {\n            value = PropertyUtil.replaceProperties(value, this);\n        }\n        return value;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/MultiPropertyResolver.java",
		"test_prompt": "// MultiPropertyResolverTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MultiPropertyResolver}.\n* It contains ten unit test cases for the {@link MultiPropertyResolver#resolve(String)} method.\n*/\nclass MultiPropertyResolverTest {"
	},
	{
		"original_code": "// RemoteConfigurationEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.net.MalformedURLException;\nimport java.net.PasswordAuthentication;\nimport java.net.URL;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Implementation of a location editor to input a remote location. Contains just\n * a text field to input the URL.\n *\n * @author Lars K�dderitzsch\n */\npublic class RemoteConfigurationEditor implements ICheckConfigurationEditor {\n\n    //\n    // attributes\n    //\n    /**\n     * the working copy this editor edits.\n     */\n    private CheckConfigurationWorkingCopy mWorkingCopy;\n\n    /**\n     * the text field containing the config name.\n     */\n    private Text mConfigName;\n\n    /**\n     * text field containing the location.\n     */\n    private Text mLocation;\n\n    /**\n     * the text containing the description.\n     */\n    private Text mDescription;\n\n    /**\n     * check box to set if the configuration should be cached.\n     */\n    private Button mChkCacheConfig;\n\n    private Text mUserName;\n\n    private Text mPassword;\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public void initialize(CheckConfigurationWorkingCopy checkConfiguration, CheckConfigurationPropertiesDialog dialog) {\n        mWorkingCopy = checkConfiguration;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createEditorControl(Composite parent, final Shell shell) {\n        Composite contents = new Composite(parent, SWT.NULL);\n        contents.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        GridLayout layout = new GridLayout(2, false);\n        layout.marginWidth = 0;\n        layout.marginHeight = 0;\n        contents.setLayout(layout);\n        Label lblConfigName = new Label(contents, SWT.NULL);\n        lblConfigName.setText(Messages.CheckConfigurationPropertiesDialog_lblName);\n        GridData gd = new GridData();\n        lblConfigName.setLayoutData(gd);\n        mConfigName = new Text(contents, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mConfigName.setLayoutData(gd);\n        Label lblConfigLocation = new Label(contents, SWT.NULL);\n        lblConfigLocation.setText(Messages.CheckConfigurationPropertiesDialog_lblLocation);\n        gd = new GridData();\n        gd.verticalAlignment = GridData.VERTICAL_ALIGN_BEGINNING;\n        lblConfigLocation.setLayoutData(gd);\n        mLocation = new Text(contents, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mLocation.setLayoutData(gd);\n        Label lblDescription = new Label(contents, SWT.NULL);\n        lblDescription.setText(Messages.CheckConfigurationPropertiesDialog_lblDescription);\n        gd = new GridData();\n        gd.horizontalSpan = 2;\n        lblDescription.setLayoutData(gd);\n        mDescription = new Text(contents, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.BORDER | SWT.VERTICAL);\n        gd = new GridData(GridData.FILL_BOTH);\n        gd.horizontalSpan = 2;\n        gd.widthHint = 300;\n        gd.heightHint = 100;\n        gd.grabExcessHorizontalSpace = true;\n        gd.grabExcessVerticalSpace = true;\n        mDescription.setLayoutData(gd);\n        Group credentialsGroup = new Group(contents, SWT.NULL);\n        credentialsGroup.setText(Messages.RemoteConfigurationEditor_titleCredentialsGroup);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 2;\n        credentialsGroup.setLayoutData(gd);\n        credentialsGroup.setLayout(new GridLayout(2, false));\n        Label lblUserName = new Label(credentialsGroup, SWT.NULL);\n        lblUserName.setText(Messages.RemoteConfigurationEditor_lblUserName);\n        gd = new GridData();\n        lblUserName.setLayoutData(gd);\n        mUserName = new Text(credentialsGroup, SWT.SINGLE | SWT.BORDER);\n        gd = new GridData();\n        gd.widthHint = 100;\n        mUserName.setLayoutData(gd);\n        Label lblPassword = new Label(credentialsGroup, SWT.NULL);\n        lblPassword.setText(Messages.RemoteConfigurationEditor_lblPassword);\n        gd = new GridData();\n        lblPassword.setLayoutData(gd);\n        mPassword = new Text(credentialsGroup, SWT.SINGLE | SWT.BORDER | SWT.PASSWORD);\n        gd = new GridData();\n        gd.widthHint = 100;\n        mPassword.setLayoutData(gd);\n        Group advancedGroup = new Group(contents, SWT.NULL);\n        advancedGroup.setText(Messages.RemoteConfigurationEditor_titleAdvancedOptions);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 2;\n        advancedGroup.setLayoutData(gd);\n        advancedGroup.setLayout(new GridLayout(2, false));\n        mChkCacheConfig = new Button(advancedGroup, SWT.CHECK);\n        mChkCacheConfig.setText(Messages.RemoteConfigurationEditor_btnCacheRemoteConfig);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 2;\n        mChkCacheConfig.setLayoutData(gd);\n        if (mWorkingCopy.getName() != null) {\n            mConfigName.setText(mWorkingCopy.getName());\n        }\n        if (mWorkingCopy.getLocation() != null) {\n            mLocation.setText(mWorkingCopy.getLocation());\n        }\n        if (mWorkingCopy.getDescription() != null) {\n            mDescription.setText(mWorkingCopy.getDescription());\n        }\n        mChkCacheConfig.setSelection(Boolean.valueOf((String) mWorkingCopy.getAdditionalData().get(RemoteConfigurationType.KEY_CACHE_CONFIG)).booleanValue());\n        if (mWorkingCopy.getLocation() != null) {\n            try {\n                PasswordAuthentication auth = RemoteConfigurationType.RemoteConfigAuthenticator.getPasswordAuthentication(mWorkingCopy.getResolvedConfigurationFileURL());\n                if (auth != null) {\n                    mUserName.setText(auth.getUserName());\n                    mPassword.setText(new String(auth.getPassword()));\n                }\n            } catch (CheckstylePluginException e) {\n                CheckstyleLog.errorDialog(shell, e, true);\n            }\n        }\n        return contents;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy getEditedWorkingCopy() throws CheckstylePluginException {\n        // set the cachefile name\n        if (mChkCacheConfig.getSelection() && mWorkingCopy.getAdditionalData().get(RemoteConfigurationType.KEY_CACHE_FILE_LOCATION) == null) {\n            long currentTime = System.currentTimeMillis();\n            mWorkingCopy.getAdditionalData().put(RemoteConfigurationType.KEY_CACHE_FILE_LOCATION, //$NON-NLS-1$ //$NON-NLS-2$ $NON-NLS-2$\n            mWorkingCopy.getName() + \"_\" + currentTime + \"_cache.xml\");\n            mWorkingCopy.getAdditionalData().put(RemoteConfigurationType.KEY_CACHE_PROPS_FILE_LOCATION, //$NON-NLS-1$ //$NON-NLS-2$ $NON-NLS-2$\n            mWorkingCopy.getName() + \"_\" + currentTime + \"_cache.properties\");\n        }\n        // store credentials if necessary\n        try {\n            if (StringUtils.trimToNull(mUserName.getText()) != null || StringUtils.trimToNull(mPassword.getText()) != null) {\n                RemoteConfigurationType.RemoteConfigAuthenticator.storeCredentials(new URL(mLocation.getText()), mUserName.getText(), mPassword.getText());\n            } else {\n                RemoteConfigurationType.RemoteConfigAuthenticator.removeCachedAuthInfo(new URL(mLocation.getText()));\n            }\n        } catch (MalformedURLException e) {\n            CheckstylePluginException.rethrow(e);\n        }\n        mWorkingCopy.setName(mConfigName.getText());\n        mWorkingCopy.setLocation(mLocation.getText());\n        mWorkingCopy.setDescription(mDescription.getText());\n        mWorkingCopy.getAdditionalData().put(RemoteConfigurationType.KEY_CACHE_CONFIG, //$NON-NLS-1$\n        \"\" + mChkCacheConfig.getSelection());\n        return mWorkingCopy;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/RemoteConfigurationEditor.java",
		"test_prompt": "// RemoteConfigurationEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.net.MalformedURLException;\nimport java.net.PasswordAuthentication;\nimport java.net.URL;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RemoteConfigurationEditor}.\n* It contains ten unit test cases for the {@link RemoteConfigurationEditor#createEditorControl(Composite, Shell)} method.\n*/\nclass RemoteConfigurationEditorTest {"
	},
	{
		"original_code": "// ResourceBundlePropertyResolver.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Property resolver that resolves properties from a resource bundle.\n *\n * @author Lars K�dderitzsch\n */\nclass ResourceBundlePropertyResolver implements PropertyResolver {\n\n    //\n    // attributes\n    //\n    /**\n     * the resource bundle.\n     */\n    private ResourceBundle mBundle;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates the property resolver.\n     *\n     * @param bundle the resource bundle\n     */\n    public ResourceBundlePropertyResolver(ResourceBundle bundle) {\n        mBundle = bundle;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * @see com.puppycrawl.tools.checkstyle.PropertyResolver#resolve(java.lang.String)\n     */\n    public String resolve(String property) throws CheckstyleException {\n        String value = null;\n        if (value == null && mBundle != null) {\n            try {\n                value = mBundle.getString(property);\n            } catch (MissingResourceException e) {\n                // ignore\n            }\n        }\n        return value;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ResourceBundlePropertyResolver.java",
		"test_prompt": "// ResourceBundlePropertyResolverTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ResourceBundlePropertyResolver}.\n* It contains ten unit test cases for the {@link ResourceBundlePropertyResolver#resolve(String)} method.\n*/\nclass ResourceBundlePropertyResolverTest {"
	},
	{
		"original_code": "// PropertyUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Utility class for handling strings that contain properties using the very\n * common ${propertyName} pattern. The code originally comes from the ANT\n * project.\n *\n * @author Lars K�dderitzsch\n */\npublic final class PropertyUtil {\n\n    /**\n     * Hidden default constructor.\n     */\n    private PropertyUtil() {\n        // NOOP\n    }\n\n    /**\n     * Checks if the current value has unresolved properties.\n     *\n     * @param value the value\n     * @return the resolved property\n     * @throws CheckstyleException Syntax exception in a property declaration\n     */\n    public static boolean hasUnresolvedProperties(String value) throws CheckstyleException {\n        if (value != null) {\n            List props = new ArrayList();\n            parsePropertyString(value, new ArrayList(), props);\n            return !props.isEmpty();\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Replaces <code>${xxx}</code> style constructions in the given value\n     * with the string value of the corresponding data types.\n     *\n     * The method is package visible to facilitate testing.\n     *\n     * @param aValue The string to be scanned for property references. May be\n     *            <code>null</code>, in which case this method returns\n     *            immediately with no effect.\n     * @param aProps Mapping (String to String) of property names to their\n     *            values. Must not be <code>null</code>.\n     * @throws CheckstyleException if the string contains an opening\n     *             <code>${</code> without a closing <code>}</code>\n     * @return the original string with the properties replaced, or\n     *         <code>null</code> if the original string is <code>null</code>.\n     *\n     * Code copied from ant -\n     * http://cvs.apache.org/viewcvs/jakarta-ant/src/main/org/apache/tools/ant/ProjectHelper.java\n     */\n    public static String replaceProperties(String aValue, PropertyResolver aProps) throws CheckstyleException {\n        if (aValue == null) {\n            return null;\n        }\n        final List fragments = new ArrayList();\n        final List propertyRefs = new ArrayList();\n        parsePropertyString(aValue, fragments, propertyRefs);\n        final StringBuffer sb = new StringBuffer();\n        final Iterator i = fragments.iterator();\n        final Iterator j = propertyRefs.iterator();\n        while (i.hasNext()) {\n            String fragment = (String) i.next();\n            if (fragment == null) {\n                final String propertyName = (String) j.next();\n                fragment = aProps.resolve(propertyName);\n                if (fragment == null) {\n                    throw new CheckstyleException(//$NON-NLS-1$\n                    \"Property ${\" + propertyName + //$NON-NLS-1$\n                    \"} has not been set\");\n                }\n            }\n            sb.append(fragment);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Parses a string containing <code>${xxx}</code> style property\n     * references into two lists. The first list is a collection of text\n     * fragments, while the other is a set of string property names.\n     * <code>null</code> entries in the first list indicate a property\n     * reference from the second list.\n     *\n     * @param aValue Text to parse. Must not be <code>null</code>.\n     * @param aFragments List to add text fragments to. Must not be\n     *            <code>null</code>.\n     * @param aPropertyRefs List to add property names to. Must not be\n     *            <code>null</code>.\n     *\n     * @throws CheckstyleException if the string contains an opening\n     *             <code>${</code> without a closing <code>}</code> Code\n     *             copied from ant -\n     *             http://cvs.apache.org/viewcvs/jakarta-ant/src/main/org/apache/tools/ant/ProjectHelper.java\n     */\n    private static void parsePropertyString(String aValue, List aFragments, List aPropertyRefs) throws CheckstyleException {\n        int prev = 0;\n        int pos;\n        // search for the next instance of $ from the 'prev' position\n        while (//$NON-NLS-1$\n        (pos = aValue.indexOf(\"$\", prev)) >= 0) {\n            // if there was any text before this, add it as a fragment\n            // TODO, this check could be modified to go if pos>prev;\n            // seems like this current version could stick empty strings\n            // into the list\n            if (pos > 0) {\n                aFragments.add(aValue.substring(prev, pos));\n            }\n            // if we are at the end of the string, we tack on a $\n            // then move past it\n            if (pos == (aValue.length() - 1)) {\n                //$NON-NLS-1$\n                aFragments.add(\"$\");\n                prev = pos + 1;\n            } else if (aValue.charAt(pos + 1) != '{') {\n                // peek ahead to see if the next char is a property or not\n                // not a property: insert the char as a literal\n                /*\n                 * fragments.addElement(value.substring(pos + 1, pos + 2)); prev =\n                 * pos + 2;\n                 */\n                if (aValue.charAt(pos + 1) == '$') {\n                    // backwards compatibility two $ map to one mode\n                    //$NON-NLS-1$\n                    aFragments.add(\"$\");\n                    prev = pos + 2;\n                } else {\n                    // new behaviour: $X maps to $X for all values of X!='$'\n                    aFragments.add(aValue.substring(pos, pos + 2));\n                    prev = pos + 2;\n                }\n            } else {\n                // property found, extract its name or bail on a typo\n                final int endName = aValue.indexOf('}', pos);\n                if (endName < 0) {\n                    //$NON-NLS-1$\n                    throw new CheckstyleException(\"Syntax error in property: \" + aValue);\n                }\n                final String propertyName = aValue.substring(pos + 2, endName);\n                aFragments.add(null);\n                aPropertyRefs.add(propertyName);\n                prev = endName + 1;\n            }\n        }\n        // no more $ signs found\n        // if there is any tail to the file, append it\n        if (prev < aValue.length()) {\n            aFragments.add(aValue.substring(prev));\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/PropertyUtil_0Test.java",
		"test_prompt": "// PropertyUtil_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PropertyUtil}.\n* It contains ten unit test cases for the {@link PropertyUtil#hasUnresolvedProperties(String)} method.\n*/\nclass PropertyUtil_0Test {"
	},
	{
		"original_code": "// PropertyUtil.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Utility class for handling strings that contain properties using the very\n * common ${propertyName} pattern. The code originally comes from the ANT\n * project.\n *\n * @author Lars K�dderitzsch\n */\npublic final class PropertyUtil {\n\n    /**\n     * Hidden default constructor.\n     */\n    private PropertyUtil() {\n        // NOOP\n    }\n\n    /**\n     * Checks if the current value has unresolved properties.\n     *\n     * @param value the value\n     * @return the resolved property\n     * @throws CheckstyleException Syntax exception in a property declaration\n     */\n    public static boolean hasUnresolvedProperties(String value) throws CheckstyleException {\n        if (value != null) {\n            List props = new ArrayList();\n            parsePropertyString(value, new ArrayList(), props);\n            return !props.isEmpty();\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Replaces <code>${xxx}</code> style constructions in the given value\n     * with the string value of the corresponding data types.\n     *\n     * The method is package visible to facilitate testing.\n     *\n     * @param aValue The string to be scanned for property references. May be\n     *            <code>null</code>, in which case this method returns\n     *            immediately with no effect.\n     * @param aProps Mapping (String to String) of property names to their\n     *            values. Must not be <code>null</code>.\n     * @throws CheckstyleException if the string contains an opening\n     *             <code>${</code> without a closing <code>}</code>\n     * @return the original string with the properties replaced, or\n     *         <code>null</code> if the original string is <code>null</code>.\n     *\n     * Code copied from ant -\n     * http://cvs.apache.org/viewcvs/jakarta-ant/src/main/org/apache/tools/ant/ProjectHelper.java\n     */\n    public static String replaceProperties(String aValue, PropertyResolver aProps) throws CheckstyleException {\n        if (aValue == null) {\n            return null;\n        }\n        final List fragments = new ArrayList();\n        final List propertyRefs = new ArrayList();\n        parsePropertyString(aValue, fragments, propertyRefs);\n        final StringBuffer sb = new StringBuffer();\n        final Iterator i = fragments.iterator();\n        final Iterator j = propertyRefs.iterator();\n        while (i.hasNext()) {\n            String fragment = (String) i.next();\n            if (fragment == null) {\n                final String propertyName = (String) j.next();\n                fragment = aProps.resolve(propertyName);\n                if (fragment == null) {\n                    throw new CheckstyleException(//$NON-NLS-1$\n                    \"Property ${\" + propertyName + //$NON-NLS-1$\n                    \"} has not been set\");\n                }\n            }\n            sb.append(fragment);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Parses a string containing <code>${xxx}</code> style property\n     * references into two lists. The first list is a collection of text\n     * fragments, while the other is a set of string property names.\n     * <code>null</code> entries in the first list indicate a property\n     * reference from the second list.\n     *\n     * @param aValue Text to parse. Must not be <code>null</code>.\n     * @param aFragments List to add text fragments to. Must not be\n     *            <code>null</code>.\n     * @param aPropertyRefs List to add property names to. Must not be\n     *            <code>null</code>.\n     *\n     * @throws CheckstyleException if the string contains an opening\n     *             <code>${</code> without a closing <code>}</code> Code\n     *             copied from ant -\n     *             http://cvs.apache.org/viewcvs/jakarta-ant/src/main/org/apache/tools/ant/ProjectHelper.java\n     */\n    private static void parsePropertyString(String aValue, List aFragments, List aPropertyRefs) throws CheckstyleException {\n        int prev = 0;\n        int pos;\n        // search for the next instance of $ from the 'prev' position\n        while (//$NON-NLS-1$\n        (pos = aValue.indexOf(\"$\", prev)) >= 0) {\n            // if there was any text before this, add it as a fragment\n            // TODO, this check could be modified to go if pos>prev;\n            // seems like this current version could stick empty strings\n            // into the list\n            if (pos > 0) {\n                aFragments.add(aValue.substring(prev, pos));\n            }\n            // if we are at the end of the string, we tack on a $\n            // then move past it\n            if (pos == (aValue.length() - 1)) {\n                //$NON-NLS-1$\n                aFragments.add(\"$\");\n                prev = pos + 1;\n            } else if (aValue.charAt(pos + 1) != '{') {\n                // peek ahead to see if the next char is a property or not\n                // not a property: insert the char as a literal\n                /*\n                 * fragments.addElement(value.substring(pos + 1, pos + 2)); prev =\n                 * pos + 2;\n                 */\n                if (aValue.charAt(pos + 1) == '$') {\n                    // backwards compatibility two $ map to one mode\n                    //$NON-NLS-1$\n                    aFragments.add(\"$\");\n                    prev = pos + 2;\n                } else {\n                    // new behaviour: $X maps to $X for all values of X!='$'\n                    aFragments.add(aValue.substring(pos, pos + 2));\n                    prev = pos + 2;\n                }\n            } else {\n                // property found, extract its name or bail on a typo\n                final int endName = aValue.indexOf('}', pos);\n                if (endName < 0) {\n                    //$NON-NLS-1$\n                    throw new CheckstyleException(\"Syntax error in property: \" + aValue);\n                }\n                final String propertyName = aValue.substring(pos + 2, endName);\n                aFragments.add(null);\n                aPropertyRefs.add(propertyName);\n                prev = endName + 1;\n            }\n        }\n        // no more $ signs found\n        // if there is any tail to the file, append it\n        if (prev < aValue.length()) {\n            aFragments.add(aValue.substring(prev));\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/PropertyUtil_1Test.java",
		"test_prompt": "// PropertyUtil_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PropertyUtil}.\n* It contains ten unit test cases for the {@link PropertyUtil#replaceProperties(String, PropertyResolver)} method.\n*/\nclass PropertyUtil_1Test {"
	},
	{
		"original_code": "// ExternalFileConfigurationEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.FileDialog;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationWriter;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Implementation of a file based location editor. Contains a text field with\n * the config file path and a 'Browse...' button opening a file dialog.\n *\n * @author Lars K�dderitzsch\n */\npublic class ExternalFileConfigurationEditor implements ICheckConfigurationEditor {\n\n    //\n    // attributes\n    //\n    /**\n     * the working copy this editor edits.\n     */\n    private CheckConfigurationWorkingCopy mWorkingCopy;\n\n    /**\n     * the text field containing the config name.\n     */\n    private Text mConfigName;\n\n    /**\n     * text field containing the location.\n     */\n    private Text mLocation;\n\n    /**\n     * browse button.\n     */\n    private Button mBtnBrowse;\n\n    /**\n     * the text containing the description.\n     */\n    private Text mDescription;\n\n    /**\n     * check box to set if the configuration file is not editable by the\n     * configuration editor.\n     */\n    private Button mChkProtectConfig;\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public void initialize(CheckConfigurationWorkingCopy checkConfiguration, CheckConfigurationPropertiesDialog dialog) {\n        mWorkingCopy = checkConfiguration;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createEditorControl(Composite parent, final Shell shell) {\n        Composite contents = new Composite(parent, SWT.NULL);\n        contents.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        GridLayout layout = new GridLayout(2, false);\n        layout.marginWidth = 0;\n        layout.marginHeight = 0;\n        contents.setLayout(layout);\n        Label lblConfigName = new Label(contents, SWT.NULL);\n        lblConfigName.setText(Messages.CheckConfigurationPropertiesDialog_lblName);\n        GridData gd = new GridData();\n        lblConfigName.setLayoutData(gd);\n        mConfigName = new Text(contents, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mConfigName.setLayoutData(gd);\n        Label lblConfigLocation = new Label(contents, SWT.NULL);\n        lblConfigLocation.setText(Messages.CheckConfigurationPropertiesDialog_lblLocation);\n        gd = new GridData();\n        lblConfigLocation.setLayoutData(gd);\n        Composite locationComposite = new Composite(contents, SWT.NULL);\n        locationComposite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        layout = new GridLayout(2, false);\n        layout.marginWidth = 0;\n        layout.marginHeight = 0;\n        locationComposite.setLayout(layout);\n        mLocation = new Text(locationComposite, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mLocation.setLayoutData(gd);\n        mBtnBrowse = new Button(locationComposite, SWT.PUSH);\n        mBtnBrowse.setText(Messages.FileConfigurationLocationEditor_btnBrowse);\n        gd = new GridData();\n        mBtnBrowse.setLayoutData(gd);\n        mBtnBrowse.addSelectionListener(new SelectionListener() {\n\n            public void widgetSelected(SelectionEvent e) {\n                FileDialog fileDialog = new FileDialog(shell);\n                fileDialog.setFileName(mLocation.getText());\n                String file = fileDialog.open();\n                if (null != file) {\n                    mLocation.setText(file);\n                }\n            }\n\n            public void widgetDefaultSelected(SelectionEvent e) {\n                // NOOP\n            }\n        });\n        Label lblDescription = new Label(contents, SWT.NULL);\n        lblDescription.setText(Messages.CheckConfigurationPropertiesDialog_lblDescription);\n        gd = new GridData();\n        gd.horizontalSpan = 2;\n        lblDescription.setLayoutData(gd);\n        mDescription = new Text(contents, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.BORDER | SWT.VERTICAL);\n        gd = new GridData(GridData.FILL_BOTH);\n        gd.horizontalSpan = 2;\n        gd.widthHint = 300;\n        gd.heightHint = 100;\n        gd.grabExcessHorizontalSpace = true;\n        gd.grabExcessVerticalSpace = true;\n        mDescription.setLayoutData(gd);\n        Group advancedGroup = new Group(contents, SWT.NULL);\n        advancedGroup.setText(Messages.RemoteConfigurationEditor_titleAdvancedOptions);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 2;\n        advancedGroup.setLayoutData(gd);\n        advancedGroup.setLayout(new GridLayout(2, false));\n        mChkProtectConfig = new Button(advancedGroup, SWT.CHECK);\n        mChkProtectConfig.setText(Messages.ExternalFileConfigurationEditor_btnProtectConfigFile);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 2;\n        mChkProtectConfig.setLayoutData(gd);\n        if (mWorkingCopy.getName() != null) {\n            mConfigName.setText(mWorkingCopy.getName());\n        }\n        if (mWorkingCopy.getLocation() != null) {\n            mLocation.setText(mWorkingCopy.getLocation());\n        }\n        if (mWorkingCopy.getDescription() != null) {\n            mDescription.setText(mWorkingCopy.getDescription());\n        }\n        mChkProtectConfig.setSelection(Boolean.valueOf((String) mWorkingCopy.getAdditionalData().get(ExternalFileConfigurationType.KEY_PROTECT_CONFIG)).booleanValue());\n        return contents;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy getEditedWorkingCopy() throws CheckstylePluginException {\n        mWorkingCopy.setName(mConfigName.getText());\n        mWorkingCopy.setDescription(mDescription.getText());\n        mWorkingCopy.getAdditionalData().put(ExternalFileConfigurationType.KEY_PROTECT_CONFIG, //$NON-NLS-1$\n        \"\" + mChkProtectConfig.getSelection());\n        try {\n            mWorkingCopy.setLocation(mLocation.getText());\n        } catch (CheckstylePluginException e) {\n            String location = mLocation.getText();\n            if (StringUtils.trimToNull(location) != null && ensureFileExists(location)) {\n                mWorkingCopy.setLocation(mLocation.getText());\n            } else {\n                throw e;\n            }\n        }\n        return mWorkingCopy;\n    }\n\n    /**\n     * Helper method trying to ensure that the file location provided by the\n     * user exists. If that is not the case it prompts the user if an empty\n     * configuration file should be created.\n     *\n     * @param location the configuration file location\n     * @throws CheckstylePluginException error when trying to ensure the\n     *             location file existance\n     */\n    private boolean ensureFileExists(String location) throws CheckstylePluginException {\n        // support dynamic location strings\n        String resolvedLocation = ExternalFileConfigurationType.resolveDynamicLocation(location);\n        File file = new File(resolvedLocation);\n        if (!file.exists()) {\n            boolean confirm = MessageDialog.openQuestion(mBtnBrowse.getShell(), Messages.ExternalFileConfigurationEditor_titleFileDoesNotExist, Messages.ExternalFileConfigurationEditor_msgFileDoesNotExist);\n            if (confirm) {\n                OutputStream out = null;\n                try {\n                    if (file.getParentFile() != null) {\n                        file.getParentFile().mkdirs();\n                    }\n                    out = new BufferedOutputStream(new FileOutputStream(file));\n                    ConfigurationWriter.writeNewConfiguration(out, mWorkingCopy);\n                } catch (IOException ioe) {\n                    CheckstylePluginException.rethrow(ioe);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                return true;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ExternalFileConfigurationEditor.java",
		"test_prompt": "// ExternalFileConfigurationEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.FileDialog;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationWriter;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ExternalFileConfigurationEditor}.\n* It contains ten unit test cases for the {@link ExternalFileConfigurationEditor#createEditorControl(Composite, Shell)} method.\n*/\nclass ExternalFileConfigurationEditorTest {"
	},
	{
		"original_code": "// ProjectConfigurationEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.PlatformUI;\nimport org.eclipse.ui.dialogs.ElementTreeSelectionDialog;\nimport org.eclipse.ui.dialogs.ISelectionStatusValidator;\nimport org.eclipse.ui.model.WorkbenchContentProvider;\nimport org.eclipse.ui.model.WorkbenchLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationWriter;\nimport com.atlassw.tools.eclipse.checkstyle.config.GlobalCheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.LocalCheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Implementation of a file based location editor. Contains a text field with\n * the config file path and a 'Browse...' button opening a file dialog.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationEditor implements ICheckConfigurationEditor {\n\n    //\n    // attributes\n    //\n    /**\n     * the working copy this editor edits.\n     */\n    private CheckConfigurationWorkingCopy mWorkingCopy;\n\n    /**\n     * the parent dialog element.\n     */\n    private CheckConfigurationPropertiesDialog mCheckConfigDialog;\n\n    /**\n     * the text field containing the config name.\n     */\n    private Text mConfigName;\n\n    /**\n     * text field containing the location.\n     */\n    private Text mLocation;\n\n    /**\n     * browse button.\n     */\n    private Button mBtnBrowse;\n\n    /**\n     * the text containing the description.\n     */\n    private Text mDescription;\n\n    /**\n     * check box to set if the configuration file is not editable by the\n     * configuration editor.\n     */\n    private Button mChkProtectConfig;\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public void initialize(CheckConfigurationWorkingCopy checkConfiguration, CheckConfigurationPropertiesDialog dialog) {\n        mWorkingCopy = checkConfiguration;\n        mCheckConfigDialog = dialog;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createEditorControl(Composite parent, final Shell shell) {\n        Composite contents = new Composite(parent, SWT.NULL);\n        contents.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        GridLayout layout = new GridLayout(2, false);\n        layout.marginWidth = 0;\n        layout.marginHeight = 0;\n        contents.setLayout(layout);\n        Label lblConfigName = new Label(contents, SWT.NULL);\n        lblConfigName.setText(Messages.CheckConfigurationPropertiesDialog_lblName);\n        GridData gd = new GridData();\n        lblConfigName.setLayoutData(gd);\n        mConfigName = new Text(contents, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mConfigName.setLayoutData(gd);\n        Label lblConfigLocation = new Label(contents, SWT.NULL);\n        lblConfigLocation.setText(Messages.CheckConfigurationPropertiesDialog_lblLocation);\n        gd = new GridData();\n        lblConfigLocation.setLayoutData(gd);\n        Composite locationComposite = new Composite(contents, SWT.NULL);\n        locationComposite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        layout = new GridLayout(2, false);\n        layout.marginWidth = 0;\n        layout.marginHeight = 0;\n        locationComposite.setLayout(layout);\n        mLocation = new Text(locationComposite, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        mLocation.setLayoutData(gd);\n        mBtnBrowse = new Button(locationComposite, SWT.PUSH);\n        mBtnBrowse.setText(Messages.ProjectConfigurationLocationEditor_btnBrowse);\n        mBtnBrowse.setLayoutData(new GridData());\n        mBtnBrowse.addSelectionListener(new SelectionListener() {\n\n            public void widgetSelected(SelectionEvent e) {\n                ElementTreeSelectionDialog dialog = new ElementTreeSelectionDialog(shell, new WorkbenchLabelProvider(), new WorkbenchContentProvider());\n                dialog.setTitle(Messages.ProjectConfigurationLocationEditor_titleSelectConfigFile);\n                dialog.setMessage(Messages.ProjectConfigurationLocationEditor_msgSelectConfigFile);\n                dialog.setBlockOnOpen(true);\n                dialog.setAllowMultiple(false);\n                dialog.setInput(CheckstylePlugin.getWorkspace().getRoot());\n                dialog.setValidator(new ISelectionStatusValidator() {\n\n                    public IStatus validate(Object[] selection) {\n                        if (selection.length == 1 && selection[0] instanceof IFile) {\n                            return new Status(IStatus.OK, PlatformUI.PLUGIN_ID, IStatus.ERROR, new String(), null);\n                        } else {\n                            return new Status(IStatus.ERROR, PlatformUI.PLUGIN_ID, IStatus.ERROR, new String(), null);\n                        }\n                    }\n                });\n                if (ElementTreeSelectionDialog.OK == dialog.open()) {\n                    Object[] result = dialog.getResult();\n                    IFile checkFile = (IFile) result[0];\n                    mLocation.setText(checkFile.getFullPath().toString());\n                }\n            }\n\n            public void widgetDefaultSelected(SelectionEvent e) {\n                // NOOP\n            }\n        });\n        Label lblDescription = new Label(contents, SWT.NULL);\n        lblDescription.setText(Messages.CheckConfigurationPropertiesDialog_lblDescription);\n        gd = new GridData();\n        gd.horizontalSpan = 2;\n        lblDescription.setLayoutData(gd);\n        mDescription = new Text(contents, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.BORDER | SWT.VERTICAL);\n        gd = new GridData(GridData.FILL_BOTH);\n        gd.horizontalSpan = 2;\n        gd.widthHint = 300;\n        gd.heightHint = 100;\n        gd.grabExcessHorizontalSpace = true;\n        gd.grabExcessVerticalSpace = true;\n        mDescription.setLayoutData(gd);\n        Group advancedGroup = new Group(contents, SWT.NULL);\n        advancedGroup.setText(Messages.RemoteConfigurationEditor_titleAdvancedOptions);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 2;\n        advancedGroup.setLayoutData(gd);\n        advancedGroup.setLayout(new GridLayout(2, false));\n        mChkProtectConfig = new Button(advancedGroup, SWT.CHECK);\n        mChkProtectConfig.setText(Messages.ProjectConfigurationEditor_chkProtectConfigFile);\n        gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 2;\n        mChkProtectConfig.setLayoutData(gd);\n        if (mWorkingCopy.getName() != null) {\n            mConfigName.setText(mWorkingCopy.getName());\n        }\n        if (mWorkingCopy.getLocation() != null) {\n            mLocation.setText(mWorkingCopy.getLocation());\n        }\n        if (mWorkingCopy.getDescription() != null) {\n            mDescription.setText(mWorkingCopy.getDescription());\n        }\n        mChkProtectConfig.setSelection(Boolean.valueOf((String) mWorkingCopy.getAdditionalData().get(ExternalFileConfigurationType.KEY_PROTECT_CONFIG)).booleanValue());\n        return contents;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy getEditedWorkingCopy() throws CheckstylePluginException {\n        mWorkingCopy.setName(mConfigName.getText());\n        mWorkingCopy.setDescription(mDescription.getText());\n        mWorkingCopy.getAdditionalData().put(ExternalFileConfigurationType.KEY_PROTECT_CONFIG, //$NON-NLS-1$\n        \"\" + mChkProtectConfig.getSelection());\n        try {\n            mWorkingCopy.setLocation(mLocation.getText());\n        } catch (CheckstylePluginException e) {\n            String location = mLocation.getText();\n            if (StringUtils.trimToNull(location) == null) {\n                throw e;\n            }\n            ICheckConfigurationWorkingSet ws = mCheckConfigDialog.getCheckConfigurationWorkingSet();\n            IPath tmp = new Path(location);\n            boolean isFirstPartProject = ResourcesPlugin.getWorkspace().getRoot().getProject(tmp.segment(0)).exists();\n            if (ws instanceof LocalCheckConfigurationWorkingSet && !isFirstPartProject) {\n                location = ((LocalCheckConfigurationWorkingSet) ws).getProject().getFullPath().append(location).toString();\n                mLocation.setText(location);\n            } else if (ws instanceof GlobalCheckConfigurationWorkingSet && !isFirstPartProject) {\n                throw new CheckstylePluginException(NLS.bind(Messages.ProjectConfigurationEditor_msgNoProjectInWorkspace, tmp.segment(0)));\n            }\n            if (ensureFileExists(location)) {\n                mWorkingCopy.setLocation(mLocation.getText());\n            } else {\n                throw e;\n            }\n        }\n        return mWorkingCopy;\n    }\n\n    /**\n     * Helper method trying to ensure that the file location provided by the\n     * user exists. If that is not the case it prompts the user if an empty\n     * configuration file should be created.\n     *\n     * @param location the configuration file location\n     * @throws CheckstylePluginException error when trying to ensure the\n     *             location file existance\n     */\n    private boolean ensureFileExists(String location) throws CheckstylePluginException {\n        IFile file = null;\n        try {\n            file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(location));\n        } catch (IllegalArgumentException e) {\n            CheckstylePluginException.rethrow(e);\n        }\n        if (!file.exists() && file.getLocation() != null) {\n            boolean confirm = MessageDialog.openQuestion(mBtnBrowse.getShell(), Messages.ExternalFileConfigurationEditor_titleFileDoesNotExist, Messages.ExternalFileConfigurationEditor_msgFileDoesNotExist);\n            if (confirm) {\n                OutputStream out = null;\n                try {\n                    File trueFile = file.getLocation().toFile();\n                    if (trueFile.getParentFile() != null) {\n                        trueFile.getParentFile().mkdirs();\n                    }\n                    out = new BufferedOutputStream(new FileOutputStream(trueFile));\n                    ConfigurationWriter.writeNewConfiguration(out, mWorkingCopy);\n                    file.refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor());\n                } catch (IOException ioe) {\n                    CheckstylePluginException.rethrow(ioe);\n                } catch (CoreException e) {\n                    CheckstylePluginException.rethrow(e);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                return true;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/configtypes/ProjectConfigurationEditor.java",
		"test_prompt": "// ProjectConfigurationEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.configtypes;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.PlatformUI;\nimport org.eclipse.ui.dialogs.ElementTreeSelectionDialog;\nimport org.eclipse.ui.dialogs.ISelectionStatusValidator;\nimport org.eclipse.ui.model.WorkbenchContentProvider;\nimport org.eclipse.ui.model.WorkbenchLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationWriter;\nimport com.atlassw.tools.eclipse.checkstyle.config.GlobalCheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationPropertiesDialog;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.LocalCheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationEditor}.\n* It contains ten unit test cases for the {@link ProjectConfigurationEditor#createEditorControl(Composite, Shell)} method.\n*/\nclass ProjectConfigurationEditorTest {"
	},
	{
		"original_code": "// CheckConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * This class acts as wrapper around check configurations to add editing\n * aspects. Check configurations by themself are not editable.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingCopy implements ICheckConfiguration, Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * The source check configuration of the working copy.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * The working set this working copy belongs to.\n     */\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    /**\n     * The edited name of the configuration.\n     */\n    private String mEditedName;\n\n    /**\n     * The edited location of the configuration.\n     */\n    private String mEditedLocation;\n\n    /**\n     * The edited description of the configuration.\n     */\n    private String mEditedDescription;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * The map of additional data for this configuration.\n     */\n    private Map mAdditionalData = new HashMap();\n\n    /**\n     * flags if the configuration is dirty.\n     */\n    private boolean mHasConfigChanged;\n\n    //\n    // constructors\n    //\n    /*\n     * NOTE: the constructors of this class are package-private because they\n     * only should be called from the\n     * ICheckConfigurationWorkingSet#newWorkingCopy methods of the enclosing\n     * working set.\n     */\n    /**\n     * Creates a new working copy from an existing check configuration.\n     *\n     * @param checkConfigToEdit the existing check configuration\n     * @param workingSet the working set this working copy belongs to\n     */\n    public CheckConfigurationWorkingCopy(ICheckConfiguration checkConfigToEdit, ICheckConfigurationWorkingSet workingSet) {\n        mCheckConfiguration = checkConfigToEdit;\n        mWorkingSet = workingSet;\n        mAdditionalData.putAll(checkConfigToEdit.getAdditionalData());\n        List props = checkConfigToEdit.getResolvableProperties();\n        Iterator it = props.iterator();\n        while (it.hasNext()) {\n            mProperties.add(((ResolvableProperty) it.next()).clone());\n        }\n    }\n\n    /**\n     * Creates a working copy for a new check configuration.\n     *\n     * @param configType the type of the new configuration\n     * @param workingSet the working set this working copy belongs to\n     * @param global <code>true</code> if the new configuration is a global\n     *            configuration\n     */\n    public CheckConfigurationWorkingCopy(IConfigurationType configType, ICheckConfigurationWorkingSet workingSet, boolean global) {\n        mWorkingSet = workingSet;\n        mCheckConfiguration = new CheckConfiguration(null, null, null, configType, global, null, null);\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the source check configuration of this working copy.\n     *\n     * @return the source check configuration\n     */\n    public ICheckConfiguration getSourceCheckConfiguration() {\n        return mCheckConfiguration;\n    }\n\n    /**\n     * Changes the name of the check configuration.\n     *\n     * @param name the new name\n     * @throws CheckstylePluginException if name is <code>null</code> or empty\n     *             or a name collision with an existing check configuration\n     *             exists\n     */\n    public void setName(String name) throws CheckstylePluginException {\n        if (name == null || name.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorConfigNameEmpty);\n        }\n        String oldName = getName();\n        if (!name.equals(oldName)) {\n            mEditedName = name;\n            // Check if the new name is in use\n            if (mWorkingSet.isNameCollision(this)) {\n                mEditedName = oldName;\n                throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorConfigNameInUse, name));\n            }\n        }\n    }\n\n    /**\n     * Changes the location of the Checkstyle configuration file.\n     *\n     * @param location the new location of Checkstyle configuration file\n     * @throws CheckstylePluginException if location is <code>null</code> or\n     *             empty or the Checkstyle configuration file cannot be resolved\n     */\n    public void setLocation(String location) throws CheckstylePluginException {\n        if (location == null || location.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorLocationEmpty);\n        }\n        String oldLocation = getLocation();\n        if (!location.equals(oldLocation)) {\n            try {\n                mEditedLocation = location;\n                // test if configuration file exists\n                getCheckstyleConfiguration();\n            } catch (Exception e) {\n                mEditedLocation = oldLocation;\n                CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorResolveConfigLocation, location, e.getLocalizedMessage()));\n            }\n        }\n    }\n\n    /**\n     * Sets a new description for the check configuration.\n     *\n     * @param description the new description\n     */\n    public void setDescription(String description) {\n        String oldDescription = getDescription();\n        if (description == null || !description.equals(oldDescription)) {\n            mEditedDescription = description;\n        }\n    }\n\n    /**\n     * Flags if the working copy changed compared to the original check\n     * configuration and needs to be saved.\n     *\n     * @return <code>true</code> if the working copy has changes over the\n     *         original check configuration\n     */\n    public boolean isDirty() {\n        return !this.equals(mCheckConfiguration);\n    }\n\n    /**\n     * Determines if the checkstyle configuration of this working copy changed.\n     * This is used to determine if specific projects need to rebuild\n     * afterwards.\n     *\n     * @return <code>true</code> if the checkstyle configuration changed.\n     */\n    public boolean hasConfigurationChanged() {\n        return mHasConfigChanged || !(new EqualsBuilder().append(getLocation(), mCheckConfiguration.getLocation()).append(getResolvableProperties(), mCheckConfiguration.getResolvableProperties()).append(getAdditionalData(), mCheckConfiguration.getAdditionalData()).isEquals());\n    }\n\n    /**\n     * Reads the Checkstyle configuration file and builds the list of configured\n     * modules. Elements are of type\n     * <code>com.atlassw.tools.eclipse.checkstyle.config.Module</code>.\n     *\n     * @return the list of configured modules in this Checkstyle configuration\n     * @throws CheckstylePluginException error when reading the Checkstyle\n     *             configuration file\n     */\n    public List getModules() throws CheckstylePluginException {\n        List result = null;\n        InputStream in = null;\n        try {\n            in = getCheckstyleConfiguration().getCheckConfigFileStream();\n            result = ConfigurationReader.read(in);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return result;\n    }\n\n    /**\n     * Stores the (edited) list of modules to the Checkstyle configuration file.\n     *\n     * @param modules the list of modules to store into the Checkstyle\n     *            configuration file\n     * @throws CheckstylePluginException error storing the Checkstyle\n     *             configuration\n     */\n    public void setModules(List modules) throws CheckstylePluginException {\n        OutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            // First write to a byte array outputstream\n            // because otherwise in an error case the original\n            // file would be destroyed\n            byteOut = new ByteArrayOutputStream();\n            ConfigurationWriter.write(byteOut, modules, this);\n            // all went ok, write to the file\n            String configFile = getResolvedConfigurationFileURL().getFile();\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n            // refresh the files if within the workspace\n            // Bug 1251194 - Resource out of sync after performing changes to\n            // config\n            IPath path = new Path(configFile);\n            IFile[] files = CheckstylePlugin.getWorkspace().getRoot().findFilesForLocation(path);\n            for (int i = 0; i < files.length; i++) {\n                try {\n                    files[i].refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());\n                } catch (CoreException e) {\n                    // NOOP - just ignore\n                }\n            }\n            mHasConfigChanged = true;\n            // throw away the cached Checkstyle configurations\n            CheckConfigurationFactory.refresh();\n        } catch (IOException e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    //\n    // Implementation of ICheckConfiguration\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mEditedName != null ? mEditedName : getSourceCheckConfiguration().getName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mEditedDescription != null ? mEditedDescription : getSourceCheckConfiguration().getDescription();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mEditedLocation != null ? mEditedLocation : getSourceCheckConfiguration().getLocation();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return getSourceCheckConfiguration().getType();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        return getType().getCheckstyleConfiguration(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return getType().isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return getType().isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mCheckConfiguration.isGlobal();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        CheckConfigurationWorkingCopy clone = null;\n        try {\n            clone = (CheckConfigurationWorkingCopy) super.clone();\n            clone.mAdditionalData = new HashMap();\n            clone.mAdditionalData.putAll(this.mAdditionalData);\n            clone.mProperties = new ArrayList();\n            Iterator it = this.mProperties.iterator();\n            while (it.hasNext()) {\n                clone.mProperties.add(((ResolvableProperty) it.next()).clone());\n            }\n        } catch (CloneNotSupportedException e) {\n            // this should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationWorkingCopy_0Test.java",
		"test_prompt": "// CheckConfigurationWorkingCopy_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingCopy#isDirty()} method.\n*/\nclass CheckConfigurationWorkingCopy_0Test {"
	},
	{
		"original_code": "// CheckConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * This class acts as wrapper around check configurations to add editing\n * aspects. Check configurations by themself are not editable.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingCopy implements ICheckConfiguration, Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * The source check configuration of the working copy.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * The working set this working copy belongs to.\n     */\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    /**\n     * The edited name of the configuration.\n     */\n    private String mEditedName;\n\n    /**\n     * The edited location of the configuration.\n     */\n    private String mEditedLocation;\n\n    /**\n     * The edited description of the configuration.\n     */\n    private String mEditedDescription;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * The map of additional data for this configuration.\n     */\n    private Map mAdditionalData = new HashMap();\n\n    /**\n     * flags if the configuration is dirty.\n     */\n    private boolean mHasConfigChanged;\n\n    //\n    // constructors\n    //\n    /*\n     * NOTE: the constructors of this class are package-private because they\n     * only should be called from the\n     * ICheckConfigurationWorkingSet#newWorkingCopy methods of the enclosing\n     * working set.\n     */\n    /**\n     * Creates a new working copy from an existing check configuration.\n     *\n     * @param checkConfigToEdit the existing check configuration\n     * @param workingSet the working set this working copy belongs to\n     */\n    public CheckConfigurationWorkingCopy(ICheckConfiguration checkConfigToEdit, ICheckConfigurationWorkingSet workingSet) {\n        mCheckConfiguration = checkConfigToEdit;\n        mWorkingSet = workingSet;\n        mAdditionalData.putAll(checkConfigToEdit.getAdditionalData());\n        List props = checkConfigToEdit.getResolvableProperties();\n        Iterator it = props.iterator();\n        while (it.hasNext()) {\n            mProperties.add(((ResolvableProperty) it.next()).clone());\n        }\n    }\n\n    /**\n     * Creates a working copy for a new check configuration.\n     *\n     * @param configType the type of the new configuration\n     * @param workingSet the working set this working copy belongs to\n     * @param global <code>true</code> if the new configuration is a global\n     *            configuration\n     */\n    public CheckConfigurationWorkingCopy(IConfigurationType configType, ICheckConfigurationWorkingSet workingSet, boolean global) {\n        mWorkingSet = workingSet;\n        mCheckConfiguration = new CheckConfiguration(null, null, null, configType, global, null, null);\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the source check configuration of this working copy.\n     *\n     * @return the source check configuration\n     */\n    public ICheckConfiguration getSourceCheckConfiguration() {\n        return mCheckConfiguration;\n    }\n\n    /**\n     * Changes the name of the check configuration.\n     *\n     * @param name the new name\n     * @throws CheckstylePluginException if name is <code>null</code> or empty\n     *             or a name collision with an existing check configuration\n     *             exists\n     */\n    public void setName(String name) throws CheckstylePluginException {\n        if (name == null || name.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorConfigNameEmpty);\n        }\n        String oldName = getName();\n        if (!name.equals(oldName)) {\n            mEditedName = name;\n            // Check if the new name is in use\n            if (mWorkingSet.isNameCollision(this)) {\n                mEditedName = oldName;\n                throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorConfigNameInUse, name));\n            }\n        }\n    }\n\n    /**\n     * Changes the location of the Checkstyle configuration file.\n     *\n     * @param location the new location of Checkstyle configuration file\n     * @throws CheckstylePluginException if location is <code>null</code> or\n     *             empty or the Checkstyle configuration file cannot be resolved\n     */\n    public void setLocation(String location) throws CheckstylePluginException {\n        if (location == null || location.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorLocationEmpty);\n        }\n        String oldLocation = getLocation();\n        if (!location.equals(oldLocation)) {\n            try {\n                mEditedLocation = location;\n                // test if configuration file exists\n                getCheckstyleConfiguration();\n            } catch (Exception e) {\n                mEditedLocation = oldLocation;\n                CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorResolveConfigLocation, location, e.getLocalizedMessage()));\n            }\n        }\n    }\n\n    /**\n     * Sets a new description for the check configuration.\n     *\n     * @param description the new description\n     */\n    public void setDescription(String description) {\n        String oldDescription = getDescription();\n        if (description == null || !description.equals(oldDescription)) {\n            mEditedDescription = description;\n        }\n    }\n\n    /**\n     * Flags if the working copy changed compared to the original check\n     * configuration and needs to be saved.\n     *\n     * @return <code>true</code> if the working copy has changes over the\n     *         original check configuration\n     */\n    public boolean isDirty() {\n        return !this.equals(mCheckConfiguration);\n    }\n\n    /**\n     * Determines if the checkstyle configuration of this working copy changed.\n     * This is used to determine if specific projects need to rebuild\n     * afterwards.\n     *\n     * @return <code>true</code> if the checkstyle configuration changed.\n     */\n    public boolean hasConfigurationChanged() {\n        return mHasConfigChanged || !(new EqualsBuilder().append(getLocation(), mCheckConfiguration.getLocation()).append(getResolvableProperties(), mCheckConfiguration.getResolvableProperties()).append(getAdditionalData(), mCheckConfiguration.getAdditionalData()).isEquals());\n    }\n\n    /**\n     * Reads the Checkstyle configuration file and builds the list of configured\n     * modules. Elements are of type\n     * <code>com.atlassw.tools.eclipse.checkstyle.config.Module</code>.\n     *\n     * @return the list of configured modules in this Checkstyle configuration\n     * @throws CheckstylePluginException error when reading the Checkstyle\n     *             configuration file\n     */\n    public List getModules() throws CheckstylePluginException {\n        List result = null;\n        InputStream in = null;\n        try {\n            in = getCheckstyleConfiguration().getCheckConfigFileStream();\n            result = ConfigurationReader.read(in);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return result;\n    }\n\n    /**\n     * Stores the (edited) list of modules to the Checkstyle configuration file.\n     *\n     * @param modules the list of modules to store into the Checkstyle\n     *            configuration file\n     * @throws CheckstylePluginException error storing the Checkstyle\n     *             configuration\n     */\n    public void setModules(List modules) throws CheckstylePluginException {\n        OutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            // First write to a byte array outputstream\n            // because otherwise in an error case the original\n            // file would be destroyed\n            byteOut = new ByteArrayOutputStream();\n            ConfigurationWriter.write(byteOut, modules, this);\n            // all went ok, write to the file\n            String configFile = getResolvedConfigurationFileURL().getFile();\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n            // refresh the files if within the workspace\n            // Bug 1251194 - Resource out of sync after performing changes to\n            // config\n            IPath path = new Path(configFile);\n            IFile[] files = CheckstylePlugin.getWorkspace().getRoot().findFilesForLocation(path);\n            for (int i = 0; i < files.length; i++) {\n                try {\n                    files[i].refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());\n                } catch (CoreException e) {\n                    // NOOP - just ignore\n                }\n            }\n            mHasConfigChanged = true;\n            // throw away the cached Checkstyle configurations\n            CheckConfigurationFactory.refresh();\n        } catch (IOException e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    //\n    // Implementation of ICheckConfiguration\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mEditedName != null ? mEditedName : getSourceCheckConfiguration().getName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mEditedDescription != null ? mEditedDescription : getSourceCheckConfiguration().getDescription();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mEditedLocation != null ? mEditedLocation : getSourceCheckConfiguration().getLocation();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return getSourceCheckConfiguration().getType();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        return getType().getCheckstyleConfiguration(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return getType().isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return getType().isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mCheckConfiguration.isGlobal();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        CheckConfigurationWorkingCopy clone = null;\n        try {\n            clone = (CheckConfigurationWorkingCopy) super.clone();\n            clone.mAdditionalData = new HashMap();\n            clone.mAdditionalData.putAll(this.mAdditionalData);\n            clone.mProperties = new ArrayList();\n            Iterator it = this.mProperties.iterator();\n            while (it.hasNext()) {\n                clone.mProperties.add(((ResolvableProperty) it.next()).clone());\n            }\n        } catch (CloneNotSupportedException e) {\n            // this should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationWorkingCopy_1Test.java",
		"test_prompt": "// CheckConfigurationWorkingCopy_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingCopy#hasConfigurationChanged()} method.\n*/\nclass CheckConfigurationWorkingCopy_1Test {"
	},
	{
		"original_code": "// CheckConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * This class acts as wrapper around check configurations to add editing\n * aspects. Check configurations by themself are not editable.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingCopy implements ICheckConfiguration, Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * The source check configuration of the working copy.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * The working set this working copy belongs to.\n     */\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    /**\n     * The edited name of the configuration.\n     */\n    private String mEditedName;\n\n    /**\n     * The edited location of the configuration.\n     */\n    private String mEditedLocation;\n\n    /**\n     * The edited description of the configuration.\n     */\n    private String mEditedDescription;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * The map of additional data for this configuration.\n     */\n    private Map mAdditionalData = new HashMap();\n\n    /**\n     * flags if the configuration is dirty.\n     */\n    private boolean mHasConfigChanged;\n\n    //\n    // constructors\n    //\n    /*\n     * NOTE: the constructors of this class are package-private because they\n     * only should be called from the\n     * ICheckConfigurationWorkingSet#newWorkingCopy methods of the enclosing\n     * working set.\n     */\n    /**\n     * Creates a new working copy from an existing check configuration.\n     *\n     * @param checkConfigToEdit the existing check configuration\n     * @param workingSet the working set this working copy belongs to\n     */\n    public CheckConfigurationWorkingCopy(ICheckConfiguration checkConfigToEdit, ICheckConfigurationWorkingSet workingSet) {\n        mCheckConfiguration = checkConfigToEdit;\n        mWorkingSet = workingSet;\n        mAdditionalData.putAll(checkConfigToEdit.getAdditionalData());\n        List props = checkConfigToEdit.getResolvableProperties();\n        Iterator it = props.iterator();\n        while (it.hasNext()) {\n            mProperties.add(((ResolvableProperty) it.next()).clone());\n        }\n    }\n\n    /**\n     * Creates a working copy for a new check configuration.\n     *\n     * @param configType the type of the new configuration\n     * @param workingSet the working set this working copy belongs to\n     * @param global <code>true</code> if the new configuration is a global\n     *            configuration\n     */\n    public CheckConfigurationWorkingCopy(IConfigurationType configType, ICheckConfigurationWorkingSet workingSet, boolean global) {\n        mWorkingSet = workingSet;\n        mCheckConfiguration = new CheckConfiguration(null, null, null, configType, global, null, null);\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the source check configuration of this working copy.\n     *\n     * @return the source check configuration\n     */\n    public ICheckConfiguration getSourceCheckConfiguration() {\n        return mCheckConfiguration;\n    }\n\n    /**\n     * Changes the name of the check configuration.\n     *\n     * @param name the new name\n     * @throws CheckstylePluginException if name is <code>null</code> or empty\n     *             or a name collision with an existing check configuration\n     *             exists\n     */\n    public void setName(String name) throws CheckstylePluginException {\n        if (name == null || name.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorConfigNameEmpty);\n        }\n        String oldName = getName();\n        if (!name.equals(oldName)) {\n            mEditedName = name;\n            // Check if the new name is in use\n            if (mWorkingSet.isNameCollision(this)) {\n                mEditedName = oldName;\n                throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorConfigNameInUse, name));\n            }\n        }\n    }\n\n    /**\n     * Changes the location of the Checkstyle configuration file.\n     *\n     * @param location the new location of Checkstyle configuration file\n     * @throws CheckstylePluginException if location is <code>null</code> or\n     *             empty or the Checkstyle configuration file cannot be resolved\n     */\n    public void setLocation(String location) throws CheckstylePluginException {\n        if (location == null || location.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorLocationEmpty);\n        }\n        String oldLocation = getLocation();\n        if (!location.equals(oldLocation)) {\n            try {\n                mEditedLocation = location;\n                // test if configuration file exists\n                getCheckstyleConfiguration();\n            } catch (Exception e) {\n                mEditedLocation = oldLocation;\n                CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorResolveConfigLocation, location, e.getLocalizedMessage()));\n            }\n        }\n    }\n\n    /**\n     * Sets a new description for the check configuration.\n     *\n     * @param description the new description\n     */\n    public void setDescription(String description) {\n        String oldDescription = getDescription();\n        if (description == null || !description.equals(oldDescription)) {\n            mEditedDescription = description;\n        }\n    }\n\n    /**\n     * Flags if the working copy changed compared to the original check\n     * configuration and needs to be saved.\n     *\n     * @return <code>true</code> if the working copy has changes over the\n     *         original check configuration\n     */\n    public boolean isDirty() {\n        return !this.equals(mCheckConfiguration);\n    }\n\n    /**\n     * Determines if the checkstyle configuration of this working copy changed.\n     * This is used to determine if specific projects need to rebuild\n     * afterwards.\n     *\n     * @return <code>true</code> if the checkstyle configuration changed.\n     */\n    public boolean hasConfigurationChanged() {\n        return mHasConfigChanged || !(new EqualsBuilder().append(getLocation(), mCheckConfiguration.getLocation()).append(getResolvableProperties(), mCheckConfiguration.getResolvableProperties()).append(getAdditionalData(), mCheckConfiguration.getAdditionalData()).isEquals());\n    }\n\n    /**\n     * Reads the Checkstyle configuration file and builds the list of configured\n     * modules. Elements are of type\n     * <code>com.atlassw.tools.eclipse.checkstyle.config.Module</code>.\n     *\n     * @return the list of configured modules in this Checkstyle configuration\n     * @throws CheckstylePluginException error when reading the Checkstyle\n     *             configuration file\n     */\n    public List getModules() throws CheckstylePluginException {\n        List result = null;\n        InputStream in = null;\n        try {\n            in = getCheckstyleConfiguration().getCheckConfigFileStream();\n            result = ConfigurationReader.read(in);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return result;\n    }\n\n    /**\n     * Stores the (edited) list of modules to the Checkstyle configuration file.\n     *\n     * @param modules the list of modules to store into the Checkstyle\n     *            configuration file\n     * @throws CheckstylePluginException error storing the Checkstyle\n     *             configuration\n     */\n    public void setModules(List modules) throws CheckstylePluginException {\n        OutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            // First write to a byte array outputstream\n            // because otherwise in an error case the original\n            // file would be destroyed\n            byteOut = new ByteArrayOutputStream();\n            ConfigurationWriter.write(byteOut, modules, this);\n            // all went ok, write to the file\n            String configFile = getResolvedConfigurationFileURL().getFile();\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n            // refresh the files if within the workspace\n            // Bug 1251194 - Resource out of sync after performing changes to\n            // config\n            IPath path = new Path(configFile);\n            IFile[] files = CheckstylePlugin.getWorkspace().getRoot().findFilesForLocation(path);\n            for (int i = 0; i < files.length; i++) {\n                try {\n                    files[i].refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());\n                } catch (CoreException e) {\n                    // NOOP - just ignore\n                }\n            }\n            mHasConfigChanged = true;\n            // throw away the cached Checkstyle configurations\n            CheckConfigurationFactory.refresh();\n        } catch (IOException e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    //\n    // Implementation of ICheckConfiguration\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mEditedName != null ? mEditedName : getSourceCheckConfiguration().getName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mEditedDescription != null ? mEditedDescription : getSourceCheckConfiguration().getDescription();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mEditedLocation != null ? mEditedLocation : getSourceCheckConfiguration().getLocation();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return getSourceCheckConfiguration().getType();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        return getType().getCheckstyleConfiguration(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return getType().isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return getType().isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mCheckConfiguration.isGlobal();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        CheckConfigurationWorkingCopy clone = null;\n        try {\n            clone = (CheckConfigurationWorkingCopy) super.clone();\n            clone.mAdditionalData = new HashMap();\n            clone.mAdditionalData.putAll(this.mAdditionalData);\n            clone.mProperties = new ArrayList();\n            Iterator it = this.mProperties.iterator();\n            while (it.hasNext()) {\n                clone.mProperties.add(((ResolvableProperty) it.next()).clone());\n            }\n        } catch (CloneNotSupportedException e) {\n            // this should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationWorkingCopy_2Test.java",
		"test_prompt": "// CheckConfigurationWorkingCopy_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingCopy#isEditable()} method.\n*/\nclass CheckConfigurationWorkingCopy_2Test {"
	},
	{
		"original_code": "// CheckConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * This class acts as wrapper around check configurations to add editing\n * aspects. Check configurations by themself are not editable.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingCopy implements ICheckConfiguration, Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * The source check configuration of the working copy.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * The working set this working copy belongs to.\n     */\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    /**\n     * The edited name of the configuration.\n     */\n    private String mEditedName;\n\n    /**\n     * The edited location of the configuration.\n     */\n    private String mEditedLocation;\n\n    /**\n     * The edited description of the configuration.\n     */\n    private String mEditedDescription;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * The map of additional data for this configuration.\n     */\n    private Map mAdditionalData = new HashMap();\n\n    /**\n     * flags if the configuration is dirty.\n     */\n    private boolean mHasConfigChanged;\n\n    //\n    // constructors\n    //\n    /*\n     * NOTE: the constructors of this class are package-private because they\n     * only should be called from the\n     * ICheckConfigurationWorkingSet#newWorkingCopy methods of the enclosing\n     * working set.\n     */\n    /**\n     * Creates a new working copy from an existing check configuration.\n     *\n     * @param checkConfigToEdit the existing check configuration\n     * @param workingSet the working set this working copy belongs to\n     */\n    public CheckConfigurationWorkingCopy(ICheckConfiguration checkConfigToEdit, ICheckConfigurationWorkingSet workingSet) {\n        mCheckConfiguration = checkConfigToEdit;\n        mWorkingSet = workingSet;\n        mAdditionalData.putAll(checkConfigToEdit.getAdditionalData());\n        List props = checkConfigToEdit.getResolvableProperties();\n        Iterator it = props.iterator();\n        while (it.hasNext()) {\n            mProperties.add(((ResolvableProperty) it.next()).clone());\n        }\n    }\n\n    /**\n     * Creates a working copy for a new check configuration.\n     *\n     * @param configType the type of the new configuration\n     * @param workingSet the working set this working copy belongs to\n     * @param global <code>true</code> if the new configuration is a global\n     *            configuration\n     */\n    public CheckConfigurationWorkingCopy(IConfigurationType configType, ICheckConfigurationWorkingSet workingSet, boolean global) {\n        mWorkingSet = workingSet;\n        mCheckConfiguration = new CheckConfiguration(null, null, null, configType, global, null, null);\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the source check configuration of this working copy.\n     *\n     * @return the source check configuration\n     */\n    public ICheckConfiguration getSourceCheckConfiguration() {\n        return mCheckConfiguration;\n    }\n\n    /**\n     * Changes the name of the check configuration.\n     *\n     * @param name the new name\n     * @throws CheckstylePluginException if name is <code>null</code> or empty\n     *             or a name collision with an existing check configuration\n     *             exists\n     */\n    public void setName(String name) throws CheckstylePluginException {\n        if (name == null || name.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorConfigNameEmpty);\n        }\n        String oldName = getName();\n        if (!name.equals(oldName)) {\n            mEditedName = name;\n            // Check if the new name is in use\n            if (mWorkingSet.isNameCollision(this)) {\n                mEditedName = oldName;\n                throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorConfigNameInUse, name));\n            }\n        }\n    }\n\n    /**\n     * Changes the location of the Checkstyle configuration file.\n     *\n     * @param location the new location of Checkstyle configuration file\n     * @throws CheckstylePluginException if location is <code>null</code> or\n     *             empty or the Checkstyle configuration file cannot be resolved\n     */\n    public void setLocation(String location) throws CheckstylePluginException {\n        if (location == null || location.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorLocationEmpty);\n        }\n        String oldLocation = getLocation();\n        if (!location.equals(oldLocation)) {\n            try {\n                mEditedLocation = location;\n                // test if configuration file exists\n                getCheckstyleConfiguration();\n            } catch (Exception e) {\n                mEditedLocation = oldLocation;\n                CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorResolveConfigLocation, location, e.getLocalizedMessage()));\n            }\n        }\n    }\n\n    /**\n     * Sets a new description for the check configuration.\n     *\n     * @param description the new description\n     */\n    public void setDescription(String description) {\n        String oldDescription = getDescription();\n        if (description == null || !description.equals(oldDescription)) {\n            mEditedDescription = description;\n        }\n    }\n\n    /**\n     * Flags if the working copy changed compared to the original check\n     * configuration and needs to be saved.\n     *\n     * @return <code>true</code> if the working copy has changes over the\n     *         original check configuration\n     */\n    public boolean isDirty() {\n        return !this.equals(mCheckConfiguration);\n    }\n\n    /**\n     * Determines if the checkstyle configuration of this working copy changed.\n     * This is used to determine if specific projects need to rebuild\n     * afterwards.\n     *\n     * @return <code>true</code> if the checkstyle configuration changed.\n     */\n    public boolean hasConfigurationChanged() {\n        return mHasConfigChanged || !(new EqualsBuilder().append(getLocation(), mCheckConfiguration.getLocation()).append(getResolvableProperties(), mCheckConfiguration.getResolvableProperties()).append(getAdditionalData(), mCheckConfiguration.getAdditionalData()).isEquals());\n    }\n\n    /**\n     * Reads the Checkstyle configuration file and builds the list of configured\n     * modules. Elements are of type\n     * <code>com.atlassw.tools.eclipse.checkstyle.config.Module</code>.\n     *\n     * @return the list of configured modules in this Checkstyle configuration\n     * @throws CheckstylePluginException error when reading the Checkstyle\n     *             configuration file\n     */\n    public List getModules() throws CheckstylePluginException {\n        List result = null;\n        InputStream in = null;\n        try {\n            in = getCheckstyleConfiguration().getCheckConfigFileStream();\n            result = ConfigurationReader.read(in);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return result;\n    }\n\n    /**\n     * Stores the (edited) list of modules to the Checkstyle configuration file.\n     *\n     * @param modules the list of modules to store into the Checkstyle\n     *            configuration file\n     * @throws CheckstylePluginException error storing the Checkstyle\n     *             configuration\n     */\n    public void setModules(List modules) throws CheckstylePluginException {\n        OutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            // First write to a byte array outputstream\n            // because otherwise in an error case the original\n            // file would be destroyed\n            byteOut = new ByteArrayOutputStream();\n            ConfigurationWriter.write(byteOut, modules, this);\n            // all went ok, write to the file\n            String configFile = getResolvedConfigurationFileURL().getFile();\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n            // refresh the files if within the workspace\n            // Bug 1251194 - Resource out of sync after performing changes to\n            // config\n            IPath path = new Path(configFile);\n            IFile[] files = CheckstylePlugin.getWorkspace().getRoot().findFilesForLocation(path);\n            for (int i = 0; i < files.length; i++) {\n                try {\n                    files[i].refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());\n                } catch (CoreException e) {\n                    // NOOP - just ignore\n                }\n            }\n            mHasConfigChanged = true;\n            // throw away the cached Checkstyle configurations\n            CheckConfigurationFactory.refresh();\n        } catch (IOException e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    //\n    // Implementation of ICheckConfiguration\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mEditedName != null ? mEditedName : getSourceCheckConfiguration().getName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mEditedDescription != null ? mEditedDescription : getSourceCheckConfiguration().getDescription();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mEditedLocation != null ? mEditedLocation : getSourceCheckConfiguration().getLocation();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return getSourceCheckConfiguration().getType();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        return getType().getCheckstyleConfiguration(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return getType().isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return getType().isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mCheckConfiguration.isGlobal();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        CheckConfigurationWorkingCopy clone = null;\n        try {\n            clone = (CheckConfigurationWorkingCopy) super.clone();\n            clone.mAdditionalData = new HashMap();\n            clone.mAdditionalData.putAll(this.mAdditionalData);\n            clone.mProperties = new ArrayList();\n            Iterator it = this.mProperties.iterator();\n            while (it.hasNext()) {\n                clone.mProperties.add(((ResolvableProperty) it.next()).clone());\n            }\n        } catch (CloneNotSupportedException e) {\n            // this should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationWorkingCopy_3Test.java",
		"test_prompt": "// CheckConfigurationWorkingCopy_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingCopy#isConfigurable()} method.\n*/\nclass CheckConfigurationWorkingCopy_3Test {"
	},
	{
		"original_code": "// CheckConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * This class acts as wrapper around check configurations to add editing\n * aspects. Check configurations by themself are not editable.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingCopy implements ICheckConfiguration, Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * The source check configuration of the working copy.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * The working set this working copy belongs to.\n     */\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    /**\n     * The edited name of the configuration.\n     */\n    private String mEditedName;\n\n    /**\n     * The edited location of the configuration.\n     */\n    private String mEditedLocation;\n\n    /**\n     * The edited description of the configuration.\n     */\n    private String mEditedDescription;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * The map of additional data for this configuration.\n     */\n    private Map mAdditionalData = new HashMap();\n\n    /**\n     * flags if the configuration is dirty.\n     */\n    private boolean mHasConfigChanged;\n\n    //\n    // constructors\n    //\n    /*\n     * NOTE: the constructors of this class are package-private because they\n     * only should be called from the\n     * ICheckConfigurationWorkingSet#newWorkingCopy methods of the enclosing\n     * working set.\n     */\n    /**\n     * Creates a new working copy from an existing check configuration.\n     *\n     * @param checkConfigToEdit the existing check configuration\n     * @param workingSet the working set this working copy belongs to\n     */\n    public CheckConfigurationWorkingCopy(ICheckConfiguration checkConfigToEdit, ICheckConfigurationWorkingSet workingSet) {\n        mCheckConfiguration = checkConfigToEdit;\n        mWorkingSet = workingSet;\n        mAdditionalData.putAll(checkConfigToEdit.getAdditionalData());\n        List props = checkConfigToEdit.getResolvableProperties();\n        Iterator it = props.iterator();\n        while (it.hasNext()) {\n            mProperties.add(((ResolvableProperty) it.next()).clone());\n        }\n    }\n\n    /**\n     * Creates a working copy for a new check configuration.\n     *\n     * @param configType the type of the new configuration\n     * @param workingSet the working set this working copy belongs to\n     * @param global <code>true</code> if the new configuration is a global\n     *            configuration\n     */\n    public CheckConfigurationWorkingCopy(IConfigurationType configType, ICheckConfigurationWorkingSet workingSet, boolean global) {\n        mWorkingSet = workingSet;\n        mCheckConfiguration = new CheckConfiguration(null, null, null, configType, global, null, null);\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the source check configuration of this working copy.\n     *\n     * @return the source check configuration\n     */\n    public ICheckConfiguration getSourceCheckConfiguration() {\n        return mCheckConfiguration;\n    }\n\n    /**\n     * Changes the name of the check configuration.\n     *\n     * @param name the new name\n     * @throws CheckstylePluginException if name is <code>null</code> or empty\n     *             or a name collision with an existing check configuration\n     *             exists\n     */\n    public void setName(String name) throws CheckstylePluginException {\n        if (name == null || name.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorConfigNameEmpty);\n        }\n        String oldName = getName();\n        if (!name.equals(oldName)) {\n            mEditedName = name;\n            // Check if the new name is in use\n            if (mWorkingSet.isNameCollision(this)) {\n                mEditedName = oldName;\n                throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorConfigNameInUse, name));\n            }\n        }\n    }\n\n    /**\n     * Changes the location of the Checkstyle configuration file.\n     *\n     * @param location the new location of Checkstyle configuration file\n     * @throws CheckstylePluginException if location is <code>null</code> or\n     *             empty or the Checkstyle configuration file cannot be resolved\n     */\n    public void setLocation(String location) throws CheckstylePluginException {\n        if (location == null || location.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorLocationEmpty);\n        }\n        String oldLocation = getLocation();\n        if (!location.equals(oldLocation)) {\n            try {\n                mEditedLocation = location;\n                // test if configuration file exists\n                getCheckstyleConfiguration();\n            } catch (Exception e) {\n                mEditedLocation = oldLocation;\n                CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorResolveConfigLocation, location, e.getLocalizedMessage()));\n            }\n        }\n    }\n\n    /**\n     * Sets a new description for the check configuration.\n     *\n     * @param description the new description\n     */\n    public void setDescription(String description) {\n        String oldDescription = getDescription();\n        if (description == null || !description.equals(oldDescription)) {\n            mEditedDescription = description;\n        }\n    }\n\n    /**\n     * Flags if the working copy changed compared to the original check\n     * configuration and needs to be saved.\n     *\n     * @return <code>true</code> if the working copy has changes over the\n     *         original check configuration\n     */\n    public boolean isDirty() {\n        return !this.equals(mCheckConfiguration);\n    }\n\n    /**\n     * Determines if the checkstyle configuration of this working copy changed.\n     * This is used to determine if specific projects need to rebuild\n     * afterwards.\n     *\n     * @return <code>true</code> if the checkstyle configuration changed.\n     */\n    public boolean hasConfigurationChanged() {\n        return mHasConfigChanged || !(new EqualsBuilder().append(getLocation(), mCheckConfiguration.getLocation()).append(getResolvableProperties(), mCheckConfiguration.getResolvableProperties()).append(getAdditionalData(), mCheckConfiguration.getAdditionalData()).isEquals());\n    }\n\n    /**\n     * Reads the Checkstyle configuration file and builds the list of configured\n     * modules. Elements are of type\n     * <code>com.atlassw.tools.eclipse.checkstyle.config.Module</code>.\n     *\n     * @return the list of configured modules in this Checkstyle configuration\n     * @throws CheckstylePluginException error when reading the Checkstyle\n     *             configuration file\n     */\n    public List getModules() throws CheckstylePluginException {\n        List result = null;\n        InputStream in = null;\n        try {\n            in = getCheckstyleConfiguration().getCheckConfigFileStream();\n            result = ConfigurationReader.read(in);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return result;\n    }\n\n    /**\n     * Stores the (edited) list of modules to the Checkstyle configuration file.\n     *\n     * @param modules the list of modules to store into the Checkstyle\n     *            configuration file\n     * @throws CheckstylePluginException error storing the Checkstyle\n     *             configuration\n     */\n    public void setModules(List modules) throws CheckstylePluginException {\n        OutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            // First write to a byte array outputstream\n            // because otherwise in an error case the original\n            // file would be destroyed\n            byteOut = new ByteArrayOutputStream();\n            ConfigurationWriter.write(byteOut, modules, this);\n            // all went ok, write to the file\n            String configFile = getResolvedConfigurationFileURL().getFile();\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n            // refresh the files if within the workspace\n            // Bug 1251194 - Resource out of sync after performing changes to\n            // config\n            IPath path = new Path(configFile);\n            IFile[] files = CheckstylePlugin.getWorkspace().getRoot().findFilesForLocation(path);\n            for (int i = 0; i < files.length; i++) {\n                try {\n                    files[i].refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());\n                } catch (CoreException e) {\n                    // NOOP - just ignore\n                }\n            }\n            mHasConfigChanged = true;\n            // throw away the cached Checkstyle configurations\n            CheckConfigurationFactory.refresh();\n        } catch (IOException e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    //\n    // Implementation of ICheckConfiguration\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mEditedName != null ? mEditedName : getSourceCheckConfiguration().getName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mEditedDescription != null ? mEditedDescription : getSourceCheckConfiguration().getDescription();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mEditedLocation != null ? mEditedLocation : getSourceCheckConfiguration().getLocation();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return getSourceCheckConfiguration().getType();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        return getType().getCheckstyleConfiguration(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return getType().isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return getType().isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mCheckConfiguration.isGlobal();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        CheckConfigurationWorkingCopy clone = null;\n        try {\n            clone = (CheckConfigurationWorkingCopy) super.clone();\n            clone.mAdditionalData = new HashMap();\n            clone.mAdditionalData.putAll(this.mAdditionalData);\n            clone.mProperties = new ArrayList();\n            Iterator it = this.mProperties.iterator();\n            while (it.hasNext()) {\n                clone.mProperties.add(((ResolvableProperty) it.next()).clone());\n            }\n        } catch (CloneNotSupportedException e) {\n            // this should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationWorkingCopy_4Test.java",
		"test_prompt": "// CheckConfigurationWorkingCopy_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingCopy#isGlobal()} method.\n*/\nclass CheckConfigurationWorkingCopy_4Test {"
	},
	{
		"original_code": "// CheckConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * This class acts as wrapper around check configurations to add editing\n * aspects. Check configurations by themself are not editable.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingCopy implements ICheckConfiguration, Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * The source check configuration of the working copy.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * The working set this working copy belongs to.\n     */\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    /**\n     * The edited name of the configuration.\n     */\n    private String mEditedName;\n\n    /**\n     * The edited location of the configuration.\n     */\n    private String mEditedLocation;\n\n    /**\n     * The edited description of the configuration.\n     */\n    private String mEditedDescription;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * The map of additional data for this configuration.\n     */\n    private Map mAdditionalData = new HashMap();\n\n    /**\n     * flags if the configuration is dirty.\n     */\n    private boolean mHasConfigChanged;\n\n    //\n    // constructors\n    //\n    /*\n     * NOTE: the constructors of this class are package-private because they\n     * only should be called from the\n     * ICheckConfigurationWorkingSet#newWorkingCopy methods of the enclosing\n     * working set.\n     */\n    /**\n     * Creates a new working copy from an existing check configuration.\n     *\n     * @param checkConfigToEdit the existing check configuration\n     * @param workingSet the working set this working copy belongs to\n     */\n    public CheckConfigurationWorkingCopy(ICheckConfiguration checkConfigToEdit, ICheckConfigurationWorkingSet workingSet) {\n        mCheckConfiguration = checkConfigToEdit;\n        mWorkingSet = workingSet;\n        mAdditionalData.putAll(checkConfigToEdit.getAdditionalData());\n        List props = checkConfigToEdit.getResolvableProperties();\n        Iterator it = props.iterator();\n        while (it.hasNext()) {\n            mProperties.add(((ResolvableProperty) it.next()).clone());\n        }\n    }\n\n    /**\n     * Creates a working copy for a new check configuration.\n     *\n     * @param configType the type of the new configuration\n     * @param workingSet the working set this working copy belongs to\n     * @param global <code>true</code> if the new configuration is a global\n     *            configuration\n     */\n    public CheckConfigurationWorkingCopy(IConfigurationType configType, ICheckConfigurationWorkingSet workingSet, boolean global) {\n        mWorkingSet = workingSet;\n        mCheckConfiguration = new CheckConfiguration(null, null, null, configType, global, null, null);\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the source check configuration of this working copy.\n     *\n     * @return the source check configuration\n     */\n    public ICheckConfiguration getSourceCheckConfiguration() {\n        return mCheckConfiguration;\n    }\n\n    /**\n     * Changes the name of the check configuration.\n     *\n     * @param name the new name\n     * @throws CheckstylePluginException if name is <code>null</code> or empty\n     *             or a name collision with an existing check configuration\n     *             exists\n     */\n    public void setName(String name) throws CheckstylePluginException {\n        if (name == null || name.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorConfigNameEmpty);\n        }\n        String oldName = getName();\n        if (!name.equals(oldName)) {\n            mEditedName = name;\n            // Check if the new name is in use\n            if (mWorkingSet.isNameCollision(this)) {\n                mEditedName = oldName;\n                throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorConfigNameInUse, name));\n            }\n        }\n    }\n\n    /**\n     * Changes the location of the Checkstyle configuration file.\n     *\n     * @param location the new location of Checkstyle configuration file\n     * @throws CheckstylePluginException if location is <code>null</code> or\n     *             empty or the Checkstyle configuration file cannot be resolved\n     */\n    public void setLocation(String location) throws CheckstylePluginException {\n        if (location == null || location.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorLocationEmpty);\n        }\n        String oldLocation = getLocation();\n        if (!location.equals(oldLocation)) {\n            try {\n                mEditedLocation = location;\n                // test if configuration file exists\n                getCheckstyleConfiguration();\n            } catch (Exception e) {\n                mEditedLocation = oldLocation;\n                CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorResolveConfigLocation, location, e.getLocalizedMessage()));\n            }\n        }\n    }\n\n    /**\n     * Sets a new description for the check configuration.\n     *\n     * @param description the new description\n     */\n    public void setDescription(String description) {\n        String oldDescription = getDescription();\n        if (description == null || !description.equals(oldDescription)) {\n            mEditedDescription = description;\n        }\n    }\n\n    /**\n     * Flags if the working copy changed compared to the original check\n     * configuration and needs to be saved.\n     *\n     * @return <code>true</code> if the working copy has changes over the\n     *         original check configuration\n     */\n    public boolean isDirty() {\n        return !this.equals(mCheckConfiguration);\n    }\n\n    /**\n     * Determines if the checkstyle configuration of this working copy changed.\n     * This is used to determine if specific projects need to rebuild\n     * afterwards.\n     *\n     * @return <code>true</code> if the checkstyle configuration changed.\n     */\n    public boolean hasConfigurationChanged() {\n        return mHasConfigChanged || !(new EqualsBuilder().append(getLocation(), mCheckConfiguration.getLocation()).append(getResolvableProperties(), mCheckConfiguration.getResolvableProperties()).append(getAdditionalData(), mCheckConfiguration.getAdditionalData()).isEquals());\n    }\n\n    /**\n     * Reads the Checkstyle configuration file and builds the list of configured\n     * modules. Elements are of type\n     * <code>com.atlassw.tools.eclipse.checkstyle.config.Module</code>.\n     *\n     * @return the list of configured modules in this Checkstyle configuration\n     * @throws CheckstylePluginException error when reading the Checkstyle\n     *             configuration file\n     */\n    public List getModules() throws CheckstylePluginException {\n        List result = null;\n        InputStream in = null;\n        try {\n            in = getCheckstyleConfiguration().getCheckConfigFileStream();\n            result = ConfigurationReader.read(in);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return result;\n    }\n\n    /**\n     * Stores the (edited) list of modules to the Checkstyle configuration file.\n     *\n     * @param modules the list of modules to store into the Checkstyle\n     *            configuration file\n     * @throws CheckstylePluginException error storing the Checkstyle\n     *             configuration\n     */\n    public void setModules(List modules) throws CheckstylePluginException {\n        OutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            // First write to a byte array outputstream\n            // because otherwise in an error case the original\n            // file would be destroyed\n            byteOut = new ByteArrayOutputStream();\n            ConfigurationWriter.write(byteOut, modules, this);\n            // all went ok, write to the file\n            String configFile = getResolvedConfigurationFileURL().getFile();\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n            // refresh the files if within the workspace\n            // Bug 1251194 - Resource out of sync after performing changes to\n            // config\n            IPath path = new Path(configFile);\n            IFile[] files = CheckstylePlugin.getWorkspace().getRoot().findFilesForLocation(path);\n            for (int i = 0; i < files.length; i++) {\n                try {\n                    files[i].refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());\n                } catch (CoreException e) {\n                    // NOOP - just ignore\n                }\n            }\n            mHasConfigChanged = true;\n            // throw away the cached Checkstyle configurations\n            CheckConfigurationFactory.refresh();\n        } catch (IOException e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    //\n    // Implementation of ICheckConfiguration\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mEditedName != null ? mEditedName : getSourceCheckConfiguration().getName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mEditedDescription != null ? mEditedDescription : getSourceCheckConfiguration().getDescription();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mEditedLocation != null ? mEditedLocation : getSourceCheckConfiguration().getLocation();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return getSourceCheckConfiguration().getType();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        return getType().getCheckstyleConfiguration(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return getType().isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return getType().isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mCheckConfiguration.isGlobal();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        CheckConfigurationWorkingCopy clone = null;\n        try {\n            clone = (CheckConfigurationWorkingCopy) super.clone();\n            clone.mAdditionalData = new HashMap();\n            clone.mAdditionalData.putAll(this.mAdditionalData);\n            clone.mProperties = new ArrayList();\n            Iterator it = this.mProperties.iterator();\n            while (it.hasNext()) {\n                clone.mProperties.add(((ResolvableProperty) it.next()).clone());\n            }\n        } catch (CloneNotSupportedException e) {\n            // this should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationWorkingCopy_5Test.java",
		"test_prompt": "// CheckConfigurationWorkingCopy_5Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingCopy#equals(Object)} method.\n*/\nclass CheckConfigurationWorkingCopy_5Test {"
	},
	{
		"original_code": "// CheckConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * This class acts as wrapper around check configurations to add editing\n * aspects. Check configurations by themself are not editable.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingCopy implements ICheckConfiguration, Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * The source check configuration of the working copy.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * The working set this working copy belongs to.\n     */\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    /**\n     * The edited name of the configuration.\n     */\n    private String mEditedName;\n\n    /**\n     * The edited location of the configuration.\n     */\n    private String mEditedLocation;\n\n    /**\n     * The edited description of the configuration.\n     */\n    private String mEditedDescription;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * The map of additional data for this configuration.\n     */\n    private Map mAdditionalData = new HashMap();\n\n    /**\n     * flags if the configuration is dirty.\n     */\n    private boolean mHasConfigChanged;\n\n    //\n    // constructors\n    //\n    /*\n     * NOTE: the constructors of this class are package-private because they\n     * only should be called from the\n     * ICheckConfigurationWorkingSet#newWorkingCopy methods of the enclosing\n     * working set.\n     */\n    /**\n     * Creates a new working copy from an existing check configuration.\n     *\n     * @param checkConfigToEdit the existing check configuration\n     * @param workingSet the working set this working copy belongs to\n     */\n    public CheckConfigurationWorkingCopy(ICheckConfiguration checkConfigToEdit, ICheckConfigurationWorkingSet workingSet) {\n        mCheckConfiguration = checkConfigToEdit;\n        mWorkingSet = workingSet;\n        mAdditionalData.putAll(checkConfigToEdit.getAdditionalData());\n        List props = checkConfigToEdit.getResolvableProperties();\n        Iterator it = props.iterator();\n        while (it.hasNext()) {\n            mProperties.add(((ResolvableProperty) it.next()).clone());\n        }\n    }\n\n    /**\n     * Creates a working copy for a new check configuration.\n     *\n     * @param configType the type of the new configuration\n     * @param workingSet the working set this working copy belongs to\n     * @param global <code>true</code> if the new configuration is a global\n     *            configuration\n     */\n    public CheckConfigurationWorkingCopy(IConfigurationType configType, ICheckConfigurationWorkingSet workingSet, boolean global) {\n        mWorkingSet = workingSet;\n        mCheckConfiguration = new CheckConfiguration(null, null, null, configType, global, null, null);\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the source check configuration of this working copy.\n     *\n     * @return the source check configuration\n     */\n    public ICheckConfiguration getSourceCheckConfiguration() {\n        return mCheckConfiguration;\n    }\n\n    /**\n     * Changes the name of the check configuration.\n     *\n     * @param name the new name\n     * @throws CheckstylePluginException if name is <code>null</code> or empty\n     *             or a name collision with an existing check configuration\n     *             exists\n     */\n    public void setName(String name) throws CheckstylePluginException {\n        if (name == null || name.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorConfigNameEmpty);\n        }\n        String oldName = getName();\n        if (!name.equals(oldName)) {\n            mEditedName = name;\n            // Check if the new name is in use\n            if (mWorkingSet.isNameCollision(this)) {\n                mEditedName = oldName;\n                throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorConfigNameInUse, name));\n            }\n        }\n    }\n\n    /**\n     * Changes the location of the Checkstyle configuration file.\n     *\n     * @param location the new location of Checkstyle configuration file\n     * @throws CheckstylePluginException if location is <code>null</code> or\n     *             empty or the Checkstyle configuration file cannot be resolved\n     */\n    public void setLocation(String location) throws CheckstylePluginException {\n        if (location == null || location.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorLocationEmpty);\n        }\n        String oldLocation = getLocation();\n        if (!location.equals(oldLocation)) {\n            try {\n                mEditedLocation = location;\n                // test if configuration file exists\n                getCheckstyleConfiguration();\n            } catch (Exception e) {\n                mEditedLocation = oldLocation;\n                CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorResolveConfigLocation, location, e.getLocalizedMessage()));\n            }\n        }\n    }\n\n    /**\n     * Sets a new description for the check configuration.\n     *\n     * @param description the new description\n     */\n    public void setDescription(String description) {\n        String oldDescription = getDescription();\n        if (description == null || !description.equals(oldDescription)) {\n            mEditedDescription = description;\n        }\n    }\n\n    /**\n     * Flags if the working copy changed compared to the original check\n     * configuration and needs to be saved.\n     *\n     * @return <code>true</code> if the working copy has changes over the\n     *         original check configuration\n     */\n    public boolean isDirty() {\n        return !this.equals(mCheckConfiguration);\n    }\n\n    /**\n     * Determines if the checkstyle configuration of this working copy changed.\n     * This is used to determine if specific projects need to rebuild\n     * afterwards.\n     *\n     * @return <code>true</code> if the checkstyle configuration changed.\n     */\n    public boolean hasConfigurationChanged() {\n        return mHasConfigChanged || !(new EqualsBuilder().append(getLocation(), mCheckConfiguration.getLocation()).append(getResolvableProperties(), mCheckConfiguration.getResolvableProperties()).append(getAdditionalData(), mCheckConfiguration.getAdditionalData()).isEquals());\n    }\n\n    /**\n     * Reads the Checkstyle configuration file and builds the list of configured\n     * modules. Elements are of type\n     * <code>com.atlassw.tools.eclipse.checkstyle.config.Module</code>.\n     *\n     * @return the list of configured modules in this Checkstyle configuration\n     * @throws CheckstylePluginException error when reading the Checkstyle\n     *             configuration file\n     */\n    public List getModules() throws CheckstylePluginException {\n        List result = null;\n        InputStream in = null;\n        try {\n            in = getCheckstyleConfiguration().getCheckConfigFileStream();\n            result = ConfigurationReader.read(in);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return result;\n    }\n\n    /**\n     * Stores the (edited) list of modules to the Checkstyle configuration file.\n     *\n     * @param modules the list of modules to store into the Checkstyle\n     *            configuration file\n     * @throws CheckstylePluginException error storing the Checkstyle\n     *             configuration\n     */\n    public void setModules(List modules) throws CheckstylePluginException {\n        OutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            // First write to a byte array outputstream\n            // because otherwise in an error case the original\n            // file would be destroyed\n            byteOut = new ByteArrayOutputStream();\n            ConfigurationWriter.write(byteOut, modules, this);\n            // all went ok, write to the file\n            String configFile = getResolvedConfigurationFileURL().getFile();\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n            // refresh the files if within the workspace\n            // Bug 1251194 - Resource out of sync after performing changes to\n            // config\n            IPath path = new Path(configFile);\n            IFile[] files = CheckstylePlugin.getWorkspace().getRoot().findFilesForLocation(path);\n            for (int i = 0; i < files.length; i++) {\n                try {\n                    files[i].refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());\n                } catch (CoreException e) {\n                    // NOOP - just ignore\n                }\n            }\n            mHasConfigChanged = true;\n            // throw away the cached Checkstyle configurations\n            CheckConfigurationFactory.refresh();\n        } catch (IOException e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    //\n    // Implementation of ICheckConfiguration\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mEditedName != null ? mEditedName : getSourceCheckConfiguration().getName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mEditedDescription != null ? mEditedDescription : getSourceCheckConfiguration().getDescription();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mEditedLocation != null ? mEditedLocation : getSourceCheckConfiguration().getLocation();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return getSourceCheckConfiguration().getType();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        return getType().getCheckstyleConfiguration(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return getType().isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return getType().isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mCheckConfiguration.isGlobal();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        CheckConfigurationWorkingCopy clone = null;\n        try {\n            clone = (CheckConfigurationWorkingCopy) super.clone();\n            clone.mAdditionalData = new HashMap();\n            clone.mAdditionalData.putAll(this.mAdditionalData);\n            clone.mProperties = new ArrayList();\n            Iterator it = this.mProperties.iterator();\n            while (it.hasNext()) {\n                clone.mProperties.add(((ResolvableProperty) it.next()).clone());\n            }\n        } catch (CloneNotSupportedException e) {\n            // this should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationWorkingCopy_6Test.java",
		"test_prompt": "// CheckConfigurationWorkingCopy_6Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingCopy#hashCode()} method.\n*/\nclass CheckConfigurationWorkingCopy_6Test {"
	},
	{
		"original_code": "// CheckConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * This class acts as wrapper around check configurations to add editing\n * aspects. Check configurations by themself are not editable.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingCopy implements ICheckConfiguration, Cloneable {\n\n    //\n    // attributes\n    //\n    /**\n     * The source check configuration of the working copy.\n     */\n    private ICheckConfiguration mCheckConfiguration;\n\n    /**\n     * The working set this working copy belongs to.\n     */\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    /**\n     * The edited name of the configuration.\n     */\n    private String mEditedName;\n\n    /**\n     * The edited location of the configuration.\n     */\n    private String mEditedLocation;\n\n    /**\n     * The edited description of the configuration.\n     */\n    private String mEditedDescription;\n\n    /**\n     * The list of resolvable properties.\n     */\n    private List mProperties = new ArrayList();\n\n    /**\n     * The map of additional data for this configuration.\n     */\n    private Map mAdditionalData = new HashMap();\n\n    /**\n     * flags if the configuration is dirty.\n     */\n    private boolean mHasConfigChanged;\n\n    //\n    // constructors\n    //\n    /*\n     * NOTE: the constructors of this class are package-private because they\n     * only should be called from the\n     * ICheckConfigurationWorkingSet#newWorkingCopy methods of the enclosing\n     * working set.\n     */\n    /**\n     * Creates a new working copy from an existing check configuration.\n     *\n     * @param checkConfigToEdit the existing check configuration\n     * @param workingSet the working set this working copy belongs to\n     */\n    public CheckConfigurationWorkingCopy(ICheckConfiguration checkConfigToEdit, ICheckConfigurationWorkingSet workingSet) {\n        mCheckConfiguration = checkConfigToEdit;\n        mWorkingSet = workingSet;\n        mAdditionalData.putAll(checkConfigToEdit.getAdditionalData());\n        List props = checkConfigToEdit.getResolvableProperties();\n        Iterator it = props.iterator();\n        while (it.hasNext()) {\n            mProperties.add(((ResolvableProperty) it.next()).clone());\n        }\n    }\n\n    /**\n     * Creates a working copy for a new check configuration.\n     *\n     * @param configType the type of the new configuration\n     * @param workingSet the working set this working copy belongs to\n     * @param global <code>true</code> if the new configuration is a global\n     *            configuration\n     */\n    public CheckConfigurationWorkingCopy(IConfigurationType configType, ICheckConfigurationWorkingSet workingSet, boolean global) {\n        mWorkingSet = workingSet;\n        mCheckConfiguration = new CheckConfiguration(null, null, null, configType, global, null, null);\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the source check configuration of this working copy.\n     *\n     * @return the source check configuration\n     */\n    public ICheckConfiguration getSourceCheckConfiguration() {\n        return mCheckConfiguration;\n    }\n\n    /**\n     * Changes the name of the check configuration.\n     *\n     * @param name the new name\n     * @throws CheckstylePluginException if name is <code>null</code> or empty\n     *             or a name collision with an existing check configuration\n     *             exists\n     */\n    public void setName(String name) throws CheckstylePluginException {\n        if (name == null || name.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorConfigNameEmpty);\n        }\n        String oldName = getName();\n        if (!name.equals(oldName)) {\n            mEditedName = name;\n            // Check if the new name is in use\n            if (mWorkingSet.isNameCollision(this)) {\n                mEditedName = oldName;\n                throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorConfigNameInUse, name));\n            }\n        }\n    }\n\n    /**\n     * Changes the location of the Checkstyle configuration file.\n     *\n     * @param location the new location of Checkstyle configuration file\n     * @throws CheckstylePluginException if location is <code>null</code> or\n     *             empty or the Checkstyle configuration file cannot be resolved\n     */\n    public void setLocation(String location) throws CheckstylePluginException {\n        if (location == null || location.trim().length() == 0) {\n            throw new CheckstylePluginException(ErrorMessages.errorLocationEmpty);\n        }\n        String oldLocation = getLocation();\n        if (!location.equals(oldLocation)) {\n            try {\n                mEditedLocation = location;\n                // test if configuration file exists\n                getCheckstyleConfiguration();\n            } catch (Exception e) {\n                mEditedLocation = oldLocation;\n                CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorResolveConfigLocation, location, e.getLocalizedMessage()));\n            }\n        }\n    }\n\n    /**\n     * Sets a new description for the check configuration.\n     *\n     * @param description the new description\n     */\n    public void setDescription(String description) {\n        String oldDescription = getDescription();\n        if (description == null || !description.equals(oldDescription)) {\n            mEditedDescription = description;\n        }\n    }\n\n    /**\n     * Flags if the working copy changed compared to the original check\n     * configuration and needs to be saved.\n     *\n     * @return <code>true</code> if the working copy has changes over the\n     *         original check configuration\n     */\n    public boolean isDirty() {\n        return !this.equals(mCheckConfiguration);\n    }\n\n    /**\n     * Determines if the checkstyle configuration of this working copy changed.\n     * This is used to determine if specific projects need to rebuild\n     * afterwards.\n     *\n     * @return <code>true</code> if the checkstyle configuration changed.\n     */\n    public boolean hasConfigurationChanged() {\n        return mHasConfigChanged || !(new EqualsBuilder().append(getLocation(), mCheckConfiguration.getLocation()).append(getResolvableProperties(), mCheckConfiguration.getResolvableProperties()).append(getAdditionalData(), mCheckConfiguration.getAdditionalData()).isEquals());\n    }\n\n    /**\n     * Reads the Checkstyle configuration file and builds the list of configured\n     * modules. Elements are of type\n     * <code>com.atlassw.tools.eclipse.checkstyle.config.Module</code>.\n     *\n     * @return the list of configured modules in this Checkstyle configuration\n     * @throws CheckstylePluginException error when reading the Checkstyle\n     *             configuration file\n     */\n    public List getModules() throws CheckstylePluginException {\n        List result = null;\n        InputStream in = null;\n        try {\n            in = getCheckstyleConfiguration().getCheckConfigFileStream();\n            result = ConfigurationReader.read(in);\n        } finally {\n            IOUtils.closeQuietly(in);\n        }\n        return result;\n    }\n\n    /**\n     * Stores the (edited) list of modules to the Checkstyle configuration file.\n     *\n     * @param modules the list of modules to store into the Checkstyle\n     *            configuration file\n     * @throws CheckstylePluginException error storing the Checkstyle\n     *             configuration\n     */\n    public void setModules(List modules) throws CheckstylePluginException {\n        OutputStream out = null;\n        ByteArrayOutputStream byteOut = null;\n        try {\n            // First write to a byte array outputstream\n            // because otherwise in an error case the original\n            // file would be destroyed\n            byteOut = new ByteArrayOutputStream();\n            ConfigurationWriter.write(byteOut, modules, this);\n            // all went ok, write to the file\n            String configFile = getResolvedConfigurationFileURL().getFile();\n            out = new BufferedOutputStream(new FileOutputStream(configFile));\n            out.write(byteOut.toByteArray());\n            // refresh the files if within the workspace\n            // Bug 1251194 - Resource out of sync after performing changes to\n            // config\n            IPath path = new Path(configFile);\n            IFile[] files = CheckstylePlugin.getWorkspace().getRoot().findFilesForLocation(path);\n            for (int i = 0; i < files.length; i++) {\n                try {\n                    files[i].refreshLocal(IResource.DEPTH_ZERO, new NullProgressMonitor());\n                } catch (CoreException e) {\n                    // NOOP - just ignore\n                }\n            }\n            mHasConfigChanged = true;\n            // throw away the cached Checkstyle configurations\n            CheckConfigurationFactory.refresh();\n        } catch (IOException e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(byteOut);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    //\n    // Implementation of ICheckConfiguration\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public String getName() {\n        return mEditedName != null ? mEditedName : getSourceCheckConfiguration().getName();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getDescription() {\n        return mEditedDescription != null ? mEditedDescription : getSourceCheckConfiguration().getDescription();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getLocation() {\n        return mEditedLocation != null ? mEditedLocation : getSourceCheckConfiguration().getLocation();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IConfigurationType getType() {\n        return getSourceCheckConfiguration().getType();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Map getAdditionalData() {\n        return mAdditionalData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getResolvableProperties() {\n        return mProperties;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResolvedConfigurationFileURL() throws CheckstylePluginException {\n        return getType().getResolvedConfigurationFileURL(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckstyleConfigurationFile getCheckstyleConfiguration() throws CheckstylePluginException {\n        return getType().getCheckstyleConfiguration(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isEditable() {\n        return getType().isEditable();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigurable() {\n        return getType().isConfigurable(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isGlobal() {\n        return mCheckConfiguration.isGlobal();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ICheckConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ICheckConfiguration rhs = (ICheckConfiguration) obj;\n        return new EqualsBuilder().append(getName(), rhs.getName()).append(getLocation(), rhs.getLocation()).append(getDescription(), rhs.getDescription()).append(getType(), rhs.getType()).append(isGlobal(), rhs.isGlobal()).append(getResolvableProperties(), rhs.getResolvableProperties()).append(getAdditionalData(), rhs.getAdditionalData()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(928729, 1000003).append(getName()).append(getLocation()).append(getDescription()).append(getType()).append(isGlobal()).append(getResolvableProperties()).append(getAdditionalData()).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        CheckConfigurationWorkingCopy clone = null;\n        try {\n            clone = (CheckConfigurationWorkingCopy) super.clone();\n            clone.mAdditionalData = new HashMap();\n            clone.mAdditionalData.putAll(this.mAdditionalData);\n            clone.mProperties = new ArrayList();\n            Iterator it = this.mProperties.iterator();\n            while (it.hasNext()) {\n                clone.mProperties.add(((ResolvableProperty) it.next()).clone());\n            }\n        } catch (CloneNotSupportedException e) {\n            // this should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationWorkingCopy_7Test.java",
		"test_prompt": "// CheckConfigurationWorkingCopy_7Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingCopy#clone()} method.\n*/\nclass CheckConfigurationWorkingCopy_7Test {"
	},
	{
		"original_code": "// PropertiesContentAssistProcessor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\n\n/**\n * Provides content assist for builtin properties.\n *\n * @author Lars K�dderitzsch\n */\npublic class PropertiesContentAssistProcessor implements IContentAssistProcessor, ISubjectControlContentAssistProcessor {\n\n    /**\n     * The context information validator.\n     */\n    private IContextInformationValidator mValidator = new SubjectControlContextInformationValidator(this);\n\n    /**\n     * {@inheritDoc}\n     */\n    public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int offset) {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformation[] computeContextInformation(ITextViewer viewer, int offset) {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public char[] getCompletionProposalAutoActivationCharacters() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public char[] getContextInformationAutoActivationCharacters() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getErrorMessage() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformationValidator getContextInformationValidator() {\n        return mValidator;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public ICompletionProposal[] computeCompletionProposals(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        List proposals = new ArrayList();\n        //$NON-NLS-1$\n        String basedir = \"${basedir}\";\n        //$NON-NLS-1$\n        String projectLoc = \"${project_loc}\";\n        //$NON-NLS-1$\n        String workspaceLoc = \"${workspace_loc}\";\n        //$NON-NLS-1$\n        String configLoc = \"${config_loc}\";\n        //$NON-NLS-1$\n        String samedir = \"${samedir}\";\n        // TODO translate the descriptions\n        proposals.add(new CompletionProposal(basedir, documentOffset, 0, basedir.length(), null, basedir, null, Messages.PropertiesContentAssistProcessor_basedir));\n        proposals.add(new CompletionProposal(projectLoc, documentOffset, 0, projectLoc.length(), null, projectLoc, null, Messages.PropertiesContentAssistProcessor_projectLoc));\n        proposals.add(new CompletionProposal(workspaceLoc, documentOffset, 0, workspaceLoc.length(), null, workspaceLoc, null, Messages.PropertiesContentAssistProcessor_workspaceLoc));\n        proposals.add(new CompletionProposal(configLoc, documentOffset, 0, configLoc.length(), null, configLoc, null, Messages.PropertiesContentAssistProcessor_configLoc));\n        proposals.add(new CompletionProposal(samedir, documentOffset, 0, samedir.length(), null, samedir, null, Messages.PropertiesContentAssistProcessor_samedir));\n        return (ICompletionProposal[]) proposals.toArray(new ICompletionProposal[proposals.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformation[] computeContextInformation(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/gui/PropertiesContentAssistProcessor_0Test.java",
		"test_prompt": "// PropertiesContentAssistProcessor_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PropertiesContentAssistProcessor}.\n* It contains ten unit test cases for the {@link PropertiesContentAssistProcessor#computeCompletionProposals(ITextViewer, int)} method.\n*/\nclass PropertiesContentAssistProcessor_0Test {"
	},
	{
		"original_code": "// PropertiesContentAssistProcessor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\n\n/**\n * Provides content assist for builtin properties.\n *\n * @author Lars K�dderitzsch\n */\npublic class PropertiesContentAssistProcessor implements IContentAssistProcessor, ISubjectControlContentAssistProcessor {\n\n    /**\n     * The context information validator.\n     */\n    private IContextInformationValidator mValidator = new SubjectControlContextInformationValidator(this);\n\n    /**\n     * {@inheritDoc}\n     */\n    public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int offset) {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformation[] computeContextInformation(ITextViewer viewer, int offset) {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public char[] getCompletionProposalAutoActivationCharacters() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public char[] getContextInformationAutoActivationCharacters() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getErrorMessage() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformationValidator getContextInformationValidator() {\n        return mValidator;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public ICompletionProposal[] computeCompletionProposals(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        List proposals = new ArrayList();\n        //$NON-NLS-1$\n        String basedir = \"${basedir}\";\n        //$NON-NLS-1$\n        String projectLoc = \"${project_loc}\";\n        //$NON-NLS-1$\n        String workspaceLoc = \"${workspace_loc}\";\n        //$NON-NLS-1$\n        String configLoc = \"${config_loc}\";\n        //$NON-NLS-1$\n        String samedir = \"${samedir}\";\n        // TODO translate the descriptions\n        proposals.add(new CompletionProposal(basedir, documentOffset, 0, basedir.length(), null, basedir, null, Messages.PropertiesContentAssistProcessor_basedir));\n        proposals.add(new CompletionProposal(projectLoc, documentOffset, 0, projectLoc.length(), null, projectLoc, null, Messages.PropertiesContentAssistProcessor_projectLoc));\n        proposals.add(new CompletionProposal(workspaceLoc, documentOffset, 0, workspaceLoc.length(), null, workspaceLoc, null, Messages.PropertiesContentAssistProcessor_workspaceLoc));\n        proposals.add(new CompletionProposal(configLoc, documentOffset, 0, configLoc.length(), null, configLoc, null, Messages.PropertiesContentAssistProcessor_configLoc));\n        proposals.add(new CompletionProposal(samedir, documentOffset, 0, samedir.length(), null, samedir, null, Messages.PropertiesContentAssistProcessor_samedir));\n        return (ICompletionProposal[]) proposals.toArray(new ICompletionProposal[proposals.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformation[] computeContextInformation(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/gui/PropertiesContentAssistProcessor_1Test.java",
		"test_prompt": "// PropertiesContentAssistProcessor_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PropertiesContentAssistProcessor}.\n* It contains ten unit test cases for the {@link PropertiesContentAssistProcessor#computeContextInformation(ITextViewer, int)} method.\n*/\nclass PropertiesContentAssistProcessor_1Test {"
	},
	{
		"original_code": "// PropertiesContentAssistProcessor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\n\n/**\n * Provides content assist for builtin properties.\n *\n * @author Lars K�dderitzsch\n */\npublic class PropertiesContentAssistProcessor implements IContentAssistProcessor, ISubjectControlContentAssistProcessor {\n\n    /**\n     * The context information validator.\n     */\n    private IContextInformationValidator mValidator = new SubjectControlContextInformationValidator(this);\n\n    /**\n     * {@inheritDoc}\n     */\n    public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int offset) {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformation[] computeContextInformation(ITextViewer viewer, int offset) {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public char[] getCompletionProposalAutoActivationCharacters() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public char[] getContextInformationAutoActivationCharacters() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getErrorMessage() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformationValidator getContextInformationValidator() {\n        return mValidator;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public ICompletionProposal[] computeCompletionProposals(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        List proposals = new ArrayList();\n        //$NON-NLS-1$\n        String basedir = \"${basedir}\";\n        //$NON-NLS-1$\n        String projectLoc = \"${project_loc}\";\n        //$NON-NLS-1$\n        String workspaceLoc = \"${workspace_loc}\";\n        //$NON-NLS-1$\n        String configLoc = \"${config_loc}\";\n        //$NON-NLS-1$\n        String samedir = \"${samedir}\";\n        // TODO translate the descriptions\n        proposals.add(new CompletionProposal(basedir, documentOffset, 0, basedir.length(), null, basedir, null, Messages.PropertiesContentAssistProcessor_basedir));\n        proposals.add(new CompletionProposal(projectLoc, documentOffset, 0, projectLoc.length(), null, projectLoc, null, Messages.PropertiesContentAssistProcessor_projectLoc));\n        proposals.add(new CompletionProposal(workspaceLoc, documentOffset, 0, workspaceLoc.length(), null, workspaceLoc, null, Messages.PropertiesContentAssistProcessor_workspaceLoc));\n        proposals.add(new CompletionProposal(configLoc, documentOffset, 0, configLoc.length(), null, configLoc, null, Messages.PropertiesContentAssistProcessor_configLoc));\n        proposals.add(new CompletionProposal(samedir, documentOffset, 0, samedir.length(), null, samedir, null, Messages.PropertiesContentAssistProcessor_samedir));\n        return (ICompletionProposal[]) proposals.toArray(new ICompletionProposal[proposals.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformation[] computeContextInformation(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/gui/PropertiesContentAssistProcessor_2Test.java",
		"test_prompt": "// PropertiesContentAssistProcessor_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PropertiesContentAssistProcessor}.\n* It contains ten unit test cases for the {@link PropertiesContentAssistProcessor#computeCompletionProposals(IContentAssistSubjectControl, int)} method.\n*/\nclass PropertiesContentAssistProcessor_2Test {"
	},
	{
		"original_code": "// PropertiesContentAssistProcessor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\n\n/**\n * Provides content assist for builtin properties.\n *\n * @author Lars K�dderitzsch\n */\npublic class PropertiesContentAssistProcessor implements IContentAssistProcessor, ISubjectControlContentAssistProcessor {\n\n    /**\n     * The context information validator.\n     */\n    private IContextInformationValidator mValidator = new SubjectControlContextInformationValidator(this);\n\n    /**\n     * {@inheritDoc}\n     */\n    public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int offset) {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformation[] computeContextInformation(ITextViewer viewer, int offset) {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public char[] getCompletionProposalAutoActivationCharacters() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public char[] getContextInformationAutoActivationCharacters() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getErrorMessage() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformationValidator getContextInformationValidator() {\n        return mValidator;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public ICompletionProposal[] computeCompletionProposals(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        List proposals = new ArrayList();\n        //$NON-NLS-1$\n        String basedir = \"${basedir}\";\n        //$NON-NLS-1$\n        String projectLoc = \"${project_loc}\";\n        //$NON-NLS-1$\n        String workspaceLoc = \"${workspace_loc}\";\n        //$NON-NLS-1$\n        String configLoc = \"${config_loc}\";\n        //$NON-NLS-1$\n        String samedir = \"${samedir}\";\n        // TODO translate the descriptions\n        proposals.add(new CompletionProposal(basedir, documentOffset, 0, basedir.length(), null, basedir, null, Messages.PropertiesContentAssistProcessor_basedir));\n        proposals.add(new CompletionProposal(projectLoc, documentOffset, 0, projectLoc.length(), null, projectLoc, null, Messages.PropertiesContentAssistProcessor_projectLoc));\n        proposals.add(new CompletionProposal(workspaceLoc, documentOffset, 0, workspaceLoc.length(), null, workspaceLoc, null, Messages.PropertiesContentAssistProcessor_workspaceLoc));\n        proposals.add(new CompletionProposal(configLoc, documentOffset, 0, configLoc.length(), null, configLoc, null, Messages.PropertiesContentAssistProcessor_configLoc));\n        proposals.add(new CompletionProposal(samedir, documentOffset, 0, samedir.length(), null, samedir, null, Messages.PropertiesContentAssistProcessor_samedir));\n        return (ICompletionProposal[]) proposals.toArray(new ICompletionProposal[proposals.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IContextInformation[] computeContextInformation(IContentAssistSubjectControl contentAssistSubjectControl, int documentOffset) {\n        return null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/gui/PropertiesContentAssistProcessor_3Test.java",
		"test_prompt": "// PropertiesContentAssistProcessor_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.jface.contentassist.IContentAssistSubjectControl;\nimport org.eclipse.jface.contentassist.ISubjectControlContentAssistProcessor;\nimport org.eclipse.jface.contentassist.SubjectControlContextInformationValidator;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.contentassist.CompletionProposal;\nimport org.eclipse.jface.text.contentassist.ICompletionProposal;\nimport org.eclipse.jface.text.contentassist.IContentAssistProcessor;\nimport org.eclipse.jface.text.contentassist.IContextInformation;\nimport org.eclipse.jface.text.contentassist.IContextInformationValidator;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PropertiesContentAssistProcessor}.\n* It contains ten unit test cases for the {@link PropertiesContentAssistProcessor#computeContextInformation(IContentAssistSubjectControl, int)} method.\n*/\nclass PropertiesContentAssistProcessor_3Test {"
	},
	{
		"original_code": "// CheckConfigurationWorkingSetEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport org.eclipse.jface.dialogs.IDialogSettings;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.ColumnWeightData;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.ITableLabelProvider;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.viewers.StructuredViewer;\nimport org.eclipse.jface.viewers.TableLayout;\nimport org.eclipse.jface.viewers.TableViewer;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.graphics.Image;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.FileDialog;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Table;\nimport org.eclipse.swt.widgets.TableColumn;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.model.WorkbenchLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.GlobalCheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginImages;\nimport com.atlassw.tools.eclipse.checkstyle.util.table.EnhancedTableViewer;\nimport com.atlassw.tools.eclipse.checkstyle.util.table.ITableComparableProvider;\nimport com.atlassw.tools.eclipse.checkstyle.util.table.ITableSettingsProvider;\n\n/**\n * This class provides the editor GUI for a check configuration working set.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckConfigurationWorkingSetEditor {\n\n    //\n    // attributes\n    //\n    private EnhancedTableViewer mViewer;\n\n    private Button mAddButton;\n\n    private Button mEditButton;\n\n    private Button mConfigureButton;\n\n    private Button mCopyButton;\n\n    private Button mRemoveButton;\n\n    private Button mDefaultButton;\n\n    private Button mExportButton;\n\n    private Text mConfigurationDescription;\n\n    private StructuredViewer mUsageView;\n\n    private PageController mController = new PageController();\n\n    private ICheckConfigurationWorkingSet mWorkingSet;\n\n    private boolean mIsShowUsage;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates the configuration working set editor.\n     *\n     * @param workingSet the configuration working set to edit\n     * @param showUsage determines if the usage area should be shown\n     */\n    public CheckConfigurationWorkingSetEditor(ICheckConfigurationWorkingSet workingSet, boolean showUsage) {\n        mWorkingSet = workingSet;\n        mIsShowUsage = showUsage;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite ancestor) {\n        //\n        // Create the check configuration section of the screen.\n        //\n        Composite configComposite = createCheckConfigContents(ancestor);\n        return configComposite;\n    }\n\n    /**\n     * Creates the content regarding the management of check configurations.\n     *\n     * @param parent the parent composite\n     * @return the configuration area\n     */\n    private Composite createCheckConfigContents(Composite parent) {\n        Composite configComposite = new Composite(parent, SWT.NULL);\n        configComposite.setLayout(new FormLayout());\n        Control rightButtons = createButtonBar(configComposite);\n        FormData fd = new FormData();\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(100);\n        rightButtons.setLayoutData(fd);\n        Composite tableAndDesc = new Composite(configComposite, SWT.NULL);\n        tableAndDesc.setLayout(new FormLayout());\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(rightButtons, -3, SWT.LEFT);\n        fd.bottom = new FormAttachment(100, 0);\n        tableAndDesc.setLayoutData(fd);\n        Control table = createConfigTable(tableAndDesc);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(70);\n        table.setLayoutData(fd);\n        Composite descArea = new Composite(tableAndDesc, SWT.NULL);\n        descArea.setLayout(new FormLayout());\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(table, 0);\n        fd.right = new FormAttachment(mIsShowUsage ? 60 : 100);\n        fd.bottom = new FormAttachment(100);\n        descArea.setLayoutData(fd);\n        Label lblDescription = new Label(descArea, SWT.NULL);\n        lblDescription.setText(Messages.CheckstylePreferencePage_lblDescription);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(3);\n        fd.right = new FormAttachment(100);\n        lblDescription.setLayoutData(fd);\n        mConfigurationDescription = new Text(descArea, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.READ_ONLY | SWT.BORDER | SWT.VERTICAL);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(lblDescription);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(100);\n        mConfigurationDescription.setLayoutData(fd);\n        if (mIsShowUsage) {\n            Composite usageArea = new Composite(tableAndDesc, SWT.NULL);\n            usageArea.setLayout(new FormLayout());\n            fd = new FormData();\n            fd.left = new FormAttachment(60, 0);\n            fd.top = new FormAttachment(table, 3);\n            fd.right = new FormAttachment(100);\n            fd.bottom = new FormAttachment(100);\n            usageArea.setLayoutData(fd);\n            Label lblUsage = new Label(usageArea, SWT.NULL);\n            lblUsage.setText(Messages.CheckstylePreferencePage_lblProjectUsage);\n            fd = new FormData();\n            fd.left = new FormAttachment(0);\n            fd.top = new FormAttachment(0);\n            fd.right = new FormAttachment(100);\n            lblUsage.setLayoutData(fd);\n            mUsageView = new TableViewer(usageArea);\n            mUsageView.getControl().setBackground(usageArea.getBackground());\n            mUsageView.setContentProvider(new ArrayContentProvider());\n            mUsageView.setLabelProvider(new WorkbenchLabelProvider());\n            fd = new FormData();\n            fd.left = new FormAttachment(0);\n            fd.top = new FormAttachment(lblUsage);\n            fd.right = new FormAttachment(100);\n            fd.bottom = new FormAttachment(100);\n            mUsageView.getControl().setLayoutData(fd);\n        }\n        return configComposite;\n    }\n\n    /**\n     * Creates the table viewer to show the existing check configurations.\n     *\n     * @param parent the parent composite\n     * @return the table control\n     */\n    private Control createConfigTable(Composite parent) {\n        Table table = new Table(parent, SWT.BORDER | SWT.SINGLE | SWT.FULL_SELECTION);\n        table.setHeaderVisible(true);\n        table.setLinesVisible(true);\n        TableLayout tableLayout = new TableLayout();\n        table.setLayout(tableLayout);\n        TableColumn column1 = new TableColumn(table, SWT.NULL);\n        column1.setText(Messages.CheckstylePreferencePage_colCheckConfig);\n        tableLayout.addColumnData(new ColumnWeightData(40));\n        TableColumn column2 = new TableColumn(table, SWT.NULL);\n        column2.setText(Messages.CheckstylePreferencePage_colLocation);\n        tableLayout.addColumnData(new ColumnWeightData(30));\n        TableColumn column3 = new TableColumn(table, SWT.NULL);\n        column3.setText(Messages.CheckstylePreferencePage_colType);\n        tableLayout.addColumnData(new ColumnWeightData(30));\n        if (mWorkingSet instanceof GlobalCheckConfigurationWorkingSet) {\n            TableColumn column4 = new TableColumn(table, SWT.NULL);\n            column4.setText(Messages.CheckstylePreferencePage_colDefault);\n            tableLayout.addColumnData(new ColumnWeightData(12));\n        }\n        mViewer = new EnhancedTableViewer(table);\n        ConfigurationLabelProvider multiProvider = new ConfigurationLabelProvider();\n        mViewer.setLabelProvider(multiProvider);\n        mViewer.setTableComparableProvider(multiProvider);\n        mViewer.setTableSettingsProvider(multiProvider);\n        mViewer.installEnhancements();\n        mViewer.setContentProvider(new ArrayContentProvider());\n        mViewer.setInput(mWorkingSet.getWorkingCopies());\n        mViewer.addDoubleClickListener(mController);\n        mViewer.addSelectionChangedListener(mController);\n        return table;\n    }\n\n    /**\n     * Creates the button bar.\n     *\n     * @param parent the parent composite\n     * @return the button bar composite\n     */\n    private Control createButtonBar(Composite parent) {\n        Composite rightButtons = new Composite(parent, SWT.NULL);\n        rightButtons.setLayout(new FormLayout());\n        mAddButton = new Button(rightButtons, SWT.PUSH);\n        mAddButton.setText(Messages.CheckstylePreferencePage_btnNew);\n        mAddButton.addSelectionListener(mController);\n        FormData fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        mAddButton.setLayoutData(fd);\n        mEditButton = new Button(rightButtons, SWT.PUSH);\n        mEditButton.setText(Messages.CheckstylePreferencePage_btnProperties);\n        mEditButton.addSelectionListener(mController);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(mAddButton, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100);\n        mEditButton.setLayoutData(fd);\n        mConfigureButton = new Button(rightButtons, SWT.PUSH);\n        mConfigureButton.setText(Messages.CheckstylePreferencePage_btnConfigure);\n        mConfigureButton.addSelectionListener(mController);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(mEditButton, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100);\n        mConfigureButton.setLayoutData(fd);\n        mCopyButton = new Button(rightButtons, SWT.PUSH);\n        mCopyButton.setText(Messages.CheckstylePreferencePage_btnCopy);\n        mCopyButton.addSelectionListener(mController);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(mConfigureButton, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100);\n        mCopyButton.setLayoutData(fd);\n        mRemoveButton = new Button(rightButtons, SWT.PUSH);\n        mRemoveButton.setText(Messages.CheckstylePreferencePage_btnRemove);\n        mRemoveButton.addSelectionListener(mController);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(mCopyButton, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100);\n        mRemoveButton.setLayoutData(fd);\n        mDefaultButton = new Button(rightButtons, SWT.PUSH);\n        mDefaultButton.setText(Messages.CheckstylePreferencePage_btnDefault);\n        mDefaultButton.addSelectionListener(mController);\n        mDefaultButton.setToolTipText(Messages.CheckstylePreferencePage_txtDefault);\n        if (mWorkingSet instanceof GlobalCheckConfigurationWorkingSet) {\n            fd = new FormData();\n            fd.left = new FormAttachment(0);\n            fd.top = new FormAttachment(mRemoveButton, 3, SWT.BOTTOM);\n            fd.right = new FormAttachment(100);\n            mDefaultButton.setLayoutData(fd);\n        }\n        mExportButton = new Button(rightButtons, SWT.PUSH);\n        mExportButton.setText(Messages.CheckstylePreferencePage_btnExport);\n        mExportButton.addSelectionListener(mController);\n        fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(100);\n        mExportButton.setLayoutData(fd);\n        return rightButtons;\n    }\n\n    private Shell getShell() {\n        return mViewer.getControl().getShell();\n    }\n\n    /**\n     * Controller for this page.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class PageController implements SelectionListener, IDoubleClickListener, ISelectionChangedListener {\n\n        /**\n         * @see SelectionListener#widgetSelected(org.eclipse.swt.events.SelectionEvent)\n         */\n        public void widgetSelected(SelectionEvent e) {\n            if (mAddButton == e.widget) {\n                addCheckConfig();\n            } else if (mEditButton == e.widget && mViewer.getSelection() instanceof IStructuredSelection) {\n                editCheckConfig();\n            } else if (mConfigureButton == e.widget && mViewer.getSelection() instanceof IStructuredSelection) {\n                configureCheckConfig();\n            } else if (mCopyButton == e.widget && mViewer.getSelection() instanceof IStructuredSelection) {\n                copyCheckConfig();\n            } else if (mRemoveButton == e.widget && mViewer.getSelection() instanceof IStructuredSelection) {\n                removeCheckConfig();\n            } else if (mDefaultButton == e.widget && mViewer.getSelection() instanceof IStructuredSelection) {\n                setDefaultCheckConfig();\n            } else if (mExportButton == e.widget && mViewer.getSelection() instanceof IStructuredSelection) {\n                exportCheckstyleCheckConfig();\n            }\n        }\n\n        /**\n         * @see sSelectionListener#widgetDefaultSelected(org.eclipse.swt.events.SelectionEvent)\n         */\n        public void widgetDefaultSelected(SelectionEvent e) {\n            // NOOP\n        }\n\n        /**\n         * @see IDoubleClickListener#doubleClick(org.eclipse.jface.viewers.DoubleClickEvent)\n         */\n        public void doubleClick(DoubleClickEvent event) {\n            configureCheckConfig();\n        }\n\n        /**\n         * @see ISelectionChangedListener#selectionChanged(\n         *      org.eclipse.jface.viewers.SelectionChangedEvent)\n         */\n        public void selectionChanged(SelectionChangedEvent event) {\n            if (event.getSource() == mViewer && event.getSelection() instanceof IStructuredSelection) {\n                CheckConfigurationWorkingCopy config = (CheckConfigurationWorkingCopy) ((IStructuredSelection) event.getSelection()).getFirstElement();\n                if (config != null) {\n                    mConfigurationDescription.setText(config.getDescription() != null ? config.getDescription() : //$NON-NLS-1$\n                    \"\");\n                    if (mIsShowUsage) {\n                        try {\n                            mUsageView.setInput(ProjectConfigurationFactory.getProjectsUsingConfig(config.getSourceCheckConfiguration()));\n                        } catch (CheckstylePluginException e) {\n                            CheckstyleLog.log(e);\n                        }\n                    }\n                } else {\n                    //$NON-NLS-1$\n                    mConfigurationDescription.setText(\"\");\n                    if (mIsShowUsage) {\n                        mUsageView.setInput(new ArrayList());\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Create a new Check configuration.\n     */\n    private void addCheckConfig() {\n        CheckConfigurationPropertiesDialog dialog = new CheckConfigurationPropertiesDialog(getShell(), null, mWorkingSet);\n        dialog.setBlockOnOpen(true);\n        if (CheckConfigurationPropertiesDialog.OK == dialog.open()) {\n            try {\n                CheckConfigurationWorkingCopy newConfig = dialog.getCheckConfiguration();\n                mWorkingSet.addCheckConfiguration(newConfig);\n                mViewer.setInput(mWorkingSet.getWorkingCopies());\n                mViewer.refresh(true);\n            } catch (CheckstylePluginException ex) {\n                CheckstyleLog.errorDialog(getShell(), ex, true);\n            }\n        }\n    }\n\n    /**\n     * Edit the properties of a check configuration.\n     */\n    private void editCheckConfig() {\n        CheckConfigurationWorkingCopy config = (CheckConfigurationWorkingCopy) ((IStructuredSelection) mViewer.getSelection()).getFirstElement();\n        if (config != null) {\n            CheckConfigurationPropertiesDialog dialog = new CheckConfigurationPropertiesDialog(getShell(), config, mWorkingSet);\n            dialog.setBlockOnOpen(true);\n            if (CheckConfigurationPropertiesDialog.OK == dialog.open()) {\n                mViewer.refresh(true);\n            }\n        }\n    }\n\n    private void configureCheckConfig() {\n        CheckConfigurationWorkingCopy config = (CheckConfigurationWorkingCopy) ((IStructuredSelection) mViewer.getSelection()).getFirstElement();\n        if (config != null) {\n            try {\n                // test if file exists\n                config.getCheckstyleConfiguration();\n                CheckConfigurationConfigureDialog dialog = new CheckConfigurationConfigureDialog(getShell(), config);\n                dialog.setBlockOnOpen(true);\n                dialog.open();\n            } catch (CheckstylePluginException e) {\n                CheckstyleLog.warningDialog(getShell(), NLS.bind(ErrorMessages.errorCannotResolveCheckLocation, config.getLocation(), config.getName()), e);\n            }\n        }\n    }\n\n    /**\n     * Copy an existing config.\n     */\n    private void copyCheckConfig() {\n        IStructuredSelection selection = (IStructuredSelection) mViewer.getSelection();\n        ICheckConfiguration sourceConfig = (ICheckConfiguration) selection.getFirstElement();\n        if (sourceConfig == null) {\n            //\n            // Nothing is selected.\n            //\n            return;\n        }\n        try {\n            // Open the properties dialog to change default name and description\n            CheckConfigurationPropertiesDialog dialog = new CheckConfigurationPropertiesDialog(getShell(), null, mWorkingSet);\n            dialog.setTemplateConfiguration(sourceConfig);\n            dialog.setBlockOnOpen(true);\n            if (CheckConfigurationPropertiesDialog.OK == dialog.open()) {\n                CheckConfigurationWorkingCopy newConfig = dialog.getCheckConfiguration();\n                // Copy the source configuration into the new internal config\n                CheckConfigurationFactory.copyConfiguration(sourceConfig, newConfig);\n                mWorkingSet.addCheckConfiguration(newConfig);\n                mViewer.setInput(mWorkingSet.getWorkingCopies());\n                mViewer.refresh();\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), e, true);\n        }\n    }\n\n    /**\n     * Remove a config.\n     */\n    private void removeCheckConfig() {\n        IStructuredSelection selection = (IStructuredSelection) mViewer.getSelection();\n        CheckConfigurationWorkingCopy checkConfig = (CheckConfigurationWorkingCopy) selection.getFirstElement();\n        if (checkConfig == null || !checkConfig.isEditable()) {\n            //\n            // Nothing is selected.\n            //\n            return;\n        }\n        boolean confirm = MessageDialog.openQuestion(getShell(), Messages.CheckstylePreferencePage_titleDelete, NLS.bind(Messages.CheckstylePreferencePage_msgDelete, checkConfig.getName()));\n        if (confirm) {\n            //\n            // Make sure the check config is not in use. Don't let it be\n            // deleted if it is.\n            //\n            if (mWorkingSet.removeCheckConfiguration(checkConfig)) {\n                mViewer.setInput(mWorkingSet.getWorkingCopies());\n                mViewer.refresh();\n            } else {\n                MessageDialog.openInformation(getShell(), Messages.CheckstylePreferencePage_titleCantDelete, Messages.bind(Messages.CheckstylePreferencePage_msgCantDelete, checkConfig.getName()));\n                return;\n            }\n        }\n    }\n\n    private void setDefaultCheckConfig() {\n        IStructuredSelection selection = (IStructuredSelection) mViewer.getSelection();\n        CheckConfigurationWorkingCopy checkConfig = (CheckConfigurationWorkingCopy) selection.getFirstElement();\n        if (checkConfig == null) {\n            //\n            // Nothing is selected.\n            //\n            return;\n        }\n        if (mWorkingSet instanceof GlobalCheckConfigurationWorkingSet) {\n            ((GlobalCheckConfigurationWorkingSet) mWorkingSet).setDefaultCheckConfig(checkConfig);\n        }\n        mViewer.refresh();\n    }\n\n    /**\n     * Export a configuration.\n     */\n    private void exportCheckstyleCheckConfig() {\n        IStructuredSelection selection = (IStructuredSelection) mViewer.getSelection();\n        ICheckConfiguration config = (ICheckConfiguration) selection.getFirstElement();\n        if (config == null) {\n            //\n            // Nothing is selected.\n            //\n            return;\n        }\n        FileDialog dialog = new FileDialog(getShell(), SWT.SAVE);\n        dialog.setText(Messages.CheckstylePreferencePage_titleExportConfig);\n        String path = dialog.open();\n        if (path == null) {\n            return;\n        }\n        File file = new File(path);\n        try {\n            CheckConfigurationFactory.exportConfiguration(file, config);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.msgErrorFailedExportConfig, e, true);\n        }\n    }\n\n    /**\n     * Label provider for the check configuration table. Implements also support\n     * for table sorting and storing of the table settings.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class ConfigurationLabelProvider extends CheckConfigurationLabelProvider implements ITableLabelProvider, ITableComparableProvider, ITableSettingsProvider {\n\n        /**\n         * {@inheritDoc}\n         */\n        public String getColumnText(Object element, int columnIndex) {\n            String result = element.toString();\n            if (element instanceof ICheckConfiguration) {\n                ICheckConfiguration cfg = (ICheckConfiguration) element;\n                if (columnIndex == 0) {\n                    result = cfg.getName();\n                }\n                if (columnIndex == 1) {\n                    result = cfg.getLocation();\n                }\n                if (columnIndex == 2) {\n                    result = cfg.getType().getName();\n                }\n                if (columnIndex == 3) {\n                    result = \"\";\n                }\n            }\n            return result;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Image getColumnImage(Object element, int columnIndex) {\n            Image image = null;\n            switch(columnIndex) {\n                case 0:\n                    image = getImage(element);\n                    break;\n                case 3:\n                    ICheckConfiguration cfg = (ICheckConfiguration) element;\n                    if (mWorkingSet instanceof GlobalCheckConfigurationWorkingSet) {\n                        if (((GlobalCheckConfigurationWorkingSet) mWorkingSet).getDefaultCheckConfig() == cfg) {\n                            image = CheckstylePluginImages.getImage(CheckstylePluginImages.TICK_ICON);\n                        }\n                    }\n                    break;\n                default:\n                    image = null;\n                    break;\n            }\n            return image;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public Comparable getComparableValue(Object element, int col) {\n            return getColumnText(element, col);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public IDialogSettings getTableSettings() {\n            String concreteViewId = mWorkingSet.getClass().getName();\n            IDialogSettings workbenchSettings = CheckstylePlugin.getDefault().getDialogSettings();\n            IDialogSettings settings = workbenchSettings.getSection(concreteViewId);\n            if (settings == null) {\n                settings = workbenchSettings.addNewSection(concreteViewId);\n            }\n            return settings;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/gui/CheckConfigurationWorkingSetEditor.java",
		"test_prompt": "// CheckConfigurationWorkingSetEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport org.eclipse.jface.dialogs.IDialogSettings;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.ColumnWeightData;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.ITableLabelProvider;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.viewers.StructuredViewer;\nimport org.eclipse.jface.viewers.TableLayout;\nimport org.eclipse.jface.viewers.TableViewer;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.graphics.Image;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.FileDialog;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Table;\nimport org.eclipse.swt.widgets.TableColumn;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.model.WorkbenchLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.GlobalCheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginImages;\nimport com.atlassw.tools.eclipse.checkstyle.util.table.EnhancedTableViewer;\nimport com.atlassw.tools.eclipse.checkstyle.util.table.ITableComparableProvider;\nimport com.atlassw.tools.eclipse.checkstyle.util.table.ITableSettingsProvider;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationWorkingSetEditor}.\n* It contains ten unit test cases for the {@link CheckConfigurationWorkingSetEditor#createContents(Composite)} method.\n*/\nclass CheckConfigurationWorkingSetEditorTest {"
	},
	{
		"original_code": "// CheckConfigurationViewerSorter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport org.eclipse.jface.viewers.Viewer;\nimport org.eclipse.jface.viewers.ViewerSorter;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\n\n/**\n * Sorts CheckConfiguration objects into their display order.\n */\npublic class CheckConfigurationViewerSorter extends ViewerSorter {\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public int compare(Viewer viewer, Object e1, Object e2) {\n        int result = 0;\n        if ((e1 instanceof ICheckConfiguration) && (e2 instanceof ICheckConfiguration)) {\n            ICheckConfiguration cfg1 = (ICheckConfiguration) e1;\n            ICheckConfiguration cfg2 = (ICheckConfiguration) e2;\n            String string1 = cfg1.getName();\n            String string2 = cfg2.getName();\n            result = string1.compareToIgnoreCase(string2);\n        }\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/gui/CheckConfigurationViewerSorter.java",
		"test_prompt": "// CheckConfigurationViewerSorterTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui;\n\nimport org.eclipse.jface.viewers.Viewer;\nimport org.eclipse.jface.viewers.ViewerSorter;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationViewerSorter}.\n* It contains ten unit test cases for the {@link CheckConfigurationViewerSorter#compare(Viewer, Object, Object)} method.\n*/\nclass CheckConfigurationViewerSorterTest {"
	},
	{
		"original_code": "// ConfigPropertyWidgetFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui.widgets;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Shell;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.ConfigPropertyType;\n\n/**\n * Create <code>ConfigPropertyWidget</code> instances based on provided\n * metadata.\n */\npublic final class ConfigPropertyWidgetFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    private ConfigPropertyWidgetFactory() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Creates a property widget for the given property.\n     *\n     * @param parent the parent component\n     * @param prop the property\n     * @param shell the parent shell\n     * @return the widget or <code>null</code> if the property type is unknown\n     */\n    public static IConfigPropertyWidget createWidget(Composite parent, ConfigProperty prop, Shell shell) {\n        IConfigPropertyWidget widget = null;\n        ConfigPropertyType type = prop.getMetaData().getDatatype();\n        if (type.equals(ConfigPropertyType.STRING)) {\n            widget = new ConfigPropertyWidgetString(parent, prop);\n        }\n        if (type.equals(ConfigPropertyType.STRING_ARRAY)) {\n            widget = new ConfigPropertyWidgetString(parent, prop);\n        } else if (type.equals(ConfigPropertyType.INTEGER)) {\n            widget = new ConfigPropertyWidgetInteger(parent, prop);\n        } else if (type.equals(ConfigPropertyType.SINGLE_SELECT)) {\n            widget = new ConfigPropertyWidgetSingleSelect(parent, prop);\n        } else if (type.equals(ConfigPropertyType.BOOLEAN)) {\n            widget = new ConfigPropertyWidgetBoolean(parent, prop);\n        } else if (type.equals(ConfigPropertyType.MULTI_CHECK)) {\n            widget = new ConfigPropertyWidgetMultiCheck(parent, prop);\n        } else if (type.equals(ConfigPropertyType.HIDDEN)) {\n            widget = new ConfigPropertyWidgetHidden(parent, prop);\n        } else if (type.equals(ConfigPropertyType.FILE)) {\n            widget = new ConfigPropertyWidgetFile(parent, prop);\n        } else if (type.equals(ConfigPropertyType.REGEX)) {\n            widget = new ConfigPropertyWidgetRegex(parent, prop);\n        }\n        widget.initialize();\n        return widget;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/gui/widgets/ConfigPropertyWidgetFactory.java",
		"test_prompt": "// ConfigPropertyWidgetFactoryTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config.gui.widgets;\n\n//=================================================\n// Imports from java namespace\n//=================================================\n//=================================================\n// Imports from javax namespace\n//=================================================\n//=================================================\n// Imports from com namespace\n//=================================================\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Shell;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.meta.ConfigPropertyType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigPropertyWidgetFactory}.\n* It contains ten unit test cases for the {@link ConfigPropertyWidgetFactory#createWidget(Composite, ConfigProperty, Shell)} method.\n*/\nclass ConfigPropertyWidgetFactoryTest {"
	},
	{
		"original_code": "// CheckConfigurationFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Platform;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.migration.CheckConfigurationMigrator;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Used to manage the life cycle of <code>CheckConfiguration</code> objects.\n */\npublic final class CheckConfigurationFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Name of the internal file storing the plugin check configurations.\n     */\n    //$NON-NLS-1$\n    protected static final String CHECKSTYLE_CONFIG_FILE = \"checkstyle-config.xml\";\n\n    /**\n     * Name of the actual config file version.\n     */\n    //$NON-NLS-1$\n    private static final String VERSION_5_0_0 = \"5.0.0\";\n\n    /**\n     * The current file version.\n     */\n    protected static final String CURRENT_CONFIG_FILE_FORMAT_VERSION = VERSION_5_0_0;\n\n    /**\n     * constant for the extension point id.\n     */\n    private static final String CONFIGS_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + //$NON-NLS-1$\n    \".configurations\";\n\n    /**\n     * List of known check configurations. Synchronized because of possible\n     * concurrend access.\n     */\n    private static List sConfigurations = Collections.synchronizedList(new ArrayList());\n\n    private static ICheckConfiguration sDefaultCheckConfig;\n\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    private CheckConfigurationFactory() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get an <code>CheckConfiguration</code> instance by its name.\n     *\n     * @param name Name of the requested instance.\n     * @return The requested instance or <code>null</code> if the named\n     *         instance could not be found.\n     */\n    public static ICheckConfiguration getByName(String name) {\n        ICheckConfiguration config = null;\n        Iterator it = sConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration tmp = (ICheckConfiguration) it.next();\n            if (tmp.getName().equals(name)) {\n                config = tmp;\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Get a list of the currently defined check configurations.\n     *\n     * @return A list containing all instances.\n     */\n    public static List getCheckConfigurations() {\n        return Collections.unmodifiableList(sConfigurations);\n    }\n\n    /**\n     * Returns the default check configuration if one is set, if none is set the\n     * Sun Checks built-in configuration will be returned.\n     *\n     * @return the default check configuration to use with unconfigured projects\n     */\n    public static ICheckConfiguration getDefaultCheckConfiguration() {\n        if (sDefaultCheckConfig != null) {\n            return sDefaultCheckConfig;\n        } else {\n            return (ICheckConfiguration) sConfigurations.get(0);\n        }\n    }\n\n    /**\n     * Creates a new working set from the existing configurations.\n     *\n     * @return a new configuration working set\n     */\n    public static ICheckConfigurationWorkingSet newWorkingSet() {\n        return new GlobalCheckConfigurationWorkingSet(sConfigurations, getDefaultCheckConfiguration());\n    }\n\n    /**\n     * Refreshes the check configurations from the persistent store.\n     */\n    public static void refresh() {\n        try {\n            sConfigurations.clear();\n            loadBuiltinConfigurations();\n            loadFromPersistence();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Copy the checkstyle configuration of a check configuration into another\n     * configuration.\n     *\n     * @param source the source check configuration\n     * @param target the target check configuartion\n     * @throws CheckstylePluginException Error copying the configuration\n     */\n    public static void copyConfiguration(ICheckConfiguration source, ICheckConfiguration target) throws CheckstylePluginException {\n        // use the export function ;-)\n        String targetFile = target.getResolvedConfigurationFileURL().getFile();\n        String sourceFile = source.getResolvedConfigurationFileURL().getFile();\n        // copying from a file to the same file will destroy it.\n        if (ObjectUtils.equals(targetFile, sourceFile)) {\n            return;\n        }\n        exportConfiguration(new File(targetFile), source);\n    }\n\n    /**\n     * Write check configurations to an external file in standard Checkstyle\n     * format.\n     *\n     * @param file File to write too.\n     * @param config List of check configurations to write out.\n     * @throws CheckstylePluginException Error during export.\n     */\n    public static void exportConfiguration(File file, ICheckConfiguration config) throws CheckstylePluginException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            // Just copy the checkstyle configuration\n            in = config.getCheckstyleConfiguration().getCheckConfigFileStream();\n            out = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copy(in, out);\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Load the check configurations from the persistent state storage.\n     */\n    private static void loadFromPersistence() throws CheckstylePluginException {\n        InputStream inStream = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            //\n            // Make sure the files exists, it might not.\n            //\n            if (!configFile.exists()) {\n                return;\n            } else {\n                inStream = new BufferedInputStream(new FileInputStream(configFile));\n            }\n            CheckConfigurationsFileHandler handler = new CheckConfigurationsFileHandler();\n            XMLUtil.parseWithSAX(inStream, handler);\n            if (handler.isOldFileFormat()) {\n                migrate();\n            } else {\n                sConfigurations.addAll(handler.getConfigurations());\n                String defaultConfigName = handler.getDefaultCheckConfigurationName();\n                Iterator it = sConfigurations.iterator();\n                while (it.hasNext()) {\n                    ICheckConfiguration config = (ICheckConfiguration) it.next();\n                    if (config.getName().equals(defaultConfigName)) {\n                        sDefaultCheckConfig = config;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorLoadingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n        }\n    }\n\n    /**\n     * Loads the built-in check configurations defined in plugin.xml or custom\n     * fragments.\n     */\n    private static void loadBuiltinConfigurations() {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(CONFIGS_EXTENSION_POINT);\n        for (int i = 0; i < elements.length; i++) {\n            String name = elements[i].getAttribute(XMLTags.NAME_TAG);\n            String description = elements[i].getAttribute(XMLTags.DESCRIPTION_TAG);\n            String location = elements[i].getAttribute(XMLTags.LOCATION_TAG);\n            //$NON-NLS-1$\n            IConfigurationType configType = ConfigurationTypes.getByInternalName(\"builtin\");\n            ICheckConfiguration checkConfig = new CheckConfiguration(name, location, description, configType, true, null, null);\n            sConfigurations.add(checkConfig);\n        }\n    }\n\n    private static void migrate() throws CheckstylePluginException {\n        InputStream inStream = null;\n        InputStream defaultConfigStream = null;\n        try {\n            // get inputstream to the current oldstyle config\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            inStream = new BufferedInputStream(new FileInputStream(configFile));\n            // migrate the configurations\n            ICheckConfigurationWorkingSet workingSet = newWorkingSet();\n            CheckConfigurationMigrator.migrate(inStream, workingSet);\n            workingSet.store();\n            // refresh the cached instances\n            refresh();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorMigratingConfig);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n            IOUtils.closeQuietly(defaultConfigStream);\n        }\n    }\n\n    /**\n     * SAX-DefaultHandler for parsing the check-configurations file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class CheckConfigurationsFileHandler extends DefaultHandler {\n\n        /**\n         * the configurations read from the xml.\n         */\n        private List mConfigurations = new ArrayList();\n\n        /**\n         * Flags if the old plugin configuration file format was detected.\n         */\n        private boolean mOldFileFormat;\n\n        /**\n         * The name of the current check configuration.\n         */\n        private String mCurrentName;\n\n        /**\n         * The location of the current check configuration.\n         */\n        private String mCurrentLocation;\n\n        /**\n         * The description of the current check configuration.\n         */\n        private String mCurrentDescription;\n\n        /**\n         * The configuration type of the current configuration.\n         */\n        private IConfigurationType mCurrentConfigType;\n\n        /**\n         * Additional data for the current configuration.\n         */\n        private Map mCurrentAddValues;\n\n        /**\n         * List of resolvable properties for this configuration.\n         */\n        private List mResolvableProperties;\n\n        /**\n         * The default check configuration name.\n         */\n        private String mDefaultConfigName;\n\n        /**\n         * Return the configurations this handler built.\n         *\n         * @return the configurations\n         */\n        public List getConfigurations() {\n            return mConfigurations;\n        }\n\n        /**\n         * Returns the default check configuration name or <code>null</code>\n         * if none was specified.\n         *\n         * @return the default check configuration name or <code>null</code>\n         */\n        public String getDefaultCheckConfigurationName() {\n            return mDefaultConfigName;\n        }\n\n        /**\n         * Returns if the old plugin file format was detected.\n         *\n         * @return <code>true</code> if the old file format was detected\n         */\n        public boolean isOldFileFormat() {\n            return mOldFileFormat;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            if (XMLTags.CHECKSTYLE_ROOT_TAG.equals(qName)) {\n                String version = attributes.getValue(XMLTags.VERSION_TAG);\n                if (!CURRENT_CONFIG_FILE_FORMAT_VERSION.equals(version)) {\n                    mOldFileFormat = true;\n                }\n                mDefaultConfigName = attributes.getValue(XMLTags.DEFAULT_CHECK_CONFIG_TAG);\n            } else if (!mOldFileFormat && XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                mCurrentName = attributes.getValue(XMLTags.NAME_TAG);\n                mCurrentDescription = attributes.getValue(XMLTags.DESCRIPTION_TAG);\n                mCurrentLocation = attributes.getValue(XMLTags.LOCATION_TAG);\n                String type = attributes.getValue(XMLTags.TYPE_TAG);\n                mCurrentConfigType = ConfigurationTypes.getByInternalName(type);\n                mCurrentAddValues = new HashMap();\n                mResolvableProperties = new ArrayList();\n            } else if (!mOldFileFormat && XMLTags.ADDITIONAL_DATA_TAG.equals(qName)) {\n                mCurrentAddValues.put(attributes.getValue(XMLTags.NAME_TAG), attributes.getValue(XMLTags.VALUE_TAG));\n            } else if (!mOldFileFormat && XMLTags.PROPERTY_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                String value = attributes.getValue(XMLTags.VALUE_TAG);\n                ResolvableProperty prop = new ResolvableProperty(name, value);\n                mResolvableProperties.add(prop);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (!mOldFileFormat && XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                try {\n                    ICheckConfiguration checkConfig = new CheckConfiguration(mCurrentName, mCurrentLocation, mCurrentDescription, mCurrentConfigType, true, mResolvableProperties, mCurrentAddValues);\n                    mConfigurations.add(checkConfig);\n                } catch (Exception e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationFactory_0Test.java",
		"test_prompt": "// CheckConfigurationFactory_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Platform;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.migration.CheckConfigurationMigrator;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationFactory}.\n* It contains ten unit test cases for the {@link CheckConfigurationFactory#getByName(String)} method.\n*/\nclass CheckConfigurationFactory_0Test {"
	},
	{
		"original_code": "// CheckConfigurationFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Platform;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.migration.CheckConfigurationMigrator;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Used to manage the life cycle of <code>CheckConfiguration</code> objects.\n */\npublic final class CheckConfigurationFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Name of the internal file storing the plugin check configurations.\n     */\n    //$NON-NLS-1$\n    protected static final String CHECKSTYLE_CONFIG_FILE = \"checkstyle-config.xml\";\n\n    /**\n     * Name of the actual config file version.\n     */\n    //$NON-NLS-1$\n    private static final String VERSION_5_0_0 = \"5.0.0\";\n\n    /**\n     * The current file version.\n     */\n    protected static final String CURRENT_CONFIG_FILE_FORMAT_VERSION = VERSION_5_0_0;\n\n    /**\n     * constant for the extension point id.\n     */\n    private static final String CONFIGS_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + //$NON-NLS-1$\n    \".configurations\";\n\n    /**\n     * List of known check configurations. Synchronized because of possible\n     * concurrend access.\n     */\n    private static List sConfigurations = Collections.synchronizedList(new ArrayList());\n\n    private static ICheckConfiguration sDefaultCheckConfig;\n\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    private CheckConfigurationFactory() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get an <code>CheckConfiguration</code> instance by its name.\n     *\n     * @param name Name of the requested instance.\n     * @return The requested instance or <code>null</code> if the named\n     *         instance could not be found.\n     */\n    public static ICheckConfiguration getByName(String name) {\n        ICheckConfiguration config = null;\n        Iterator it = sConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration tmp = (ICheckConfiguration) it.next();\n            if (tmp.getName().equals(name)) {\n                config = tmp;\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Get a list of the currently defined check configurations.\n     *\n     * @return A list containing all instances.\n     */\n    public static List getCheckConfigurations() {\n        return Collections.unmodifiableList(sConfigurations);\n    }\n\n    /**\n     * Returns the default check configuration if one is set, if none is set the\n     * Sun Checks built-in configuration will be returned.\n     *\n     * @return the default check configuration to use with unconfigured projects\n     */\n    public static ICheckConfiguration getDefaultCheckConfiguration() {\n        if (sDefaultCheckConfig != null) {\n            return sDefaultCheckConfig;\n        } else {\n            return (ICheckConfiguration) sConfigurations.get(0);\n        }\n    }\n\n    /**\n     * Creates a new working set from the existing configurations.\n     *\n     * @return a new configuration working set\n     */\n    public static ICheckConfigurationWorkingSet newWorkingSet() {\n        return new GlobalCheckConfigurationWorkingSet(sConfigurations, getDefaultCheckConfiguration());\n    }\n\n    /**\n     * Refreshes the check configurations from the persistent store.\n     */\n    public static void refresh() {\n        try {\n            sConfigurations.clear();\n            loadBuiltinConfigurations();\n            loadFromPersistence();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Copy the checkstyle configuration of a check configuration into another\n     * configuration.\n     *\n     * @param source the source check configuration\n     * @param target the target check configuartion\n     * @throws CheckstylePluginException Error copying the configuration\n     */\n    public static void copyConfiguration(ICheckConfiguration source, ICheckConfiguration target) throws CheckstylePluginException {\n        // use the export function ;-)\n        String targetFile = target.getResolvedConfigurationFileURL().getFile();\n        String sourceFile = source.getResolvedConfigurationFileURL().getFile();\n        // copying from a file to the same file will destroy it.\n        if (ObjectUtils.equals(targetFile, sourceFile)) {\n            return;\n        }\n        exportConfiguration(new File(targetFile), source);\n    }\n\n    /**\n     * Write check configurations to an external file in standard Checkstyle\n     * format.\n     *\n     * @param file File to write too.\n     * @param config List of check configurations to write out.\n     * @throws CheckstylePluginException Error during export.\n     */\n    public static void exportConfiguration(File file, ICheckConfiguration config) throws CheckstylePluginException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            // Just copy the checkstyle configuration\n            in = config.getCheckstyleConfiguration().getCheckConfigFileStream();\n            out = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copy(in, out);\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Load the check configurations from the persistent state storage.\n     */\n    private static void loadFromPersistence() throws CheckstylePluginException {\n        InputStream inStream = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            //\n            // Make sure the files exists, it might not.\n            //\n            if (!configFile.exists()) {\n                return;\n            } else {\n                inStream = new BufferedInputStream(new FileInputStream(configFile));\n            }\n            CheckConfigurationsFileHandler handler = new CheckConfigurationsFileHandler();\n            XMLUtil.parseWithSAX(inStream, handler);\n            if (handler.isOldFileFormat()) {\n                migrate();\n            } else {\n                sConfigurations.addAll(handler.getConfigurations());\n                String defaultConfigName = handler.getDefaultCheckConfigurationName();\n                Iterator it = sConfigurations.iterator();\n                while (it.hasNext()) {\n                    ICheckConfiguration config = (ICheckConfiguration) it.next();\n                    if (config.getName().equals(defaultConfigName)) {\n                        sDefaultCheckConfig = config;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorLoadingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n        }\n    }\n\n    /**\n     * Loads the built-in check configurations defined in plugin.xml or custom\n     * fragments.\n     */\n    private static void loadBuiltinConfigurations() {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(CONFIGS_EXTENSION_POINT);\n        for (int i = 0; i < elements.length; i++) {\n            String name = elements[i].getAttribute(XMLTags.NAME_TAG);\n            String description = elements[i].getAttribute(XMLTags.DESCRIPTION_TAG);\n            String location = elements[i].getAttribute(XMLTags.LOCATION_TAG);\n            //$NON-NLS-1$\n            IConfigurationType configType = ConfigurationTypes.getByInternalName(\"builtin\");\n            ICheckConfiguration checkConfig = new CheckConfiguration(name, location, description, configType, true, null, null);\n            sConfigurations.add(checkConfig);\n        }\n    }\n\n    private static void migrate() throws CheckstylePluginException {\n        InputStream inStream = null;\n        InputStream defaultConfigStream = null;\n        try {\n            // get inputstream to the current oldstyle config\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            inStream = new BufferedInputStream(new FileInputStream(configFile));\n            // migrate the configurations\n            ICheckConfigurationWorkingSet workingSet = newWorkingSet();\n            CheckConfigurationMigrator.migrate(inStream, workingSet);\n            workingSet.store();\n            // refresh the cached instances\n            refresh();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorMigratingConfig);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n            IOUtils.closeQuietly(defaultConfigStream);\n        }\n    }\n\n    /**\n     * SAX-DefaultHandler for parsing the check-configurations file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class CheckConfigurationsFileHandler extends DefaultHandler {\n\n        /**\n         * the configurations read from the xml.\n         */\n        private List mConfigurations = new ArrayList();\n\n        /**\n         * Flags if the old plugin configuration file format was detected.\n         */\n        private boolean mOldFileFormat;\n\n        /**\n         * The name of the current check configuration.\n         */\n        private String mCurrentName;\n\n        /**\n         * The location of the current check configuration.\n         */\n        private String mCurrentLocation;\n\n        /**\n         * The description of the current check configuration.\n         */\n        private String mCurrentDescription;\n\n        /**\n         * The configuration type of the current configuration.\n         */\n        private IConfigurationType mCurrentConfigType;\n\n        /**\n         * Additional data for the current configuration.\n         */\n        private Map mCurrentAddValues;\n\n        /**\n         * List of resolvable properties for this configuration.\n         */\n        private List mResolvableProperties;\n\n        /**\n         * The default check configuration name.\n         */\n        private String mDefaultConfigName;\n\n        /**\n         * Return the configurations this handler built.\n         *\n         * @return the configurations\n         */\n        public List getConfigurations() {\n            return mConfigurations;\n        }\n\n        /**\n         * Returns the default check configuration name or <code>null</code>\n         * if none was specified.\n         *\n         * @return the default check configuration name or <code>null</code>\n         */\n        public String getDefaultCheckConfigurationName() {\n            return mDefaultConfigName;\n        }\n\n        /**\n         * Returns if the old plugin file format was detected.\n         *\n         * @return <code>true</code> if the old file format was detected\n         */\n        public boolean isOldFileFormat() {\n            return mOldFileFormat;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            if (XMLTags.CHECKSTYLE_ROOT_TAG.equals(qName)) {\n                String version = attributes.getValue(XMLTags.VERSION_TAG);\n                if (!CURRENT_CONFIG_FILE_FORMAT_VERSION.equals(version)) {\n                    mOldFileFormat = true;\n                }\n                mDefaultConfigName = attributes.getValue(XMLTags.DEFAULT_CHECK_CONFIG_TAG);\n            } else if (!mOldFileFormat && XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                mCurrentName = attributes.getValue(XMLTags.NAME_TAG);\n                mCurrentDescription = attributes.getValue(XMLTags.DESCRIPTION_TAG);\n                mCurrentLocation = attributes.getValue(XMLTags.LOCATION_TAG);\n                String type = attributes.getValue(XMLTags.TYPE_TAG);\n                mCurrentConfigType = ConfigurationTypes.getByInternalName(type);\n                mCurrentAddValues = new HashMap();\n                mResolvableProperties = new ArrayList();\n            } else if (!mOldFileFormat && XMLTags.ADDITIONAL_DATA_TAG.equals(qName)) {\n                mCurrentAddValues.put(attributes.getValue(XMLTags.NAME_TAG), attributes.getValue(XMLTags.VALUE_TAG));\n            } else if (!mOldFileFormat && XMLTags.PROPERTY_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                String value = attributes.getValue(XMLTags.VALUE_TAG);\n                ResolvableProperty prop = new ResolvableProperty(name, value);\n                mResolvableProperties.add(prop);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (!mOldFileFormat && XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                try {\n                    ICheckConfiguration checkConfig = new CheckConfiguration(mCurrentName, mCurrentLocation, mCurrentDescription, mCurrentConfigType, true, mResolvableProperties, mCurrentAddValues);\n                    mConfigurations.add(checkConfig);\n                } catch (Exception e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationFactory_1Test.java",
		"test_prompt": "// CheckConfigurationFactory_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Platform;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.migration.CheckConfigurationMigrator;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationFactory}.\n* It contains ten unit test cases for the {@link CheckConfigurationFactory#getCheckConfigurations()} method.\n*/\nclass CheckConfigurationFactory_1Test {"
	},
	{
		"original_code": "// CheckConfigurationFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Platform;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.migration.CheckConfigurationMigrator;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Used to manage the life cycle of <code>CheckConfiguration</code> objects.\n */\npublic final class CheckConfigurationFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Name of the internal file storing the plugin check configurations.\n     */\n    //$NON-NLS-1$\n    protected static final String CHECKSTYLE_CONFIG_FILE = \"checkstyle-config.xml\";\n\n    /**\n     * Name of the actual config file version.\n     */\n    //$NON-NLS-1$\n    private static final String VERSION_5_0_0 = \"5.0.0\";\n\n    /**\n     * The current file version.\n     */\n    protected static final String CURRENT_CONFIG_FILE_FORMAT_VERSION = VERSION_5_0_0;\n\n    /**\n     * constant for the extension point id.\n     */\n    private static final String CONFIGS_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + //$NON-NLS-1$\n    \".configurations\";\n\n    /**\n     * List of known check configurations. Synchronized because of possible\n     * concurrend access.\n     */\n    private static List sConfigurations = Collections.synchronizedList(new ArrayList());\n\n    private static ICheckConfiguration sDefaultCheckConfig;\n\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    private CheckConfigurationFactory() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get an <code>CheckConfiguration</code> instance by its name.\n     *\n     * @param name Name of the requested instance.\n     * @return The requested instance or <code>null</code> if the named\n     *         instance could not be found.\n     */\n    public static ICheckConfiguration getByName(String name) {\n        ICheckConfiguration config = null;\n        Iterator it = sConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration tmp = (ICheckConfiguration) it.next();\n            if (tmp.getName().equals(name)) {\n                config = tmp;\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Get a list of the currently defined check configurations.\n     *\n     * @return A list containing all instances.\n     */\n    public static List getCheckConfigurations() {\n        return Collections.unmodifiableList(sConfigurations);\n    }\n\n    /**\n     * Returns the default check configuration if one is set, if none is set the\n     * Sun Checks built-in configuration will be returned.\n     *\n     * @return the default check configuration to use with unconfigured projects\n     */\n    public static ICheckConfiguration getDefaultCheckConfiguration() {\n        if (sDefaultCheckConfig != null) {\n            return sDefaultCheckConfig;\n        } else {\n            return (ICheckConfiguration) sConfigurations.get(0);\n        }\n    }\n\n    /**\n     * Creates a new working set from the existing configurations.\n     *\n     * @return a new configuration working set\n     */\n    public static ICheckConfigurationWorkingSet newWorkingSet() {\n        return new GlobalCheckConfigurationWorkingSet(sConfigurations, getDefaultCheckConfiguration());\n    }\n\n    /**\n     * Refreshes the check configurations from the persistent store.\n     */\n    public static void refresh() {\n        try {\n            sConfigurations.clear();\n            loadBuiltinConfigurations();\n            loadFromPersistence();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Copy the checkstyle configuration of a check configuration into another\n     * configuration.\n     *\n     * @param source the source check configuration\n     * @param target the target check configuartion\n     * @throws CheckstylePluginException Error copying the configuration\n     */\n    public static void copyConfiguration(ICheckConfiguration source, ICheckConfiguration target) throws CheckstylePluginException {\n        // use the export function ;-)\n        String targetFile = target.getResolvedConfigurationFileURL().getFile();\n        String sourceFile = source.getResolvedConfigurationFileURL().getFile();\n        // copying from a file to the same file will destroy it.\n        if (ObjectUtils.equals(targetFile, sourceFile)) {\n            return;\n        }\n        exportConfiguration(new File(targetFile), source);\n    }\n\n    /**\n     * Write check configurations to an external file in standard Checkstyle\n     * format.\n     *\n     * @param file File to write too.\n     * @param config List of check configurations to write out.\n     * @throws CheckstylePluginException Error during export.\n     */\n    public static void exportConfiguration(File file, ICheckConfiguration config) throws CheckstylePluginException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            // Just copy the checkstyle configuration\n            in = config.getCheckstyleConfiguration().getCheckConfigFileStream();\n            out = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copy(in, out);\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Load the check configurations from the persistent state storage.\n     */\n    private static void loadFromPersistence() throws CheckstylePluginException {\n        InputStream inStream = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            //\n            // Make sure the files exists, it might not.\n            //\n            if (!configFile.exists()) {\n                return;\n            } else {\n                inStream = new BufferedInputStream(new FileInputStream(configFile));\n            }\n            CheckConfigurationsFileHandler handler = new CheckConfigurationsFileHandler();\n            XMLUtil.parseWithSAX(inStream, handler);\n            if (handler.isOldFileFormat()) {\n                migrate();\n            } else {\n                sConfigurations.addAll(handler.getConfigurations());\n                String defaultConfigName = handler.getDefaultCheckConfigurationName();\n                Iterator it = sConfigurations.iterator();\n                while (it.hasNext()) {\n                    ICheckConfiguration config = (ICheckConfiguration) it.next();\n                    if (config.getName().equals(defaultConfigName)) {\n                        sDefaultCheckConfig = config;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorLoadingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n        }\n    }\n\n    /**\n     * Loads the built-in check configurations defined in plugin.xml or custom\n     * fragments.\n     */\n    private static void loadBuiltinConfigurations() {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(CONFIGS_EXTENSION_POINT);\n        for (int i = 0; i < elements.length; i++) {\n            String name = elements[i].getAttribute(XMLTags.NAME_TAG);\n            String description = elements[i].getAttribute(XMLTags.DESCRIPTION_TAG);\n            String location = elements[i].getAttribute(XMLTags.LOCATION_TAG);\n            //$NON-NLS-1$\n            IConfigurationType configType = ConfigurationTypes.getByInternalName(\"builtin\");\n            ICheckConfiguration checkConfig = new CheckConfiguration(name, location, description, configType, true, null, null);\n            sConfigurations.add(checkConfig);\n        }\n    }\n\n    private static void migrate() throws CheckstylePluginException {\n        InputStream inStream = null;\n        InputStream defaultConfigStream = null;\n        try {\n            // get inputstream to the current oldstyle config\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            inStream = new BufferedInputStream(new FileInputStream(configFile));\n            // migrate the configurations\n            ICheckConfigurationWorkingSet workingSet = newWorkingSet();\n            CheckConfigurationMigrator.migrate(inStream, workingSet);\n            workingSet.store();\n            // refresh the cached instances\n            refresh();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorMigratingConfig);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n            IOUtils.closeQuietly(defaultConfigStream);\n        }\n    }\n\n    /**\n     * SAX-DefaultHandler for parsing the check-configurations file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class CheckConfigurationsFileHandler extends DefaultHandler {\n\n        /**\n         * the configurations read from the xml.\n         */\n        private List mConfigurations = new ArrayList();\n\n        /**\n         * Flags if the old plugin configuration file format was detected.\n         */\n        private boolean mOldFileFormat;\n\n        /**\n         * The name of the current check configuration.\n         */\n        private String mCurrentName;\n\n        /**\n         * The location of the current check configuration.\n         */\n        private String mCurrentLocation;\n\n        /**\n         * The description of the current check configuration.\n         */\n        private String mCurrentDescription;\n\n        /**\n         * The configuration type of the current configuration.\n         */\n        private IConfigurationType mCurrentConfigType;\n\n        /**\n         * Additional data for the current configuration.\n         */\n        private Map mCurrentAddValues;\n\n        /**\n         * List of resolvable properties for this configuration.\n         */\n        private List mResolvableProperties;\n\n        /**\n         * The default check configuration name.\n         */\n        private String mDefaultConfigName;\n\n        /**\n         * Return the configurations this handler built.\n         *\n         * @return the configurations\n         */\n        public List getConfigurations() {\n            return mConfigurations;\n        }\n\n        /**\n         * Returns the default check configuration name or <code>null</code>\n         * if none was specified.\n         *\n         * @return the default check configuration name or <code>null</code>\n         */\n        public String getDefaultCheckConfigurationName() {\n            return mDefaultConfigName;\n        }\n\n        /**\n         * Returns if the old plugin file format was detected.\n         *\n         * @return <code>true</code> if the old file format was detected\n         */\n        public boolean isOldFileFormat() {\n            return mOldFileFormat;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            if (XMLTags.CHECKSTYLE_ROOT_TAG.equals(qName)) {\n                String version = attributes.getValue(XMLTags.VERSION_TAG);\n                if (!CURRENT_CONFIG_FILE_FORMAT_VERSION.equals(version)) {\n                    mOldFileFormat = true;\n                }\n                mDefaultConfigName = attributes.getValue(XMLTags.DEFAULT_CHECK_CONFIG_TAG);\n            } else if (!mOldFileFormat && XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                mCurrentName = attributes.getValue(XMLTags.NAME_TAG);\n                mCurrentDescription = attributes.getValue(XMLTags.DESCRIPTION_TAG);\n                mCurrentLocation = attributes.getValue(XMLTags.LOCATION_TAG);\n                String type = attributes.getValue(XMLTags.TYPE_TAG);\n                mCurrentConfigType = ConfigurationTypes.getByInternalName(type);\n                mCurrentAddValues = new HashMap();\n                mResolvableProperties = new ArrayList();\n            } else if (!mOldFileFormat && XMLTags.ADDITIONAL_DATA_TAG.equals(qName)) {\n                mCurrentAddValues.put(attributes.getValue(XMLTags.NAME_TAG), attributes.getValue(XMLTags.VALUE_TAG));\n            } else if (!mOldFileFormat && XMLTags.PROPERTY_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                String value = attributes.getValue(XMLTags.VALUE_TAG);\n                ResolvableProperty prop = new ResolvableProperty(name, value);\n                mResolvableProperties.add(prop);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (!mOldFileFormat && XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                try {\n                    ICheckConfiguration checkConfig = new CheckConfiguration(mCurrentName, mCurrentLocation, mCurrentDescription, mCurrentConfigType, true, mResolvableProperties, mCurrentAddValues);\n                    mConfigurations.add(checkConfig);\n                } catch (Exception e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationFactory_2Test.java",
		"test_prompt": "// CheckConfigurationFactory_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Platform;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.migration.CheckConfigurationMigrator;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationFactory}.\n* It contains ten unit test cases for the {@link CheckConfigurationFactory#getDefaultCheckConfiguration()} method.\n*/\nclass CheckConfigurationFactory_2Test {"
	},
	{
		"original_code": "// CheckConfigurationFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Platform;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.migration.CheckConfigurationMigrator;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Used to manage the life cycle of <code>CheckConfiguration</code> objects.\n */\npublic final class CheckConfigurationFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * Name of the internal file storing the plugin check configurations.\n     */\n    //$NON-NLS-1$\n    protected static final String CHECKSTYLE_CONFIG_FILE = \"checkstyle-config.xml\";\n\n    /**\n     * Name of the actual config file version.\n     */\n    //$NON-NLS-1$\n    private static final String VERSION_5_0_0 = \"5.0.0\";\n\n    /**\n     * The current file version.\n     */\n    protected static final String CURRENT_CONFIG_FILE_FORMAT_VERSION = VERSION_5_0_0;\n\n    /**\n     * constant for the extension point id.\n     */\n    private static final String CONFIGS_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + //$NON-NLS-1$\n    \".configurations\";\n\n    /**\n     * List of known check configurations. Synchronized because of possible\n     * concurrend access.\n     */\n    private static List sConfigurations = Collections.synchronizedList(new ArrayList());\n\n    private static ICheckConfiguration sDefaultCheckConfig;\n\n    static {\n        refresh();\n    }\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    private CheckConfigurationFactory() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get an <code>CheckConfiguration</code> instance by its name.\n     *\n     * @param name Name of the requested instance.\n     * @return The requested instance or <code>null</code> if the named\n     *         instance could not be found.\n     */\n    public static ICheckConfiguration getByName(String name) {\n        ICheckConfiguration config = null;\n        Iterator it = sConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration tmp = (ICheckConfiguration) it.next();\n            if (tmp.getName().equals(name)) {\n                config = tmp;\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Get a list of the currently defined check configurations.\n     *\n     * @return A list containing all instances.\n     */\n    public static List getCheckConfigurations() {\n        return Collections.unmodifiableList(sConfigurations);\n    }\n\n    /**\n     * Returns the default check configuration if one is set, if none is set the\n     * Sun Checks built-in configuration will be returned.\n     *\n     * @return the default check configuration to use with unconfigured projects\n     */\n    public static ICheckConfiguration getDefaultCheckConfiguration() {\n        if (sDefaultCheckConfig != null) {\n            return sDefaultCheckConfig;\n        } else {\n            return (ICheckConfiguration) sConfigurations.get(0);\n        }\n    }\n\n    /**\n     * Creates a new working set from the existing configurations.\n     *\n     * @return a new configuration working set\n     */\n    public static ICheckConfigurationWorkingSet newWorkingSet() {\n        return new GlobalCheckConfigurationWorkingSet(sConfigurations, getDefaultCheckConfiguration());\n    }\n\n    /**\n     * Refreshes the check configurations from the persistent store.\n     */\n    public static void refresh() {\n        try {\n            sConfigurations.clear();\n            loadBuiltinConfigurations();\n            loadFromPersistence();\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.log(e);\n        }\n    }\n\n    /**\n     * Copy the checkstyle configuration of a check configuration into another\n     * configuration.\n     *\n     * @param source the source check configuration\n     * @param target the target check configuartion\n     * @throws CheckstylePluginException Error copying the configuration\n     */\n    public static void copyConfiguration(ICheckConfiguration source, ICheckConfiguration target) throws CheckstylePluginException {\n        // use the export function ;-)\n        String targetFile = target.getResolvedConfigurationFileURL().getFile();\n        String sourceFile = source.getResolvedConfigurationFileURL().getFile();\n        // copying from a file to the same file will destroy it.\n        if (ObjectUtils.equals(targetFile, sourceFile)) {\n            return;\n        }\n        exportConfiguration(new File(targetFile), source);\n    }\n\n    /**\n     * Write check configurations to an external file in standard Checkstyle\n     * format.\n     *\n     * @param file File to write too.\n     * @param config List of check configurations to write out.\n     * @throws CheckstylePluginException Error during export.\n     */\n    public static void exportConfiguration(File file, ICheckConfiguration config) throws CheckstylePluginException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            // Just copy the checkstyle configuration\n            in = config.getCheckstyleConfiguration().getCheckConfigFileStream();\n            out = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copy(in, out);\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Load the check configurations from the persistent state storage.\n     */\n    private static void loadFromPersistence() throws CheckstylePluginException {\n        InputStream inStream = null;\n        try {\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            //\n            // Make sure the files exists, it might not.\n            //\n            if (!configFile.exists()) {\n                return;\n            } else {\n                inStream = new BufferedInputStream(new FileInputStream(configFile));\n            }\n            CheckConfigurationsFileHandler handler = new CheckConfigurationsFileHandler();\n            XMLUtil.parseWithSAX(inStream, handler);\n            if (handler.isOldFileFormat()) {\n                migrate();\n            } else {\n                sConfigurations.addAll(handler.getConfigurations());\n                String defaultConfigName = handler.getDefaultCheckConfigurationName();\n                Iterator it = sConfigurations.iterator();\n                while (it.hasNext()) {\n                    ICheckConfiguration config = (ICheckConfiguration) it.next();\n                    if (config.getName().equals(defaultConfigName)) {\n                        sDefaultCheckConfig = config;\n                    }\n                }\n            }\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorLoadingConfigFile);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n        }\n    }\n\n    /**\n     * Loads the built-in check configurations defined in plugin.xml or custom\n     * fragments.\n     */\n    private static void loadBuiltinConfigurations() {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(CONFIGS_EXTENSION_POINT);\n        for (int i = 0; i < elements.length; i++) {\n            String name = elements[i].getAttribute(XMLTags.NAME_TAG);\n            String description = elements[i].getAttribute(XMLTags.DESCRIPTION_TAG);\n            String location = elements[i].getAttribute(XMLTags.LOCATION_TAG);\n            //$NON-NLS-1$\n            IConfigurationType configType = ConfigurationTypes.getByInternalName(\"builtin\");\n            ICheckConfiguration checkConfig = new CheckConfiguration(name, location, description, configType, true, null, null);\n            sConfigurations.add(checkConfig);\n        }\n    }\n\n    private static void migrate() throws CheckstylePluginException {\n        InputStream inStream = null;\n        InputStream defaultConfigStream = null;\n        try {\n            // get inputstream to the current oldstyle config\n            IPath configPath = CheckstylePlugin.getDefault().getStateLocation();\n            configPath = configPath.append(CHECKSTYLE_CONFIG_FILE);\n            File configFile = configPath.toFile();\n            inStream = new BufferedInputStream(new FileInputStream(configFile));\n            // migrate the configurations\n            ICheckConfigurationWorkingSet workingSet = newWorkingSet();\n            CheckConfigurationMigrator.migrate(inStream, workingSet);\n            workingSet.store();\n            // refresh the cached instances\n            refresh();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, ErrorMessages.errorMigratingConfig);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n            IOUtils.closeQuietly(defaultConfigStream);\n        }\n    }\n\n    /**\n     * SAX-DefaultHandler for parsing the check-configurations file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class CheckConfigurationsFileHandler extends DefaultHandler {\n\n        /**\n         * the configurations read from the xml.\n         */\n        private List mConfigurations = new ArrayList();\n\n        /**\n         * Flags if the old plugin configuration file format was detected.\n         */\n        private boolean mOldFileFormat;\n\n        /**\n         * The name of the current check configuration.\n         */\n        private String mCurrentName;\n\n        /**\n         * The location of the current check configuration.\n         */\n        private String mCurrentLocation;\n\n        /**\n         * The description of the current check configuration.\n         */\n        private String mCurrentDescription;\n\n        /**\n         * The configuration type of the current configuration.\n         */\n        private IConfigurationType mCurrentConfigType;\n\n        /**\n         * Additional data for the current configuration.\n         */\n        private Map mCurrentAddValues;\n\n        /**\n         * List of resolvable properties for this configuration.\n         */\n        private List mResolvableProperties;\n\n        /**\n         * The default check configuration name.\n         */\n        private String mDefaultConfigName;\n\n        /**\n         * Return the configurations this handler built.\n         *\n         * @return the configurations\n         */\n        public List getConfigurations() {\n            return mConfigurations;\n        }\n\n        /**\n         * Returns the default check configuration name or <code>null</code>\n         * if none was specified.\n         *\n         * @return the default check configuration name or <code>null</code>\n         */\n        public String getDefaultCheckConfigurationName() {\n            return mDefaultConfigName;\n        }\n\n        /**\n         * Returns if the old plugin file format was detected.\n         *\n         * @return <code>true</code> if the old file format was detected\n         */\n        public boolean isOldFileFormat() {\n            return mOldFileFormat;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            if (XMLTags.CHECKSTYLE_ROOT_TAG.equals(qName)) {\n                String version = attributes.getValue(XMLTags.VERSION_TAG);\n                if (!CURRENT_CONFIG_FILE_FORMAT_VERSION.equals(version)) {\n                    mOldFileFormat = true;\n                }\n                mDefaultConfigName = attributes.getValue(XMLTags.DEFAULT_CHECK_CONFIG_TAG);\n            } else if (!mOldFileFormat && XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                mCurrentName = attributes.getValue(XMLTags.NAME_TAG);\n                mCurrentDescription = attributes.getValue(XMLTags.DESCRIPTION_TAG);\n                mCurrentLocation = attributes.getValue(XMLTags.LOCATION_TAG);\n                String type = attributes.getValue(XMLTags.TYPE_TAG);\n                mCurrentConfigType = ConfigurationTypes.getByInternalName(type);\n                mCurrentAddValues = new HashMap();\n                mResolvableProperties = new ArrayList();\n            } else if (!mOldFileFormat && XMLTags.ADDITIONAL_DATA_TAG.equals(qName)) {\n                mCurrentAddValues.put(attributes.getValue(XMLTags.NAME_TAG), attributes.getValue(XMLTags.VALUE_TAG));\n            } else if (!mOldFileFormat && XMLTags.PROPERTY_TAG.equals(qName)) {\n                String name = attributes.getValue(XMLTags.NAME_TAG);\n                String value = attributes.getValue(XMLTags.VALUE_TAG);\n                ResolvableProperty prop = new ResolvableProperty(name, value);\n                mResolvableProperties.add(prop);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (!mOldFileFormat && XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                try {\n                    ICheckConfiguration checkConfig = new CheckConfiguration(mCurrentName, mCurrentLocation, mCurrentDescription, mCurrentConfigType, true, mResolvableProperties, mCurrentAddValues);\n                    mConfigurations.add(checkConfig);\n                } catch (Exception e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/config/CheckConfigurationFactory_3Test.java",
		"test_prompt": "// CheckConfigurationFactory_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.config;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.ObjectUtils;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Platform;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.migration.CheckConfigurationMigrator;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckConfigurationFactory}.\n* It contains ten unit test cases for the {@link CheckConfigurationFactory#newWorkingSet()} method.\n*/\nclass CheckConfigurationFactory_3Test {"
	},
	{
		"original_code": "// VotingPreferencePage.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.voting;\n\nimport java.io.IOException;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.jface.preference.PreferencePage;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.ComboViewer;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.StructuredSelection;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchPreferencePage;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Page to cast votes for the plugin.\n *\n * @author Lars Koedderitzsch\n */\npublic class VotingPreferencePage extends PreferencePage implements IWorkbenchPreferencePage {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    private static final Integer[] RATINGS = new Integer[] { new Integer(10), new Integer(9), new Integer(8), new Integer(7), new Integer(6), new Integer(5), new Integer(4), new Integer(3), new Integer(2), new Integer(1) };\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private ComboViewer mComboRating;\n\n    private Text mTxtComment;\n\n    private Button mBtnVote;\n\n    private PageController mPageController = new PageController();\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Constructor.\n     */\n    public VotingPreferencePage() {\n        super();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * {@inheritDoc}\n     */\n    public void init(IWorkbench workbench) {\n        // NOOP\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite ancestor) {\n        noDefaultAndApplyButton();\n        //\n        // Build the top level composite with one colume.\n        //\n        Composite parentComposite = new Composite(ancestor, SWT.NULL);\n        GridLayout layout = new GridLayout(2, false);\n        parentComposite.setLayout(layout);\n        Label lblVotingDesc = new Label(parentComposite, SWT.WRAP);\n        lblVotingDesc.setText(Messages.VotingPreferencePage_lblDescription);\n        GridData gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.horizontalSpan = 2;\n        lblVotingDesc.setLayoutData(gd);\n        Label lblRating = new Label(parentComposite, SWT.NULL);\n        lblRating.setText(Messages.VotingPreferencePage_lblRating);\n        gd = new GridData();\n        lblRating.setLayoutData(gd);\n        mComboRating = new ComboViewer(parentComposite);\n        mComboRating.setContentProvider(new ArrayContentProvider());\n        mComboRating.setInput(RATINGS);\n        mComboRating.setSelection(new StructuredSelection(RATINGS[0]));\n        mComboRating.setLabelProvider(new RatingLabelProvider());\n        gd = new GridData();\n        mComboRating.getCombo().setLayoutData(gd);\n        Label lblComment = new Label(parentComposite, SWT.NULL);\n        lblComment.setText(Messages.VotingPreferencePage_lblComment);\n        gd = new GridData();\n        gd.horizontalSpan = 2;\n        lblComment.setLayoutData(gd);\n        mTxtComment = new Text(parentComposite, SWT.MULTI | SWT.WRAP | SWT.BORDER);\n        gd = new GridData(GridData.FILL_BOTH);\n        gd.horizontalSpan = 2;\n        mTxtComment.setLayoutData(gd);\n        mBtnVote = new Button(parentComposite, SWT.PUSH);\n        mBtnVote.setText(Messages.VotingPreferencePage_btnVote);\n        gd = new GridData();\n        gd.widthHint = 80;\n        gd.horizontalAlignment = GridData.END;\n        gd.horizontalSpan = 2;\n        mBtnVote.setLayoutData(gd);\n        mBtnVote.addSelectionListener(mPageController);\n        return parentComposite;\n    }\n\n    /**\n     * The controller.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class PageController implements SelectionListener {\n\n        public void widgetSelected(SelectionEvent e) {\n            if (e.widget == mBtnVote) {\n                IStructuredSelection sel = (IStructuredSelection) mComboRating.getSelection();\n                Vote vote = new Vote(((Integer) sel.getFirstElement()).intValue(), mTxtComment.getText());\n                try {\n                    vote.cast();\n                    MessageDialog.openInformation(getShell(), Messages.VotingPreferencePage_titleVoteRegistered, Messages.VotingPreferencePage_msgVoteRegistered);\n                } catch (IOException e1) {\n                    CheckstyleLog.errorDialog(getShell(), e1, false);\n                }\n            }\n        }\n\n        public void widgetDefaultSelected(SelectionEvent e) {\n            // NOOP\n        }\n    }\n\n    /**\n     * Label provider to illustrate the ratings a bit more.\n     *\n     * @author Lars Koedderitzsch\n     */\n    private class RatingLabelProvider extends LabelProvider {\n\n        public String getText(Object element) {\n            String text = null;\n            if (element.equals(RATINGS[0])) {\n                text = Messages.VotingPreferencePage_ratingBest;\n            } else if (element.equals(RATINGS[RATINGS.length - 1])) {\n                text = Messages.VotingPreferencePage_ratingWorst;\n            } else {\n                text = super.getText(element);\n            }\n            return text;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/voting/VotingPreferencePage.java",
		"test_prompt": "// VotingPreferencePageTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.voting;\n\nimport java.io.IOException;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.jface.preference.PreferencePage;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.ComboViewer;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.StructuredSelection;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchPreferencePage;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link VotingPreferencePage}.\n* It contains ten unit test cases for the {@link VotingPreferencePage#createContents(Composite)} method.\n*/\nclass VotingPreferencePageTest {"
	},
	{
		"original_code": "// ConfigureDeconfigureNatureJob.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.nature;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.WorkspaceJob;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\n\n/**\n * This operation configures or deconfigures a project with a given nature. If\n * the project is already configured with this nature, the nature will be\n * deconfigured. Otherwise if the project is not configured with this nature,\n * the nature will be configured for this project\n *\n * @author Lars K�dderitzsch\n */\npublic class ConfigureDeconfigureNatureJob extends WorkspaceJob {\n\n    /**\n     * the project to be configured/deconfigured.\n     */\n    private IProject mProject;\n\n    /**\n     * the nature to be configured/deconfigured.\n     */\n    private String mNatureId;\n\n    /**\n     * the monitor.\n     */\n    private IProgressMonitor mMonitor;\n\n    /**\n     * Construktor for this operation.\n     *\n     * @param project the project to be configured/deconfiured\n     * @param natureId the nature the project will be configured/deconfigured\n     */\n    public ConfigureDeconfigureNatureJob(IProject project, String natureId) {\n        super(NLS.bind(Messages.ConfigureDeconfigureNatureJob_msgTaksAddingNature, natureId));\n        mProject = project;\n        mNatureId = natureId;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n        IStatus status = null;\n        mMonitor = monitor;\n        try {\n            if (mProject.hasNature(mNatureId)) {\n                disableNature();\n            } else {\n                enableNature();\n            }\n            status = Status.OK_STATUS;\n        } finally {\n            monitor.done();\n        }\n        return status;\n    }\n\n    /**\n     * Helper method to enable the given nature for the project.\n     *\n     * @throws CoreException an error while setting the nature occured\n     */\n    private void enableNature() throws CoreException {\n        // get the description\n        IProjectDescription desc = mProject.getDescription();\n        // copy existing natures and add the nature\n        String[] natures = desc.getNatureIds();\n        String[] newNatures = new String[natures.length + 1];\n        System.arraycopy(natures, 0, newNatures, 0, natures.length);\n        newNatures[natures.length] = mNatureId;\n        // set natures\n        desc.setNatureIds(newNatures);\n        mProject.setDescription(desc, mMonitor);\n    }\n\n    /**\n     * Helper method to disable the given nature for the project.\n     *\n     * @throws CoreException an error while removing the nature occured\n     */\n    private void disableNature() throws CoreException {\n        IProjectDescription desc = mProject.getDescription();\n        String[] natures = desc.getNatureIds();\n        // remove given nature from the array\n        List newNaturesList = new ArrayList();\n        for (int i = 0; i < natures.length; i++) {\n            if (!mNatureId.equals(natures[i])) {\n                newNaturesList.add(natures[i]);\n            }\n        }\n        String[] newNatures = (String[]) newNaturesList.toArray(new String[newNaturesList.size()]);\n        // set natures\n        desc.setNatureIds(newNatures);\n        mProject.setDescription(desc, mMonitor);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/nature/ConfigureDeconfigureNatureJob.java",
		"test_prompt": "// ConfigureDeconfigureNatureJobTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.nature;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.WorkspaceJob;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigureDeconfigureNatureJob}.\n* It contains ten unit test cases for the {@link ConfigureDeconfigureNatureJob#runInWorkspace(IProgressMonitor)} method.\n*/\nclass ConfigureDeconfigureNatureJobTest {"
	},
	{
		"original_code": "// CheckstyleNature.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.nature;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.util.Vector;\nimport org.eclipse.core.resources.ICommand;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.IProjectNature;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.JavaCore;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleMarker;\n\n/**\n * Checkstyle project nature.\n */\npublic class CheckstyleNature implements IProjectNature {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    /**\n     * ID for the Checkstyle project nature.\n     */\n    //$NON-NLS-1$\n    public static final String NATURE_ID = CheckstylePlugin.PLUGIN_ID + \".CheckstyleNature\";\n\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    /**\n     * The project.\n     */\n    private IProject mProject;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * {@inheritDoc}\n     */\n    public void configure() throws CoreException {\n        //\n        // Add the builder to the project.\n        //\n        IProjectDescription description = mProject.getDescription();\n        ICommand[] commands = description.getBuildSpec();\n        boolean found = false;\n        for (int i = 0; i < commands.length; ++i) {\n            if (commands[i].getBuilderName().equals(CheckstyleBuilder.BUILDER_ID)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            // add builder to project\n            ICommand command = description.newCommand();\n            command.setBuilderName(CheckstyleBuilder.BUILDER_ID);\n            ICommand[] newCommands = new ICommand[commands.length + 1];\n            // Add it after the other builders.\n            System.arraycopy(commands, 0, newCommands, 0, commands.length);\n            newCommands[commands.length] = command;\n            description.setBuildSpec(newCommands);\n            mProject.setDescription(description, null);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void deconfigure() throws CoreException {\n        //\n        // Remove the builder from the project.\n        //\n        IProjectDescription description = mProject.getDescription();\n        ICommand[] commands = description.getBuildSpec();\n        Vector newCommandsVec = new Vector(0);\n        for (int i = 0; i < commands.length; ++i) {\n            if (commands[i].getBuilderName().equals(CheckstyleBuilder.BUILDER_ID)) {\n                continue;\n            } else {\n                newCommandsVec.add(commands[i]);\n            }\n        }\n        ICommand[] newCommands = new ICommand[newCommandsVec.size()];\n        for (int i = 0; i < newCommandsVec.size(); i++) {\n            newCommands[i] = (ICommand) newCommandsVec.elementAt(i);\n        }\n        description.setBuildSpec(newCommands);\n        mProject.setDescription(description, new NullProgressMonitor());\n        // remove checkstyle markers from the project\n        getProject().deleteMarkers(CheckstyleMarker.MARKER_ID, true, IResource.DEPTH_INFINITE);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProject;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setProject(IProject project) {\n        mProject = project;\n    }\n\n    /**\n     * Checks if the ordering of the builders of the given project is correct,\n     * more specifically if the CheckstyleBuilder is set to run after the\n     * JavaBuilder.\n     *\n     * @param project the project to check\n     * @return <code>true</code> if the builder order for this project is\n     *         correct, <code>false</code> otherwise\n     * @throws CoreException error getting project description\n     */\n    public static boolean hasCorrectBuilderOrder(IProject project) throws CoreException {\n        IProjectDescription description = project.getDescription();\n        ICommand[] commands = description.getBuildSpec();\n        int javaBuilderIndex = -1;\n        int checkstyleBuilderIndex = -1;\n        for (int i = 0; i < commands.length; i++) {\n            if (commands[i].getBuilderName().equals(CheckstyleBuilder.BUILDER_ID)) {\n                checkstyleBuilderIndex = i;\n            } else if (commands[i].getBuilderName().equals(JavaCore.BUILDER_ID)) {\n                javaBuilderIndex = i;\n            }\n        }\n        return javaBuilderIndex < checkstyleBuilderIndex;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/nature/CheckstyleNature.java",
		"test_prompt": "// CheckstyleNatureTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.nature;\n\n//=================================================\n// Imports from java namespace\n//=================================================\nimport java.util.Vector;\nimport org.eclipse.core.resources.ICommand;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.IProjectNature;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.jdt.core.JavaCore;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleBuilder;\nimport com.atlassw.tools.eclipse.checkstyle.builder.CheckstyleMarker;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstyleNature}.\n* It contains ten unit test cases for the {@link CheckstyleNature#hasCorrectBuilderOrder(IProject)} method.\n*/\nclass CheckstyleNatureTest {"
	},
	{
		"original_code": "// ComplexFileSetsEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.CheckboxTableViewer;\nimport org.eclipse.jface.viewers.ColumnWeightData;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.ITableLabelProvider;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.TableLayout;\nimport org.eclipse.jface.viewers.Viewer;\nimport org.eclipse.jface.viewers.ViewerSorter;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.graphics.Image;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Event;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Listener;\nimport org.eclipse.swt.widgets.Table;\nimport org.eclipse.swt.widgets.TableColumn;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Property page.\n */\npublic class ComplexFileSetsEditor implements IFileSetsEditor {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private IProject mProject;\n\n    private Composite mComposite;\n\n    private CheckboxTableViewer mViewer;\n\n    private Button mAddButton;\n\n    private Button mEditButton;\n\n    private Button mRemoveButton;\n\n    private List mFileSets;\n\n    private CheckstylePropertyPage mPropertyPage;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Creates the ComplexFileSetsEditor.\n     *\n     * @param propsPage the property page\n     */\n    public ComplexFileSetsEditor(CheckstylePropertyPage propsPage) {\n        mPropertyPage = propsPage;\n        mProject = (IProject) propsPage.getElement();\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * {@inheritDoc}\n     */\n    public void setFileSets(List fileSets) {\n        mFileSets = fileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite parent) throws CheckstylePluginException {\n        mComposite = parent;\n        Group composite = new Group(parent, SWT.NONE);\n        composite.setText(Messages.ComplexFileSetsEditor_titleAdvancedFilesetEditor);\n        GridLayout layout = new GridLayout();\n        layout.numColumns = 2;\n        composite.setLayout(layout);\n        //\n        // Create the table of file sets.\n        //\n        Table table = new Table(composite, SWT.CHECK | SWT.BORDER | SWT.FULL_SELECTION);\n        GridData data = new GridData(GridData.FILL_BOTH);\n        table.setLayoutData(data);\n        table.setHeaderVisible(true);\n        table.setLinesVisible(true);\n        TableLayout tableLayout = new TableLayout();\n        table.setLayout(tableLayout);\n        TableColumn column1 = new TableColumn(table, SWT.NONE);\n        column1.setText(Messages.ComplexFileSetsEditor_colEnabled);\n        column1.setResizable(false);\n        TableColumn column2 = new TableColumn(table, SWT.NONE);\n        column2.setText(Messages.ComplexFileSetsEditor_colFilesetName);\n        TableColumn column3 = new TableColumn(table, SWT.NONE);\n        column3.setText(Messages.ComplexFileSetsEditor_colConfiguration);\n        tableLayout.addColumnData(new ColumnWeightData(20));\n        tableLayout.addColumnData(new ColumnWeightData(40));\n        tableLayout.addColumnData(new ColumnWeightData(40));\n        mViewer = new CheckboxTableViewer(table);\n        mViewer.setLabelProvider(new FileSetLabelProvider());\n        mViewer.setContentProvider(new ArrayContentProvider());\n        mViewer.setSorter(new FileSetViewerSorter());\n        mViewer.setInput(mFileSets);\n        //\n        // Set checked state\n        //\n        Iterator iter = mFileSets.iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            mViewer.setChecked(fileSet, fileSet.isEnabled());\n        }\n        mViewer.addDoubleClickListener(new IDoubleClickListener() {\n\n            public void doubleClick(DoubleClickEvent e) {\n                editFileSet();\n            }\n        });\n        mViewer.addCheckStateListener(new ICheckStateListener() {\n\n            public void checkStateChanged(CheckStateChangedEvent event) {\n                changeEnabledState(event);\n            }\n        });\n        //\n        // Build the buttons.\n        //\n        Composite buttons = new Composite(composite, SWT.NULL);\n        buttons.setLayoutData(new GridData(GridData.VERTICAL_ALIGN_BEGINNING));\n        layout = new GridLayout();\n        layout.marginHeight = 0;\n        layout.marginWidth = 0;\n        buttons.setLayout(layout);\n        mAddButton = createPushButton(buttons, Messages.ComplexFileSetsEditor_btnAdd);\n        mAddButton.addListener(SWT.Selection, new Listener() {\n\n            public void handleEvent(Event evt) {\n                addFileSet();\n            }\n        });\n        mEditButton = createPushButton(buttons, Messages.ComplexFileSetsEditor_btnEdit);\n        mEditButton.addListener(SWT.Selection, new Listener() {\n\n            public void handleEvent(Event evt) {\n                editFileSet();\n            }\n        });\n        mRemoveButton = createPushButton(buttons, Messages.ComplexFileSetsEditor_btnRemove);\n        mRemoveButton.addListener(SWT.Selection, new Listener() {\n\n            public void handleEvent(Event evt) {\n                removeFileSet();\n            }\n        });\n        return composite;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void refresh() {\n        // NOOP\n    }\n\n    /**\n     * Utility method that creates a push button instance and sets the default\n     * layout data.\n     *\n     * @param parent the parent for the new button\n     * @param label the label for the new button\n     * @return the newly-created button\n     */\n    private Button createPushButton(Composite parent, String label) {\n        Button button = new Button(parent, SWT.PUSH);\n        button.setText(label);\n        GridData data = new GridData();\n        data.horizontalAlignment = GridData.FILL;\n        button.setLayoutData(data);\n        return button;\n    }\n\n    private void addFileSet() {\n        try {\n            FileSetEditDialog dialog = new FileSetEditDialog(mComposite.getShell(), null, mProject, mPropertyPage);\n            if (FileSetEditDialog.OK == dialog.open()) {\n                FileSet fileSet = dialog.getFileSet();\n                mFileSets.add(fileSet);\n                mViewer.refresh();\n                mViewer.setChecked(fileSet, fileSet.isEnabled());\n                mPropertyPage.getContainer().updateButtons();\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(mComposite.getShell(), NLS.bind(ErrorMessages.errorFailedAddFileset, e.getMessage()), e, true);\n        }\n    }\n\n    private void editFileSet() {\n        IStructuredSelection selection = (IStructuredSelection) mViewer.getSelection();\n        FileSet fileSet = (FileSet) selection.getFirstElement();\n        if (fileSet == null) {\n            //\n            // Nothing is selected.\n            //\n            return;\n        }\n        try {\n            FileSetEditDialog dialog = new FileSetEditDialog(mComposite.getShell(), (FileSet) fileSet.clone(), mProject, mPropertyPage);\n            if (FileSetEditDialog.OK == dialog.open()) {\n                FileSet newFileSet = dialog.getFileSet();\n                mFileSets.remove(fileSet);\n                mFileSets.add(newFileSet);\n                mViewer.refresh();\n                mViewer.setChecked(newFileSet, newFileSet.isEnabled());\n                mPropertyPage.getContainer().updateButtons();\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(mComposite.getShell(), NLS.bind(ErrorMessages.errorFailedEditFileset, e.getMessage()), e, true);\n        }\n    }\n\n    private void removeFileSet() {\n        IStructuredSelection selection = (IStructuredSelection) mViewer.getSelection();\n        FileSet fileSet = (FileSet) selection.getFirstElement();\n        if (fileSet == null) {\n            //\n            // Nothing is selected.\n            //\n            return;\n        }\n        mFileSets.remove(fileSet);\n        mViewer.refresh();\n        mPropertyPage.getContainer().updateButtons();\n    }\n\n    private void changeEnabledState(CheckStateChangedEvent event) {\n        if (event.getElement() instanceof FileSet) {\n            FileSet fileSet = (FileSet) event.getElement();\n            fileSet.setEnabled(event.getChecked());\n            mViewer.refresh();\n        }\n    }\n\n    /**\n     * Provides the labels for the FileSet list display.\n     */\n    class FileSetLabelProvider extends LabelProvider implements ITableLabelProvider {\n\n        private CheckConfigurationLabelProvider mCheckConfigLabelProvider = new CheckConfigurationLabelProvider();\n\n        /**\n         * @see ITableLabelProvider#getColumnText(Object, int)\n         */\n        public String getColumnText(Object element, int columnIndex) {\n            String result = element.toString();\n            if (element instanceof FileSet) {\n                FileSet fileSet = (FileSet) element;\n                switch(columnIndex) {\n                    case 0:\n                        result = new String();\n                        break;\n                    case 1:\n                        result = fileSet.getName();\n                        break;\n                    case 2:\n                        result = fileSet.getCheckConfig() != null ? mCheckConfigLabelProvider.getText(fileSet.getCheckConfig()) : //$NON-NLS-1$\n                        \"\";\n                        break;\n                    default:\n                        break;\n                }\n            }\n            return result;\n        }\n\n        /**\n         * @see ITableLabelProvider#getColumnImage(Object, int)\n         */\n        public Image getColumnImage(Object element, int columnIndex) {\n            return null;\n        }\n    }\n\n    /**\n     * Sorts CheckConfiguration objects into their display order.\n     */\n    public class FileSetViewerSorter extends ViewerSorter {\n\n        /**\n         * {@inheritDoc}\n         */\n        public int compare(Viewer viewer, Object e1, Object e2) {\n            int result = 0;\n            if ((e1 instanceof FileSet) && (e2 instanceof FileSet)) {\n                FileSet fileSet1 = (FileSet) e1;\n                FileSet fileSet2 = (FileSet) e2;\n                String name1 = fileSet1.getName();\n                String name2 = fileSet2.getName();\n                result = name1.compareTo(name2);\n            }\n            return result;\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/properties/ComplexFileSetsEditor.java",
		"test_prompt": "// ComplexFileSetsEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.CheckboxTableViewer;\nimport org.eclipse.jface.viewers.ColumnWeightData;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.ITableLabelProvider;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.TableLayout;\nimport org.eclipse.jface.viewers.Viewer;\nimport org.eclipse.jface.viewers.ViewerSorter;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.graphics.Image;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Event;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Listener;\nimport org.eclipse.swt.widgets.Table;\nimport org.eclipse.swt.widgets.TableColumn;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ComplexFileSetsEditor}.\n* It contains ten unit test cases for the {@link ComplexFileSetsEditor#createContents(Composite)} method.\n*/\nclass ComplexFileSetsEditorTest {"
	},
	{
		"original_code": "// CheckstylePropertyPage.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IncrementalProjectBuilder;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.CheckboxTableViewer;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.ISelection;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.TabFolder;\nimport org.eclipse.swt.widgets.TabItem;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.dialogs.PropertyPage;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.BuildProjectJob;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.nature.CheckstyleNature;\nimport com.atlassw.tools.eclipse.checkstyle.nature.ConfigureDeconfigureNatureJob;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilterEditor;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Property page for projects to enable checkstyle audit.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckstylePropertyPage extends PropertyPage {\n\n    //\n    // controls\n    //\n    /**\n     * The tab folder.\n     */\n    private TabFolder mMainTab = null;\n\n    /**\n     * button to enable checkstyle for the project.\n     */\n    private Button mChkEnable;\n\n    /**\n     * button to enable/disable the simple configuration.\n     */\n    private Button mChkSimpleConfig;\n\n    /**\n     * the container holding the file sets editor.\n     */\n    private Composite mFileSetsContainer;\n\n    /**\n     * the editor for the file sets.\n     */\n    private IFileSetsEditor mFileSetsEditor;\n\n    /**\n     * viewer to display the known checkstyle filters.\n     */\n    private CheckboxTableViewer mFilterList;\n\n    /**\n     * button to open a filter editor.\n     */\n    private Button mBtnEditFilter;\n\n    /**\n     * used to display the filter description.\n     */\n    private Text mTxtFilterDescription;\n\n    //\n    // other members\n    //\n    /**\n     * controller of this page.\n     */\n    private PageController mPageController;\n\n    /**\n     * the actual working data for this form.\n     */\n    private ProjectConfigurationWorkingCopy mProjectConfig;\n\n    /**\n     * the local configurations working set editor.\n     */\n    private CheckConfigurationWorkingSetEditor mWorkingSetEditor;\n\n    private boolean mCheckstyleInitiallyActivated;\n\n    //\n    // methods\n    //\n    /**\n     * Returns the project configuration.\n     *\n     * @return the project configuration\n     */\n    public ProjectConfigurationWorkingCopy getProjectConfigurationWorkingCopy() {\n        return mProjectConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setElement(IAdaptable element) {\n        super.setElement(element);\n        try {\n            //\n            // Get the project.\n            //\n            IProject project = null;\n            IResource resource = (IResource) element;\n            if (resource.getType() == IResource.PROJECT) {\n                project = (IProject) resource;\n            }\n            IProjectConfiguration projectConfig = ProjectConfigurationFactory.getConfiguration(project);\n            mProjectConfig = new ProjectConfigurationWorkingCopy(projectConfig);\n            mCheckstyleInitiallyActivated = project.hasNature(CheckstyleNature.NATURE_ID);\n        } catch (CoreException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite parent) {\n        Composite container = null;\n        try {\n            this.mPageController = new PageController();\n            // suppress default- & apply-buttons\n            noDefaultAndApplyButton();\n            mMainTab = new TabFolder(parent, SWT.TOP);\n            mMainTab.setLayoutData(new GridData(GridData.FILL_BOTH));\n            mMainTab.addSelectionListener(mPageController);\n            // create the main container\n            container = new Composite(mMainTab, SWT.NULL);\n            container.setLayout(new FormLayout());\n            container.setLayoutData(new GridData(GridData.FILL_BOTH));\n            // create the checkbox to enable/diable the simple configuration\n            this.mChkSimpleConfig = new Button(container, SWT.CHECK);\n            this.mChkSimpleConfig.setText(Messages.CheckstylePropertyPage_btnUseSimpleConfig);\n            this.mChkSimpleConfig.addSelectionListener(this.mPageController);\n            this.mChkSimpleConfig.setSelection(mProjectConfig.isUseSimpleConfig());\n            FormData fd = new FormData();\n            // fd.left = new FormAttachment(this.mChkEnable, 0, SWT.RIGHT);\n            fd.top = new FormAttachment(0, 3);\n            fd.right = new FormAttachment(100, -3);\n            this.mChkSimpleConfig.setLayoutData(fd);\n            // create the checkbox to enabel/disable checkstyle\n            this.mChkEnable = new Button(container, SWT.CHECK);\n            this.mChkEnable.setText(Messages.CheckstylePropertyPage_btnActivateCheckstyle);\n            this.mChkEnable.addSelectionListener(this.mPageController);\n            this.mChkEnable.setSelection(mCheckstyleInitiallyActivated);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(0, 3);\n            fd.right = new FormAttachment(this.mChkSimpleConfig, 3, SWT.LEFT);\n            this.mChkEnable.setLayoutData(fd);\n            // create the configuration area\n            mFileSetsContainer = new Composite(container, SWT.NULL);\n            Control configArea = createFileSetsArea(mFileSetsContainer);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(this.mChkEnable, 6, SWT.BOTTOM);\n            fd.right = new FormAttachment(100, -3);\n            fd.bottom = new FormAttachment(45);\n            configArea.setLayoutData(fd);\n            // create the filter area\n            Control filterArea = createFilterArea(container);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(configArea, 3, SWT.BOTTOM);\n            fd.right = new FormAttachment(100, -3);\n            fd.bottom = new FormAttachment(100, -3);\n            fd.width = 500;\n            filterArea.setLayoutData(fd);\n            // create the local configurations area\n            Control localConfigArea = createLocalConfigArea(mMainTab);\n            TabItem mainItem = new TabItem(mMainTab, SWT.NULL);\n            mainItem.setControl(container);\n            mainItem.setText(Messages.CheckstylePropertyPage_tabMain);\n            TabItem localItem = new TabItem(mMainTab, SWT.NULL);\n            localItem.setControl(localConfigArea);\n            localItem.setText(Messages.CheckstylePropertyPage_tabCheckConfigs);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        }\n        return container;\n    }\n\n    /**\n     * Creates the file sets area.\n     *\n     * @param fileSetsContainer the container to add the file sets area to\n     */\n    private Control createFileSetsArea(Composite fileSetsContainer) throws CheckstylePluginException {\n        Control[] controls = fileSetsContainer.getChildren();\n        for (int i = 0; i < controls.length; i++) {\n            controls[i].dispose();\n        }\n        if (mProjectConfig.isUseSimpleConfig()) {\n            mFileSetsEditor = new SimpleFileSetsEditor(this);\n        } else {\n            mFileSetsEditor = new ComplexFileSetsEditor(this);\n        }\n        mFileSetsEditor.setFileSets(mProjectConfig.getFileSets());\n        Control editor = mFileSetsEditor.createContents(mFileSetsContainer);\n        fileSetsContainer.setLayout(new FormLayout());\n        FormData fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(100);\n        editor.setLayoutData(fd);\n        return fileSetsContainer;\n    }\n\n    /**\n     * Creates the filter area.\n     *\n     * @param container the container to add the filter area\n     */\n    private Control createFilterArea(Composite container) {\n        FormData fd = new FormData();\n        // group composite containing the filter settings\n        Group filterArea = new Group(container, SWT.NULL);\n        filterArea.setText(Messages.CheckstylePropertyPage_titleFilterGroup);\n        filterArea.setLayout(new FormLayout());\n        this.mFilterList = CheckboxTableViewer.newCheckList(filterArea, SWT.BORDER);\n        this.mBtnEditFilter = new Button(filterArea, SWT.PUSH);\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(this.mBtnEditFilter, -3, SWT.LEFT);\n        fd.bottom = new FormAttachment(60, -3);\n        this.mFilterList.getTable().setLayoutData(fd);\n        this.mFilterList.setLabelProvider(new LabelProvider() {\n\n            public String getText(Object element) {\n                StringBuffer buf = new StringBuffer();\n                if (element instanceof IFilter) {\n                    IFilter filter = (IFilter) element;\n                    buf.append(filter.getName());\n                    if (filter.getPresentableFilterData() != null) {\n                        //$NON-NLS-1$\n                        buf.append(\": \").append(filter.getPresentableFilterData());\n                    }\n                } else {\n                    buf.append(super.getText(element));\n                }\n                return buf.toString();\n            }\n        });\n        this.mFilterList.setContentProvider(new ArrayContentProvider());\n        this.mFilterList.addSelectionChangedListener(this.mPageController);\n        this.mFilterList.addDoubleClickListener(this.mPageController);\n        this.mFilterList.addCheckStateListener(this.mPageController);\n        this.mBtnEditFilter.setText(Messages.CheckstylePropertyPage_btnChangeFilter);\n        this.mBtnEditFilter.addSelectionListener(this.mPageController);\n        fd = new FormData();\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(100, -3);\n        this.mBtnEditFilter.setLayoutData(fd);\n        // Description\n        Label lblDesc = new Label(filterArea, SWT.LEFT);\n        lblDesc.setText(Messages.CheckstylePropertyPage_lblDescription);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(this.mFilterList.getTable(), 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100, -3);\n        lblDesc.setLayoutData(fd);\n        this.mTxtFilterDescription = new Text(filterArea, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.READ_ONLY | SWT.BORDER | SWT.VERTICAL);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(lblDesc, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100, -3);\n        fd.bottom = new FormAttachment(100, -3);\n        this.mTxtFilterDescription.setLayoutData(fd);\n        // intialize filter list\n        List filterDefs = mProjectConfig.getFilters();\n        this.mFilterList.setInput(filterDefs);\n        // set the checked state\n        for (int i = 0; i < filterDefs.size(); i++) {\n            IFilter filter = (IFilter) filterDefs.get(i);\n            this.mFilterList.setChecked(filter, filter.isEnabled());\n        }\n        // set the readonly state\n        for (int i = 0; i < filterDefs.size(); i++) {\n            IFilter filter = (IFilter) filterDefs.get(i);\n            this.mFilterList.setGrayed(filter, filter.isReadonly());\n        }\n        this.mBtnEditFilter.setEnabled(false);\n        return filterArea;\n    }\n\n    private Control createLocalConfigArea(Composite parent) {\n        Composite noteAndEditor = new Composite(parent, SWT.NULL);\n        noteAndEditor.setLayout(new GridLayout(1, false));\n        noteAndEditor.setLayoutData(new GridData(GridData.FILL_BOTH));\n        Label lblHint = new Label(noteAndEditor, SWT.WRAP);\n        lblHint.setText(Messages.CheckstylePropertyPage_msgLocalConfigs);\n        GridData gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.widthHint = 200;\n        lblHint.setLayoutData(gd);\n        mWorkingSetEditor = new CheckConfigurationWorkingSetEditor(mProjectConfig.getLocalCheckConfigWorkingSet(), false);\n        Control editorControl = mWorkingSetEditor.createContents(noteAndEditor);\n        editorControl.setLayoutData(new GridData(GridData.FILL_BOTH));\n        return noteAndEditor;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isValid() {\n        // check if all check configurations resolve\n        List fileSets = mProjectConfig.getFileSets();\n        Iterator it = fileSets.iterator();\n        while (it.hasNext()) {\n            FileSet fileset = (FileSet) it.next();\n            ICheckConfiguration checkConfig = fileset.getCheckConfig();\n            if (checkConfig != null) {\n                try {\n                    checkConfig.getCheckstyleConfiguration();\n                } catch (CheckstylePluginException e) {\n                    CheckstyleLog.warningDialog(getShell(), NLS.bind(ErrorMessages.errorCannotResolveCheckLocation, checkConfig.getLocation(), checkConfig.getName()), e);\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @return the result of the ok action\n     * @see org.eclipse.jface.preference.IPreferencePage#performOk()\n     */\n    public boolean performOk() {\n        try {\n            IProject project = mProjectConfig.getProject();\n            // save the edited project configuration\n            if (mProjectConfig.isDirty()) {\n                mProjectConfig.store();\n            }\n            boolean checkstyleEnabled = mChkEnable.getSelection();\n            boolean needRebuild = mProjectConfig.isRebuildNeeded();\n            // check if checkstyle nature has to be configured/deconfigured\n            if (checkstyleEnabled != mCheckstyleInitiallyActivated) {\n                ConfigureDeconfigureNatureJob configOperation = new ConfigureDeconfigureNatureJob(project, CheckstyleNature.NATURE_ID);\n                configOperation.setRule(ResourcesPlugin.getWorkspace().getRoot());\n                configOperation.schedule();\n                needRebuild = needRebuild || !mCheckstyleInitiallyActivated;\n            }\n            // if a rebuild is advised, check/prompt if the rebuild should\n            // really be done.\n            if (checkstyleEnabled && needRebuild) {\n                IPreferenceStore prefStore = CheckstylePlugin.getDefault().getPreferenceStore();\n                String promptRebuildPref = prefStore.getString(CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n                boolean doRebuild = MessageDialogWithToggle.ALWAYS.equals(promptRebuildPref) && needRebuild;\n                //\n                // Prompt for rebuild\n                //\n                if (MessageDialogWithToggle.PROMPT.equals(promptRebuildPref) && needRebuild) {\n                    MessageDialogWithToggle dialog = MessageDialogWithToggle.openYesNoQuestion(getShell(), Messages.CheckstylePropertyPage_titleRebuild, Messages.CheckstylePropertyPage_msgRebuild, Messages.CheckstylePropertyPage_nagRebuild, false, prefStore, CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n                    doRebuild = dialog.getReturnCode() == IDialogConstants.YES_ID;\n                }\n                // check if a rebuild is necessary\n                if (checkstyleEnabled && doRebuild) {\n                    BuildProjectJob rebuildOperation = new BuildProjectJob(project, IncrementalProjectBuilder.FULL_BUILD);\n                    rebuildOperation.setRule(ResourcesPlugin.getWorkspace().getRoot());\n                    rebuildOperation.schedule();\n                }\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), e, true);\n        }\n        return true;\n    }\n\n    /**\n     * This class works as controller for the page. It listenes for events to\n     * occur and handles the pages context.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class PageController extends SelectionAdapter implements ISelectionChangedListener, ICheckStateListener, IDoubleClickListener {\n\n        /**\n         * @see org.eclipse.swt.events.SelectionListener#widgetSelected(\n         *      org.eclipse.swt.events.SelectionEvent)\n         */\n        public void widgetSelected(SelectionEvent e) {\n            Object source = e.getSource();\n            // edit filter\n            if (source == mBtnEditFilter) {\n                ISelection selection = mFilterList.getSelection();\n                openFilterEditor(selection);\n            }\n            if (source == mMainTab) {\n                mFileSetsEditor.refresh();\n            } else if (source == mChkSimpleConfig) {\n                try {\n                    mProjectConfig.setUseSimpleConfig(mChkSimpleConfig.getSelection());\n                    IPreferenceStore prefStore = CheckstylePlugin.getDefault().getPreferenceStore();\n                    boolean showWarning = prefStore.getBoolean(CheckstylePlugin.PREF_FILESET_WARNING);\n                    if (mProjectConfig.isUseSimpleConfig() && showWarning) {\n                        MessageDialogWithToggle dialog = new MessageDialogWithToggle(getShell(), Messages.CheckstylePropertyPage_titleWarnFilesets, null, Messages.CheckstylePropertyPage_msgWarnFilesets, MessageDialogWithToggle.WARNING, new String[] { IDialogConstants.OK_LABEL }, 0, Messages.CheckstylePropertyPage_mgsWarnFileSetNagOption, showWarning) {\n\n                            /**\n                             * Overwritten because we don't want to store which\n                             * button the user pressed but the state of the\n                             * toggle.\n                             *\n                             * @see MessageDialogWithToggle#buttonPressed(int)\n                             */\n                            protected void buttonPressed(int buttonId) {\n                                getPrefStore().setValue(getPrefKey(), getToggleState());\n                                setReturnCode(buttonId);\n                                close();\n                            }\n                        };\n                        dialog.setPrefStore(prefStore);\n                        dialog.setPrefKey(CheckstylePlugin.PREF_FILESET_WARNING);\n                        dialog.open();\n                    }\n                    createFileSetsArea(mFileSetsContainer);\n                    mFileSetsContainer.redraw();\n                    mFileSetsContainer.update();\n                    mFileSetsContainer.layout();\n                } catch (CheckstylePluginException ex) {\n                    CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorChangingFilesetEditor, ex, true);\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.ISelectionChangedListener#selectionChanged\n         *      (org.eclipse.jface.viewers.SelectionChangedEvent)\n         */\n        public void selectionChanged(SelectionChangedEvent event) {\n            Object source = event.getSource();\n            if (source == mFilterList) {\n                ISelection selection = event.getSelection();\n                if (selection instanceof IStructuredSelection) {\n                    Object selectedElement = ((IStructuredSelection) selection).getFirstElement();\n                    if (selectedElement instanceof IFilter) {\n                        IFilter filterDef = (IFilter) selectedElement;\n                        mTxtFilterDescription.setText(filterDef.getDescription());\n                        // activate edit button\n                        mBtnEditFilter.setEnabled(filterDef.isEditable());\n                    }\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.ICheckStateListener#checkStateChanged\n         *      (org.eclipse.jface.viewers.CheckStateChangedEvent)\n         */\n        public void checkStateChanged(CheckStateChangedEvent event) {\n            Object element = event.getElement();\n            if (element instanceof IFilter) {\n                IFilter filter = (IFilter) element;\n                if (!filter.isReadonly()) {\n                    filter.setEnabled(event.getChecked());\n                } else {\n                    event.getCheckable().setChecked(event.getElement(), true);\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.IDoubleClickListener#doubleClick(\n         *      org.eclipse.jface.viewers.DoubleClickEvent)\n         */\n        public void doubleClick(DoubleClickEvent event) {\n            openFilterEditor(event.getSelection());\n        }\n\n        /**\n         * Open the filter editor on a given selection of the list.\n         *\n         * @param selection the selection\n         */\n        private void openFilterEditor(ISelection selection) {\n            if (selection instanceof IStructuredSelection) {\n                Object selectedElement = ((IStructuredSelection) selection).getFirstElement();\n                if (selectedElement instanceof IFilter) {\n                    try {\n                        IFilter aFilterDef = (IFilter) selectedElement;\n                        if (!aFilterDef.isEditable()) {\n                            return;\n                        }\n                        Class editorClass = aFilterDef.getEditorClass();\n                        IFilterEditor editableFilter = (IFilterEditor) editorClass.newInstance();\n                        editableFilter.setInputProject(mProjectConfig.getProject());\n                        editableFilter.setFilterData(aFilterDef.getFilterData());\n                        if (Window.OK == editableFilter.openEditor(getShell())) {\n                            aFilterDef.setFilterData(editableFilter.getFilterData());\n                            mFilterList.refresh();\n                        }\n                    } catch (IllegalAccessException ex) {\n                        CheckstyleLog.errorDialog(getShell(), ex, true);\n                    } catch (InstantiationException ex) {\n                        CheckstyleLog.errorDialog(getShell(), ex, true);\n                    }\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/properties/CheckstylePropertyPage_0Test.java",
		"test_prompt": "// CheckstylePropertyPage_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IncrementalProjectBuilder;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.CheckboxTableViewer;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.ISelection;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.TabFolder;\nimport org.eclipse.swt.widgets.TabItem;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.dialogs.PropertyPage;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.BuildProjectJob;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.nature.CheckstyleNature;\nimport com.atlassw.tools.eclipse.checkstyle.nature.ConfigureDeconfigureNatureJob;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilterEditor;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstylePropertyPage}.\n* It contains ten unit test cases for the {@link CheckstylePropertyPage#createContents(Composite)} method.\n*/\nclass CheckstylePropertyPage_0Test {"
	},
	{
		"original_code": "// CheckstylePropertyPage.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IncrementalProjectBuilder;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.CheckboxTableViewer;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.ISelection;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.TabFolder;\nimport org.eclipse.swt.widgets.TabItem;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.dialogs.PropertyPage;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.BuildProjectJob;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.nature.CheckstyleNature;\nimport com.atlassw.tools.eclipse.checkstyle.nature.ConfigureDeconfigureNatureJob;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilterEditor;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Property page for projects to enable checkstyle audit.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckstylePropertyPage extends PropertyPage {\n\n    //\n    // controls\n    //\n    /**\n     * The tab folder.\n     */\n    private TabFolder mMainTab = null;\n\n    /**\n     * button to enable checkstyle for the project.\n     */\n    private Button mChkEnable;\n\n    /**\n     * button to enable/disable the simple configuration.\n     */\n    private Button mChkSimpleConfig;\n\n    /**\n     * the container holding the file sets editor.\n     */\n    private Composite mFileSetsContainer;\n\n    /**\n     * the editor for the file sets.\n     */\n    private IFileSetsEditor mFileSetsEditor;\n\n    /**\n     * viewer to display the known checkstyle filters.\n     */\n    private CheckboxTableViewer mFilterList;\n\n    /**\n     * button to open a filter editor.\n     */\n    private Button mBtnEditFilter;\n\n    /**\n     * used to display the filter description.\n     */\n    private Text mTxtFilterDescription;\n\n    //\n    // other members\n    //\n    /**\n     * controller of this page.\n     */\n    private PageController mPageController;\n\n    /**\n     * the actual working data for this form.\n     */\n    private ProjectConfigurationWorkingCopy mProjectConfig;\n\n    /**\n     * the local configurations working set editor.\n     */\n    private CheckConfigurationWorkingSetEditor mWorkingSetEditor;\n\n    private boolean mCheckstyleInitiallyActivated;\n\n    //\n    // methods\n    //\n    /**\n     * Returns the project configuration.\n     *\n     * @return the project configuration\n     */\n    public ProjectConfigurationWorkingCopy getProjectConfigurationWorkingCopy() {\n        return mProjectConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setElement(IAdaptable element) {\n        super.setElement(element);\n        try {\n            //\n            // Get the project.\n            //\n            IProject project = null;\n            IResource resource = (IResource) element;\n            if (resource.getType() == IResource.PROJECT) {\n                project = (IProject) resource;\n            }\n            IProjectConfiguration projectConfig = ProjectConfigurationFactory.getConfiguration(project);\n            mProjectConfig = new ProjectConfigurationWorkingCopy(projectConfig);\n            mCheckstyleInitiallyActivated = project.hasNature(CheckstyleNature.NATURE_ID);\n        } catch (CoreException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite parent) {\n        Composite container = null;\n        try {\n            this.mPageController = new PageController();\n            // suppress default- & apply-buttons\n            noDefaultAndApplyButton();\n            mMainTab = new TabFolder(parent, SWT.TOP);\n            mMainTab.setLayoutData(new GridData(GridData.FILL_BOTH));\n            mMainTab.addSelectionListener(mPageController);\n            // create the main container\n            container = new Composite(mMainTab, SWT.NULL);\n            container.setLayout(new FormLayout());\n            container.setLayoutData(new GridData(GridData.FILL_BOTH));\n            // create the checkbox to enable/diable the simple configuration\n            this.mChkSimpleConfig = new Button(container, SWT.CHECK);\n            this.mChkSimpleConfig.setText(Messages.CheckstylePropertyPage_btnUseSimpleConfig);\n            this.mChkSimpleConfig.addSelectionListener(this.mPageController);\n            this.mChkSimpleConfig.setSelection(mProjectConfig.isUseSimpleConfig());\n            FormData fd = new FormData();\n            // fd.left = new FormAttachment(this.mChkEnable, 0, SWT.RIGHT);\n            fd.top = new FormAttachment(0, 3);\n            fd.right = new FormAttachment(100, -3);\n            this.mChkSimpleConfig.setLayoutData(fd);\n            // create the checkbox to enabel/disable checkstyle\n            this.mChkEnable = new Button(container, SWT.CHECK);\n            this.mChkEnable.setText(Messages.CheckstylePropertyPage_btnActivateCheckstyle);\n            this.mChkEnable.addSelectionListener(this.mPageController);\n            this.mChkEnable.setSelection(mCheckstyleInitiallyActivated);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(0, 3);\n            fd.right = new FormAttachment(this.mChkSimpleConfig, 3, SWT.LEFT);\n            this.mChkEnable.setLayoutData(fd);\n            // create the configuration area\n            mFileSetsContainer = new Composite(container, SWT.NULL);\n            Control configArea = createFileSetsArea(mFileSetsContainer);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(this.mChkEnable, 6, SWT.BOTTOM);\n            fd.right = new FormAttachment(100, -3);\n            fd.bottom = new FormAttachment(45);\n            configArea.setLayoutData(fd);\n            // create the filter area\n            Control filterArea = createFilterArea(container);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(configArea, 3, SWT.BOTTOM);\n            fd.right = new FormAttachment(100, -3);\n            fd.bottom = new FormAttachment(100, -3);\n            fd.width = 500;\n            filterArea.setLayoutData(fd);\n            // create the local configurations area\n            Control localConfigArea = createLocalConfigArea(mMainTab);\n            TabItem mainItem = new TabItem(mMainTab, SWT.NULL);\n            mainItem.setControl(container);\n            mainItem.setText(Messages.CheckstylePropertyPage_tabMain);\n            TabItem localItem = new TabItem(mMainTab, SWT.NULL);\n            localItem.setControl(localConfigArea);\n            localItem.setText(Messages.CheckstylePropertyPage_tabCheckConfigs);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        }\n        return container;\n    }\n\n    /**\n     * Creates the file sets area.\n     *\n     * @param fileSetsContainer the container to add the file sets area to\n     */\n    private Control createFileSetsArea(Composite fileSetsContainer) throws CheckstylePluginException {\n        Control[] controls = fileSetsContainer.getChildren();\n        for (int i = 0; i < controls.length; i++) {\n            controls[i].dispose();\n        }\n        if (mProjectConfig.isUseSimpleConfig()) {\n            mFileSetsEditor = new SimpleFileSetsEditor(this);\n        } else {\n            mFileSetsEditor = new ComplexFileSetsEditor(this);\n        }\n        mFileSetsEditor.setFileSets(mProjectConfig.getFileSets());\n        Control editor = mFileSetsEditor.createContents(mFileSetsContainer);\n        fileSetsContainer.setLayout(new FormLayout());\n        FormData fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(100);\n        editor.setLayoutData(fd);\n        return fileSetsContainer;\n    }\n\n    /**\n     * Creates the filter area.\n     *\n     * @param container the container to add the filter area\n     */\n    private Control createFilterArea(Composite container) {\n        FormData fd = new FormData();\n        // group composite containing the filter settings\n        Group filterArea = new Group(container, SWT.NULL);\n        filterArea.setText(Messages.CheckstylePropertyPage_titleFilterGroup);\n        filterArea.setLayout(new FormLayout());\n        this.mFilterList = CheckboxTableViewer.newCheckList(filterArea, SWT.BORDER);\n        this.mBtnEditFilter = new Button(filterArea, SWT.PUSH);\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(this.mBtnEditFilter, -3, SWT.LEFT);\n        fd.bottom = new FormAttachment(60, -3);\n        this.mFilterList.getTable().setLayoutData(fd);\n        this.mFilterList.setLabelProvider(new LabelProvider() {\n\n            public String getText(Object element) {\n                StringBuffer buf = new StringBuffer();\n                if (element instanceof IFilter) {\n                    IFilter filter = (IFilter) element;\n                    buf.append(filter.getName());\n                    if (filter.getPresentableFilterData() != null) {\n                        //$NON-NLS-1$\n                        buf.append(\": \").append(filter.getPresentableFilterData());\n                    }\n                } else {\n                    buf.append(super.getText(element));\n                }\n                return buf.toString();\n            }\n        });\n        this.mFilterList.setContentProvider(new ArrayContentProvider());\n        this.mFilterList.addSelectionChangedListener(this.mPageController);\n        this.mFilterList.addDoubleClickListener(this.mPageController);\n        this.mFilterList.addCheckStateListener(this.mPageController);\n        this.mBtnEditFilter.setText(Messages.CheckstylePropertyPage_btnChangeFilter);\n        this.mBtnEditFilter.addSelectionListener(this.mPageController);\n        fd = new FormData();\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(100, -3);\n        this.mBtnEditFilter.setLayoutData(fd);\n        // Description\n        Label lblDesc = new Label(filterArea, SWT.LEFT);\n        lblDesc.setText(Messages.CheckstylePropertyPage_lblDescription);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(this.mFilterList.getTable(), 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100, -3);\n        lblDesc.setLayoutData(fd);\n        this.mTxtFilterDescription = new Text(filterArea, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.READ_ONLY | SWT.BORDER | SWT.VERTICAL);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(lblDesc, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100, -3);\n        fd.bottom = new FormAttachment(100, -3);\n        this.mTxtFilterDescription.setLayoutData(fd);\n        // intialize filter list\n        List filterDefs = mProjectConfig.getFilters();\n        this.mFilterList.setInput(filterDefs);\n        // set the checked state\n        for (int i = 0; i < filterDefs.size(); i++) {\n            IFilter filter = (IFilter) filterDefs.get(i);\n            this.mFilterList.setChecked(filter, filter.isEnabled());\n        }\n        // set the readonly state\n        for (int i = 0; i < filterDefs.size(); i++) {\n            IFilter filter = (IFilter) filterDefs.get(i);\n            this.mFilterList.setGrayed(filter, filter.isReadonly());\n        }\n        this.mBtnEditFilter.setEnabled(false);\n        return filterArea;\n    }\n\n    private Control createLocalConfigArea(Composite parent) {\n        Composite noteAndEditor = new Composite(parent, SWT.NULL);\n        noteAndEditor.setLayout(new GridLayout(1, false));\n        noteAndEditor.setLayoutData(new GridData(GridData.FILL_BOTH));\n        Label lblHint = new Label(noteAndEditor, SWT.WRAP);\n        lblHint.setText(Messages.CheckstylePropertyPage_msgLocalConfigs);\n        GridData gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.widthHint = 200;\n        lblHint.setLayoutData(gd);\n        mWorkingSetEditor = new CheckConfigurationWorkingSetEditor(mProjectConfig.getLocalCheckConfigWorkingSet(), false);\n        Control editorControl = mWorkingSetEditor.createContents(noteAndEditor);\n        editorControl.setLayoutData(new GridData(GridData.FILL_BOTH));\n        return noteAndEditor;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isValid() {\n        // check if all check configurations resolve\n        List fileSets = mProjectConfig.getFileSets();\n        Iterator it = fileSets.iterator();\n        while (it.hasNext()) {\n            FileSet fileset = (FileSet) it.next();\n            ICheckConfiguration checkConfig = fileset.getCheckConfig();\n            if (checkConfig != null) {\n                try {\n                    checkConfig.getCheckstyleConfiguration();\n                } catch (CheckstylePluginException e) {\n                    CheckstyleLog.warningDialog(getShell(), NLS.bind(ErrorMessages.errorCannotResolveCheckLocation, checkConfig.getLocation(), checkConfig.getName()), e);\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @return the result of the ok action\n     * @see org.eclipse.jface.preference.IPreferencePage#performOk()\n     */\n    public boolean performOk() {\n        try {\n            IProject project = mProjectConfig.getProject();\n            // save the edited project configuration\n            if (mProjectConfig.isDirty()) {\n                mProjectConfig.store();\n            }\n            boolean checkstyleEnabled = mChkEnable.getSelection();\n            boolean needRebuild = mProjectConfig.isRebuildNeeded();\n            // check if checkstyle nature has to be configured/deconfigured\n            if (checkstyleEnabled != mCheckstyleInitiallyActivated) {\n                ConfigureDeconfigureNatureJob configOperation = new ConfigureDeconfigureNatureJob(project, CheckstyleNature.NATURE_ID);\n                configOperation.setRule(ResourcesPlugin.getWorkspace().getRoot());\n                configOperation.schedule();\n                needRebuild = needRebuild || !mCheckstyleInitiallyActivated;\n            }\n            // if a rebuild is advised, check/prompt if the rebuild should\n            // really be done.\n            if (checkstyleEnabled && needRebuild) {\n                IPreferenceStore prefStore = CheckstylePlugin.getDefault().getPreferenceStore();\n                String promptRebuildPref = prefStore.getString(CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n                boolean doRebuild = MessageDialogWithToggle.ALWAYS.equals(promptRebuildPref) && needRebuild;\n                //\n                // Prompt for rebuild\n                //\n                if (MessageDialogWithToggle.PROMPT.equals(promptRebuildPref) && needRebuild) {\n                    MessageDialogWithToggle dialog = MessageDialogWithToggle.openYesNoQuestion(getShell(), Messages.CheckstylePropertyPage_titleRebuild, Messages.CheckstylePropertyPage_msgRebuild, Messages.CheckstylePropertyPage_nagRebuild, false, prefStore, CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n                    doRebuild = dialog.getReturnCode() == IDialogConstants.YES_ID;\n                }\n                // check if a rebuild is necessary\n                if (checkstyleEnabled && doRebuild) {\n                    BuildProjectJob rebuildOperation = new BuildProjectJob(project, IncrementalProjectBuilder.FULL_BUILD);\n                    rebuildOperation.setRule(ResourcesPlugin.getWorkspace().getRoot());\n                    rebuildOperation.schedule();\n                }\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), e, true);\n        }\n        return true;\n    }\n\n    /**\n     * This class works as controller for the page. It listenes for events to\n     * occur and handles the pages context.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class PageController extends SelectionAdapter implements ISelectionChangedListener, ICheckStateListener, IDoubleClickListener {\n\n        /**\n         * @see org.eclipse.swt.events.SelectionListener#widgetSelected(\n         *      org.eclipse.swt.events.SelectionEvent)\n         */\n        public void widgetSelected(SelectionEvent e) {\n            Object source = e.getSource();\n            // edit filter\n            if (source == mBtnEditFilter) {\n                ISelection selection = mFilterList.getSelection();\n                openFilterEditor(selection);\n            }\n            if (source == mMainTab) {\n                mFileSetsEditor.refresh();\n            } else if (source == mChkSimpleConfig) {\n                try {\n                    mProjectConfig.setUseSimpleConfig(mChkSimpleConfig.getSelection());\n                    IPreferenceStore prefStore = CheckstylePlugin.getDefault().getPreferenceStore();\n                    boolean showWarning = prefStore.getBoolean(CheckstylePlugin.PREF_FILESET_WARNING);\n                    if (mProjectConfig.isUseSimpleConfig() && showWarning) {\n                        MessageDialogWithToggle dialog = new MessageDialogWithToggle(getShell(), Messages.CheckstylePropertyPage_titleWarnFilesets, null, Messages.CheckstylePropertyPage_msgWarnFilesets, MessageDialogWithToggle.WARNING, new String[] { IDialogConstants.OK_LABEL }, 0, Messages.CheckstylePropertyPage_mgsWarnFileSetNagOption, showWarning) {\n\n                            /**\n                             * Overwritten because we don't want to store which\n                             * button the user pressed but the state of the\n                             * toggle.\n                             *\n                             * @see MessageDialogWithToggle#buttonPressed(int)\n                             */\n                            protected void buttonPressed(int buttonId) {\n                                getPrefStore().setValue(getPrefKey(), getToggleState());\n                                setReturnCode(buttonId);\n                                close();\n                            }\n                        };\n                        dialog.setPrefStore(prefStore);\n                        dialog.setPrefKey(CheckstylePlugin.PREF_FILESET_WARNING);\n                        dialog.open();\n                    }\n                    createFileSetsArea(mFileSetsContainer);\n                    mFileSetsContainer.redraw();\n                    mFileSetsContainer.update();\n                    mFileSetsContainer.layout();\n                } catch (CheckstylePluginException ex) {\n                    CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorChangingFilesetEditor, ex, true);\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.ISelectionChangedListener#selectionChanged\n         *      (org.eclipse.jface.viewers.SelectionChangedEvent)\n         */\n        public void selectionChanged(SelectionChangedEvent event) {\n            Object source = event.getSource();\n            if (source == mFilterList) {\n                ISelection selection = event.getSelection();\n                if (selection instanceof IStructuredSelection) {\n                    Object selectedElement = ((IStructuredSelection) selection).getFirstElement();\n                    if (selectedElement instanceof IFilter) {\n                        IFilter filterDef = (IFilter) selectedElement;\n                        mTxtFilterDescription.setText(filterDef.getDescription());\n                        // activate edit button\n                        mBtnEditFilter.setEnabled(filterDef.isEditable());\n                    }\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.ICheckStateListener#checkStateChanged\n         *      (org.eclipse.jface.viewers.CheckStateChangedEvent)\n         */\n        public void checkStateChanged(CheckStateChangedEvent event) {\n            Object element = event.getElement();\n            if (element instanceof IFilter) {\n                IFilter filter = (IFilter) element;\n                if (!filter.isReadonly()) {\n                    filter.setEnabled(event.getChecked());\n                } else {\n                    event.getCheckable().setChecked(event.getElement(), true);\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.IDoubleClickListener#doubleClick(\n         *      org.eclipse.jface.viewers.DoubleClickEvent)\n         */\n        public void doubleClick(DoubleClickEvent event) {\n            openFilterEditor(event.getSelection());\n        }\n\n        /**\n         * Open the filter editor on a given selection of the list.\n         *\n         * @param selection the selection\n         */\n        private void openFilterEditor(ISelection selection) {\n            if (selection instanceof IStructuredSelection) {\n                Object selectedElement = ((IStructuredSelection) selection).getFirstElement();\n                if (selectedElement instanceof IFilter) {\n                    try {\n                        IFilter aFilterDef = (IFilter) selectedElement;\n                        if (!aFilterDef.isEditable()) {\n                            return;\n                        }\n                        Class editorClass = aFilterDef.getEditorClass();\n                        IFilterEditor editableFilter = (IFilterEditor) editorClass.newInstance();\n                        editableFilter.setInputProject(mProjectConfig.getProject());\n                        editableFilter.setFilterData(aFilterDef.getFilterData());\n                        if (Window.OK == editableFilter.openEditor(getShell())) {\n                            aFilterDef.setFilterData(editableFilter.getFilterData());\n                            mFilterList.refresh();\n                        }\n                    } catch (IllegalAccessException ex) {\n                        CheckstyleLog.errorDialog(getShell(), ex, true);\n                    } catch (InstantiationException ex) {\n                        CheckstyleLog.errorDialog(getShell(), ex, true);\n                    }\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/properties/CheckstylePropertyPage_1Test.java",
		"test_prompt": "// CheckstylePropertyPage_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IncrementalProjectBuilder;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.CheckboxTableViewer;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.ISelection;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.TabFolder;\nimport org.eclipse.swt.widgets.TabItem;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.dialogs.PropertyPage;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.BuildProjectJob;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.nature.CheckstyleNature;\nimport com.atlassw.tools.eclipse.checkstyle.nature.ConfigureDeconfigureNatureJob;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilterEditor;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstylePropertyPage}.\n* It contains ten unit test cases for the {@link CheckstylePropertyPage#isValid()} method.\n*/\nclass CheckstylePropertyPage_1Test {"
	},
	{
		"original_code": "// CheckstylePropertyPage.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IncrementalProjectBuilder;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.CheckboxTableViewer;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.ISelection;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.TabFolder;\nimport org.eclipse.swt.widgets.TabItem;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.dialogs.PropertyPage;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.BuildProjectJob;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.nature.CheckstyleNature;\nimport com.atlassw.tools.eclipse.checkstyle.nature.ConfigureDeconfigureNatureJob;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilterEditor;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Property page for projects to enable checkstyle audit.\n *\n * @author Lars K�dderitzsch\n */\npublic class CheckstylePropertyPage extends PropertyPage {\n\n    //\n    // controls\n    //\n    /**\n     * The tab folder.\n     */\n    private TabFolder mMainTab = null;\n\n    /**\n     * button to enable checkstyle for the project.\n     */\n    private Button mChkEnable;\n\n    /**\n     * button to enable/disable the simple configuration.\n     */\n    private Button mChkSimpleConfig;\n\n    /**\n     * the container holding the file sets editor.\n     */\n    private Composite mFileSetsContainer;\n\n    /**\n     * the editor for the file sets.\n     */\n    private IFileSetsEditor mFileSetsEditor;\n\n    /**\n     * viewer to display the known checkstyle filters.\n     */\n    private CheckboxTableViewer mFilterList;\n\n    /**\n     * button to open a filter editor.\n     */\n    private Button mBtnEditFilter;\n\n    /**\n     * used to display the filter description.\n     */\n    private Text mTxtFilterDescription;\n\n    //\n    // other members\n    //\n    /**\n     * controller of this page.\n     */\n    private PageController mPageController;\n\n    /**\n     * the actual working data for this form.\n     */\n    private ProjectConfigurationWorkingCopy mProjectConfig;\n\n    /**\n     * the local configurations working set editor.\n     */\n    private CheckConfigurationWorkingSetEditor mWorkingSetEditor;\n\n    private boolean mCheckstyleInitiallyActivated;\n\n    //\n    // methods\n    //\n    /**\n     * Returns the project configuration.\n     *\n     * @return the project configuration\n     */\n    public ProjectConfigurationWorkingCopy getProjectConfigurationWorkingCopy() {\n        return mProjectConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setElement(IAdaptable element) {\n        super.setElement(element);\n        try {\n            //\n            // Get the project.\n            //\n            IProject project = null;\n            IResource resource = (IResource) element;\n            if (resource.getType() == IResource.PROJECT) {\n                project = (IProject) resource;\n            }\n            IProjectConfiguration projectConfig = ProjectConfigurationFactory.getConfiguration(project);\n            mProjectConfig = new ProjectConfigurationWorkingCopy(projectConfig);\n            mCheckstyleInitiallyActivated = project.hasNature(CheckstyleNature.NATURE_ID);\n        } catch (CoreException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite parent) {\n        Composite container = null;\n        try {\n            this.mPageController = new PageController();\n            // suppress default- & apply-buttons\n            noDefaultAndApplyButton();\n            mMainTab = new TabFolder(parent, SWT.TOP);\n            mMainTab.setLayoutData(new GridData(GridData.FILL_BOTH));\n            mMainTab.addSelectionListener(mPageController);\n            // create the main container\n            container = new Composite(mMainTab, SWT.NULL);\n            container.setLayout(new FormLayout());\n            container.setLayoutData(new GridData(GridData.FILL_BOTH));\n            // create the checkbox to enable/diable the simple configuration\n            this.mChkSimpleConfig = new Button(container, SWT.CHECK);\n            this.mChkSimpleConfig.setText(Messages.CheckstylePropertyPage_btnUseSimpleConfig);\n            this.mChkSimpleConfig.addSelectionListener(this.mPageController);\n            this.mChkSimpleConfig.setSelection(mProjectConfig.isUseSimpleConfig());\n            FormData fd = new FormData();\n            // fd.left = new FormAttachment(this.mChkEnable, 0, SWT.RIGHT);\n            fd.top = new FormAttachment(0, 3);\n            fd.right = new FormAttachment(100, -3);\n            this.mChkSimpleConfig.setLayoutData(fd);\n            // create the checkbox to enabel/disable checkstyle\n            this.mChkEnable = new Button(container, SWT.CHECK);\n            this.mChkEnable.setText(Messages.CheckstylePropertyPage_btnActivateCheckstyle);\n            this.mChkEnable.addSelectionListener(this.mPageController);\n            this.mChkEnable.setSelection(mCheckstyleInitiallyActivated);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(0, 3);\n            fd.right = new FormAttachment(this.mChkSimpleConfig, 3, SWT.LEFT);\n            this.mChkEnable.setLayoutData(fd);\n            // create the configuration area\n            mFileSetsContainer = new Composite(container, SWT.NULL);\n            Control configArea = createFileSetsArea(mFileSetsContainer);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(this.mChkEnable, 6, SWT.BOTTOM);\n            fd.right = new FormAttachment(100, -3);\n            fd.bottom = new FormAttachment(45);\n            configArea.setLayoutData(fd);\n            // create the filter area\n            Control filterArea = createFilterArea(container);\n            fd = new FormData();\n            fd.left = new FormAttachment(0, 3);\n            fd.top = new FormAttachment(configArea, 3, SWT.BOTTOM);\n            fd.right = new FormAttachment(100, -3);\n            fd.bottom = new FormAttachment(100, -3);\n            fd.width = 500;\n            filterArea.setLayoutData(fd);\n            // create the local configurations area\n            Control localConfigArea = createLocalConfigArea(mMainTab);\n            TabItem mainItem = new TabItem(mMainTab, SWT.NULL);\n            mainItem.setControl(container);\n            mainItem.setText(Messages.CheckstylePropertyPage_tabMain);\n            TabItem localItem = new TabItem(mMainTab, SWT.NULL);\n            localItem.setControl(localConfigArea);\n            localItem.setText(Messages.CheckstylePropertyPage_tabCheckConfigs);\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorOpeningPropertiesPage, e, true);\n        }\n        return container;\n    }\n\n    /**\n     * Creates the file sets area.\n     *\n     * @param fileSetsContainer the container to add the file sets area to\n     */\n    private Control createFileSetsArea(Composite fileSetsContainer) throws CheckstylePluginException {\n        Control[] controls = fileSetsContainer.getChildren();\n        for (int i = 0; i < controls.length; i++) {\n            controls[i].dispose();\n        }\n        if (mProjectConfig.isUseSimpleConfig()) {\n            mFileSetsEditor = new SimpleFileSetsEditor(this);\n        } else {\n            mFileSetsEditor = new ComplexFileSetsEditor(this);\n        }\n        mFileSetsEditor.setFileSets(mProjectConfig.getFileSets());\n        Control editor = mFileSetsEditor.createContents(mFileSetsContainer);\n        fileSetsContainer.setLayout(new FormLayout());\n        FormData fd = new FormData();\n        fd.left = new FormAttachment(0);\n        fd.top = new FormAttachment(0);\n        fd.right = new FormAttachment(100);\n        fd.bottom = new FormAttachment(100);\n        editor.setLayoutData(fd);\n        return fileSetsContainer;\n    }\n\n    /**\n     * Creates the filter area.\n     *\n     * @param container the container to add the filter area\n     */\n    private Control createFilterArea(Composite container) {\n        FormData fd = new FormData();\n        // group composite containing the filter settings\n        Group filterArea = new Group(container, SWT.NULL);\n        filterArea.setText(Messages.CheckstylePropertyPage_titleFilterGroup);\n        filterArea.setLayout(new FormLayout());\n        this.mFilterList = CheckboxTableViewer.newCheckList(filterArea, SWT.BORDER);\n        this.mBtnEditFilter = new Button(filterArea, SWT.PUSH);\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(this.mBtnEditFilter, -3, SWT.LEFT);\n        fd.bottom = new FormAttachment(60, -3);\n        this.mFilterList.getTable().setLayoutData(fd);\n        this.mFilterList.setLabelProvider(new LabelProvider() {\n\n            public String getText(Object element) {\n                StringBuffer buf = new StringBuffer();\n                if (element instanceof IFilter) {\n                    IFilter filter = (IFilter) element;\n                    buf.append(filter.getName());\n                    if (filter.getPresentableFilterData() != null) {\n                        //$NON-NLS-1$\n                        buf.append(\": \").append(filter.getPresentableFilterData());\n                    }\n                } else {\n                    buf.append(super.getText(element));\n                }\n                return buf.toString();\n            }\n        });\n        this.mFilterList.setContentProvider(new ArrayContentProvider());\n        this.mFilterList.addSelectionChangedListener(this.mPageController);\n        this.mFilterList.addDoubleClickListener(this.mPageController);\n        this.mFilterList.addCheckStateListener(this.mPageController);\n        this.mBtnEditFilter.setText(Messages.CheckstylePropertyPage_btnChangeFilter);\n        this.mBtnEditFilter.addSelectionListener(this.mPageController);\n        fd = new FormData();\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(100, -3);\n        this.mBtnEditFilter.setLayoutData(fd);\n        // Description\n        Label lblDesc = new Label(filterArea, SWT.LEFT);\n        lblDesc.setText(Messages.CheckstylePropertyPage_lblDescription);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(this.mFilterList.getTable(), 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100, -3);\n        lblDesc.setLayoutData(fd);\n        this.mTxtFilterDescription = new Text(filterArea, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.READ_ONLY | SWT.BORDER | SWT.VERTICAL);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(lblDesc, 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100, -3);\n        fd.bottom = new FormAttachment(100, -3);\n        this.mTxtFilterDescription.setLayoutData(fd);\n        // intialize filter list\n        List filterDefs = mProjectConfig.getFilters();\n        this.mFilterList.setInput(filterDefs);\n        // set the checked state\n        for (int i = 0; i < filterDefs.size(); i++) {\n            IFilter filter = (IFilter) filterDefs.get(i);\n            this.mFilterList.setChecked(filter, filter.isEnabled());\n        }\n        // set the readonly state\n        for (int i = 0; i < filterDefs.size(); i++) {\n            IFilter filter = (IFilter) filterDefs.get(i);\n            this.mFilterList.setGrayed(filter, filter.isReadonly());\n        }\n        this.mBtnEditFilter.setEnabled(false);\n        return filterArea;\n    }\n\n    private Control createLocalConfigArea(Composite parent) {\n        Composite noteAndEditor = new Composite(parent, SWT.NULL);\n        noteAndEditor.setLayout(new GridLayout(1, false));\n        noteAndEditor.setLayoutData(new GridData(GridData.FILL_BOTH));\n        Label lblHint = new Label(noteAndEditor, SWT.WRAP);\n        lblHint.setText(Messages.CheckstylePropertyPage_msgLocalConfigs);\n        GridData gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.widthHint = 200;\n        lblHint.setLayoutData(gd);\n        mWorkingSetEditor = new CheckConfigurationWorkingSetEditor(mProjectConfig.getLocalCheckConfigWorkingSet(), false);\n        Control editorControl = mWorkingSetEditor.createContents(noteAndEditor);\n        editorControl.setLayoutData(new GridData(GridData.FILL_BOTH));\n        return noteAndEditor;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isValid() {\n        // check if all check configurations resolve\n        List fileSets = mProjectConfig.getFileSets();\n        Iterator it = fileSets.iterator();\n        while (it.hasNext()) {\n            FileSet fileset = (FileSet) it.next();\n            ICheckConfiguration checkConfig = fileset.getCheckConfig();\n            if (checkConfig != null) {\n                try {\n                    checkConfig.getCheckstyleConfiguration();\n                } catch (CheckstylePluginException e) {\n                    CheckstyleLog.warningDialog(getShell(), NLS.bind(ErrorMessages.errorCannotResolveCheckLocation, checkConfig.getLocation(), checkConfig.getName()), e);\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @return the result of the ok action\n     * @see org.eclipse.jface.preference.IPreferencePage#performOk()\n     */\n    public boolean performOk() {\n        try {\n            IProject project = mProjectConfig.getProject();\n            // save the edited project configuration\n            if (mProjectConfig.isDirty()) {\n                mProjectConfig.store();\n            }\n            boolean checkstyleEnabled = mChkEnable.getSelection();\n            boolean needRebuild = mProjectConfig.isRebuildNeeded();\n            // check if checkstyle nature has to be configured/deconfigured\n            if (checkstyleEnabled != mCheckstyleInitiallyActivated) {\n                ConfigureDeconfigureNatureJob configOperation = new ConfigureDeconfigureNatureJob(project, CheckstyleNature.NATURE_ID);\n                configOperation.setRule(ResourcesPlugin.getWorkspace().getRoot());\n                configOperation.schedule();\n                needRebuild = needRebuild || !mCheckstyleInitiallyActivated;\n            }\n            // if a rebuild is advised, check/prompt if the rebuild should\n            // really be done.\n            if (checkstyleEnabled && needRebuild) {\n                IPreferenceStore prefStore = CheckstylePlugin.getDefault().getPreferenceStore();\n                String promptRebuildPref = prefStore.getString(CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n                boolean doRebuild = MessageDialogWithToggle.ALWAYS.equals(promptRebuildPref) && needRebuild;\n                //\n                // Prompt for rebuild\n                //\n                if (MessageDialogWithToggle.PROMPT.equals(promptRebuildPref) && needRebuild) {\n                    MessageDialogWithToggle dialog = MessageDialogWithToggle.openYesNoQuestion(getShell(), Messages.CheckstylePropertyPage_titleRebuild, Messages.CheckstylePropertyPage_msgRebuild, Messages.CheckstylePropertyPage_nagRebuild, false, prefStore, CheckstylePlugin.PREF_ASK_BEFORE_REBUILD);\n                    doRebuild = dialog.getReturnCode() == IDialogConstants.YES_ID;\n                }\n                // check if a rebuild is necessary\n                if (checkstyleEnabled && doRebuild) {\n                    BuildProjectJob rebuildOperation = new BuildProjectJob(project, IncrementalProjectBuilder.FULL_BUILD);\n                    rebuildOperation.setRule(ResourcesPlugin.getWorkspace().getRoot());\n                    rebuildOperation.schedule();\n                }\n            }\n        } catch (CheckstylePluginException e) {\n            CheckstyleLog.errorDialog(getShell(), e, true);\n        }\n        return true;\n    }\n\n    /**\n     * This class works as controller for the page. It listenes for events to\n     * occur and handles the pages context.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class PageController extends SelectionAdapter implements ISelectionChangedListener, ICheckStateListener, IDoubleClickListener {\n\n        /**\n         * @see org.eclipse.swt.events.SelectionListener#widgetSelected(\n         *      org.eclipse.swt.events.SelectionEvent)\n         */\n        public void widgetSelected(SelectionEvent e) {\n            Object source = e.getSource();\n            // edit filter\n            if (source == mBtnEditFilter) {\n                ISelection selection = mFilterList.getSelection();\n                openFilterEditor(selection);\n            }\n            if (source == mMainTab) {\n                mFileSetsEditor.refresh();\n            } else if (source == mChkSimpleConfig) {\n                try {\n                    mProjectConfig.setUseSimpleConfig(mChkSimpleConfig.getSelection());\n                    IPreferenceStore prefStore = CheckstylePlugin.getDefault().getPreferenceStore();\n                    boolean showWarning = prefStore.getBoolean(CheckstylePlugin.PREF_FILESET_WARNING);\n                    if (mProjectConfig.isUseSimpleConfig() && showWarning) {\n                        MessageDialogWithToggle dialog = new MessageDialogWithToggle(getShell(), Messages.CheckstylePropertyPage_titleWarnFilesets, null, Messages.CheckstylePropertyPage_msgWarnFilesets, MessageDialogWithToggle.WARNING, new String[] { IDialogConstants.OK_LABEL }, 0, Messages.CheckstylePropertyPage_mgsWarnFileSetNagOption, showWarning) {\n\n                            /**\n                             * Overwritten because we don't want to store which\n                             * button the user pressed but the state of the\n                             * toggle.\n                             *\n                             * @see MessageDialogWithToggle#buttonPressed(int)\n                             */\n                            protected void buttonPressed(int buttonId) {\n                                getPrefStore().setValue(getPrefKey(), getToggleState());\n                                setReturnCode(buttonId);\n                                close();\n                            }\n                        };\n                        dialog.setPrefStore(prefStore);\n                        dialog.setPrefKey(CheckstylePlugin.PREF_FILESET_WARNING);\n                        dialog.open();\n                    }\n                    createFileSetsArea(mFileSetsContainer);\n                    mFileSetsContainer.redraw();\n                    mFileSetsContainer.update();\n                    mFileSetsContainer.layout();\n                } catch (CheckstylePluginException ex) {\n                    CheckstyleLog.errorDialog(getShell(), ErrorMessages.errorChangingFilesetEditor, ex, true);\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.ISelectionChangedListener#selectionChanged\n         *      (org.eclipse.jface.viewers.SelectionChangedEvent)\n         */\n        public void selectionChanged(SelectionChangedEvent event) {\n            Object source = event.getSource();\n            if (source == mFilterList) {\n                ISelection selection = event.getSelection();\n                if (selection instanceof IStructuredSelection) {\n                    Object selectedElement = ((IStructuredSelection) selection).getFirstElement();\n                    if (selectedElement instanceof IFilter) {\n                        IFilter filterDef = (IFilter) selectedElement;\n                        mTxtFilterDescription.setText(filterDef.getDescription());\n                        // activate edit button\n                        mBtnEditFilter.setEnabled(filterDef.isEditable());\n                    }\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.ICheckStateListener#checkStateChanged\n         *      (org.eclipse.jface.viewers.CheckStateChangedEvent)\n         */\n        public void checkStateChanged(CheckStateChangedEvent event) {\n            Object element = event.getElement();\n            if (element instanceof IFilter) {\n                IFilter filter = (IFilter) element;\n                if (!filter.isReadonly()) {\n                    filter.setEnabled(event.getChecked());\n                } else {\n                    event.getCheckable().setChecked(event.getElement(), true);\n                }\n            }\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.IDoubleClickListener#doubleClick(\n         *      org.eclipse.jface.viewers.DoubleClickEvent)\n         */\n        public void doubleClick(DoubleClickEvent event) {\n            openFilterEditor(event.getSelection());\n        }\n\n        /**\n         * Open the filter editor on a given selection of the list.\n         *\n         * @param selection the selection\n         */\n        private void openFilterEditor(ISelection selection) {\n            if (selection instanceof IStructuredSelection) {\n                Object selectedElement = ((IStructuredSelection) selection).getFirstElement();\n                if (selectedElement instanceof IFilter) {\n                    try {\n                        IFilter aFilterDef = (IFilter) selectedElement;\n                        if (!aFilterDef.isEditable()) {\n                            return;\n                        }\n                        Class editorClass = aFilterDef.getEditorClass();\n                        IFilterEditor editableFilter = (IFilterEditor) editorClass.newInstance();\n                        editableFilter.setInputProject(mProjectConfig.getProject());\n                        editableFilter.setFilterData(aFilterDef.getFilterData());\n                        if (Window.OK == editableFilter.openEditor(getShell())) {\n                            aFilterDef.setFilterData(editableFilter.getFilterData());\n                            mFilterList.refresh();\n                        }\n                    } catch (IllegalAccessException ex) {\n                        CheckstyleLog.errorDialog(getShell(), ex, true);\n                    } catch (InstantiationException ex) {\n                        CheckstyleLog.errorDialog(getShell(), ex, true);\n                    }\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/properties/CheckstylePropertyPage_2Test.java",
		"test_prompt": "// CheckstylePropertyPage_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IncrementalProjectBuilder;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IAdaptable;\nimport org.eclipse.jface.dialogs.IDialogConstants;\nimport org.eclipse.jface.dialogs.MessageDialogWithToggle;\nimport org.eclipse.jface.preference.IPreferenceStore;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.CheckStateChangedEvent;\nimport org.eclipse.jface.viewers.CheckboxTableViewer;\nimport org.eclipse.jface.viewers.DoubleClickEvent;\nimport org.eclipse.jface.viewers.ICheckStateListener;\nimport org.eclipse.jface.viewers.IDoubleClickListener;\nimport org.eclipse.jface.viewers.ISelection;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.osgi.util.NLS;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.TabFolder;\nimport org.eclipse.swt.widgets.TabItem;\nimport org.eclipse.swt.widgets.Text;\nimport org.eclipse.ui.dialogs.PropertyPage;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.builder.BuildProjectJob;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationWorkingSetEditor;\nimport com.atlassw.tools.eclipse.checkstyle.nature.CheckstyleNature;\nimport com.atlassw.tools.eclipse.checkstyle.nature.ConfigureDeconfigureNatureJob;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilterEditor;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstylePropertyPage}.\n* It contains ten unit test cases for the {@link CheckstylePropertyPage#performOk()} method.\n*/\nclass CheckstylePropertyPage_2Test {"
	},
	{
		"original_code": "// SimpleFileSetsEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.jface.viewers.ComboViewer;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.viewers.StructuredSelection;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationConfigureDialog;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationViewerSorter;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileMatchPattern;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Simple file sets editor producing only one file set that contains all files.\n * Only the check configuration can be chosen.\n *\n * @author Lars K�dderitzsch\n */\npublic class SimpleFileSetsEditor implements IFileSetsEditor {\n\n    //\n    // attributes\n    //\n    /**\n     * viewer to display the known checkstyle configurations.\n     */\n    private ComboViewer mComboViewer;\n\n    /**\n     * used to display the config description.\n     */\n    private Text mTxtConfigDescription;\n\n    /**\n     * button to open the check configuration preferences page.\n     */\n    private Button mBtnManageConfigs;\n\n    private List mFileSets;\n\n    private FileSet mDefaultFileSet;\n\n    private Controller mController;\n\n    private CheckstylePropertyPage mPropertyPage;\n\n    //\n    // constructor\n    //\n    /**\n     * Creates the SimpleFileSetsEditor.\n     *\n     * @param propsPage the property page\n     */\n    public SimpleFileSetsEditor(CheckstylePropertyPage propsPage) {\n        mPropertyPage = propsPage;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public void setFileSets(List fileSets) throws CheckstylePluginException {\n        mFileSets = fileSets;\n        ICheckConfiguration config = null;\n        if (mFileSets.size() > 0) {\n            config = ((FileSet) mFileSets.get(0)).getCheckConfig();\n        }\n        if (config == null) {\n            CheckConfigurationWorkingCopy[] allConfigs = mPropertyPage.getProjectConfigurationWorkingCopy().getGlobalCheckConfigWorkingSet().getWorkingCopies();\n            if (allConfigs.length > 0) {\n                config = (ICheckConfiguration) allConfigs[0];\n            }\n        }\n        mDefaultFileSet = new FileSet(Messages.SimpleFileSetsEditor_nameAllFileset, config);\n        //$NON-NLS-1$\n        mDefaultFileSet.getFileMatchPatterns().add(new FileMatchPattern(\".\"));\n        mFileSets.clear();\n        mFileSets.add(mDefaultFileSet);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Control createContents(Composite parent) throws CheckstylePluginException {\n        mController = new Controller();\n        // group composite containing the config settings\n        Group configArea = new Group(parent, SWT.NULL);\n        configArea.setText(Messages.SimpleFileSetsEditor_titleSimpleConfig);\n        configArea.setLayout(new FormLayout());\n        this.mBtnManageConfigs = new Button(configArea, SWT.PUSH);\n        this.mBtnManageConfigs.setText(Messages.SimpleFileSetsEditor_btnManageConfigs);\n        this.mBtnManageConfigs.addSelectionListener(mController);\n        FormData fd = new FormData();\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(100, -3);\n        this.mBtnManageConfigs.setLayoutData(fd);\n        mComboViewer = new ComboViewer(configArea);\n        mComboViewer.getCombo().setVisibleItemCount(10);\n        mComboViewer.setContentProvider(new CheckConfigurationContentProvider());\n        mComboViewer.setLabelProvider(new CheckConfigurationLabelProvider());\n        mComboViewer.setSorter(new CheckConfigurationViewerSorter());\n        mComboViewer.getControl().setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n        mComboViewer.addSelectionChangedListener(mController);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(0, 3);\n        fd.right = new FormAttachment(mBtnManageConfigs, -3, SWT.LEFT);\n        // fd.right = new FormAttachment(100, -3);\n        mComboViewer.getCombo().setLayoutData(fd);\n        // Description\n        Label lblConfigDesc = new Label(configArea, SWT.LEFT);\n        lblConfigDesc.setText(Messages.SimpleFileSetsEditor_lblDescription);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(mComboViewer.getCombo(), 3, SWT.BOTTOM);\n        fd.right = new FormAttachment(100, -3);\n        lblConfigDesc.setLayoutData(fd);\n        this.mTxtConfigDescription = new Text(configArea, SWT.LEFT | SWT.WRAP | SWT.MULTI | SWT.READ_ONLY | SWT.BORDER | SWT.VERTICAL);\n        fd = new FormData();\n        fd.left = new FormAttachment(0, 3);\n        fd.top = new FormAttachment(lblConfigDesc, 0, SWT.BOTTOM);\n        fd.right = new FormAttachment(100, -3);\n        fd.bottom = new FormAttachment(100, -3);\n        this.mTxtConfigDescription.setLayoutData(fd);\n        // init the check configuration combo\n        mComboViewer.setInput(mPropertyPage.getProjectConfigurationWorkingCopy());\n        if (mDefaultFileSet.getCheckConfig() != null) {\n            mComboViewer.setSelection(new StructuredSelection(mDefaultFileSet.getCheckConfig()));\n        }\n        return configArea;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void refresh() {\n        mComboViewer.refresh();\n    }\n\n    /**\n     * Controller for this file set editor.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class Controller implements SelectionListener, ISelectionChangedListener {\n\n        /**\n         * @see SelectionListener#widgetSelected(org.eclipse.swt.events.SelectionEvent)\n         */\n        public void widgetSelected(SelectionEvent e) {\n            if (mBtnManageConfigs == e.widget) {\n                ICheckConfiguration config = mDefaultFileSet.getCheckConfig();\n                if (config != null) {\n                    IProject project = (IProject) mPropertyPage.getElement();\n                    try {\n                        config.getCheckstyleConfiguration();\n                        CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) config;\n                        CheckConfigurationConfigureDialog dialog = new CheckConfigurationConfigureDialog(mTxtConfigDescription.getShell(), workingCopy);\n                        dialog.setBlockOnOpen(true);\n                        dialog.open();\n                    } catch (CheckstylePluginException ex) {\n                        CheckstyleLog.warningDialog(mPropertyPage.getShell(), Messages.bind(Messages.CheckstylePreferencePage_msgProjectRelativeConfigNoFound, project, config.getLocation()), ex);\n                    }\n                }\n            }\n        }\n\n        /**\n         * @see SelectionListener#widgetDefaultSelected(org.eclipse.swt.events.SelectionEvent)\n         */\n        public void widgetDefaultSelected(SelectionEvent e) {\n            // NOOP\n        }\n\n        /**\n         * @see ISelectionChangedListener#selectionChanged(SelectionChangedEvent)\n         */\n        public void selectionChanged(SelectionChangedEvent event) {\n            IStructuredSelection selection = (IStructuredSelection) event.getSelection();\n            ICheckConfiguration config = (ICheckConfiguration) selection.getFirstElement();\n            if (config != null) {\n                mDefaultFileSet.setCheckConfig(config);\n                mTxtConfigDescription.setText(config.getDescription() != null ? config.getDescription() : //$NON-NLS-1$\n                \"\");\n            } else {\n                mComboViewer.setSelection(new StructuredSelection(mComboViewer.getElementAt(0)));\n            }\n            mPropertyPage.getContainer().updateButtons();\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/properties/SimpleFileSetsEditor.java",
		"test_prompt": "// SimpleFileSetsEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.properties;\n\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.jface.viewers.ComboViewer;\nimport org.eclipse.jface.viewers.ISelectionChangedListener;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.SelectionChangedEvent;\nimport org.eclipse.jface.viewers.StructuredSelection;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Group;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationConfigureDialog;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.config.gui.CheckConfigurationViewerSorter;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileMatchPattern;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.FileSet;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleFileSetsEditor}.\n* It contains ten unit test cases for the {@link SimpleFileSetsEditor#createContents(Composite)} method.\n*/\nclass SimpleFileSetsEditorTest {"
	},
	{
		"original_code": "// CheckstylePlugin.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle;\n\nimport java.util.Locale;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.ui.IWindowListener;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.CheckFileOnOpenPartListener;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.EclipseLogHandler;\n\n/**\n * The main plugin class to be used in the desktop.\n */\npublic class CheckstylePlugin extends AbstractUIPlugin {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    /**\n     * Identifier of the plug-in.\n     */\n    //$NON-NLS-1$\n    public static final String PLUGIN_ID = \"com.atlassw.tools.eclipse.checkstyle\";\n\n    /**\n     * Preference name indicating if rule names are to be included in violation\n     * messages.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_INCLUDE_RULE_NAMES = \"include.rule.names\";\n\n    /**\n     * Preference name indicating if module ids are to be included in violation\n     * messages.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_INCLUDE_MODULE_IDS = \"include.module.ids\";\n\n    /**\n     * Preference name indication if the user should be warned of possibly\n     * losing fileset configurations if he switches from advanced to simple\n     * fileset configuration.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_FILESET_WARNING = \"warn.before.losing.filesets\";\n\n    /**\n     * Preference name indication if the user should be asked before rebuilding\n     * projects.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_ASK_BEFORE_REBUILD = \"ask.before.rebuild\";\n\n    /**\n     * Preference name indicating if the checkstyle tokens within the module\n     * editor should be translated.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_TRANSLATE_TOKENS = \"translate.checkstyle.tokens\";\n\n    /**\n     * Preference name indicating if the checkstyle tokens within the module\n     * editor should be sorted.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_SORT_TOKENS = \"translate.sort.tokens\";\n\n    /**\n     * Preference name indicating if the module editor should be opened when\n     * adding a module.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_OPEN_MODULE_EDITOR = \"open.module.editor.on.add\";\n\n    /**\n     * Preference name indicating if the number of checkstyle warning generated\n     * per file should be limited.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_LIMIT_MARKERS_PER_RESOURCE = \"limit.markers.per.resource\";\n\n    /**\n     * Preference name for the preference that stores the limit of markers per\n     * resource.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_MARKER_AMOUNT_LIMIT = \"marker.amount.limit\";\n\n    /**\n     * Preference name indicating the minimum amount of lines that is used for\n     * the checker analysis.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_DUPLICATED_CODE_MIN_LINES = \"checker.strictDuplicatedCode.minLines\";\n\n    /**\n     * Preference name indicating if the project classloader feature should be\n     * disabled. This can help with worspace crashes with RAD 6.0.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_DISABLE_PROJ_CLASSLOADER = \"diable.project.classloader\";\n\n    /**\n     * Default value for the minimum amount of lines that is used for the\n     * checker analysis.\n     */\n    public static final int DUPLICATED_CODE_MIN_LINES = 20;\n\n    /**\n     * Default value for the marker limitation.\n     */\n    public static final int MARKER_LIMIT = 100;\n\n    /**\n     * Constant for the path of the (custom) package names file.\n     */\n    //$NON-NLS-1$\n    public static final String PACKAGE_NAMES_FILE = \"/extension-libraries/checkstyle_packages.xml\";\n\n    /**\n     * Constant for the path to the extension-libraries directory.\n     */\n    //$NON-NLS-1$\n    public static final String EXTENSION_LIBS_DIR = \"/extension-libraries\";\n\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * The shared instance.\n     */\n    private static CheckstylePlugin sPlugin;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * The constructor.\n     */\n    public CheckstylePlugin() {\n        super();\n        sPlugin = this;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * {@inheritDoc}\n     */\n    public void start(BundleContext context) throws Exception {\n        super.start(context);\n        try {\n            Logger checkstyleErrorLog = Logger.getLogger(//$NON-NLS-1$\n            \"com.puppycrawl.tools.checkstyle.ExceptionLog\");\n            checkstyleErrorLog.addHandler(new EclipseLogHandler(this));\n            checkstyleErrorLog.setLevel(Level.ALL);\n        } catch (Exception ioe) {\n            CheckstyleLog.log(ioe);\n        }\n        // add listeners for the Check-On-Open support\n        final IWorkbench workbench = getWorkbench();\n        workbench.addWindowListener(mWindowListener);\n        workbench.getDisplay().asyncExec(new Runnable() {\n\n            public void run() {\n                IWorkbenchWindow window = workbench.getActiveWorkbenchWindow();\n                if (window != null) {\n                    // remove listener first for safety, we don't want register\n                    // the same listener twice accidently\n                    window.getPartService().removePartListener(mPartListener);\n                    window.getPartService().addPartListener(mPartListener);\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns the shared instance.\n     *\n     * @return The shared plug-in instance.\n     */\n    public static CheckstylePlugin getDefault() {\n        return sPlugin;\n    }\n\n    /**\n     * Returns the workspace instance.\n     *\n     * @return Workspace instance.\n     */\n    public static IWorkspace getWorkspace() {\n        return ResourcesPlugin.getWorkspace();\n    }\n\n    /**\n     * Helper method to get the current plattform locale.\n     *\n     * @return the platform locale\n     */\n    public static Locale getPlatformLocale() {\n        String nl = Platform.getNL();\n        //$NON-NLS-1$\n        String[] parts = nl.split(\"_\");\n        //$NON-NLS-1$\n        String language = parts.length > 0 ? parts[0] : \"\";\n        //$NON-NLS-1$\n        String country = parts.length > 1 ? parts[1] : \"\";\n        //$NON-NLS-1$\n        String variant = parts.length > 2 ? parts[2] : \"\";\n        return new Locale(language, country, variant);\n    }\n\n    private CheckFileOnOpenPartListener mPartListener = new CheckFileOnOpenPartListener();\n\n    private IWindowListener mWindowListener = new IWindowListener() {\n\n        public void windowOpened(IWorkbenchWindow window) {\n            window.getPartService().addPartListener(mPartListener);\n        }\n\n        public void windowActivated(IWorkbenchWindow window) {\n        }\n\n        public void windowClosed(IWorkbenchWindow window) {\n            window.getPartService().removePartListener(mPartListener);\n        }\n\n        public void windowDeactivated(IWorkbenchWindow window) {\n        }\n    };\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/CheckstylePlugin_0Test.java",
		"test_prompt": "// CheckstylePlugin_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle;\n\nimport java.util.Locale;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.ui.IWindowListener;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.CheckFileOnOpenPartListener;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.EclipseLogHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstylePlugin}.\n* It contains ten unit test cases for the {@link CheckstylePlugin#getDefault()} method.\n*/\nclass CheckstylePlugin_0Test {"
	},
	{
		"original_code": "// CheckstylePlugin.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle;\n\nimport java.util.Locale;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.ui.IWindowListener;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.CheckFileOnOpenPartListener;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.EclipseLogHandler;\n\n/**\n * The main plugin class to be used in the desktop.\n */\npublic class CheckstylePlugin extends AbstractUIPlugin {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    /**\n     * Identifier of the plug-in.\n     */\n    //$NON-NLS-1$\n    public static final String PLUGIN_ID = \"com.atlassw.tools.eclipse.checkstyle\";\n\n    /**\n     * Preference name indicating if rule names are to be included in violation\n     * messages.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_INCLUDE_RULE_NAMES = \"include.rule.names\";\n\n    /**\n     * Preference name indicating if module ids are to be included in violation\n     * messages.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_INCLUDE_MODULE_IDS = \"include.module.ids\";\n\n    /**\n     * Preference name indication if the user should be warned of possibly\n     * losing fileset configurations if he switches from advanced to simple\n     * fileset configuration.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_FILESET_WARNING = \"warn.before.losing.filesets\";\n\n    /**\n     * Preference name indication if the user should be asked before rebuilding\n     * projects.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_ASK_BEFORE_REBUILD = \"ask.before.rebuild\";\n\n    /**\n     * Preference name indicating if the checkstyle tokens within the module\n     * editor should be translated.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_TRANSLATE_TOKENS = \"translate.checkstyle.tokens\";\n\n    /**\n     * Preference name indicating if the checkstyle tokens within the module\n     * editor should be sorted.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_SORT_TOKENS = \"translate.sort.tokens\";\n\n    /**\n     * Preference name indicating if the module editor should be opened when\n     * adding a module.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_OPEN_MODULE_EDITOR = \"open.module.editor.on.add\";\n\n    /**\n     * Preference name indicating if the number of checkstyle warning generated\n     * per file should be limited.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_LIMIT_MARKERS_PER_RESOURCE = \"limit.markers.per.resource\";\n\n    /**\n     * Preference name for the preference that stores the limit of markers per\n     * resource.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_MARKER_AMOUNT_LIMIT = \"marker.amount.limit\";\n\n    /**\n     * Preference name indicating the minimum amount of lines that is used for\n     * the checker analysis.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_DUPLICATED_CODE_MIN_LINES = \"checker.strictDuplicatedCode.minLines\";\n\n    /**\n     * Preference name indicating if the project classloader feature should be\n     * disabled. This can help with worspace crashes with RAD 6.0.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_DISABLE_PROJ_CLASSLOADER = \"diable.project.classloader\";\n\n    /**\n     * Default value for the minimum amount of lines that is used for the\n     * checker analysis.\n     */\n    public static final int DUPLICATED_CODE_MIN_LINES = 20;\n\n    /**\n     * Default value for the marker limitation.\n     */\n    public static final int MARKER_LIMIT = 100;\n\n    /**\n     * Constant for the path of the (custom) package names file.\n     */\n    //$NON-NLS-1$\n    public static final String PACKAGE_NAMES_FILE = \"/extension-libraries/checkstyle_packages.xml\";\n\n    /**\n     * Constant for the path to the extension-libraries directory.\n     */\n    //$NON-NLS-1$\n    public static final String EXTENSION_LIBS_DIR = \"/extension-libraries\";\n\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * The shared instance.\n     */\n    private static CheckstylePlugin sPlugin;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * The constructor.\n     */\n    public CheckstylePlugin() {\n        super();\n        sPlugin = this;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * {@inheritDoc}\n     */\n    public void start(BundleContext context) throws Exception {\n        super.start(context);\n        try {\n            Logger checkstyleErrorLog = Logger.getLogger(//$NON-NLS-1$\n            \"com.puppycrawl.tools.checkstyle.ExceptionLog\");\n            checkstyleErrorLog.addHandler(new EclipseLogHandler(this));\n            checkstyleErrorLog.setLevel(Level.ALL);\n        } catch (Exception ioe) {\n            CheckstyleLog.log(ioe);\n        }\n        // add listeners for the Check-On-Open support\n        final IWorkbench workbench = getWorkbench();\n        workbench.addWindowListener(mWindowListener);\n        workbench.getDisplay().asyncExec(new Runnable() {\n\n            public void run() {\n                IWorkbenchWindow window = workbench.getActiveWorkbenchWindow();\n                if (window != null) {\n                    // remove listener first for safety, we don't want register\n                    // the same listener twice accidently\n                    window.getPartService().removePartListener(mPartListener);\n                    window.getPartService().addPartListener(mPartListener);\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns the shared instance.\n     *\n     * @return The shared plug-in instance.\n     */\n    public static CheckstylePlugin getDefault() {\n        return sPlugin;\n    }\n\n    /**\n     * Returns the workspace instance.\n     *\n     * @return Workspace instance.\n     */\n    public static IWorkspace getWorkspace() {\n        return ResourcesPlugin.getWorkspace();\n    }\n\n    /**\n     * Helper method to get the current plattform locale.\n     *\n     * @return the platform locale\n     */\n    public static Locale getPlatformLocale() {\n        String nl = Platform.getNL();\n        //$NON-NLS-1$\n        String[] parts = nl.split(\"_\");\n        //$NON-NLS-1$\n        String language = parts.length > 0 ? parts[0] : \"\";\n        //$NON-NLS-1$\n        String country = parts.length > 1 ? parts[1] : \"\";\n        //$NON-NLS-1$\n        String variant = parts.length > 2 ? parts[2] : \"\";\n        return new Locale(language, country, variant);\n    }\n\n    private CheckFileOnOpenPartListener mPartListener = new CheckFileOnOpenPartListener();\n\n    private IWindowListener mWindowListener = new IWindowListener() {\n\n        public void windowOpened(IWorkbenchWindow window) {\n            window.getPartService().addPartListener(mPartListener);\n        }\n\n        public void windowActivated(IWorkbenchWindow window) {\n        }\n\n        public void windowClosed(IWorkbenchWindow window) {\n            window.getPartService().removePartListener(mPartListener);\n        }\n\n        public void windowDeactivated(IWorkbenchWindow window) {\n        }\n    };\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/CheckstylePlugin_1Test.java",
		"test_prompt": "// CheckstylePlugin_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle;\n\nimport java.util.Locale;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.ui.IWindowListener;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.CheckFileOnOpenPartListener;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.EclipseLogHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstylePlugin}.\n* It contains ten unit test cases for the {@link CheckstylePlugin#getWorkspace()} method.\n*/\nclass CheckstylePlugin_1Test {"
	},
	{
		"original_code": "// CheckstylePlugin.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle;\n\nimport java.util.Locale;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.ui.IWindowListener;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.CheckFileOnOpenPartListener;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.EclipseLogHandler;\n\n/**\n * The main plugin class to be used in the desktop.\n */\npublic class CheckstylePlugin extends AbstractUIPlugin {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    /**\n     * Identifier of the plug-in.\n     */\n    //$NON-NLS-1$\n    public static final String PLUGIN_ID = \"com.atlassw.tools.eclipse.checkstyle\";\n\n    /**\n     * Preference name indicating if rule names are to be included in violation\n     * messages.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_INCLUDE_RULE_NAMES = \"include.rule.names\";\n\n    /**\n     * Preference name indicating if module ids are to be included in violation\n     * messages.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_INCLUDE_MODULE_IDS = \"include.module.ids\";\n\n    /**\n     * Preference name indication if the user should be warned of possibly\n     * losing fileset configurations if he switches from advanced to simple\n     * fileset configuration.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_FILESET_WARNING = \"warn.before.losing.filesets\";\n\n    /**\n     * Preference name indication if the user should be asked before rebuilding\n     * projects.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_ASK_BEFORE_REBUILD = \"ask.before.rebuild\";\n\n    /**\n     * Preference name indicating if the checkstyle tokens within the module\n     * editor should be translated.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_TRANSLATE_TOKENS = \"translate.checkstyle.tokens\";\n\n    /**\n     * Preference name indicating if the checkstyle tokens within the module\n     * editor should be sorted.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_SORT_TOKENS = \"translate.sort.tokens\";\n\n    /**\n     * Preference name indicating if the module editor should be opened when\n     * adding a module.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_OPEN_MODULE_EDITOR = \"open.module.editor.on.add\";\n\n    /**\n     * Preference name indicating if the number of checkstyle warning generated\n     * per file should be limited.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_LIMIT_MARKERS_PER_RESOURCE = \"limit.markers.per.resource\";\n\n    /**\n     * Preference name for the preference that stores the limit of markers per\n     * resource.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_MARKER_AMOUNT_LIMIT = \"marker.amount.limit\";\n\n    /**\n     * Preference name indicating the minimum amount of lines that is used for\n     * the checker analysis.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_DUPLICATED_CODE_MIN_LINES = \"checker.strictDuplicatedCode.minLines\";\n\n    /**\n     * Preference name indicating if the project classloader feature should be\n     * disabled. This can help with worspace crashes with RAD 6.0.\n     */\n    //$NON-NLS-1$\n    public static final String PREF_DISABLE_PROJ_CLASSLOADER = \"diable.project.classloader\";\n\n    /**\n     * Default value for the minimum amount of lines that is used for the\n     * checker analysis.\n     */\n    public static final int DUPLICATED_CODE_MIN_LINES = 20;\n\n    /**\n     * Default value for the marker limitation.\n     */\n    public static final int MARKER_LIMIT = 100;\n\n    /**\n     * Constant for the path of the (custom) package names file.\n     */\n    //$NON-NLS-1$\n    public static final String PACKAGE_NAMES_FILE = \"/extension-libraries/checkstyle_packages.xml\";\n\n    /**\n     * Constant for the path to the extension-libraries directory.\n     */\n    //$NON-NLS-1$\n    public static final String EXTENSION_LIBS_DIR = \"/extension-libraries\";\n\n    // =================================================\n    // Static class variables.\n    // =================================================\n    /**\n     * The shared instance.\n     */\n    private static CheckstylePlugin sPlugin;\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * The constructor.\n     */\n    public CheckstylePlugin() {\n        super();\n        sPlugin = this;\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * {@inheritDoc}\n     */\n    public void start(BundleContext context) throws Exception {\n        super.start(context);\n        try {\n            Logger checkstyleErrorLog = Logger.getLogger(//$NON-NLS-1$\n            \"com.puppycrawl.tools.checkstyle.ExceptionLog\");\n            checkstyleErrorLog.addHandler(new EclipseLogHandler(this));\n            checkstyleErrorLog.setLevel(Level.ALL);\n        } catch (Exception ioe) {\n            CheckstyleLog.log(ioe);\n        }\n        // add listeners for the Check-On-Open support\n        final IWorkbench workbench = getWorkbench();\n        workbench.addWindowListener(mWindowListener);\n        workbench.getDisplay().asyncExec(new Runnable() {\n\n            public void run() {\n                IWorkbenchWindow window = workbench.getActiveWorkbenchWindow();\n                if (window != null) {\n                    // remove listener first for safety, we don't want register\n                    // the same listener twice accidently\n                    window.getPartService().removePartListener(mPartListener);\n                    window.getPartService().addPartListener(mPartListener);\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns the shared instance.\n     *\n     * @return The shared plug-in instance.\n     */\n    public static CheckstylePlugin getDefault() {\n        return sPlugin;\n    }\n\n    /**\n     * Returns the workspace instance.\n     *\n     * @return Workspace instance.\n     */\n    public static IWorkspace getWorkspace() {\n        return ResourcesPlugin.getWorkspace();\n    }\n\n    /**\n     * Helper method to get the current plattform locale.\n     *\n     * @return the platform locale\n     */\n    public static Locale getPlatformLocale() {\n        String nl = Platform.getNL();\n        //$NON-NLS-1$\n        String[] parts = nl.split(\"_\");\n        //$NON-NLS-1$\n        String language = parts.length > 0 ? parts[0] : \"\";\n        //$NON-NLS-1$\n        String country = parts.length > 1 ? parts[1] : \"\";\n        //$NON-NLS-1$\n        String variant = parts.length > 2 ? parts[2] : \"\";\n        return new Locale(language, country, variant);\n    }\n\n    private CheckFileOnOpenPartListener mPartListener = new CheckFileOnOpenPartListener();\n\n    private IWindowListener mWindowListener = new IWindowListener() {\n\n        public void windowOpened(IWorkbenchWindow window) {\n            window.getPartService().addPartListener(mPartListener);\n        }\n\n        public void windowActivated(IWorkbenchWindow window) {\n        }\n\n        public void windowClosed(IWorkbenchWindow window) {\n            window.getPartService().removePartListener(mPartListener);\n        }\n\n        public void windowDeactivated(IWorkbenchWindow window) {\n        }\n    };\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/CheckstylePlugin_2Test.java",
		"test_prompt": "// CheckstylePlugin_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle;\n\nimport java.util.Locale;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.ui.IWindowListener;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.plugin.AbstractUIPlugin;\nimport org.osgi.framework.BundleContext;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.CheckFileOnOpenPartListener;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.EclipseLogHandler;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckstylePlugin}.\n* It contains ten unit test cases for the {@link CheckstylePlugin#getPlatformLocale()} method.\n*/\nclass CheckstylePlugin_2Test {"
	},
	{
		"original_code": "// PackageFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\n\n/**\n * filters resources that lie within excluded packages. This filter is used for\n * the checkstyle audit funtion of this plugin.\n *\n * @author Lars K�dderitzsch\n */\npublic class PackageFilter extends AbstractFilter {\n\n    private List mData = new ArrayList();\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean goesThrough = true;\n        if (element instanceof IResource) {\n            IResource resource = (IResource) element;\n            IPath projRelativPath = resource.getProjectRelativePath();\n            int size = mData != null ? mData.size() : 0;\n            for (int i = 0; i < size; i++) {\n                IPath filteredPath = new Path((String) mData.get(i));\n                if (filteredPath.isPrefixOf(projRelativPath)) {\n                    goesThrough = false;\n                    break;\n                }\n            }\n        }\n        return goesThrough;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setFilterData(List filterData) {\n        if (filterData == null) {\n            mData = new ArrayList();\n        }\n        mData = filterData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilterData() {\n        return mData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getPresentableFilterData() {\n        StringBuffer buf = new StringBuffer();\n        int size = mData != null ? mData.size() : 0;\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                //$NON-NLS-1$\n                buf.append(\", \");\n            }\n            buf.append(mData.get(i));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object o) {\n        if (o == null || !(o instanceof PackageFilter)) {\n            return false;\n        }\n        if (this == o) {\n            return true;\n        }\n        PackageFilter rhs = (PackageFilter) o;\n        return new EqualsBuilder().appendSuper(super.equals(o)).append(mData, rhs.mData).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7834681, 1000003).appendSuper(super.hashCode()).append(mData).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/PackageFilter_0Test.java",
		"test_prompt": "// PackageFilter_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PackageFilter}.\n* It contains ten unit test cases for the {@link PackageFilter#accept(Object)} method.\n*/\nclass PackageFilter_0Test {"
	},
	{
		"original_code": "// PackageFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\n\n/**\n * filters resources that lie within excluded packages. This filter is used for\n * the checkstyle audit funtion of this plugin.\n *\n * @author Lars K�dderitzsch\n */\npublic class PackageFilter extends AbstractFilter {\n\n    private List mData = new ArrayList();\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean goesThrough = true;\n        if (element instanceof IResource) {\n            IResource resource = (IResource) element;\n            IPath projRelativPath = resource.getProjectRelativePath();\n            int size = mData != null ? mData.size() : 0;\n            for (int i = 0; i < size; i++) {\n                IPath filteredPath = new Path((String) mData.get(i));\n                if (filteredPath.isPrefixOf(projRelativPath)) {\n                    goesThrough = false;\n                    break;\n                }\n            }\n        }\n        return goesThrough;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setFilterData(List filterData) {\n        if (filterData == null) {\n            mData = new ArrayList();\n        }\n        mData = filterData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilterData() {\n        return mData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getPresentableFilterData() {\n        StringBuffer buf = new StringBuffer();\n        int size = mData != null ? mData.size() : 0;\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                //$NON-NLS-1$\n                buf.append(\", \");\n            }\n            buf.append(mData.get(i));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object o) {\n        if (o == null || !(o instanceof PackageFilter)) {\n            return false;\n        }\n        if (this == o) {\n            return true;\n        }\n        PackageFilter rhs = (PackageFilter) o;\n        return new EqualsBuilder().appendSuper(super.equals(o)).append(mData, rhs.mData).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7834681, 1000003).appendSuper(super.hashCode()).append(mData).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/PackageFilter_1Test.java",
		"test_prompt": "// PackageFilter_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PackageFilter}.\n* It contains ten unit test cases for the {@link PackageFilter#equals(Object)} method.\n*/\nclass PackageFilter_1Test {"
	},
	{
		"original_code": "// PackageFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\n\n/**\n * filters resources that lie within excluded packages. This filter is used for\n * the checkstyle audit funtion of this plugin.\n *\n * @author Lars K�dderitzsch\n */\npublic class PackageFilter extends AbstractFilter {\n\n    private List mData = new ArrayList();\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean goesThrough = true;\n        if (element instanceof IResource) {\n            IResource resource = (IResource) element;\n            IPath projRelativPath = resource.getProjectRelativePath();\n            int size = mData != null ? mData.size() : 0;\n            for (int i = 0; i < size; i++) {\n                IPath filteredPath = new Path((String) mData.get(i));\n                if (filteredPath.isPrefixOf(projRelativPath)) {\n                    goesThrough = false;\n                    break;\n                }\n            }\n        }\n        return goesThrough;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setFilterData(List filterData) {\n        if (filterData == null) {\n            mData = new ArrayList();\n        }\n        mData = filterData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilterData() {\n        return mData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getPresentableFilterData() {\n        StringBuffer buf = new StringBuffer();\n        int size = mData != null ? mData.size() : 0;\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                //$NON-NLS-1$\n                buf.append(\", \");\n            }\n            buf.append(mData.get(i));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object o) {\n        if (o == null || !(o instanceof PackageFilter)) {\n            return false;\n        }\n        if (this == o) {\n            return true;\n        }\n        PackageFilter rhs = (PackageFilter) o;\n        return new EqualsBuilder().appendSuper(super.equals(o)).append(mData, rhs.mData).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7834681, 1000003).appendSuper(super.hashCode()).append(mData).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/PackageFilter_2Test.java",
		"test_prompt": "// PackageFilter_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PackageFilter}.\n* It contains ten unit test cases for the {@link PackageFilter#hashCode()} method.\n*/\nclass PackageFilter_2Test {"
	},
	{
		"original_code": "// NonSrcDirsFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.jdt.core.IClasspathEntry;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.JavaModelException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Implementation of a filter that filters all ressources that are not within a\n * source directory.\n *\n * @author Lars K�dderitzsch\n */\npublic class NonSrcDirsFilter extends AbstractFilter {\n\n    //\n    // attributes\n    //\n    /**\n     * the current project.\n     */\n    private IProject mCurrentProject;\n\n    /**\n     * the list of source paths of the current project.\n     */\n    private List mCurrentSourcePaths;\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean goesThrough = false;\n        if (element instanceof IResource) {\n            IResource resource = (IResource) element;\n            IProject project = resource.getProject();\n            if (mCurrentProject != project) {\n                mCurrentSourcePaths = getSourceDirPaths(project);\n                mCurrentProject = project;\n            }\n            Iterator it = mCurrentSourcePaths.iterator();\n            while (it.hasNext()) {\n                IPath sourcePath = (IPath) it.next();\n                if (sourcePath.isPrefixOf(resource.getFullPath())) {\n                    goesThrough = true;\n                    break;\n                }\n            }\n        }\n        return goesThrough;\n    }\n\n    /**\n     * Gets all source paths of a project.\n     *\n     * @param project the project\n     * @return the list of source paths\n     */\n    private List getSourceDirPaths(IProject project) {\n        List sourceDirs = new ArrayList();\n        try {\n            if (project.hasNature(JavaCore.NATURE_ID)) {\n                IJavaProject javaProject = JavaCore.create(project);\n                IClasspathEntry[] cp = javaProject.getResolvedClasspath(true);\n                for (int i = 0; i < cp.length; i++) {\n                    if (cp[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) {\n                        sourceDirs.add(cp[i].getPath());\n                    }\n                }\n            }\n        } catch (JavaModelException e) {\n            CheckstyleLog.log(e);\n        } catch (CoreException e) {\n            CheckstyleLog.log(e);\n        }\n        return sourceDirs;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/NonSrcDirsFilter.java",
		"test_prompt": "// NonSrcDirsFilterTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.jdt.core.IClasspathEntry;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.JavaModelException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonSrcDirsFilter}.\n* It contains ten unit test cases for the {@link NonSrcDirsFilter#accept(Object)} method.\n*/\nclass NonSrcDirsFilterTest {"
	},
	{
		"original_code": "// FilesInSyncFilter2.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.swt.widgets.Display;\nimport org.eclipse.team.core.RepositoryProvider;\nimport org.eclipse.team.core.TeamException;\nimport org.eclipse.team.core.subscribers.Subscriber;\nimport org.eclipse.team.core.synchronize.SyncInfo;\nimport org.osgi.framework.Bundle;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Filters all files that are in sync with the source repository.\n *\n * @author Lars K�dderitzsch\n */\npublic class FilesInSyncFilter2 extends AbstractFilter {\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean passes = true;\n        if (!isCorrectEclipseVersion()) {\n            Status status = new Status(Status.ERROR, CheckstylePlugin.PLUGIN_ID, Status.OK, \"FilesInSyncFilter2 only supported since Eclipse 3.2 and greater\", //$NON-NLS-1$\n            null);\n            CheckstylePlugin.getDefault().getLog().log(status);\n            return true;\n        }\n        if (element instanceof IFile) {\n            IFile file = (IFile) element;\n            IProject project = file.getProject();\n            if (RepositoryProvider.isShared(project)) {\n                RepositoryProvider provider = RepositoryProvider.getProvider(project);\n                if (provider != null) {\n                    Subscriber subscriber = provider.getSubscriber();\n                    try {\n                        SyncInfo synchInfo = subscriber.getSyncInfo(file);\n                        if (synchInfo != null) {\n                            int kind = synchInfo.getKind();\n                            passes = (SyncInfo.getDirection(kind) & SyncInfo.OUTGOING) == SyncInfo.OUTGOING;\n                        }\n                    } catch (TeamException e) {\n                        CheckstyleLog.log(e);\n                    }\n                }\n            }\n        }\n        return passes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setEnabled(boolean selected) {\n        if (isCorrectEclipseVersion()) {\n            super.setEnabled(selected);\n        } else if (selected) {\n            CheckstyleLog.errorDialog(Display.getDefault().getActiveShell(), \"This filter is only supported since Eclipse 3.2 and greater\", null, //$NON-NLS-1$\n            false);\n        }\n    }\n\n    private boolean isCorrectEclipseVersion() {\n        // Check for the team plugin version\n        // since the used API is only since 3.2.0\n        //$NON-NLS-1$\n        Bundle teamCorePlugin = Platform.getBundle(\"org.eclipse.team.core\");\n        String version = (String) teamCorePlugin.getHeaders().get(org.osgi.framework.Constants.BUNDLE_VERSION);\n        //$NON-NLS-1$\n        return \"3.2.0\".compareTo(version) < 1;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/FilesInSyncFilter2.java",
		"test_prompt": "// FilesInSyncFilter2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.swt.widgets.Display;\nimport org.eclipse.team.core.RepositoryProvider;\nimport org.eclipse.team.core.TeamException;\nimport org.eclipse.team.core.subscribers.Subscriber;\nimport org.eclipse.team.core.synchronize.SyncInfo;\nimport org.osgi.framework.Bundle;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FilesInSyncFilter2}.\n* It contains ten unit test cases for the {@link FilesInSyncFilter2#accept(Object)} method.\n*/\nclass FilesInSyncFilter2Test {"
	},
	{
		"original_code": "// FileTypesFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\n\n/**\n * Filter that excludes all but some specifically defined file types from the\n * checks.\n *\n * @author Lars K�dderitzsch\n */\npublic class FileTypesFilter extends AbstractFilter {\n\n    //\n    // attributes\n    //\n    /**\n     * List containing the passing file types.\n     */\n    private List mFileTypes;\n\n    //\n    // attributes\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean goesThrough = false;\n        if (element instanceof IResource) {\n            IResource resource = (IResource) element;\n            int type = resource.getType();\n            // java files go through\n            goesThrough = (IResource.FILE == type) && (mFileTypes.contains(resource.getFileExtension()));\n        }\n        return goesThrough;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setFilterData(List filterData) {\n        mFileTypes = filterData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilterData() {\n        return mFileTypes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getPresentableFilterData() {\n        StringBuffer buf = new StringBuffer();\n        int size = mFileTypes != null ? mFileTypes.size() : 0;\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                //$NON-NLS-1$\n                buf.append(\", \");\n            }\n            buf.append(mFileTypes.get(i));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object o) {\n        if (o == null || !(o instanceof FileTypesFilter)) {\n            return false;\n        }\n        if (this == o) {\n            return true;\n        }\n        FileTypesFilter rhs = (FileTypesFilter) o;\n        return new EqualsBuilder().appendSuper(super.equals(o)).append(mFileTypes, rhs.mFileTypes).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7834681, 1000003).appendSuper(super.hashCode()).append(mFileTypes).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/FileTypesFilter_0Test.java",
		"test_prompt": "// FileTypesFilter_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileTypesFilter}.\n* It contains ten unit test cases for the {@link FileTypesFilter#accept(Object)} method.\n*/\nclass FileTypesFilter_0Test {"
	},
	{
		"original_code": "// FileTypesFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\n\n/**\n * Filter that excludes all but some specifically defined file types from the\n * checks.\n *\n * @author Lars K�dderitzsch\n */\npublic class FileTypesFilter extends AbstractFilter {\n\n    //\n    // attributes\n    //\n    /**\n     * List containing the passing file types.\n     */\n    private List mFileTypes;\n\n    //\n    // attributes\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean goesThrough = false;\n        if (element instanceof IResource) {\n            IResource resource = (IResource) element;\n            int type = resource.getType();\n            // java files go through\n            goesThrough = (IResource.FILE == type) && (mFileTypes.contains(resource.getFileExtension()));\n        }\n        return goesThrough;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setFilterData(List filterData) {\n        mFileTypes = filterData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilterData() {\n        return mFileTypes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getPresentableFilterData() {\n        StringBuffer buf = new StringBuffer();\n        int size = mFileTypes != null ? mFileTypes.size() : 0;\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                //$NON-NLS-1$\n                buf.append(\", \");\n            }\n            buf.append(mFileTypes.get(i));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object o) {\n        if (o == null || !(o instanceof FileTypesFilter)) {\n            return false;\n        }\n        if (this == o) {\n            return true;\n        }\n        FileTypesFilter rhs = (FileTypesFilter) o;\n        return new EqualsBuilder().appendSuper(super.equals(o)).append(mFileTypes, rhs.mFileTypes).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7834681, 1000003).appendSuper(super.hashCode()).append(mFileTypes).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/FileTypesFilter_1Test.java",
		"test_prompt": "// FileTypesFilter_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileTypesFilter}.\n* It contains ten unit test cases for the {@link FileTypesFilter#equals(Object)} method.\n*/\nclass FileTypesFilter_1Test {"
	},
	{
		"original_code": "// FileTypesFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\n\n/**\n * Filter that excludes all but some specifically defined file types from the\n * checks.\n *\n * @author Lars K�dderitzsch\n */\npublic class FileTypesFilter extends AbstractFilter {\n\n    //\n    // attributes\n    //\n    /**\n     * List containing the passing file types.\n     */\n    private List mFileTypes;\n\n    //\n    // attributes\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean goesThrough = false;\n        if (element instanceof IResource) {\n            IResource resource = (IResource) element;\n            int type = resource.getType();\n            // java files go through\n            goesThrough = (IResource.FILE == type) && (mFileTypes.contains(resource.getFileExtension()));\n        }\n        return goesThrough;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setFilterData(List filterData) {\n        mFileTypes = filterData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilterData() {\n        return mFileTypes;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String getPresentableFilterData() {\n        StringBuffer buf = new StringBuffer();\n        int size = mFileTypes != null ? mFileTypes.size() : 0;\n        for (int i = 0; i < size; i++) {\n            if (i > 0) {\n                //$NON-NLS-1$\n                buf.append(\", \");\n            }\n            buf.append(mFileTypes.get(i));\n        }\n        return buf.toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object o) {\n        if (o == null || !(o instanceof FileTypesFilter)) {\n            return false;\n        }\n        if (this == o) {\n            return true;\n        }\n        FileTypesFilter rhs = (FileTypesFilter) o;\n        return new EqualsBuilder().appendSuper(super.equals(o)).append(mFileTypes, rhs.mFileTypes).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7834681, 1000003).appendSuper(super.hashCode()).append(mFileTypes).toHashCode();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/FileTypesFilter_2Test.java",
		"test_prompt": "// FileTypesFilter_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IResource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileTypesFilter}.\n* It contains ten unit test cases for the {@link FileTypesFilter#hashCode()} method.\n*/\nclass FileTypesFilter_2Test {"
	},
	{
		"original_code": "// FileTypesFilterEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.jface.dialogs.Dialog;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.ListViewer;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\n\n/**\n * Editor dialog for the package filter.\n *\n * @author Lars K�dderitzsch\n */\npublic class FileTypesFilterEditor implements IFilterEditor {\n\n    //\n    // constants\n    //\n    //\n    // attributes\n    //\n    /**\n     * the dialog for this editor.\n     */\n    private FileTypesDialog mDialog;\n\n    /**\n     * the filter data.\n     */\n    private List mFilterData;\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public int openEditor(Shell parent) {\n        this.mDialog = new FileTypesDialog(parent, mFilterData);\n        // open the dialog\n        int retCode = this.mDialog.open();\n        // actualize the filter data\n        if (Window.OK == retCode) {\n            this.mFilterData = this.getFilterDataFromDialog();\n        }\n        return retCode;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setInputProject(IProject input) {\n        // NOOP\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setFilterData(List filterData) {\n        this.mFilterData = new ArrayList(filterData);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilterData() {\n        return this.mFilterData;\n    }\n\n    /**\n     * Helper method to extract the edited data from the dialog.\n     *\n     * @return the filter data\n     */\n    private List getFilterDataFromDialog() {\n        return mFilterData;\n    }\n\n    /**\n     * Dialog to edit file types to check.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class FileTypesDialog extends Dialog {\n\n        // =================================================\n        // Public static final variables.\n        // =================================================\n        // =================================================\n        // Static class variables.\n        // =================================================\n        // =================================================\n        // Instance member variables.\n        // =================================================\n        private ListViewer mListViewer;\n\n        private Button mAddButton;\n\n        private Button mRemoveButton;\n\n        private Text mFileTypeText;\n\n        private List mFileTypesList;\n\n        // =================================================\n        // Constructors & finalizer.\n        // =================================================\n        /**\n         * Creates a file matching pattern editor dialog.\n         *\n         * @param parentShell the parent shell\n         * @param pattern the pattern\n         */\n        public FileTypesDialog(Shell parentShell, List fileTypes) {\n            super(parentShell);\n            mFileTypesList = fileTypes;\n        }\n\n        // =================================================\n        // Methods.\n        // =================================================\n        /**\n         * @see Dialog#createDialogArea(org.eclipse.swt.widgets.Composite)\n         */\n        protected Control createDialogArea(Composite parent) {\n            Composite composite = (Composite) super.createDialogArea(parent);\n            Composite main = new Composite(composite, SWT.NONE);\n            GridLayout layout = new GridLayout(2, false);\n            layout.marginHeight = 0;\n            layout.marginWidth = 0;\n            main.setLayout(layout);\n            GridData gd = new GridData(GridData.FILL_BOTH);\n            main.setLayoutData(gd);\n            mFileTypeText = new Text(main, SWT.LEFT | SWT.SINGLE | SWT.BORDER);\n            gd = new GridData(GridData.FILL_HORIZONTAL);\n            mFileTypeText.setLayoutData(gd);\n            mAddButton = new Button(main, SWT.PUSH);\n            mAddButton.setText(Messages.FileTypesFilterEditor_btnAdd);\n            gd = new GridData(GridData.FILL_HORIZONTAL);\n            gd.verticalAlignment = SWT.TOP;\n            mAddButton.setLayoutData(gd);\n            mAddButton.addSelectionListener(new SelectionListener() {\n\n                public void widgetSelected(SelectionEvent e) {\n                    String text = mFileTypeText.getText();\n                    if (text.trim().length() > 0) {\n                        mFileTypesList.add(mFileTypeText.getText());\n                        mListViewer.refresh();\n                        //$NON-NLS-1$\n                        mFileTypeText.setText(\"\");\n                    }\n                }\n\n                public void widgetDefaultSelected(SelectionEvent e) {\n                    // NOOP\n                }\n            });\n            mListViewer = new ListViewer(main, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);\n            mListViewer.setLabelProvider(new LabelProvider());\n            mListViewer.setContentProvider(new ArrayContentProvider());\n            mListViewer.setInput(mFileTypesList);\n            gd = new GridData(GridData.FILL_BOTH);\n            gd.heightHint = 100;\n            gd.widthHint = 150;\n            gd.grabExcessVerticalSpace = true;\n            mListViewer.getControl().setLayoutData(gd);\n            mRemoveButton = new Button(main, SWT.PUSH);\n            mRemoveButton.setText(Messages.FileTypesFilterEditor_btnRemove);\n            gd = new GridData(GridData.FILL_HORIZONTAL);\n            gd.verticalAlignment = SWT.TOP;\n            mRemoveButton.setLayoutData(gd);\n            mRemoveButton.addSelectionListener(new SelectionListener() {\n\n                public void widgetSelected(SelectionEvent e) {\n                    IStructuredSelection selection = (IStructuredSelection) mListViewer.getSelection();\n                    mFileTypesList.remove(selection.getFirstElement());\n                    mListViewer.refresh();\n                }\n\n                public void widgetDefaultSelected(SelectionEvent e) {\n                    // NOOP\n                }\n            });\n            return main;\n        }\n\n        /**\n         * @see org.eclipse.jface.dialogs.Dialog#okPressed()\n         */\n        protected void okPressed() {\n            super.okPressed();\n        }\n\n        /**\n         * Over-rides method from Window to configure the shell (e.g. the\n         * enclosing window).\n         */\n        protected void configureShell(Shell shell) {\n            super.configureShell(shell);\n            shell.setText(Messages.FileTypesFilterEditor_title);\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/FileTypesFilterEditor.java",
		"test_prompt": "// FileTypesFilterEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.jface.dialogs.Dialog;\nimport org.eclipse.jface.viewers.ArrayContentProvider;\nimport org.eclipse.jface.viewers.IStructuredSelection;\nimport org.eclipse.jface.viewers.LabelProvider;\nimport org.eclipse.jface.viewers.ListViewer;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.SelectionListener;\nimport org.eclipse.swt.layout.GridData;\nimport org.eclipse.swt.layout.GridLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Composite;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileTypesFilterEditor}.\n* It contains ten unit test cases for the {@link FileTypesFilterEditor#openEditor(Shell)} method.\n*/\nclass FileTypesFilterEditorTest {"
	},
	{
		"original_code": "// WriteProtectedFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport org.eclipse.core.resources.IResource;\n\n/**\n * Implementation of a filter that filters all ressources that are write\n * protected.\n *\n * @author Lars K�dderitzsch\n */\npublic class WriteProtectedFilter extends AbstractFilter {\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean goesThrough = true;\n        if (element instanceof IResource) {\n            goesThrough = !((IResource) element).isReadOnly();\n        }\n        return goesThrough;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/WriteProtectedFilter.java",
		"test_prompt": "// WriteProtectedFilterTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport org.eclipse.core.resources.IResource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WriteProtectedFilter}.\n* It contains ten unit test cases for the {@link WriteProtectedFilter#accept(Object)} method.\n*/\nclass WriteProtectedFilterTest {"
	},
	{
		"original_code": "// PackageFilterEditor.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.resources.IContainer;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.IPackageFragmentRoot;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.JavaModelException;\nimport org.eclipse.jface.viewers.ITreeContentProvider;\nimport org.eclipse.jface.viewers.Viewer;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.ui.dialogs.CheckedTreeSelectionDialog;\nimport org.eclipse.ui.model.WorkbenchLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Editor dialog for the package filter.\n *\n * @author Lars K�dderitzsch\n */\npublic class PackageFilterEditor implements IFilterEditor {\n\n    //\n    // constants\n    //\n    //\n    // attributes\n    //\n    /**\n     * the dialog for this editor.\n     */\n    private CheckedTreeSelectionDialog mDialog;\n\n    /**\n     * the input for the editor.\n     */\n    private IProject mInputProject;\n\n    /**\n     * the filter data.\n     */\n    private List mFilterData;\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public int openEditor(Shell parent) {\n        this.mDialog = new CheckedTreeSelectionDialog(parent, WorkbenchLabelProvider.getDecoratingWorkbenchLabelProvider(), new SourceFolderContentProvider());\n        // initialize the dialog with the filter data\n        initCheckedTreeSelectionDialog();\n        // open the dialog\n        int retCode = this.mDialog.open();\n        // actualize the filter data\n        if (Window.OK == retCode) {\n            this.mFilterData = this.getFilterDataFromDialog();\n        }\n        return retCode;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setInputProject(IProject input) {\n        this.mInputProject = input;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setFilterData(List filterData) {\n        this.mFilterData = filterData;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilterData() {\n        return this.mFilterData;\n    }\n\n    /**\n     * Helper method to initialize the dialog.\n     */\n    private void initCheckedTreeSelectionDialog() {\n        this.mDialog.setTitle(Messages.PackageFilterEditor_titleFilterPackages);\n        this.mDialog.setMessage(Messages.PackageFilterEditor_msgFilterPackages);\n        this.mDialog.setBlockOnOpen(true);\n        this.mDialog.setInput(this.mInputProject);\n        // display the filter data\n        if (this.mInputProject != null && this.mFilterData != null) {\n            List selectedElements = new ArrayList();\n            List expandedElements = new ArrayList();\n            int size = mFilterData != null ? mFilterData.size() : 0;\n            for (int i = 0; i < size; i++) {\n                IPath path = new Path((String) mFilterData.get(i));\n                IResource selElement = this.mInputProject.findMember(path);\n                if (selElement != null) {\n                    selectedElements.add(selElement);\n                }\n                // get all parent elements to expand\n                while (path.segmentCount() > 0) {\n                    path = path.removeLastSegments(1);\n                    IResource expElement = this.mInputProject.findMember(path);\n                    if (expElement != null) {\n                        expandedElements.add(expElement);\n                    }\n                }\n            }\n            this.mDialog.setInitialSelections(selectedElements.toArray());\n            this.mDialog.setExpandedElements(expandedElements.toArray());\n        }\n    }\n\n    /**\n     * Helper method to extract the edited data from the dialog.\n     *\n     * @return the filter data\n     */\n    private List getFilterDataFromDialog() {\n        Object[] checked = this.mDialog.getResult();\n        List result = new ArrayList();\n        for (int i = 0; i < checked.length; i++) {\n            if (checked[i] instanceof IResource) {\n                result.add(((IResource) checked[i]).getProjectRelativePath().toString());\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Content provider that provides the source folders of a project and their\n     * container members.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private class SourceFolderContentProvider implements ITreeContentProvider {\n\n        /**\n         * @see org.eclipse.jface.viewers.ITreeContentProvider#getChildren(java.lang.Object)\n         */\n        public Object[] getChildren(Object parentElement) {\n            List children = null;\n            if (parentElement instanceof IProject) {\n                IProject project = (IProject) parentElement;\n                children = handleProject(project);\n            } else if (parentElement instanceof IContainer) {\n                IContainer container = (IContainer) parentElement;\n                children = handleContainer(container);\n            } else {\n                children = new ArrayList();\n            }\n            return children.toArray();\n        }\n\n        private List handleProject(IProject project) {\n            List children = new ArrayList();\n            if (project.isAccessible()) {\n                try {\n                    IJavaProject javaProject = JavaCore.create(project);\n                    if (javaProject.exists()) {\n                        IPackageFragmentRoot[] packageRoots = javaProject.getAllPackageFragmentRoots();\n                        for (int i = 0, size = packageRoots.length; i < size; i++) {\n                            // special case - project itself is package root\n                            if (project.equals(packageRoots[i].getResource())) {\n                                IResource[] members = project.members();\n                                for (int j = 0; j < members.length; j++) {\n                                    if (members[j].getType() != IResource.FILE) {\n                                        children.add(members[j]);\n                                    }\n                                }\n                            } else if (!packageRoots[i].isArchive() && packageRoots[i].getParent().equals(javaProject)) {\n                                children.add(packageRoots[i].getResource());\n                            }\n                        }\n                    }\n                } catch (JavaModelException e) {\n                    CheckstyleLog.log(e);\n                } catch (CoreException e) {\n                    // this should never happen because we call\n                    // #isAccessible before invoking #members\n                }\n            }\n            return children;\n        }\n\n        private List handleContainer(IContainer container) {\n            List children;\n            children = new ArrayList();\n            if (container.isAccessible()) {\n                try {\n                    IResource[] members = container.members();\n                    for (int i = 0; i < members.length; i++) {\n                        if (members[i].getType() != IResource.FILE) {\n                            children.add(members[i]);\n                        }\n                    }\n                } catch (CoreException e) {\n                    // this should never happen because we call\n                    // #isAccessible before invoking #members\n                }\n            }\n            return children;\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.ITreeContentProvider#getParent(java.lang.Object)\n         */\n        public Object getParent(Object element) {\n            return element instanceof IResource ? ((IResource) element).getParent() : null;\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.ITreeContentProvider#hasChildren(java.lang.Object)\n         */\n        public boolean hasChildren(Object element) {\n            return getChildren(element).length > 0;\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.IStructuredContentProvider#getElements(java.lang.Object)\n         */\n        public Object[] getElements(Object inputElement) {\n            return getChildren(inputElement);\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.IContentProvider#dispose()\n         */\n        public void dispose() {\n            // NOOP\n        }\n\n        /**\n         * @see org.eclipse.jface.viewers.IContentProvider#inputChanged(org.eclipse.jface.viewers.Viewer,\n         *      java.lang.Object, java.lang.Object)\n         */\n        public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {\n            // NOOP\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/PackageFilterEditor.java",
		"test_prompt": "// PackageFilterEditorTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.resources.IContainer;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.IPackageFragmentRoot;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.JavaModelException;\nimport org.eclipse.jface.viewers.ITreeContentProvider;\nimport org.eclipse.jface.viewers.Viewer;\nimport org.eclipse.jface.window.Window;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.ui.dialogs.CheckedTreeSelectionDialog;\nimport org.eclipse.ui.model.WorkbenchLabelProvider;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PackageFilterEditor}.\n* It contains ten unit test cases for the {@link PackageFilterEditor#openEditor(Shell)} method.\n*/\nclass PackageFilterEditorTest {"
	},
	{
		"original_code": "// FilesInSyncFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.team.internal.ccvs.core.CVSException;\nimport org.eclipse.team.internal.ccvs.core.ICVSResource;\nimport org.eclipse.team.internal.ccvs.core.resources.CVSWorkspaceRoot;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Filters all files that are in sync with the repository.\n *\n * @author Lars K�dderitzsch\n */\npublic class FilesInSyncFilter extends AbstractFilter {\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        boolean passes = true;\n        if (element instanceof IFile) {\n            ICVSResource cvsResource = CVSWorkspaceRoot.getCVSResourceFor((IFile) element);\n            try {\n                if (cvsResource.isIgnored() || (cvsResource.isManaged() && !cvsResource.isModified(null))) {\n                    passes = false;\n                }\n            } catch (CVSException e) {\n                CheckstyleLog.log(e);\n            }\n        }\n        return passes;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/FilesInSyncFilter.java",
		"test_prompt": "// FilesInSyncFilterTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.team.internal.ccvs.core.CVSException;\nimport org.eclipse.team.internal.ccvs.core.ICVSResource;\nimport org.eclipse.team.internal.ccvs.core.resources.CVSWorkspaceRoot;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FilesInSyncFilter}.\n* It contains ten unit test cases for the {@link FilesInSyncFilter#accept(Object)} method.\n*/\nclass FilesInSyncFilterTest {"
	},
	{
		"original_code": "// UnOpenedFilesFilter.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.ui.IEditorInput;\nimport org.eclipse.ui.IEditorPart;\nimport org.eclipse.ui.IEditorReference;\nimport org.eclipse.ui.IFileEditorInput;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchPage;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.PlatformUI;\n\n/**\n * Filter that excludes all files that are not opened in an eclipse editor.\n *\n * @author Lars K�dderitzsch\n */\npublic class UnOpenedFilesFilter extends AbstractFilter {\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean accept(Object element) {\n        if (element instanceof IFile) {\n            //TODO refactor!\n            IWorkbench workBench = PlatformUI.getWorkbench();\n            IWorkbenchWindow[] windows = workBench.getWorkbenchWindows();\n            for (int i = 0; i < windows.length; i++) {\n                IWorkbenchPage[] pages = windows[i].getPages();\n                for (int j = 0; j < pages.length; j++) {\n                    IEditorReference[] editorRefs = pages[j].getEditorReferences();\n                    for (int k = 0; k < editorRefs.length; k++) {\n                        IEditorPart editor = editorRefs[k] != null ? editorRefs[k].getEditor(false) : null;\n                        IEditorInput input = editor != null ? editor.getEditorInput() : null;\n                        if (input != null && input instanceof IFileEditorInput) {\n                            IFileEditorInput fileInput = (IFileEditorInput) input;\n                            boolean accept = fileInput.getFile().equals(element);\n                            if (accept) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/filters/UnOpenedFilesFilter.java",
		"test_prompt": "// UnOpenedFilesFilterTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig.filters;\n\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.ui.IEditorInput;\nimport org.eclipse.ui.IEditorPart;\nimport org.eclipse.ui.IEditorReference;\nimport org.eclipse.ui.IFileEditorInput;\nimport org.eclipse.ui.IWorkbench;\nimport org.eclipse.ui.IWorkbenchPage;\nimport org.eclipse.ui.IWorkbenchWindow;\nimport org.eclipse.ui.PlatformUI;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UnOpenedFilesFilter}.\n* It contains ten unit test cases for the {@link UnOpenedFilesFilter#accept(Object)} method.\n*/\nclass UnOpenedFilesFilterTest {"
	},
	{
		"original_code": "// PluginFilters.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Register for the filters thats use the\n * <i>com.atlassw.tools.eclipse.checkstyle.checkstyleFilter </i> extension\n * point. Checkstyle filters can be enabled per project.\n *\n * @author Lars K�dderitzsch\n */\npublic final class PluginFilters {\n\n    //\n    // constants\n    //\n    /**\n     * constant for the extension point id.\n     */\n    //$NON-NLS-1$\n    private static final String FILTER_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + \".filters\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_NAME = \"name\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_INTERNAL_NAME = \"internal-name\";\n\n    /**\n     * constant for the description attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_DESCRIPTION = \"description\";\n\n    /**\n     * constant for the class attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CLASS = \"class\";\n\n    /**\n     * constant for the editorClass attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITOR = \"editorClass\";\n\n    /**\n     * contant for the readonly attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_READONLY = \"readonly\";\n\n    /**\n     * constant for the selected attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_SELECTED = \"selected\";\n\n    /**\n     * constant for the value attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_VALUE = \"value\";\n\n    /**\n     * constant for the data tag.\n     */\n    //$NON-NLS-1$\n    private static final String TAG_DATA = \"data\";\n\n    /**\n     * the filter prototypes configured to the extension point.\n     */\n    private static final IFilter[] FILTER_PROTOTYPES;\n\n    //\n    // Initializer\n    //\n    /**\n     * Initialize the configured to the filter extension point.\n     */\n    static {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(FILTER_EXTENSION_POINT);\n        List filters = new ArrayList();\n        for (int i = 0; i < elements.length; i++) {\n            try {\n                Class filterClass = Class.forName(elements[i].getAttributeAsIs(ATTR_CLASS));\n                String name = elements[i].getAttribute(ATTR_NAME);\n                String internalName = elements[i].getAttribute(ATTR_INTERNAL_NAME);\n                String desc = elements[i].getAttribute(ATTR_DESCRIPTION);\n                Class editorClass = elements[i].getAttributeAsIs(ATTR_EDITOR) == null ? null : Class.forName(elements[i].getAttributeAsIs(ATTR_EDITOR));\n                boolean readOnly = Boolean.valueOf(elements[i].getAttribute(ATTR_READONLY)).booleanValue();\n                IFilter filter = (IFilter) filterClass.newInstance();\n                filter.initialize(name, internalName, desc, editorClass, readOnly);\n                boolean defaultState = Boolean.valueOf(elements[i].getAttribute(ATTR_SELECTED)).booleanValue();\n                filter.setEnabled(defaultState);\n                // Load initial filter data\n                List data = new ArrayList();\n                IConfigurationElement[] dataTags = elements[i].getChildren(TAG_DATA);\n                int size = dataTags != null ? dataTags.length : 0;\n                for (int j = 0; j < size; j++) {\n                    data.add(dataTags[j].getAttribute(ATTR_VALUE));\n                }\n                filter.setFilterData(data);\n                filters.add(filter);\n            } catch (Exception e) {\n                CheckstyleLog.log(e);\n            }\n        }\n        FILTER_PROTOTYPES = (IFilter[]) filters.toArray(new IFilter[filters.size()]);\n    }\n\n    //\n    // constructor\n    //\n    /**\n     * Hidden default constructor.\n     */\n    private PluginFilters() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the available filters.\n     *\n     * @return the available filters.\n     */\n    public static IFilter[] getConfiguredFilters() {\n        // Copy the prototypes for the client\n        IFilter[] mFilter = new IFilter[FILTER_PROTOTYPES.length];\n        // Clone and set the state of the filter\n        for (int i = 0; i < mFilter.length; i++) {\n            mFilter[i] = (IFilter) FILTER_PROTOTYPES[i].clone();\n        }\n        return mFilter;\n    }\n\n    /**\n     * Gets a filter prototype by name.\n     *\n     * @param internalName the filters internal name\n     * @return the filter prototype or <code>null</code>\n     */\n    public static IFilter getByInternalName(String internalName) {\n        IFilter filter = null;\n        for (int i = 0; i < FILTER_PROTOTYPES.length; i++) {\n            if (FILTER_PROTOTYPES[i].getInternalName().equals(internalName)) {\n                filter = (IFilter) FILTER_PROTOTYPES[i].clone();\n                break;\n            }\n        }\n        return filter;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/PluginFilters_0Test.java",
		"test_prompt": "// PluginFilters_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PluginFilters}.\n* It contains ten unit test cases for the {@link PluginFilters#getConfiguredFilters()} method.\n*/\nclass PluginFilters_0Test {"
	},
	{
		"original_code": "// PluginFilters.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\n\n/**\n * Register for the filters thats use the\n * <i>com.atlassw.tools.eclipse.checkstyle.checkstyleFilter </i> extension\n * point. Checkstyle filters can be enabled per project.\n *\n * @author Lars K�dderitzsch\n */\npublic final class PluginFilters {\n\n    //\n    // constants\n    //\n    /**\n     * constant for the extension point id.\n     */\n    //$NON-NLS-1$\n    private static final String FILTER_EXTENSION_POINT = CheckstylePlugin.PLUGIN_ID + \".filters\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_NAME = \"name\";\n\n    /**\n     * constant for the name attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_INTERNAL_NAME = \"internal-name\";\n\n    /**\n     * constant for the description attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_DESCRIPTION = \"description\";\n\n    /**\n     * constant for the class attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_CLASS = \"class\";\n\n    /**\n     * constant for the editorClass attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_EDITOR = \"editorClass\";\n\n    /**\n     * contant for the readonly attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_READONLY = \"readonly\";\n\n    /**\n     * constant for the selected attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_SELECTED = \"selected\";\n\n    /**\n     * constant for the value attribute.\n     */\n    //$NON-NLS-1$\n    private static final String ATTR_VALUE = \"value\";\n\n    /**\n     * constant for the data tag.\n     */\n    //$NON-NLS-1$\n    private static final String TAG_DATA = \"data\";\n\n    /**\n     * the filter prototypes configured to the extension point.\n     */\n    private static final IFilter[] FILTER_PROTOTYPES;\n\n    //\n    // Initializer\n    //\n    /**\n     * Initialize the configured to the filter extension point.\n     */\n    static {\n        IExtensionRegistry pluginRegistry = Platform.getExtensionRegistry();\n        IConfigurationElement[] elements = pluginRegistry.getConfigurationElementsFor(FILTER_EXTENSION_POINT);\n        List filters = new ArrayList();\n        for (int i = 0; i < elements.length; i++) {\n            try {\n                Class filterClass = Class.forName(elements[i].getAttributeAsIs(ATTR_CLASS));\n                String name = elements[i].getAttribute(ATTR_NAME);\n                String internalName = elements[i].getAttribute(ATTR_INTERNAL_NAME);\n                String desc = elements[i].getAttribute(ATTR_DESCRIPTION);\n                Class editorClass = elements[i].getAttributeAsIs(ATTR_EDITOR) == null ? null : Class.forName(elements[i].getAttributeAsIs(ATTR_EDITOR));\n                boolean readOnly = Boolean.valueOf(elements[i].getAttribute(ATTR_READONLY)).booleanValue();\n                IFilter filter = (IFilter) filterClass.newInstance();\n                filter.initialize(name, internalName, desc, editorClass, readOnly);\n                boolean defaultState = Boolean.valueOf(elements[i].getAttribute(ATTR_SELECTED)).booleanValue();\n                filter.setEnabled(defaultState);\n                // Load initial filter data\n                List data = new ArrayList();\n                IConfigurationElement[] dataTags = elements[i].getChildren(TAG_DATA);\n                int size = dataTags != null ? dataTags.length : 0;\n                for (int j = 0; j < size; j++) {\n                    data.add(dataTags[j].getAttribute(ATTR_VALUE));\n                }\n                filter.setFilterData(data);\n                filters.add(filter);\n            } catch (Exception e) {\n                CheckstyleLog.log(e);\n            }\n        }\n        FILTER_PROTOTYPES = (IFilter[]) filters.toArray(new IFilter[filters.size()]);\n    }\n\n    //\n    // constructor\n    //\n    /**\n     * Hidden default constructor.\n     */\n    private PluginFilters() {\n        // NOOP\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the available filters.\n     *\n     * @return the available filters.\n     */\n    public static IFilter[] getConfiguredFilters() {\n        // Copy the prototypes for the client\n        IFilter[] mFilter = new IFilter[FILTER_PROTOTYPES.length];\n        // Clone and set the state of the filter\n        for (int i = 0; i < mFilter.length; i++) {\n            mFilter[i] = (IFilter) FILTER_PROTOTYPES[i].clone();\n        }\n        return mFilter;\n    }\n\n    /**\n     * Gets a filter prototype by name.\n     *\n     * @param internalName the filters internal name\n     * @return the filter prototype or <code>null</code>\n     */\n    public static IFilter getByInternalName(String internalName) {\n        IFilter filter = null;\n        for (int i = 0; i < FILTER_PROTOTYPES.length; i++) {\n            if (FILTER_PROTOTYPES[i].getInternalName().equals(internalName)) {\n                filter = (IFilter) FILTER_PROTOTYPES[i].clone();\n                break;\n            }\n        }\n        return filter;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/PluginFilters_1Test.java",
		"test_prompt": "// PluginFilters_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.eclipse.core.runtime.IConfigurationElement;\nimport org.eclipse.core.runtime.IExtensionRegistry;\nimport org.eclipse.core.runtime.Platform;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PluginFilters}.\n* It contains ten unit test cases for the {@link PluginFilters#getByInternalName(String)} method.\n*/\nclass PluginFilters_1Test {"
	},
	{
		"original_code": "// LocalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class LocalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage local configurations.\n     *\n     * @param projectConfig the project configuration\n     * @param checkConfigs the list of local check configurations\n     */\n    LocalCheckConfigurationWorkingSet(IProjectConfiguration projectConfig, List checkConfigs) {\n        mProjectConfig = projectConfig;\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean inUse = mProjectConfig.isConfigInUse(checkConfig);\n        if (!inUse) {\n            mWorkingCopies.remove(checkConfig);\n            mDeletedConfigurations.add(checkConfig);\n        }\n        return !inUse;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        notifyDeletedCheckConfigs();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the project of the local check configuration working set.\n     *\n     * @return the project\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (workingCopies[i].hasConfigurationChanged() && mProjectConfig.isConfigInUse(workingCopies[i])) {\n                projects.add(mProjectConfig.getProject());\n                break;\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/LocalCheckConfigurationWorkingSet_0Test.java",
		"test_prompt": "// LocalCheckConfigurationWorkingSet_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link LocalCheckConfigurationWorkingSet#newWorkingCopy(ICheckConfiguration)} method.\n*/\nclass LocalCheckConfigurationWorkingSet_0Test {"
	},
	{
		"original_code": "// LocalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class LocalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage local configurations.\n     *\n     * @param projectConfig the project configuration\n     * @param checkConfigs the list of local check configurations\n     */\n    LocalCheckConfigurationWorkingSet(IProjectConfiguration projectConfig, List checkConfigs) {\n        mProjectConfig = projectConfig;\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean inUse = mProjectConfig.isConfigInUse(checkConfig);\n        if (!inUse) {\n            mWorkingCopies.remove(checkConfig);\n            mDeletedConfigurations.add(checkConfig);\n        }\n        return !inUse;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        notifyDeletedCheckConfigs();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the project of the local check configuration working set.\n     *\n     * @return the project\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (workingCopies[i].hasConfigurationChanged() && mProjectConfig.isConfigInUse(workingCopies[i])) {\n                projects.add(mProjectConfig.getProject());\n                break;\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/LocalCheckConfigurationWorkingSet_1Test.java",
		"test_prompt": "// LocalCheckConfigurationWorkingSet_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link LocalCheckConfigurationWorkingSet#newWorkingCopy(IConfigurationType)} method.\n*/\nclass LocalCheckConfigurationWorkingSet_1Test {"
	},
	{
		"original_code": "// LocalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class LocalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage local configurations.\n     *\n     * @param projectConfig the project configuration\n     * @param checkConfigs the list of local check configurations\n     */\n    LocalCheckConfigurationWorkingSet(IProjectConfiguration projectConfig, List checkConfigs) {\n        mProjectConfig = projectConfig;\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean inUse = mProjectConfig.isConfigInUse(checkConfig);\n        if (!inUse) {\n            mWorkingCopies.remove(checkConfig);\n            mDeletedConfigurations.add(checkConfig);\n        }\n        return !inUse;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        notifyDeletedCheckConfigs();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the project of the local check configuration working set.\n     *\n     * @return the project\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (workingCopies[i].hasConfigurationChanged() && mProjectConfig.isConfigInUse(workingCopies[i])) {\n                projects.add(mProjectConfig.getProject());\n                break;\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/LocalCheckConfigurationWorkingSet_2Test.java",
		"test_prompt": "// LocalCheckConfigurationWorkingSet_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link LocalCheckConfigurationWorkingSet#removeCheckConfiguration(CheckConfigurationWorkingCopy)} method.\n*/\nclass LocalCheckConfigurationWorkingSet_2Test {"
	},
	{
		"original_code": "// LocalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class LocalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage local configurations.\n     *\n     * @param projectConfig the project configuration\n     * @param checkConfigs the list of local check configurations\n     */\n    LocalCheckConfigurationWorkingSet(IProjectConfiguration projectConfig, List checkConfigs) {\n        mProjectConfig = projectConfig;\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean inUse = mProjectConfig.isConfigInUse(checkConfig);\n        if (!inUse) {\n            mWorkingCopies.remove(checkConfig);\n            mDeletedConfigurations.add(checkConfig);\n        }\n        return !inUse;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        notifyDeletedCheckConfigs();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the project of the local check configuration working set.\n     *\n     * @return the project\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (workingCopies[i].hasConfigurationChanged() && mProjectConfig.isConfigInUse(workingCopies[i])) {\n                projects.add(mProjectConfig.getProject());\n                break;\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/LocalCheckConfigurationWorkingSet_3Test.java",
		"test_prompt": "// LocalCheckConfigurationWorkingSet_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link LocalCheckConfigurationWorkingSet#isDirty()} method.\n*/\nclass LocalCheckConfigurationWorkingSet_3Test {"
	},
	{
		"original_code": "// LocalCheckConfigurationWorkingSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Working set implementation that manages global configurations configured for\n * the Eclipse workspace.\n *\n * @author Lars K�dderitzsch\n */\npublic class LocalCheckConfigurationWorkingSet implements ICheckConfigurationWorkingSet {\n\n    //\n    // attributes\n    //\n    /**\n     * The project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The internal list of working copies belonging to this working set.\n     */\n    private List mWorkingCopies;\n\n    /**\n     * List of working copies that were deleted from the working set.\n     */\n    private List mDeletedConfigurations;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working set to manage local configurations.\n     *\n     * @param projectConfig the project configuration\n     * @param checkConfigs the list of local check configurations\n     */\n    LocalCheckConfigurationWorkingSet(IProjectConfiguration projectConfig, List checkConfigs) {\n        mProjectConfig = projectConfig;\n        mWorkingCopies = new ArrayList();\n        mDeletedConfigurations = new ArrayList();\n        Iterator iter = checkConfigs.iterator();\n        while (iter.hasNext()) {\n            ICheckConfiguration cfg = (ICheckConfiguration) iter.next();\n            CheckConfigurationWorkingCopy workingCopy = new CheckConfigurationWorkingCopy(cfg, this);\n            mWorkingCopies.add(workingCopy);\n        }\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(ICheckConfiguration checkConfig) {\n        return new CheckConfigurationWorkingCopy(checkConfig, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy newWorkingCopy(IConfigurationType configType) {\n        return new CheckConfigurationWorkingCopy(configType, this, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public CheckConfigurationWorkingCopy[] getWorkingCopies() {\n        return (CheckConfigurationWorkingCopy[]) mWorkingCopies.toArray(new CheckConfigurationWorkingCopy[mWorkingCopies.size()]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        mWorkingCopies.add(checkConfig);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean removeCheckConfiguration(CheckConfigurationWorkingCopy checkConfig) {\n        boolean inUse = mProjectConfig.isConfigInUse(checkConfig);\n        if (!inUse) {\n            mWorkingCopies.remove(checkConfig);\n            mDeletedConfigurations.add(checkConfig);\n        }\n        return !inUse;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void store() throws CheckstylePluginException {\n        notifyDeletedCheckConfigs();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isDirty() {\n        if (mDeletedConfigurations.size() > 0) {\n            return true;\n        }\n        boolean dirty = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy workingCopy = (CheckConfigurationWorkingCopy) it.next();\n            dirty = workingCopy.isDirty();\n            if (dirty) {\n                break;\n            }\n        }\n        return dirty;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isNameCollision(CheckConfigurationWorkingCopy configuration) {\n        boolean result = false;\n        Iterator it = mWorkingCopies.iterator();\n        while (it.hasNext()) {\n            CheckConfigurationWorkingCopy tmp = (CheckConfigurationWorkingCopy) it.next();\n            if (tmp != configuration && tmp.getName().equals(configuration.getName())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the project of the local check configuration working set.\n     *\n     * @return the project\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Collection getAffectedProjects() throws CheckstylePluginException {\n        Set projects = new HashSet();\n        CheckConfigurationWorkingCopy[] workingCopies = this.getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            // skip non dirty configurations\n            if (workingCopies[i].hasConfigurationChanged() && mProjectConfig.isConfigInUse(workingCopies[i])) {\n                projects.add(mProjectConfig.getProject());\n                break;\n            }\n        }\n        return projects;\n    }\n\n    /**\n     * Notifies the check configurations that have been deleted.\n     *\n     * @throws CheckstylePluginException an exception while notifiing for\n     *             deletion\n     */\n    private void notifyDeletedCheckConfigs() throws CheckstylePluginException {\n        Iterator it = mDeletedConfigurations.iterator();\n        while (it.hasNext()) {\n            ICheckConfiguration checkConfig = (ICheckConfiguration) it.next();\n            checkConfig.getType().notifyCheckConfigRemoved(checkConfig);\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/LocalCheckConfigurationWorkingSet_4Test.java",
		"test_prompt": "// LocalCheckConfigurationWorkingSet_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LocalCheckConfigurationWorkingSet}.\n* It contains ten unit test cases for the {@link LocalCheckConfigurationWorkingSet#isNameCollision(CheckConfigurationWorkingCopy)} method.\n*/\nclass LocalCheckConfigurationWorkingSet_4Test {"
	},
	{
		"original_code": "// FileSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\n\n/**\n * A File Set is a collection of files audited with a common set of audit rules.\n */\npublic class FileSet implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private String mName;\n\n    private ICheckConfiguration mCheckConfig;\n\n    private boolean mEnabled = true;\n\n    private List mFileMatchPatterns = new LinkedList();\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Default constructor.\n     */\n    public FileSet() {\n    }\n\n    /**\n     * Default constructor.\n     *\n     * @param name The name of the <code>FileSet</code>\n     *\n     * @param checkConfig The name of the <code>CheckConfiguration</code> used\n     *            to check this <code>FileSet</code>.\n     */\n    public FileSet(String name, ICheckConfiguration checkConfig) {\n        setName(name);\n        setCheckConfig(checkConfig);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns a list of <code>FileMatchPattern</code> objects.\n     *\n     * @return List\n     */\n    public List getFileMatchPatterns() {\n        return mFileMatchPatterns;\n    }\n\n    /**\n     * Set the list of <code>FileMatchPattern</code> objects.\n     *\n     * @param list The new list of pattern objects.\n     */\n    public void setFileMatchPatterns(List list) {\n        mFileMatchPatterns = list;\n    }\n\n    /**\n     * Get the check configuration used by this file set.\n     *\n     * @return The check configuration used to audit files in the file set.\n     */\n    public ICheckConfiguration getCheckConfig() {\n        return mCheckConfig;\n    }\n\n    /**\n     * Sets the check configuration used by this file set.\n     *\n     * @param checkConfig the check configuration\n     */\n    public void setCheckConfig(ICheckConfiguration checkConfig) {\n        mCheckConfig = checkConfig;\n    }\n\n    /**\n     * Returns the name.\n     *\n     * @return String\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * Sets the name.\n     *\n     * @param name The name to set\n     */\n    public void setName(String name) {\n        mName = name;\n    }\n\n    /**\n     * Returns the enabled flag.\n     *\n     * @return boolean\n     */\n    public boolean isEnabled() {\n        return mEnabled;\n    }\n\n    /**\n     * Sets the enabled flag.\n     *\n     * @param enabled The enabled to set\n     */\n    public void setEnabled(boolean enabled) {\n        mEnabled = enabled;\n    }\n\n    /**\n     * Tests a file to see if its included in the file set.\n     *\n     * @param file The file to test.\n     *\n     * @return <code>true</code>= the file is included in the file set,\n     *         <p>\n     *         <code>false</code>= the file is not included in the file set.\n     */\n    public boolean includesFile(IFile file) {\n        boolean result = false;\n        String filePath = file.getProjectRelativePath().toOSString();\n        Iterator iter = mFileMatchPatterns.iterator();\n        while (iter.hasNext()) {\n            FileMatchPattern pattern = (FileMatchPattern) iter.next();\n            boolean matches = pattern.isMatch(filePath);\n            if (matches) {\n                if (pattern.isIncludePattern()) {\n                    result = true;\n                } else {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            FileSet clone = (FileSet) super.clone();\n            // clone filesets\n            List clonedPatterns = new LinkedList();\n            Iterator it = mFileMatchPatterns.iterator();\n            while (it.hasNext()) {\n                clonedPatterns.add(((FileMatchPattern) it.next()).clone());\n            }\n            clone.mFileMatchPatterns = clonedPatterns;\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileSet)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileSet rhs = (FileSet) obj;\n        return new EqualsBuilder().append(mEnabled, rhs.mEnabled).append(mName, rhs.mName).append(mFileMatchPatterns, rhs.mFileMatchPatterns).append(mCheckConfig, rhs.mCheckConfig).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(987349, 1000003).append(mEnabled).append(mName).append(mCheckConfig).append(mFileMatchPatterns).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileSet_0Test.java",
		"test_prompt": "// FileSet_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileSet}.\n* It contains ten unit test cases for the {@link FileSet#isEnabled()} method.\n*/\nclass FileSet_0Test {"
	},
	{
		"original_code": "// FileSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\n\n/**\n * A File Set is a collection of files audited with a common set of audit rules.\n */\npublic class FileSet implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private String mName;\n\n    private ICheckConfiguration mCheckConfig;\n\n    private boolean mEnabled = true;\n\n    private List mFileMatchPatterns = new LinkedList();\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Default constructor.\n     */\n    public FileSet() {\n    }\n\n    /**\n     * Default constructor.\n     *\n     * @param name The name of the <code>FileSet</code>\n     *\n     * @param checkConfig The name of the <code>CheckConfiguration</code> used\n     *            to check this <code>FileSet</code>.\n     */\n    public FileSet(String name, ICheckConfiguration checkConfig) {\n        setName(name);\n        setCheckConfig(checkConfig);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns a list of <code>FileMatchPattern</code> objects.\n     *\n     * @return List\n     */\n    public List getFileMatchPatterns() {\n        return mFileMatchPatterns;\n    }\n\n    /**\n     * Set the list of <code>FileMatchPattern</code> objects.\n     *\n     * @param list The new list of pattern objects.\n     */\n    public void setFileMatchPatterns(List list) {\n        mFileMatchPatterns = list;\n    }\n\n    /**\n     * Get the check configuration used by this file set.\n     *\n     * @return The check configuration used to audit files in the file set.\n     */\n    public ICheckConfiguration getCheckConfig() {\n        return mCheckConfig;\n    }\n\n    /**\n     * Sets the check configuration used by this file set.\n     *\n     * @param checkConfig the check configuration\n     */\n    public void setCheckConfig(ICheckConfiguration checkConfig) {\n        mCheckConfig = checkConfig;\n    }\n\n    /**\n     * Returns the name.\n     *\n     * @return String\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * Sets the name.\n     *\n     * @param name The name to set\n     */\n    public void setName(String name) {\n        mName = name;\n    }\n\n    /**\n     * Returns the enabled flag.\n     *\n     * @return boolean\n     */\n    public boolean isEnabled() {\n        return mEnabled;\n    }\n\n    /**\n     * Sets the enabled flag.\n     *\n     * @param enabled The enabled to set\n     */\n    public void setEnabled(boolean enabled) {\n        mEnabled = enabled;\n    }\n\n    /**\n     * Tests a file to see if its included in the file set.\n     *\n     * @param file The file to test.\n     *\n     * @return <code>true</code>= the file is included in the file set,\n     *         <p>\n     *         <code>false</code>= the file is not included in the file set.\n     */\n    public boolean includesFile(IFile file) {\n        boolean result = false;\n        String filePath = file.getProjectRelativePath().toOSString();\n        Iterator iter = mFileMatchPatterns.iterator();\n        while (iter.hasNext()) {\n            FileMatchPattern pattern = (FileMatchPattern) iter.next();\n            boolean matches = pattern.isMatch(filePath);\n            if (matches) {\n                if (pattern.isIncludePattern()) {\n                    result = true;\n                } else {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            FileSet clone = (FileSet) super.clone();\n            // clone filesets\n            List clonedPatterns = new LinkedList();\n            Iterator it = mFileMatchPatterns.iterator();\n            while (it.hasNext()) {\n                clonedPatterns.add(((FileMatchPattern) it.next()).clone());\n            }\n            clone.mFileMatchPatterns = clonedPatterns;\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileSet)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileSet rhs = (FileSet) obj;\n        return new EqualsBuilder().append(mEnabled, rhs.mEnabled).append(mName, rhs.mName).append(mFileMatchPatterns, rhs.mFileMatchPatterns).append(mCheckConfig, rhs.mCheckConfig).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(987349, 1000003).append(mEnabled).append(mName).append(mCheckConfig).append(mFileMatchPatterns).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileSet_1Test.java",
		"test_prompt": "// FileSet_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileSet}.\n* It contains ten unit test cases for the {@link FileSet#includesFile(IFile)} method.\n*/\nclass FileSet_1Test {"
	},
	{
		"original_code": "// FileSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\n\n/**\n * A File Set is a collection of files audited with a common set of audit rules.\n */\npublic class FileSet implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private String mName;\n\n    private ICheckConfiguration mCheckConfig;\n\n    private boolean mEnabled = true;\n\n    private List mFileMatchPatterns = new LinkedList();\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Default constructor.\n     */\n    public FileSet() {\n    }\n\n    /**\n     * Default constructor.\n     *\n     * @param name The name of the <code>FileSet</code>\n     *\n     * @param checkConfig The name of the <code>CheckConfiguration</code> used\n     *            to check this <code>FileSet</code>.\n     */\n    public FileSet(String name, ICheckConfiguration checkConfig) {\n        setName(name);\n        setCheckConfig(checkConfig);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns a list of <code>FileMatchPattern</code> objects.\n     *\n     * @return List\n     */\n    public List getFileMatchPatterns() {\n        return mFileMatchPatterns;\n    }\n\n    /**\n     * Set the list of <code>FileMatchPattern</code> objects.\n     *\n     * @param list The new list of pattern objects.\n     */\n    public void setFileMatchPatterns(List list) {\n        mFileMatchPatterns = list;\n    }\n\n    /**\n     * Get the check configuration used by this file set.\n     *\n     * @return The check configuration used to audit files in the file set.\n     */\n    public ICheckConfiguration getCheckConfig() {\n        return mCheckConfig;\n    }\n\n    /**\n     * Sets the check configuration used by this file set.\n     *\n     * @param checkConfig the check configuration\n     */\n    public void setCheckConfig(ICheckConfiguration checkConfig) {\n        mCheckConfig = checkConfig;\n    }\n\n    /**\n     * Returns the name.\n     *\n     * @return String\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * Sets the name.\n     *\n     * @param name The name to set\n     */\n    public void setName(String name) {\n        mName = name;\n    }\n\n    /**\n     * Returns the enabled flag.\n     *\n     * @return boolean\n     */\n    public boolean isEnabled() {\n        return mEnabled;\n    }\n\n    /**\n     * Sets the enabled flag.\n     *\n     * @param enabled The enabled to set\n     */\n    public void setEnabled(boolean enabled) {\n        mEnabled = enabled;\n    }\n\n    /**\n     * Tests a file to see if its included in the file set.\n     *\n     * @param file The file to test.\n     *\n     * @return <code>true</code>= the file is included in the file set,\n     *         <p>\n     *         <code>false</code>= the file is not included in the file set.\n     */\n    public boolean includesFile(IFile file) {\n        boolean result = false;\n        String filePath = file.getProjectRelativePath().toOSString();\n        Iterator iter = mFileMatchPatterns.iterator();\n        while (iter.hasNext()) {\n            FileMatchPattern pattern = (FileMatchPattern) iter.next();\n            boolean matches = pattern.isMatch(filePath);\n            if (matches) {\n                if (pattern.isIncludePattern()) {\n                    result = true;\n                } else {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            FileSet clone = (FileSet) super.clone();\n            // clone filesets\n            List clonedPatterns = new LinkedList();\n            Iterator it = mFileMatchPatterns.iterator();\n            while (it.hasNext()) {\n                clonedPatterns.add(((FileMatchPattern) it.next()).clone());\n            }\n            clone.mFileMatchPatterns = clonedPatterns;\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileSet)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileSet rhs = (FileSet) obj;\n        return new EqualsBuilder().append(mEnabled, rhs.mEnabled).append(mName, rhs.mName).append(mFileMatchPatterns, rhs.mFileMatchPatterns).append(mCheckConfig, rhs.mCheckConfig).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(987349, 1000003).append(mEnabled).append(mName).append(mCheckConfig).append(mFileMatchPatterns).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileSet_2Test.java",
		"test_prompt": "// FileSet_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileSet}.\n* It contains ten unit test cases for the {@link FileSet#clone()} method.\n*/\nclass FileSet_2Test {"
	},
	{
		"original_code": "// FileSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\n\n/**\n * A File Set is a collection of files audited with a common set of audit rules.\n */\npublic class FileSet implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private String mName;\n\n    private ICheckConfiguration mCheckConfig;\n\n    private boolean mEnabled = true;\n\n    private List mFileMatchPatterns = new LinkedList();\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Default constructor.\n     */\n    public FileSet() {\n    }\n\n    /**\n     * Default constructor.\n     *\n     * @param name The name of the <code>FileSet</code>\n     *\n     * @param checkConfig The name of the <code>CheckConfiguration</code> used\n     *            to check this <code>FileSet</code>.\n     */\n    public FileSet(String name, ICheckConfiguration checkConfig) {\n        setName(name);\n        setCheckConfig(checkConfig);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns a list of <code>FileMatchPattern</code> objects.\n     *\n     * @return List\n     */\n    public List getFileMatchPatterns() {\n        return mFileMatchPatterns;\n    }\n\n    /**\n     * Set the list of <code>FileMatchPattern</code> objects.\n     *\n     * @param list The new list of pattern objects.\n     */\n    public void setFileMatchPatterns(List list) {\n        mFileMatchPatterns = list;\n    }\n\n    /**\n     * Get the check configuration used by this file set.\n     *\n     * @return The check configuration used to audit files in the file set.\n     */\n    public ICheckConfiguration getCheckConfig() {\n        return mCheckConfig;\n    }\n\n    /**\n     * Sets the check configuration used by this file set.\n     *\n     * @param checkConfig the check configuration\n     */\n    public void setCheckConfig(ICheckConfiguration checkConfig) {\n        mCheckConfig = checkConfig;\n    }\n\n    /**\n     * Returns the name.\n     *\n     * @return String\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * Sets the name.\n     *\n     * @param name The name to set\n     */\n    public void setName(String name) {\n        mName = name;\n    }\n\n    /**\n     * Returns the enabled flag.\n     *\n     * @return boolean\n     */\n    public boolean isEnabled() {\n        return mEnabled;\n    }\n\n    /**\n     * Sets the enabled flag.\n     *\n     * @param enabled The enabled to set\n     */\n    public void setEnabled(boolean enabled) {\n        mEnabled = enabled;\n    }\n\n    /**\n     * Tests a file to see if its included in the file set.\n     *\n     * @param file The file to test.\n     *\n     * @return <code>true</code>= the file is included in the file set,\n     *         <p>\n     *         <code>false</code>= the file is not included in the file set.\n     */\n    public boolean includesFile(IFile file) {\n        boolean result = false;\n        String filePath = file.getProjectRelativePath().toOSString();\n        Iterator iter = mFileMatchPatterns.iterator();\n        while (iter.hasNext()) {\n            FileMatchPattern pattern = (FileMatchPattern) iter.next();\n            boolean matches = pattern.isMatch(filePath);\n            if (matches) {\n                if (pattern.isIncludePattern()) {\n                    result = true;\n                } else {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            FileSet clone = (FileSet) super.clone();\n            // clone filesets\n            List clonedPatterns = new LinkedList();\n            Iterator it = mFileMatchPatterns.iterator();\n            while (it.hasNext()) {\n                clonedPatterns.add(((FileMatchPattern) it.next()).clone());\n            }\n            clone.mFileMatchPatterns = clonedPatterns;\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileSet)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileSet rhs = (FileSet) obj;\n        return new EqualsBuilder().append(mEnabled, rhs.mEnabled).append(mName, rhs.mName).append(mFileMatchPatterns, rhs.mFileMatchPatterns).append(mCheckConfig, rhs.mCheckConfig).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(987349, 1000003).append(mEnabled).append(mName).append(mCheckConfig).append(mFileMatchPatterns).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileSet_3Test.java",
		"test_prompt": "// FileSet_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileSet}.\n* It contains ten unit test cases for the {@link FileSet#equals(Object)} method.\n*/\nclass FileSet_3Test {"
	},
	{
		"original_code": "// FileSet.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\n\n/**\n * A File Set is a collection of files audited with a common set of audit rules.\n */\npublic class FileSet implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private String mName;\n\n    private ICheckConfiguration mCheckConfig;\n\n    private boolean mEnabled = true;\n\n    private List mFileMatchPatterns = new LinkedList();\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Default constructor.\n     */\n    public FileSet() {\n    }\n\n    /**\n     * Default constructor.\n     *\n     * @param name The name of the <code>FileSet</code>\n     *\n     * @param checkConfig The name of the <code>CheckConfiguration</code> used\n     *            to check this <code>FileSet</code>.\n     */\n    public FileSet(String name, ICheckConfiguration checkConfig) {\n        setName(name);\n        setCheckConfig(checkConfig);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns a list of <code>FileMatchPattern</code> objects.\n     *\n     * @return List\n     */\n    public List getFileMatchPatterns() {\n        return mFileMatchPatterns;\n    }\n\n    /**\n     * Set the list of <code>FileMatchPattern</code> objects.\n     *\n     * @param list The new list of pattern objects.\n     */\n    public void setFileMatchPatterns(List list) {\n        mFileMatchPatterns = list;\n    }\n\n    /**\n     * Get the check configuration used by this file set.\n     *\n     * @return The check configuration used to audit files in the file set.\n     */\n    public ICheckConfiguration getCheckConfig() {\n        return mCheckConfig;\n    }\n\n    /**\n     * Sets the check configuration used by this file set.\n     *\n     * @param checkConfig the check configuration\n     */\n    public void setCheckConfig(ICheckConfiguration checkConfig) {\n        mCheckConfig = checkConfig;\n    }\n\n    /**\n     * Returns the name.\n     *\n     * @return String\n     */\n    public String getName() {\n        return mName;\n    }\n\n    /**\n     * Sets the name.\n     *\n     * @param name The name to set\n     */\n    public void setName(String name) {\n        mName = name;\n    }\n\n    /**\n     * Returns the enabled flag.\n     *\n     * @return boolean\n     */\n    public boolean isEnabled() {\n        return mEnabled;\n    }\n\n    /**\n     * Sets the enabled flag.\n     *\n     * @param enabled The enabled to set\n     */\n    public void setEnabled(boolean enabled) {\n        mEnabled = enabled;\n    }\n\n    /**\n     * Tests a file to see if its included in the file set.\n     *\n     * @param file The file to test.\n     *\n     * @return <code>true</code>= the file is included in the file set,\n     *         <p>\n     *         <code>false</code>= the file is not included in the file set.\n     */\n    public boolean includesFile(IFile file) {\n        boolean result = false;\n        String filePath = file.getProjectRelativePath().toOSString();\n        Iterator iter = mFileMatchPatterns.iterator();\n        while (iter.hasNext()) {\n            FileMatchPattern pattern = (FileMatchPattern) iter.next();\n            boolean matches = pattern.isMatch(filePath);\n            if (matches) {\n                if (pattern.isIncludePattern()) {\n                    result = true;\n                } else {\n                    result = false;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        try {\n            FileSet clone = (FileSet) super.clone();\n            // clone filesets\n            List clonedPatterns = new LinkedList();\n            Iterator it = mFileMatchPatterns.iterator();\n            while (it.hasNext()) {\n                clonedPatterns.add(((FileMatchPattern) it.next()).clone());\n            }\n            clone.mFileMatchPatterns = clonedPatterns;\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileSet)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileSet rhs = (FileSet) obj;\n        return new EqualsBuilder().append(mEnabled, rhs.mEnabled).append(mName, rhs.mName).append(mFileMatchPatterns, rhs.mFileMatchPatterns).append(mCheckConfig, rhs.mCheckConfig).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(987349, 1000003).append(mEnabled).append(mName).append(mCheckConfig).append(mFileMatchPatterns).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileSet_4Test.java",
		"test_prompt": "// FileSet_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileSet}.\n* It contains ten unit test cases for the {@link FileSet#hashCode()} method.\n*/\nclass FileSet_4Test {"
	},
	{
		"original_code": "// ProjectConfigurationFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Used to manage the life cycle of FileSet objects.\n */\npublic final class ProjectConfigurationFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    //$NON-NLS-1$\n    static final String PROJECT_CONFIGURATION_FILE = \".checkstyle\";\n\n    //$NON-NLS-1$\n    static final String CURRENT_FILE_FORMAT_VERSION = \"1.2.0\";\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    private ProjectConfigurationFactory() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get the <code>ProjectConfiguration</code> object for the specified\n     * project.\n     *\n     * @param project The project to get <code>FileSet</code>'s for.\n     * @return The <code>ProjectConfiguration</code> instance.\n     * @throws CheckstylePluginException Error during processing.\n     */\n    public static IProjectConfiguration getConfiguration(IProject project) throws CheckstylePluginException {\n        return loadFromPersistence(project);\n    }\n\n    /**\n     * Check to see if a check configuration is currently in use by any\n     * projects.\n     *\n     * @param checkConfig The check configuration to check for.\n     * @return <code>true</code>= in use, <code>false</code>= not in use.\n     * @throws CheckstylePluginException Error during processing.\n     */\n    public static boolean isCheckConfigInUse(ICheckConfiguration checkConfig) throws CheckstylePluginException {\n        return getProjectsUsingConfig(checkConfig).size() > 0;\n    }\n\n    /**\n     * Returns a list of projects using this check configuration.\n     *\n     * @param checkConfig the check configuration\n     * @return the list of projects using this configuration\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public static List getProjectsUsingConfig(ICheckConfiguration checkConfig) throws CheckstylePluginException {\n        List result = new ArrayList();\n        IWorkspace workspace = ResourcesPlugin.getWorkspace();\n        IProject[] projects = workspace.getRoot().getProjects();\n        for (int i = 0; (i < projects.length); i++) {\n            if (ProjectConfigurationFactory.getConfiguration(projects[i]).isConfigInUse(checkConfig)) {\n                result.add(projects[i]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Load the audit configurations from the persistent state storage.\n     */\n    private static IProjectConfiguration loadFromPersistence(IProject project) throws CheckstylePluginException {\n        IProjectConfiguration configuration = null;\n        //\n        // Make sure the files exists, it might not.\n        //\n        IFile file = project.getFile(PROJECT_CONFIGURATION_FILE);\n        boolean exists = file.exists();\n        if (!exists) {\n            FileSet standardFileSet = new FileSet(Messages.SimpleFileSetsEditor_nameAllFileset, CheckConfigurationFactory.getDefaultCheckConfiguration());\n            standardFileSet.getFileMatchPatterns().add(new FileMatchPattern(\".*\"));\n            List fileSets = Arrays.asList(new Object[] { standardFileSet });\n            return new ProjectConfiguration(project, null, fileSets, null, true);\n        }\n        InputStream inStream = null;\n        try {\n            inStream = file.getContents(true);\n            ProjectConfigFileHandler handler = new ProjectConfigFileHandler(project);\n            XMLUtil.parseWithSAX(inStream, handler);\n            configuration = handler.getConfiguration();\n        } catch (CoreException ce) {\n            CheckstylePluginException.rethrow(ce);\n        } catch (SAXException se) {\n            Exception ex = se.getException() != null ? se.getException() : se;\n            CheckstylePluginException.rethrow(ex);\n        } catch (ParserConfigurationException pe) {\n            CheckstylePluginException.rethrow(pe);\n        } catch (IOException ioe) {\n            CheckstylePluginException.rethrow(ioe);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n        }\n        return configuration;\n    }\n\n    /**\n     * Sax-Handler for parsing the checkstyle plugin project configuration file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class ProjectConfigFileHandler extends DefaultHandler {\n\n        //\n        // constants\n        //\n        /**\n         * constant list of supported file versions.\n         */\n        private static final List SUPPORTED_VERSIONS = Arrays.asList(new String[] { //$NON-NLS-1$ //$NON-NLS-2$\n        \"1.0.0\", //$NON-NLS-1$ //$NON-NLS-2$\n        \"1.1.0\", CURRENT_FILE_FORMAT_VERSION });\n\n        //\n        // attributes\n        //\n        /**\n         * The project.\n         */\n        private IProject mProject;\n\n        /**\n         * the file set currently built.\n         */\n        private FileSet mCurrentFileSet;\n\n        /**\n         * the current filter.\n         */\n        private IFilter mCurrentFilter;\n\n        /**\n         * The name of the current check configuration.\n         */\n        private String mCurrentName;\n\n        /**\n         * The location of the current check configuration.\n         */\n        private String mCurrentLocation;\n\n        /**\n         * The description of the current check configuration.\n         */\n        private String mCurrentDescription;\n\n        /**\n         * The configuration type of the current configuration.\n         */\n        private IConfigurationType mCurrentConfigType;\n\n        /**\n         * if the project configuration uses simple configuration.\n         */\n        private boolean mUseSimpleConfig;\n\n        /**\n         * The list of configurations.\n         */\n        private List mCheckConfigs;\n\n        /**\n         * The list of file sets.\n         */\n        private List mFileSets;\n\n        /**\n         * The filters.\n         */\n        private List mFilters;\n\n        /**\n         * Additional data for the current configuration.\n         */\n        private Map mCurrentAddValues;\n\n        /**\n         * List of resolvable properties for the current configuration.\n         */\n        private List mResolvableProperties;\n\n        //\n        // constructors\n        //\n        public ProjectConfigFileHandler(IProject project) {\n            mProject = project;\n        }\n\n        //\n        // methods\n        //\n        /**\n         * Returns the project configuration.\n         *\n         * @return the project configuration\n         */\n        public IProjectConfiguration getConfiguration() {\n            return new ProjectConfiguration(mProject, mCheckConfigs, mFileSets, mFilters, mUseSimpleConfig);\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,\n         *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            try {\n                if (XMLTags.FILESET_CONFIG_TAG.equals(qName)) {\n                    String version = attributes.getValue(XMLTags.FORMAT_VERSION_TAG);\n                    if (!SUPPORTED_VERSIONS.contains(version)) {\n                        throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorUnknownFileFormat, version));\n                    }\n                    mUseSimpleConfig = Boolean.valueOf(attributes.getValue(XMLTags.SIMPLE_CONFIG_TAG)).booleanValue();\n                    mCheckConfigs = new ArrayList();\n                    mFileSets = new ArrayList();\n                    mFilters = new ArrayList();\n                } else if (XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                    mCurrentName = attributes.getValue(XMLTags.NAME_TAG);\n                    mCurrentDescription = attributes.getValue(XMLTags.DESCRIPTION_TAG);\n                    mCurrentLocation = attributes.getValue(XMLTags.LOCATION_TAG);\n                    String type = attributes.getValue(XMLTags.TYPE_TAG);\n                    mCurrentConfigType = ConfigurationTypes.getByInternalName(type);\n                    if (mCurrentConfigType instanceof ProjectConfigurationType) {\n                        // RFE 1420212\n                        // treat config files relative to *THIS* project\n                        IWorkspaceRoot root = mProject.getWorkspace().getRoot();\n                        // test if the location contains the project name\n                        if (root.findMember(mCurrentLocation) == null) {\n                            mCurrentLocation = mProject.getFullPath().append(mCurrentLocation).toString();\n                        }\n                    }\n                    mCurrentAddValues = new HashMap();\n                    mResolvableProperties = new ArrayList();\n                } else if (XMLTags.ADDITIONAL_DATA_TAG.equalsIgnoreCase(qName)) {\n                    mCurrentAddValues.put(attributes.getValue(XMLTags.NAME_TAG), attributes.getValue(XMLTags.VALUE_TAG));\n                } else if (XMLTags.PROPERTY_TAG.equals(qName)) {\n                    String name = attributes.getValue(XMLTags.NAME_TAG);\n                    String value = attributes.getValue(XMLTags.VALUE_TAG);\n                    ResolvableProperty prop = new ResolvableProperty(name, value);\n                    mResolvableProperties.add(prop);\n                } else if (XMLTags.FILESET_TAG.equals(qName)) {\n                    String name = attributes.getValue(XMLTags.CHECK_CONFIG_NAME_TAG);\n                    boolean local = Boolean.valueOf(attributes.getValue(XMLTags.LOCAL_TAG)).booleanValue();\n                    mCurrentFileSet = new FileSet();\n                    mCurrentFileSet.setName(attributes.getValue(XMLTags.NAME_TAG));\n                    mCurrentFileSet.setEnabled(Boolean.valueOf(attributes.getValue(XMLTags.ENABLED_TAG)).booleanValue());\n                    ICheckConfiguration checkConfig = null;\n                    if (local) {\n                        Iterator it = mCheckConfigs.iterator();\n                        while (it.hasNext()) {\n                            ICheckConfiguration tmp = (ICheckConfiguration) it.next();\n                            if (tmp.getName().equals(name)) {\n                                checkConfig = tmp;\n                            }\n                        }\n                    } else {\n                        checkConfig = CheckConfigurationFactory.getByName(name);\n                    }\n                    mCurrentFileSet.setCheckConfig(checkConfig);\n                    // set an empty list for the patterns to store\n                    mCurrentFileSet.setFileMatchPatterns(new ArrayList());\n                    mFileSets.add(mCurrentFileSet);\n                } else if (XMLTags.FILE_MATCH_PATTERN_TAG.equals(qName)) {\n                    FileMatchPattern pattern = new FileMatchPattern(attributes.getValue(XMLTags.MATCH_PATTERN_TAG));\n                    pattern.setIsIncludePattern(Boolean.valueOf(attributes.getValue(XMLTags.INCLUDE_PATTERN_TAG)).booleanValue());\n                    mCurrentFileSet.getFileMatchPatterns().add(pattern);\n                } else if (XMLTags.FILTER_TAG.equals(qName)) {\n                    mCurrentFilter = PluginFilters.getByInternalName(attributes.getValue(XMLTags.NAME_TAG));\n                    if (mCurrentFilter != null) {\n                        mCurrentFilter.setEnabled(Boolean.valueOf(attributes.getValue(XMLTags.ENABLED_TAG)).booleanValue());\n                        // set an empty list for the filter data\n                        mCurrentFilter.setFilterData(new ArrayList());\n                        mFilters.add(mCurrentFilter);\n                    }\n                } else if (XMLTags.FILTER_DATA_TAG.equals(qName) && mCurrentFilter != null) {\n                    mCurrentFilter.getFilterData().add(attributes.getValue(XMLTags.VALUE_TAG));\n                }\n            } catch (CheckstylePluginException e) {\n                throw new SAXException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                try {\n                    ICheckConfiguration checkConfig = new CheckConfiguration(mCurrentName, mCurrentLocation, mCurrentDescription, mCurrentConfigType, false, mResolvableProperties, mCurrentAddValues);\n                    mCheckConfigs.add(checkConfig);\n                } catch (Exception e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationFactory_0Test.java",
		"test_prompt": "// ProjectConfigurationFactory_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationFactory}.\n* It contains ten unit test cases for the {@link ProjectConfigurationFactory#getConfiguration(IProject)} method.\n*/\nclass ProjectConfigurationFactory_0Test {"
	},
	{
		"original_code": "// ProjectConfigurationFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Used to manage the life cycle of FileSet objects.\n */\npublic final class ProjectConfigurationFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    //$NON-NLS-1$\n    static final String PROJECT_CONFIGURATION_FILE = \".checkstyle\";\n\n    //$NON-NLS-1$\n    static final String CURRENT_FILE_FORMAT_VERSION = \"1.2.0\";\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    private ProjectConfigurationFactory() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get the <code>ProjectConfiguration</code> object for the specified\n     * project.\n     *\n     * @param project The project to get <code>FileSet</code>'s for.\n     * @return The <code>ProjectConfiguration</code> instance.\n     * @throws CheckstylePluginException Error during processing.\n     */\n    public static IProjectConfiguration getConfiguration(IProject project) throws CheckstylePluginException {\n        return loadFromPersistence(project);\n    }\n\n    /**\n     * Check to see if a check configuration is currently in use by any\n     * projects.\n     *\n     * @param checkConfig The check configuration to check for.\n     * @return <code>true</code>= in use, <code>false</code>= not in use.\n     * @throws CheckstylePluginException Error during processing.\n     */\n    public static boolean isCheckConfigInUse(ICheckConfiguration checkConfig) throws CheckstylePluginException {\n        return getProjectsUsingConfig(checkConfig).size() > 0;\n    }\n\n    /**\n     * Returns a list of projects using this check configuration.\n     *\n     * @param checkConfig the check configuration\n     * @return the list of projects using this configuration\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public static List getProjectsUsingConfig(ICheckConfiguration checkConfig) throws CheckstylePluginException {\n        List result = new ArrayList();\n        IWorkspace workspace = ResourcesPlugin.getWorkspace();\n        IProject[] projects = workspace.getRoot().getProjects();\n        for (int i = 0; (i < projects.length); i++) {\n            if (ProjectConfigurationFactory.getConfiguration(projects[i]).isConfigInUse(checkConfig)) {\n                result.add(projects[i]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Load the audit configurations from the persistent state storage.\n     */\n    private static IProjectConfiguration loadFromPersistence(IProject project) throws CheckstylePluginException {\n        IProjectConfiguration configuration = null;\n        //\n        // Make sure the files exists, it might not.\n        //\n        IFile file = project.getFile(PROJECT_CONFIGURATION_FILE);\n        boolean exists = file.exists();\n        if (!exists) {\n            FileSet standardFileSet = new FileSet(Messages.SimpleFileSetsEditor_nameAllFileset, CheckConfigurationFactory.getDefaultCheckConfiguration());\n            standardFileSet.getFileMatchPatterns().add(new FileMatchPattern(\".*\"));\n            List fileSets = Arrays.asList(new Object[] { standardFileSet });\n            return new ProjectConfiguration(project, null, fileSets, null, true);\n        }\n        InputStream inStream = null;\n        try {\n            inStream = file.getContents(true);\n            ProjectConfigFileHandler handler = new ProjectConfigFileHandler(project);\n            XMLUtil.parseWithSAX(inStream, handler);\n            configuration = handler.getConfiguration();\n        } catch (CoreException ce) {\n            CheckstylePluginException.rethrow(ce);\n        } catch (SAXException se) {\n            Exception ex = se.getException() != null ? se.getException() : se;\n            CheckstylePluginException.rethrow(ex);\n        } catch (ParserConfigurationException pe) {\n            CheckstylePluginException.rethrow(pe);\n        } catch (IOException ioe) {\n            CheckstylePluginException.rethrow(ioe);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n        }\n        return configuration;\n    }\n\n    /**\n     * Sax-Handler for parsing the checkstyle plugin project configuration file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class ProjectConfigFileHandler extends DefaultHandler {\n\n        //\n        // constants\n        //\n        /**\n         * constant list of supported file versions.\n         */\n        private static final List SUPPORTED_VERSIONS = Arrays.asList(new String[] { //$NON-NLS-1$ //$NON-NLS-2$\n        \"1.0.0\", //$NON-NLS-1$ //$NON-NLS-2$\n        \"1.1.0\", CURRENT_FILE_FORMAT_VERSION });\n\n        //\n        // attributes\n        //\n        /**\n         * The project.\n         */\n        private IProject mProject;\n\n        /**\n         * the file set currently built.\n         */\n        private FileSet mCurrentFileSet;\n\n        /**\n         * the current filter.\n         */\n        private IFilter mCurrentFilter;\n\n        /**\n         * The name of the current check configuration.\n         */\n        private String mCurrentName;\n\n        /**\n         * The location of the current check configuration.\n         */\n        private String mCurrentLocation;\n\n        /**\n         * The description of the current check configuration.\n         */\n        private String mCurrentDescription;\n\n        /**\n         * The configuration type of the current configuration.\n         */\n        private IConfigurationType mCurrentConfigType;\n\n        /**\n         * if the project configuration uses simple configuration.\n         */\n        private boolean mUseSimpleConfig;\n\n        /**\n         * The list of configurations.\n         */\n        private List mCheckConfigs;\n\n        /**\n         * The list of file sets.\n         */\n        private List mFileSets;\n\n        /**\n         * The filters.\n         */\n        private List mFilters;\n\n        /**\n         * Additional data for the current configuration.\n         */\n        private Map mCurrentAddValues;\n\n        /**\n         * List of resolvable properties for the current configuration.\n         */\n        private List mResolvableProperties;\n\n        //\n        // constructors\n        //\n        public ProjectConfigFileHandler(IProject project) {\n            mProject = project;\n        }\n\n        //\n        // methods\n        //\n        /**\n         * Returns the project configuration.\n         *\n         * @return the project configuration\n         */\n        public IProjectConfiguration getConfiguration() {\n            return new ProjectConfiguration(mProject, mCheckConfigs, mFileSets, mFilters, mUseSimpleConfig);\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,\n         *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            try {\n                if (XMLTags.FILESET_CONFIG_TAG.equals(qName)) {\n                    String version = attributes.getValue(XMLTags.FORMAT_VERSION_TAG);\n                    if (!SUPPORTED_VERSIONS.contains(version)) {\n                        throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorUnknownFileFormat, version));\n                    }\n                    mUseSimpleConfig = Boolean.valueOf(attributes.getValue(XMLTags.SIMPLE_CONFIG_TAG)).booleanValue();\n                    mCheckConfigs = new ArrayList();\n                    mFileSets = new ArrayList();\n                    mFilters = new ArrayList();\n                } else if (XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                    mCurrentName = attributes.getValue(XMLTags.NAME_TAG);\n                    mCurrentDescription = attributes.getValue(XMLTags.DESCRIPTION_TAG);\n                    mCurrentLocation = attributes.getValue(XMLTags.LOCATION_TAG);\n                    String type = attributes.getValue(XMLTags.TYPE_TAG);\n                    mCurrentConfigType = ConfigurationTypes.getByInternalName(type);\n                    if (mCurrentConfigType instanceof ProjectConfigurationType) {\n                        // RFE 1420212\n                        // treat config files relative to *THIS* project\n                        IWorkspaceRoot root = mProject.getWorkspace().getRoot();\n                        // test if the location contains the project name\n                        if (root.findMember(mCurrentLocation) == null) {\n                            mCurrentLocation = mProject.getFullPath().append(mCurrentLocation).toString();\n                        }\n                    }\n                    mCurrentAddValues = new HashMap();\n                    mResolvableProperties = new ArrayList();\n                } else if (XMLTags.ADDITIONAL_DATA_TAG.equalsIgnoreCase(qName)) {\n                    mCurrentAddValues.put(attributes.getValue(XMLTags.NAME_TAG), attributes.getValue(XMLTags.VALUE_TAG));\n                } else if (XMLTags.PROPERTY_TAG.equals(qName)) {\n                    String name = attributes.getValue(XMLTags.NAME_TAG);\n                    String value = attributes.getValue(XMLTags.VALUE_TAG);\n                    ResolvableProperty prop = new ResolvableProperty(name, value);\n                    mResolvableProperties.add(prop);\n                } else if (XMLTags.FILESET_TAG.equals(qName)) {\n                    String name = attributes.getValue(XMLTags.CHECK_CONFIG_NAME_TAG);\n                    boolean local = Boolean.valueOf(attributes.getValue(XMLTags.LOCAL_TAG)).booleanValue();\n                    mCurrentFileSet = new FileSet();\n                    mCurrentFileSet.setName(attributes.getValue(XMLTags.NAME_TAG));\n                    mCurrentFileSet.setEnabled(Boolean.valueOf(attributes.getValue(XMLTags.ENABLED_TAG)).booleanValue());\n                    ICheckConfiguration checkConfig = null;\n                    if (local) {\n                        Iterator it = mCheckConfigs.iterator();\n                        while (it.hasNext()) {\n                            ICheckConfiguration tmp = (ICheckConfiguration) it.next();\n                            if (tmp.getName().equals(name)) {\n                                checkConfig = tmp;\n                            }\n                        }\n                    } else {\n                        checkConfig = CheckConfigurationFactory.getByName(name);\n                    }\n                    mCurrentFileSet.setCheckConfig(checkConfig);\n                    // set an empty list for the patterns to store\n                    mCurrentFileSet.setFileMatchPatterns(new ArrayList());\n                    mFileSets.add(mCurrentFileSet);\n                } else if (XMLTags.FILE_MATCH_PATTERN_TAG.equals(qName)) {\n                    FileMatchPattern pattern = new FileMatchPattern(attributes.getValue(XMLTags.MATCH_PATTERN_TAG));\n                    pattern.setIsIncludePattern(Boolean.valueOf(attributes.getValue(XMLTags.INCLUDE_PATTERN_TAG)).booleanValue());\n                    mCurrentFileSet.getFileMatchPatterns().add(pattern);\n                } else if (XMLTags.FILTER_TAG.equals(qName)) {\n                    mCurrentFilter = PluginFilters.getByInternalName(attributes.getValue(XMLTags.NAME_TAG));\n                    if (mCurrentFilter != null) {\n                        mCurrentFilter.setEnabled(Boolean.valueOf(attributes.getValue(XMLTags.ENABLED_TAG)).booleanValue());\n                        // set an empty list for the filter data\n                        mCurrentFilter.setFilterData(new ArrayList());\n                        mFilters.add(mCurrentFilter);\n                    }\n                } else if (XMLTags.FILTER_DATA_TAG.equals(qName) && mCurrentFilter != null) {\n                    mCurrentFilter.getFilterData().add(attributes.getValue(XMLTags.VALUE_TAG));\n                }\n            } catch (CheckstylePluginException e) {\n                throw new SAXException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                try {\n                    ICheckConfiguration checkConfig = new CheckConfiguration(mCurrentName, mCurrentLocation, mCurrentDescription, mCurrentConfigType, false, mResolvableProperties, mCurrentAddValues);\n                    mCheckConfigs.add(checkConfig);\n                } catch (Exception e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationFactory_1Test.java",
		"test_prompt": "// ProjectConfigurationFactory_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationFactory}.\n* It contains ten unit test cases for the {@link ProjectConfigurationFactory#isCheckConfigInUse(ICheckConfiguration)} method.\n*/\nclass ProjectConfigurationFactory_1Test {"
	},
	{
		"original_code": "// ProjectConfigurationFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * Used to manage the life cycle of FileSet objects.\n */\npublic final class ProjectConfigurationFactory {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    //$NON-NLS-1$\n    static final String PROJECT_CONFIGURATION_FILE = \".checkstyle\";\n\n    //$NON-NLS-1$\n    static final String CURRENT_FILE_FORMAT_VERSION = \"1.2.0\";\n\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    private ProjectConfigurationFactory() {\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Get the <code>ProjectConfiguration</code> object for the specified\n     * project.\n     *\n     * @param project The project to get <code>FileSet</code>'s for.\n     * @return The <code>ProjectConfiguration</code> instance.\n     * @throws CheckstylePluginException Error during processing.\n     */\n    public static IProjectConfiguration getConfiguration(IProject project) throws CheckstylePluginException {\n        return loadFromPersistence(project);\n    }\n\n    /**\n     * Check to see if a check configuration is currently in use by any\n     * projects.\n     *\n     * @param checkConfig The check configuration to check for.\n     * @return <code>true</code>= in use, <code>false</code>= not in use.\n     * @throws CheckstylePluginException Error during processing.\n     */\n    public static boolean isCheckConfigInUse(ICheckConfiguration checkConfig) throws CheckstylePluginException {\n        return getProjectsUsingConfig(checkConfig).size() > 0;\n    }\n\n    /**\n     * Returns a list of projects using this check configuration.\n     *\n     * @param checkConfig the check configuration\n     * @return the list of projects using this configuration\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public static List getProjectsUsingConfig(ICheckConfiguration checkConfig) throws CheckstylePluginException {\n        List result = new ArrayList();\n        IWorkspace workspace = ResourcesPlugin.getWorkspace();\n        IProject[] projects = workspace.getRoot().getProjects();\n        for (int i = 0; (i < projects.length); i++) {\n            if (ProjectConfigurationFactory.getConfiguration(projects[i]).isConfigInUse(checkConfig)) {\n                result.add(projects[i]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Load the audit configurations from the persistent state storage.\n     */\n    private static IProjectConfiguration loadFromPersistence(IProject project) throws CheckstylePluginException {\n        IProjectConfiguration configuration = null;\n        //\n        // Make sure the files exists, it might not.\n        //\n        IFile file = project.getFile(PROJECT_CONFIGURATION_FILE);\n        boolean exists = file.exists();\n        if (!exists) {\n            FileSet standardFileSet = new FileSet(Messages.SimpleFileSetsEditor_nameAllFileset, CheckConfigurationFactory.getDefaultCheckConfiguration());\n            standardFileSet.getFileMatchPatterns().add(new FileMatchPattern(\".*\"));\n            List fileSets = Arrays.asList(new Object[] { standardFileSet });\n            return new ProjectConfiguration(project, null, fileSets, null, true);\n        }\n        InputStream inStream = null;\n        try {\n            inStream = file.getContents(true);\n            ProjectConfigFileHandler handler = new ProjectConfigFileHandler(project);\n            XMLUtil.parseWithSAX(inStream, handler);\n            configuration = handler.getConfiguration();\n        } catch (CoreException ce) {\n            CheckstylePluginException.rethrow(ce);\n        } catch (SAXException se) {\n            Exception ex = se.getException() != null ? se.getException() : se;\n            CheckstylePluginException.rethrow(ex);\n        } catch (ParserConfigurationException pe) {\n            CheckstylePluginException.rethrow(pe);\n        } catch (IOException ioe) {\n            CheckstylePluginException.rethrow(ioe);\n        } finally {\n            IOUtils.closeQuietly(inStream);\n        }\n        return configuration;\n    }\n\n    /**\n     * Sax-Handler for parsing the checkstyle plugin project configuration file.\n     *\n     * @author Lars K�dderitzsch\n     */\n    private static class ProjectConfigFileHandler extends DefaultHandler {\n\n        //\n        // constants\n        //\n        /**\n         * constant list of supported file versions.\n         */\n        private static final List SUPPORTED_VERSIONS = Arrays.asList(new String[] { //$NON-NLS-1$ //$NON-NLS-2$\n        \"1.0.0\", //$NON-NLS-1$ //$NON-NLS-2$\n        \"1.1.0\", CURRENT_FILE_FORMAT_VERSION });\n\n        //\n        // attributes\n        //\n        /**\n         * The project.\n         */\n        private IProject mProject;\n\n        /**\n         * the file set currently built.\n         */\n        private FileSet mCurrentFileSet;\n\n        /**\n         * the current filter.\n         */\n        private IFilter mCurrentFilter;\n\n        /**\n         * The name of the current check configuration.\n         */\n        private String mCurrentName;\n\n        /**\n         * The location of the current check configuration.\n         */\n        private String mCurrentLocation;\n\n        /**\n         * The description of the current check configuration.\n         */\n        private String mCurrentDescription;\n\n        /**\n         * The configuration type of the current configuration.\n         */\n        private IConfigurationType mCurrentConfigType;\n\n        /**\n         * if the project configuration uses simple configuration.\n         */\n        private boolean mUseSimpleConfig;\n\n        /**\n         * The list of configurations.\n         */\n        private List mCheckConfigs;\n\n        /**\n         * The list of file sets.\n         */\n        private List mFileSets;\n\n        /**\n         * The filters.\n         */\n        private List mFilters;\n\n        /**\n         * Additional data for the current configuration.\n         */\n        private Map mCurrentAddValues;\n\n        /**\n         * List of resolvable properties for the current configuration.\n         */\n        private List mResolvableProperties;\n\n        //\n        // constructors\n        //\n        public ProjectConfigFileHandler(IProject project) {\n            mProject = project;\n        }\n\n        //\n        // methods\n        //\n        /**\n         * Returns the project configuration.\n         *\n         * @return the project configuration\n         */\n        public IProjectConfiguration getConfiguration() {\n            return new ProjectConfiguration(mProject, mCheckConfigs, mFileSets, mFilters, mUseSimpleConfig);\n        }\n\n        /**\n         * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String,\n         *      java.lang.String, java.lang.String, org.xml.sax.Attributes)\n         */\n        public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {\n            try {\n                if (XMLTags.FILESET_CONFIG_TAG.equals(qName)) {\n                    String version = attributes.getValue(XMLTags.FORMAT_VERSION_TAG);\n                    if (!SUPPORTED_VERSIONS.contains(version)) {\n                        throw new CheckstylePluginException(NLS.bind(ErrorMessages.errorUnknownFileFormat, version));\n                    }\n                    mUseSimpleConfig = Boolean.valueOf(attributes.getValue(XMLTags.SIMPLE_CONFIG_TAG)).booleanValue();\n                    mCheckConfigs = new ArrayList();\n                    mFileSets = new ArrayList();\n                    mFilters = new ArrayList();\n                } else if (XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                    mCurrentName = attributes.getValue(XMLTags.NAME_TAG);\n                    mCurrentDescription = attributes.getValue(XMLTags.DESCRIPTION_TAG);\n                    mCurrentLocation = attributes.getValue(XMLTags.LOCATION_TAG);\n                    String type = attributes.getValue(XMLTags.TYPE_TAG);\n                    mCurrentConfigType = ConfigurationTypes.getByInternalName(type);\n                    if (mCurrentConfigType instanceof ProjectConfigurationType) {\n                        // RFE 1420212\n                        // treat config files relative to *THIS* project\n                        IWorkspaceRoot root = mProject.getWorkspace().getRoot();\n                        // test if the location contains the project name\n                        if (root.findMember(mCurrentLocation) == null) {\n                            mCurrentLocation = mProject.getFullPath().append(mCurrentLocation).toString();\n                        }\n                    }\n                    mCurrentAddValues = new HashMap();\n                    mResolvableProperties = new ArrayList();\n                } else if (XMLTags.ADDITIONAL_DATA_TAG.equalsIgnoreCase(qName)) {\n                    mCurrentAddValues.put(attributes.getValue(XMLTags.NAME_TAG), attributes.getValue(XMLTags.VALUE_TAG));\n                } else if (XMLTags.PROPERTY_TAG.equals(qName)) {\n                    String name = attributes.getValue(XMLTags.NAME_TAG);\n                    String value = attributes.getValue(XMLTags.VALUE_TAG);\n                    ResolvableProperty prop = new ResolvableProperty(name, value);\n                    mResolvableProperties.add(prop);\n                } else if (XMLTags.FILESET_TAG.equals(qName)) {\n                    String name = attributes.getValue(XMLTags.CHECK_CONFIG_NAME_TAG);\n                    boolean local = Boolean.valueOf(attributes.getValue(XMLTags.LOCAL_TAG)).booleanValue();\n                    mCurrentFileSet = new FileSet();\n                    mCurrentFileSet.setName(attributes.getValue(XMLTags.NAME_TAG));\n                    mCurrentFileSet.setEnabled(Boolean.valueOf(attributes.getValue(XMLTags.ENABLED_TAG)).booleanValue());\n                    ICheckConfiguration checkConfig = null;\n                    if (local) {\n                        Iterator it = mCheckConfigs.iterator();\n                        while (it.hasNext()) {\n                            ICheckConfiguration tmp = (ICheckConfiguration) it.next();\n                            if (tmp.getName().equals(name)) {\n                                checkConfig = tmp;\n                            }\n                        }\n                    } else {\n                        checkConfig = CheckConfigurationFactory.getByName(name);\n                    }\n                    mCurrentFileSet.setCheckConfig(checkConfig);\n                    // set an empty list for the patterns to store\n                    mCurrentFileSet.setFileMatchPatterns(new ArrayList());\n                    mFileSets.add(mCurrentFileSet);\n                } else if (XMLTags.FILE_MATCH_PATTERN_TAG.equals(qName)) {\n                    FileMatchPattern pattern = new FileMatchPattern(attributes.getValue(XMLTags.MATCH_PATTERN_TAG));\n                    pattern.setIsIncludePattern(Boolean.valueOf(attributes.getValue(XMLTags.INCLUDE_PATTERN_TAG)).booleanValue());\n                    mCurrentFileSet.getFileMatchPatterns().add(pattern);\n                } else if (XMLTags.FILTER_TAG.equals(qName)) {\n                    mCurrentFilter = PluginFilters.getByInternalName(attributes.getValue(XMLTags.NAME_TAG));\n                    if (mCurrentFilter != null) {\n                        mCurrentFilter.setEnabled(Boolean.valueOf(attributes.getValue(XMLTags.ENABLED_TAG)).booleanValue());\n                        // set an empty list for the filter data\n                        mCurrentFilter.setFilterData(new ArrayList());\n                        mFilters.add(mCurrentFilter);\n                    }\n                } else if (XMLTags.FILTER_DATA_TAG.equals(qName) && mCurrentFilter != null) {\n                    mCurrentFilter.getFilterData().add(attributes.getValue(XMLTags.VALUE_TAG));\n                }\n            } catch (CheckstylePluginException e) {\n                throw new SAXException(e);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        public void endElement(String uri, String localName, String qName) throws SAXException {\n            if (XMLTags.CHECK_CONFIG_TAG.equals(qName)) {\n                try {\n                    ICheckConfiguration checkConfig = new CheckConfiguration(mCurrentName, mCurrentLocation, mCurrentDescription, mCurrentConfigType, false, mResolvableProperties, mCurrentAddValues);\n                    mCheckConfigs.add(checkConfig);\n                } catch (Exception e) {\n                    throw new SAXException(e);\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationFactory_2Test.java",
		"test_prompt": "// ProjectConfigurationFactory_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IWorkspace;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ConfigurationTypes;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationFactory}.\n* It contains ten unit test cases for the {@link ProjectConfigurationFactory#getProjectsUsingConfig(ICheckConfiguration)} method.\n*/\nclass ProjectConfigurationFactory_2Test {"
	},
	{
		"original_code": "// ProjectConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\n\n/**\n * Represents the configuration for a project. Contains the file sets configured\n * for the project plus the additional filters.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfiguration implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The project.\n     */\n    private IProject mProject;\n\n    /**\n     * The local check configurations.\n     */\n    private List mLocalCheckConfigs;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets;\n\n    /**\n     * the filters.\n     */\n    private List mFilters;\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig = true;\n\n    //\n    // constructors\n    //\n    /**\n     * Default constructor.\n     *\n     * @param project the project\n     * @param localConfigs the list of local check configurations\n     * @param fileSets the list of configured file sets\n     * @param filters the filters\n     * @param useSimpleConfig <code>true</code> if simple configuration is\n     *            used\n     */\n    public ProjectConfiguration(IProject project, List localConfigs, List fileSets, List filters, boolean useSimpleConfig) {\n        mProject = project;\n        mLocalCheckConfigs = localConfigs != null ? Collections.unmodifiableList(localConfigs) : Collections.unmodifiableList(new ArrayList());\n        mFileSets = fileSets != null ? Collections.unmodifiableList(fileSets) : Collections.unmodifiableList(new ArrayList());\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        if (filters != null) {\n            // merge with filters configured for the project\n            for (int i = 0, size = mFilters.size(); i < size; i++) {\n                IFilter standardFilter = (IFilter) mFilters.get(i);\n                for (int j = 0, size2 = filters.size(); j < size2; j++) {\n                    IFilter configuredFilter = (IFilter) filters.get(j);\n                    if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                        mFilters.set(i, configuredFilter);\n                    }\n                }\n            }\n        }\n        mFilters = Collections.unmodifiableList(mFilters);\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProject;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return mLocalCheckConfigs;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * Checks if this project configuration uses the given checkstyle\n     * configuration.\n     *\n     * @param configuration the check configuration\n     * @return <code>true</code>, if the project config uses the checkstyle\n     *         config, <code>false</code> otherwise\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfiguration clone = null;\n        try {\n            clone = (ProjectConfiguration) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.mUseSimpleConfig = mUseSimpleConfig;\n            // clone file sets\n            List clonedFileSets = new ArrayList();\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clonedFileSets.add(((FileSet) iter.next()).clone());\n            }\n            clone.mFileSets = clonedFileSets;\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ProjectConfiguration rhs = (ProjectConfiguration) obj;\n        return new EqualsBuilder().append(mProject, rhs.mProject).append(mLocalCheckConfigs, rhs.mLocalCheckConfigs).append(mUseSimpleConfig, rhs.mUseSimpleConfig).append(mFileSets, rhs.mFileSets).append(mFilters, rhs.mFilters).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProject).append(mLocalCheckConfigs).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfiguration_0Test.java",
		"test_prompt": "// ProjectConfiguration_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfiguration}.\n* It contains ten unit test cases for the {@link ProjectConfiguration#isUseSimpleConfig()} method.\n*/\nclass ProjectConfiguration_0Test {"
	},
	{
		"original_code": "// ProjectConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\n\n/**\n * Represents the configuration for a project. Contains the file sets configured\n * for the project plus the additional filters.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfiguration implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The project.\n     */\n    private IProject mProject;\n\n    /**\n     * The local check configurations.\n     */\n    private List mLocalCheckConfigs;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets;\n\n    /**\n     * the filters.\n     */\n    private List mFilters;\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig = true;\n\n    //\n    // constructors\n    //\n    /**\n     * Default constructor.\n     *\n     * @param project the project\n     * @param localConfigs the list of local check configurations\n     * @param fileSets the list of configured file sets\n     * @param filters the filters\n     * @param useSimpleConfig <code>true</code> if simple configuration is\n     *            used\n     */\n    public ProjectConfiguration(IProject project, List localConfigs, List fileSets, List filters, boolean useSimpleConfig) {\n        mProject = project;\n        mLocalCheckConfigs = localConfigs != null ? Collections.unmodifiableList(localConfigs) : Collections.unmodifiableList(new ArrayList());\n        mFileSets = fileSets != null ? Collections.unmodifiableList(fileSets) : Collections.unmodifiableList(new ArrayList());\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        if (filters != null) {\n            // merge with filters configured for the project\n            for (int i = 0, size = mFilters.size(); i < size; i++) {\n                IFilter standardFilter = (IFilter) mFilters.get(i);\n                for (int j = 0, size2 = filters.size(); j < size2; j++) {\n                    IFilter configuredFilter = (IFilter) filters.get(j);\n                    if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                        mFilters.set(i, configuredFilter);\n                    }\n                }\n            }\n        }\n        mFilters = Collections.unmodifiableList(mFilters);\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProject;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return mLocalCheckConfigs;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * Checks if this project configuration uses the given checkstyle\n     * configuration.\n     *\n     * @param configuration the check configuration\n     * @return <code>true</code>, if the project config uses the checkstyle\n     *         config, <code>false</code> otherwise\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfiguration clone = null;\n        try {\n            clone = (ProjectConfiguration) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.mUseSimpleConfig = mUseSimpleConfig;\n            // clone file sets\n            List clonedFileSets = new ArrayList();\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clonedFileSets.add(((FileSet) iter.next()).clone());\n            }\n            clone.mFileSets = clonedFileSets;\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ProjectConfiguration rhs = (ProjectConfiguration) obj;\n        return new EqualsBuilder().append(mProject, rhs.mProject).append(mLocalCheckConfigs, rhs.mLocalCheckConfigs).append(mUseSimpleConfig, rhs.mUseSimpleConfig).append(mFileSets, rhs.mFileSets).append(mFilters, rhs.mFilters).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProject).append(mLocalCheckConfigs).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfiguration_1Test.java",
		"test_prompt": "// ProjectConfiguration_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfiguration}.\n* It contains ten unit test cases for the {@link ProjectConfiguration#isConfigInUse(ICheckConfiguration)} method.\n*/\nclass ProjectConfiguration_1Test {"
	},
	{
		"original_code": "// ProjectConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\n\n/**\n * Represents the configuration for a project. Contains the file sets configured\n * for the project plus the additional filters.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfiguration implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The project.\n     */\n    private IProject mProject;\n\n    /**\n     * The local check configurations.\n     */\n    private List mLocalCheckConfigs;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets;\n\n    /**\n     * the filters.\n     */\n    private List mFilters;\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig = true;\n\n    //\n    // constructors\n    //\n    /**\n     * Default constructor.\n     *\n     * @param project the project\n     * @param localConfigs the list of local check configurations\n     * @param fileSets the list of configured file sets\n     * @param filters the filters\n     * @param useSimpleConfig <code>true</code> if simple configuration is\n     *            used\n     */\n    public ProjectConfiguration(IProject project, List localConfigs, List fileSets, List filters, boolean useSimpleConfig) {\n        mProject = project;\n        mLocalCheckConfigs = localConfigs != null ? Collections.unmodifiableList(localConfigs) : Collections.unmodifiableList(new ArrayList());\n        mFileSets = fileSets != null ? Collections.unmodifiableList(fileSets) : Collections.unmodifiableList(new ArrayList());\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        if (filters != null) {\n            // merge with filters configured for the project\n            for (int i = 0, size = mFilters.size(); i < size; i++) {\n                IFilter standardFilter = (IFilter) mFilters.get(i);\n                for (int j = 0, size2 = filters.size(); j < size2; j++) {\n                    IFilter configuredFilter = (IFilter) filters.get(j);\n                    if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                        mFilters.set(i, configuredFilter);\n                    }\n                }\n            }\n        }\n        mFilters = Collections.unmodifiableList(mFilters);\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProject;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return mLocalCheckConfigs;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * Checks if this project configuration uses the given checkstyle\n     * configuration.\n     *\n     * @param configuration the check configuration\n     * @return <code>true</code>, if the project config uses the checkstyle\n     *         config, <code>false</code> otherwise\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfiguration clone = null;\n        try {\n            clone = (ProjectConfiguration) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.mUseSimpleConfig = mUseSimpleConfig;\n            // clone file sets\n            List clonedFileSets = new ArrayList();\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clonedFileSets.add(((FileSet) iter.next()).clone());\n            }\n            clone.mFileSets = clonedFileSets;\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ProjectConfiguration rhs = (ProjectConfiguration) obj;\n        return new EqualsBuilder().append(mProject, rhs.mProject).append(mLocalCheckConfigs, rhs.mLocalCheckConfigs).append(mUseSimpleConfig, rhs.mUseSimpleConfig).append(mFileSets, rhs.mFileSets).append(mFilters, rhs.mFilters).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProject).append(mLocalCheckConfigs).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfiguration_2Test.java",
		"test_prompt": "// ProjectConfiguration_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfiguration}.\n* It contains ten unit test cases for the {@link ProjectConfiguration#clone()} method.\n*/\nclass ProjectConfiguration_2Test {"
	},
	{
		"original_code": "// ProjectConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\n\n/**\n * Represents the configuration for a project. Contains the file sets configured\n * for the project plus the additional filters.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfiguration implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The project.\n     */\n    private IProject mProject;\n\n    /**\n     * The local check configurations.\n     */\n    private List mLocalCheckConfigs;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets;\n\n    /**\n     * the filters.\n     */\n    private List mFilters;\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig = true;\n\n    //\n    // constructors\n    //\n    /**\n     * Default constructor.\n     *\n     * @param project the project\n     * @param localConfigs the list of local check configurations\n     * @param fileSets the list of configured file sets\n     * @param filters the filters\n     * @param useSimpleConfig <code>true</code> if simple configuration is\n     *            used\n     */\n    public ProjectConfiguration(IProject project, List localConfigs, List fileSets, List filters, boolean useSimpleConfig) {\n        mProject = project;\n        mLocalCheckConfigs = localConfigs != null ? Collections.unmodifiableList(localConfigs) : Collections.unmodifiableList(new ArrayList());\n        mFileSets = fileSets != null ? Collections.unmodifiableList(fileSets) : Collections.unmodifiableList(new ArrayList());\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        if (filters != null) {\n            // merge with filters configured for the project\n            for (int i = 0, size = mFilters.size(); i < size; i++) {\n                IFilter standardFilter = (IFilter) mFilters.get(i);\n                for (int j = 0, size2 = filters.size(); j < size2; j++) {\n                    IFilter configuredFilter = (IFilter) filters.get(j);\n                    if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                        mFilters.set(i, configuredFilter);\n                    }\n                }\n            }\n        }\n        mFilters = Collections.unmodifiableList(mFilters);\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProject;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return mLocalCheckConfigs;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * Checks if this project configuration uses the given checkstyle\n     * configuration.\n     *\n     * @param configuration the check configuration\n     * @return <code>true</code>, if the project config uses the checkstyle\n     *         config, <code>false</code> otherwise\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfiguration clone = null;\n        try {\n            clone = (ProjectConfiguration) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.mUseSimpleConfig = mUseSimpleConfig;\n            // clone file sets\n            List clonedFileSets = new ArrayList();\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clonedFileSets.add(((FileSet) iter.next()).clone());\n            }\n            clone.mFileSets = clonedFileSets;\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ProjectConfiguration rhs = (ProjectConfiguration) obj;\n        return new EqualsBuilder().append(mProject, rhs.mProject).append(mLocalCheckConfigs, rhs.mLocalCheckConfigs).append(mUseSimpleConfig, rhs.mUseSimpleConfig).append(mFileSets, rhs.mFileSets).append(mFilters, rhs.mFilters).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProject).append(mLocalCheckConfigs).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfiguration_3Test.java",
		"test_prompt": "// ProjectConfiguration_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfiguration}.\n* It contains ten unit test cases for the {@link ProjectConfiguration#equals(Object)} method.\n*/\nclass ProjectConfiguration_3Test {"
	},
	{
		"original_code": "// ProjectConfiguration.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\n\n/**\n * Represents the configuration for a project. Contains the file sets configured\n * for the project plus the additional filters.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfiguration implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The project.\n     */\n    private IProject mProject;\n\n    /**\n     * The local check configurations.\n     */\n    private List mLocalCheckConfigs;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets;\n\n    /**\n     * the filters.\n     */\n    private List mFilters;\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig = true;\n\n    //\n    // constructors\n    //\n    /**\n     * Default constructor.\n     *\n     * @param project the project\n     * @param localConfigs the list of local check configurations\n     * @param fileSets the list of configured file sets\n     * @param filters the filters\n     * @param useSimpleConfig <code>true</code> if simple configuration is\n     *            used\n     */\n    public ProjectConfiguration(IProject project, List localConfigs, List fileSets, List filters, boolean useSimpleConfig) {\n        mProject = project;\n        mLocalCheckConfigs = localConfigs != null ? Collections.unmodifiableList(localConfigs) : Collections.unmodifiableList(new ArrayList());\n        mFileSets = fileSets != null ? Collections.unmodifiableList(fileSets) : Collections.unmodifiableList(new ArrayList());\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        if (filters != null) {\n            // merge with filters configured for the project\n            for (int i = 0, size = mFilters.size(); i < size; i++) {\n                IFilter standardFilter = (IFilter) mFilters.get(i);\n                for (int j = 0, size2 = filters.size(); j < size2; j++) {\n                    IFilter configuredFilter = (IFilter) filters.get(j);\n                    if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                        mFilters.set(i, configuredFilter);\n                    }\n                }\n            }\n        }\n        mFilters = Collections.unmodifiableList(mFilters);\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProject;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return mLocalCheckConfigs;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * Checks if this project configuration uses the given checkstyle\n     * configuration.\n     *\n     * @param configuration the check configuration\n     * @return <code>true</code>, if the project config uses the checkstyle\n     *         config, <code>false</code> otherwise\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfiguration clone = null;\n        try {\n            clone = (ProjectConfiguration) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.mUseSimpleConfig = mUseSimpleConfig;\n            // clone file sets\n            List clonedFileSets = new ArrayList();\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clonedFileSets.add(((FileSet) iter.next()).clone());\n            }\n            clone.mFileSets = clonedFileSets;\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof ProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        ProjectConfiguration rhs = (ProjectConfiguration) obj;\n        return new EqualsBuilder().append(mProject, rhs.mProject).append(mLocalCheckConfigs, rhs.mLocalCheckConfigs).append(mUseSimpleConfig, rhs.mUseSimpleConfig).append(mFileSets, rhs.mFileSets).append(mFilters, rhs.mFilters).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProject).append(mLocalCheckConfigs).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfiguration_4Test.java",
		"test_prompt": "// ProjectConfiguration_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport org.eclipse.core.resources.IProject;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfiguration}.\n* It contains ten unit test cases for the {@link ProjectConfiguration#hashCode()} method.\n*/\nclass ProjectConfiguration_4Test {"
	},
	{
		"original_code": "// ProjectConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * A modifiable project configuration implementation.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationWorkingCopy implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The original, unmodified project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The local check configurations.\n     */\n    private ICheckConfigurationWorkingSet mLocalConfigWorkingSet;\n\n    /**\n     * The global check configurations.\n     */\n    private ICheckConfigurationWorkingSet mGlobalConfigWorkingSet;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets = new LinkedList();\n\n    /**\n     * the filters.\n     */\n    private List mFilters = new LinkedList();\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working copy of a given project configuration.\n     *\n     * @param projectConfig the project configuration\n     */\n    public ProjectConfigurationWorkingCopy(IProjectConfiguration projectConfig) {\n        mProjectConfig = projectConfig;\n        mLocalConfigWorkingSet = new LocalCheckConfigurationWorkingSet(this, projectConfig.getLocalCheckConfigurations());\n        mGlobalConfigWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        // clone file sets of the original config\n        Iterator it = projectConfig.getFileSets().iterator();\n        while (it.hasNext()) {\n            mFileSets.add(((FileSet) it.next()).clone());\n        }\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        // merge with filters configured for the project\n        List configuredFilters = projectConfig.getFilters();\n        for (int i = 0, size = mFilters.size(); i < size; i++) {\n            IFilter standardFilter = (IFilter) mFilters.get(i);\n            for (int j = 0, size2 = configuredFilters.size(); j < size2; j++) {\n                IFilter configuredFilter = (IFilter) configuredFilters.get(j);\n                if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                    mFilters.set(i, configuredFilter.clone());\n                }\n            }\n        }\n        mUseSimpleConfig = projectConfig.isUseSimpleConfig();\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the check configuration working set for local configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getLocalCheckConfigWorkingSet() {\n        return mLocalConfigWorkingSet;\n    }\n\n    /**\n     * Returns the check configuration working set for global configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getGlobalCheckConfigWorkingSet() {\n        return mGlobalConfigWorkingSet;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getLocalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mLocalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getGlobalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mGlobalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Sets if the simple configuration should be used.\n     *\n     * @param useSimpleConfig true if the project uses the simple fileset\n     *            configuration\n     */\n    public void setUseSimpleConfig(boolean useSimpleConfig) {\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    /**\n     * Determines if the project configuration changed.\n     *\n     * @return <code>true</code> if changed\n     */\n    public boolean isDirty() {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.isDirty();\n    }\n\n    /**\n     * Determines if a rebuild is needed for the project of this project\n     * configuration. A rebuild is not needed when only some local config was\n     * added which is not used by the project.\n     *\n     * @return <code>true</code> if rebuild is needed.\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public boolean isRebuildNeeded() throws CheckstylePluginException {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.getAffectedProjects().contains(getProject()) || mGlobalConfigWorkingSet.getAffectedProjects().contains(getProject());\n    }\n\n    /**\n     * Stores the project configuration.\n     *\n     * @throws CheckstylePluginException error while storing the project\n     *             configuration\n     */\n    public void store() throws CheckstylePluginException {\n        storeToPersistence(this);\n    }\n\n    //\n    // implementation of IProjectConfiguration interface\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return Arrays.asList(mLocalConfigWorkingSet.getWorkingCopies());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfigurationWorkingCopy clone = null;\n        try {\n            clone = (ProjectConfigurationWorkingCopy) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.setUseSimpleConfig(this.isUseSimpleConfig());\n            // clone file sets\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clone.getFileSets().add(((FileSet) iter.next()).clone());\n            }\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof IProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        IProjectConfiguration rhs = (IProjectConfiguration) obj;\n        return new EqualsBuilder().append(getProject(), rhs.getProject()).append(isUseSimpleConfig(), rhs.isUseSimpleConfig()).append(getFileSets(), rhs.getFileSets()).append(getFilters(), rhs.getFilters()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProjectConfig).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * Store the audit configurations to the persistent state storage.\n     */\n    private void storeToPersistence(ProjectConfigurationWorkingCopy config) throws CheckstylePluginException {\n        ByteArrayOutputStream pipeOut = null;\n        InputStream pipeIn = null;\n        try {\n            pipeOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(pipeOut, null, null);\n            writeProjectConfig(config, xmlOut);\n            pipeIn = new ByteArrayInputStream(pipeOut.toByteArray());\n            // create or overwrite the .checkstyle file\n            IProject project = config.getProject();\n            IFile file = project.getFile(ProjectConfigurationFactory.PROJECT_CONFIGURATION_FILE);\n            if (!file.exists()) {\n                file.create(pipeIn, true, null);\n                file.setLocal(true, IResource.DEPTH_INFINITE, null);\n            } else {\n                file.setContents(pipeIn, true, true, null);\n            }\n            config.getLocalCheckConfigWorkingSet().store();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorWritingCheckConfigurations, e.getLocalizedMessage()));\n        } finally {\n            IOUtils.closeQuietly(pipeIn);\n            IOUtils.closeQuietly(pipeOut);\n        }\n    }\n\n    /**\n     * Produces the sax events to write a project configuration.\n     *\n     * @param config the configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeProjectConfig(ProjectConfigurationWorkingCopy config, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        xmlOut.startDocument();\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.FORMAT_VERSION_TAG, XMLTags.FORMAT_VERSION_TAG, emptyString, ProjectConfigurationFactory.CURRENT_FILE_FORMAT_VERSION);\n        attr.addAttribute(emptyString, XMLTags.SIMPLE_CONFIG_TAG, XMLTags.SIMPLE_CONFIG_TAG, emptyString, emptyString + config.isUseSimpleConfig());\n        xmlOut.startElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG, attr);\n        ICheckConfiguration[] workingCopies = config.getLocalCheckConfigWorkingSet().getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            writeLocalConfiguration(workingCopies[i], xmlOut);\n        }\n        List fileSets = config.getFileSets();\n        int size = fileSets != null ? fileSets.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFileSet((FileSet) fileSets.get(i), config.getProject(), xmlOut);\n        }\n        // write filters\n        List filters = config.getFilters();\n        size = filters != null ? filters.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFilter((IFilter) filters.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG);\n        xmlOut.endDocument();\n    }\n\n    /**\n     * Writes a local check configuration.\n     *\n     * @param checkConfig the local check configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     * @throws CheckstylePluginException\n     */\n    private void writeLocalConfiguration(ICheckConfiguration checkConfig, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        // TODO refactor to avoid code duplication with\n        // GlobalCheckConfigurationWorkingSet\n        // don't store built-in configurations to persistence or local\n        // configurations\n        if (checkConfig.getType() instanceof BuiltInConfigurationType || checkConfig.isGlobal()) {\n            return;\n        }\n        // RFE 1420212\n        String location = checkConfig.getLocation();\n        if (checkConfig.getType() instanceof ProjectConfigurationType) {\n            IProject project = mProjectConfig.getProject();\n            IWorkspaceRoot root = project.getWorkspace().getRoot();\n            IFile configFile = root.getFile(new Path(location));\n            IProject configFileProject = configFile.getProject();\n            // if the configuration is in *same* project don't store project\n            // path part\n            if (project.equals(configFileProject)) {\n                location = configFile.getProjectRelativePath().toString();\n            }\n        }\n        String emptyString = new String();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, checkConfig.getName());\n        attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, location);\n        attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, checkConfig.getType().getInternalName());\n        if (checkConfig.getDescription() != null) {\n            attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, checkConfig.getDescription());\n        }\n        xmlOut.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n        // Write resolvable properties\n        Iterator propsIterator = checkConfig.getResolvableProperties().iterator();\n        while (propsIterator.hasNext()) {\n            ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n            xmlOut.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n        }\n        Iterator addDataIterator = checkConfig.getAdditionalData().keySet().iterator();\n        while (addDataIterator.hasNext()) {\n            String key = (String) addDataIterator.next();\n            String value = (String) checkConfig.getAdditionalData().get(key);\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n            xmlOut.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a file set to xml.\n     *\n     * @param fileSet the file set\n     * @param project the project\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFileSet(FileSet fileSet, IProject project, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        if (fileSet.getCheckConfig() == null) {\n            throw new CheckstylePluginException(ErrorMessages.bind(ErrorMessages.errorFilesetWithoutCheckConfig, fileSet.getName(), project.getName()));\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, fileSet.getName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + fileSet.isEnabled());\n        ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n        if (checkConfig != null) {\n            attr.addAttribute(emptyString, XMLTags.CHECK_CONFIG_NAME_TAG, XMLTags.CHECK_CONFIG_NAME_TAG, emptyString, checkConfig.getName());\n            attr.addAttribute(emptyString, XMLTags.LOCAL_TAG, XMLTags.LOCAL_TAG, emptyString, emptyString + !checkConfig.isGlobal());\n        }\n        xmlOut.startElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG, attr);\n        // write patterns\n        List patterns = fileSet.getFileMatchPatterns();\n        int size = patterns != null ? patterns.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeMatchPattern((FileMatchPattern) patterns.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG);\n    }\n\n    /**\n     * Produces the sax events to write the file match pattern to xml.\n     *\n     * @param pattern the pattern\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeMatchPattern(FileMatchPattern pattern, TransformerHandler xmlOut) throws SAXException {\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.MATCH_PATTERN_TAG, XMLTags.MATCH_PATTERN_TAG, emptyString, pattern.getMatchPattern() != null ? pattern.getMatchPattern() : emptyString);\n        attr.addAttribute(emptyString, XMLTags.INCLUDE_PATTERN_TAG, XMLTags.INCLUDE_PATTERN_TAG, emptyString, emptyString + pattern.isIncludePattern());\n        xmlOut.startElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG, attr);\n        xmlOut.endElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a filter to xml.\n     *\n     * @param filter the filter\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFilter(IFilter filter, TransformerHandler xmlOut) throws SAXException {\n        // write only filters that are actually changed\n        // (enabled or contain data)\n        IFilter prototype = PluginFilters.getByInternalName(filter.getInternalName());\n        if (prototype.equals(filter)) {\n            return;\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, filter.getInternalName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + filter.isEnabled());\n        xmlOut.startElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG, attr);\n        List data = filter.getFilterData();\n        int size = data != null ? data.size() : 0;\n        for (int i = 0; i < size; i++) {\n            attr = new AttributesImpl();\n            attr.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, (String) data.get(i));\n            xmlOut.startElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG, attr);\n            xmlOut.endElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationWorkingCopy_0Test.java",
		"test_prompt": "// ProjectConfigurationWorkingCopy_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link ProjectConfigurationWorkingCopy#isDirty()} method.\n*/\nclass ProjectConfigurationWorkingCopy_0Test {"
	},
	{
		"original_code": "// ProjectConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * A modifiable project configuration implementation.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationWorkingCopy implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The original, unmodified project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The local check configurations.\n     */\n    private ICheckConfigurationWorkingSet mLocalConfigWorkingSet;\n\n    /**\n     * The global check configurations.\n     */\n    private ICheckConfigurationWorkingSet mGlobalConfigWorkingSet;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets = new LinkedList();\n\n    /**\n     * the filters.\n     */\n    private List mFilters = new LinkedList();\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working copy of a given project configuration.\n     *\n     * @param projectConfig the project configuration\n     */\n    public ProjectConfigurationWorkingCopy(IProjectConfiguration projectConfig) {\n        mProjectConfig = projectConfig;\n        mLocalConfigWorkingSet = new LocalCheckConfigurationWorkingSet(this, projectConfig.getLocalCheckConfigurations());\n        mGlobalConfigWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        // clone file sets of the original config\n        Iterator it = projectConfig.getFileSets().iterator();\n        while (it.hasNext()) {\n            mFileSets.add(((FileSet) it.next()).clone());\n        }\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        // merge with filters configured for the project\n        List configuredFilters = projectConfig.getFilters();\n        for (int i = 0, size = mFilters.size(); i < size; i++) {\n            IFilter standardFilter = (IFilter) mFilters.get(i);\n            for (int j = 0, size2 = configuredFilters.size(); j < size2; j++) {\n                IFilter configuredFilter = (IFilter) configuredFilters.get(j);\n                if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                    mFilters.set(i, configuredFilter.clone());\n                }\n            }\n        }\n        mUseSimpleConfig = projectConfig.isUseSimpleConfig();\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the check configuration working set for local configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getLocalCheckConfigWorkingSet() {\n        return mLocalConfigWorkingSet;\n    }\n\n    /**\n     * Returns the check configuration working set for global configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getGlobalCheckConfigWorkingSet() {\n        return mGlobalConfigWorkingSet;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getLocalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mLocalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getGlobalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mGlobalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Sets if the simple configuration should be used.\n     *\n     * @param useSimpleConfig true if the project uses the simple fileset\n     *            configuration\n     */\n    public void setUseSimpleConfig(boolean useSimpleConfig) {\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    /**\n     * Determines if the project configuration changed.\n     *\n     * @return <code>true</code> if changed\n     */\n    public boolean isDirty() {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.isDirty();\n    }\n\n    /**\n     * Determines if a rebuild is needed for the project of this project\n     * configuration. A rebuild is not needed when only some local config was\n     * added which is not used by the project.\n     *\n     * @return <code>true</code> if rebuild is needed.\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public boolean isRebuildNeeded() throws CheckstylePluginException {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.getAffectedProjects().contains(getProject()) || mGlobalConfigWorkingSet.getAffectedProjects().contains(getProject());\n    }\n\n    /**\n     * Stores the project configuration.\n     *\n     * @throws CheckstylePluginException error while storing the project\n     *             configuration\n     */\n    public void store() throws CheckstylePluginException {\n        storeToPersistence(this);\n    }\n\n    //\n    // implementation of IProjectConfiguration interface\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return Arrays.asList(mLocalConfigWorkingSet.getWorkingCopies());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfigurationWorkingCopy clone = null;\n        try {\n            clone = (ProjectConfigurationWorkingCopy) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.setUseSimpleConfig(this.isUseSimpleConfig());\n            // clone file sets\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clone.getFileSets().add(((FileSet) iter.next()).clone());\n            }\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof IProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        IProjectConfiguration rhs = (IProjectConfiguration) obj;\n        return new EqualsBuilder().append(getProject(), rhs.getProject()).append(isUseSimpleConfig(), rhs.isUseSimpleConfig()).append(getFileSets(), rhs.getFileSets()).append(getFilters(), rhs.getFilters()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProjectConfig).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * Store the audit configurations to the persistent state storage.\n     */\n    private void storeToPersistence(ProjectConfigurationWorkingCopy config) throws CheckstylePluginException {\n        ByteArrayOutputStream pipeOut = null;\n        InputStream pipeIn = null;\n        try {\n            pipeOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(pipeOut, null, null);\n            writeProjectConfig(config, xmlOut);\n            pipeIn = new ByteArrayInputStream(pipeOut.toByteArray());\n            // create or overwrite the .checkstyle file\n            IProject project = config.getProject();\n            IFile file = project.getFile(ProjectConfigurationFactory.PROJECT_CONFIGURATION_FILE);\n            if (!file.exists()) {\n                file.create(pipeIn, true, null);\n                file.setLocal(true, IResource.DEPTH_INFINITE, null);\n            } else {\n                file.setContents(pipeIn, true, true, null);\n            }\n            config.getLocalCheckConfigWorkingSet().store();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorWritingCheckConfigurations, e.getLocalizedMessage()));\n        } finally {\n            IOUtils.closeQuietly(pipeIn);\n            IOUtils.closeQuietly(pipeOut);\n        }\n    }\n\n    /**\n     * Produces the sax events to write a project configuration.\n     *\n     * @param config the configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeProjectConfig(ProjectConfigurationWorkingCopy config, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        xmlOut.startDocument();\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.FORMAT_VERSION_TAG, XMLTags.FORMAT_VERSION_TAG, emptyString, ProjectConfigurationFactory.CURRENT_FILE_FORMAT_VERSION);\n        attr.addAttribute(emptyString, XMLTags.SIMPLE_CONFIG_TAG, XMLTags.SIMPLE_CONFIG_TAG, emptyString, emptyString + config.isUseSimpleConfig());\n        xmlOut.startElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG, attr);\n        ICheckConfiguration[] workingCopies = config.getLocalCheckConfigWorkingSet().getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            writeLocalConfiguration(workingCopies[i], xmlOut);\n        }\n        List fileSets = config.getFileSets();\n        int size = fileSets != null ? fileSets.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFileSet((FileSet) fileSets.get(i), config.getProject(), xmlOut);\n        }\n        // write filters\n        List filters = config.getFilters();\n        size = filters != null ? filters.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFilter((IFilter) filters.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG);\n        xmlOut.endDocument();\n    }\n\n    /**\n     * Writes a local check configuration.\n     *\n     * @param checkConfig the local check configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     * @throws CheckstylePluginException\n     */\n    private void writeLocalConfiguration(ICheckConfiguration checkConfig, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        // TODO refactor to avoid code duplication with\n        // GlobalCheckConfigurationWorkingSet\n        // don't store built-in configurations to persistence or local\n        // configurations\n        if (checkConfig.getType() instanceof BuiltInConfigurationType || checkConfig.isGlobal()) {\n            return;\n        }\n        // RFE 1420212\n        String location = checkConfig.getLocation();\n        if (checkConfig.getType() instanceof ProjectConfigurationType) {\n            IProject project = mProjectConfig.getProject();\n            IWorkspaceRoot root = project.getWorkspace().getRoot();\n            IFile configFile = root.getFile(new Path(location));\n            IProject configFileProject = configFile.getProject();\n            // if the configuration is in *same* project don't store project\n            // path part\n            if (project.equals(configFileProject)) {\n                location = configFile.getProjectRelativePath().toString();\n            }\n        }\n        String emptyString = new String();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, checkConfig.getName());\n        attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, location);\n        attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, checkConfig.getType().getInternalName());\n        if (checkConfig.getDescription() != null) {\n            attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, checkConfig.getDescription());\n        }\n        xmlOut.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n        // Write resolvable properties\n        Iterator propsIterator = checkConfig.getResolvableProperties().iterator();\n        while (propsIterator.hasNext()) {\n            ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n            xmlOut.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n        }\n        Iterator addDataIterator = checkConfig.getAdditionalData().keySet().iterator();\n        while (addDataIterator.hasNext()) {\n            String key = (String) addDataIterator.next();\n            String value = (String) checkConfig.getAdditionalData().get(key);\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n            xmlOut.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a file set to xml.\n     *\n     * @param fileSet the file set\n     * @param project the project\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFileSet(FileSet fileSet, IProject project, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        if (fileSet.getCheckConfig() == null) {\n            throw new CheckstylePluginException(ErrorMessages.bind(ErrorMessages.errorFilesetWithoutCheckConfig, fileSet.getName(), project.getName()));\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, fileSet.getName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + fileSet.isEnabled());\n        ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n        if (checkConfig != null) {\n            attr.addAttribute(emptyString, XMLTags.CHECK_CONFIG_NAME_TAG, XMLTags.CHECK_CONFIG_NAME_TAG, emptyString, checkConfig.getName());\n            attr.addAttribute(emptyString, XMLTags.LOCAL_TAG, XMLTags.LOCAL_TAG, emptyString, emptyString + !checkConfig.isGlobal());\n        }\n        xmlOut.startElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG, attr);\n        // write patterns\n        List patterns = fileSet.getFileMatchPatterns();\n        int size = patterns != null ? patterns.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeMatchPattern((FileMatchPattern) patterns.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG);\n    }\n\n    /**\n     * Produces the sax events to write the file match pattern to xml.\n     *\n     * @param pattern the pattern\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeMatchPattern(FileMatchPattern pattern, TransformerHandler xmlOut) throws SAXException {\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.MATCH_PATTERN_TAG, XMLTags.MATCH_PATTERN_TAG, emptyString, pattern.getMatchPattern() != null ? pattern.getMatchPattern() : emptyString);\n        attr.addAttribute(emptyString, XMLTags.INCLUDE_PATTERN_TAG, XMLTags.INCLUDE_PATTERN_TAG, emptyString, emptyString + pattern.isIncludePattern());\n        xmlOut.startElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG, attr);\n        xmlOut.endElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a filter to xml.\n     *\n     * @param filter the filter\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFilter(IFilter filter, TransformerHandler xmlOut) throws SAXException {\n        // write only filters that are actually changed\n        // (enabled or contain data)\n        IFilter prototype = PluginFilters.getByInternalName(filter.getInternalName());\n        if (prototype.equals(filter)) {\n            return;\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, filter.getInternalName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + filter.isEnabled());\n        xmlOut.startElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG, attr);\n        List data = filter.getFilterData();\n        int size = data != null ? data.size() : 0;\n        for (int i = 0; i < size; i++) {\n            attr = new AttributesImpl();\n            attr.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, (String) data.get(i));\n            xmlOut.startElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG, attr);\n            xmlOut.endElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationWorkingCopy_1Test.java",
		"test_prompt": "// ProjectConfigurationWorkingCopy_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link ProjectConfigurationWorkingCopy#isRebuildNeeded()} method.\n*/\nclass ProjectConfigurationWorkingCopy_1Test {"
	},
	{
		"original_code": "// ProjectConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * A modifiable project configuration implementation.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationWorkingCopy implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The original, unmodified project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The local check configurations.\n     */\n    private ICheckConfigurationWorkingSet mLocalConfigWorkingSet;\n\n    /**\n     * The global check configurations.\n     */\n    private ICheckConfigurationWorkingSet mGlobalConfigWorkingSet;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets = new LinkedList();\n\n    /**\n     * the filters.\n     */\n    private List mFilters = new LinkedList();\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working copy of a given project configuration.\n     *\n     * @param projectConfig the project configuration\n     */\n    public ProjectConfigurationWorkingCopy(IProjectConfiguration projectConfig) {\n        mProjectConfig = projectConfig;\n        mLocalConfigWorkingSet = new LocalCheckConfigurationWorkingSet(this, projectConfig.getLocalCheckConfigurations());\n        mGlobalConfigWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        // clone file sets of the original config\n        Iterator it = projectConfig.getFileSets().iterator();\n        while (it.hasNext()) {\n            mFileSets.add(((FileSet) it.next()).clone());\n        }\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        // merge with filters configured for the project\n        List configuredFilters = projectConfig.getFilters();\n        for (int i = 0, size = mFilters.size(); i < size; i++) {\n            IFilter standardFilter = (IFilter) mFilters.get(i);\n            for (int j = 0, size2 = configuredFilters.size(); j < size2; j++) {\n                IFilter configuredFilter = (IFilter) configuredFilters.get(j);\n                if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                    mFilters.set(i, configuredFilter.clone());\n                }\n            }\n        }\n        mUseSimpleConfig = projectConfig.isUseSimpleConfig();\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the check configuration working set for local configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getLocalCheckConfigWorkingSet() {\n        return mLocalConfigWorkingSet;\n    }\n\n    /**\n     * Returns the check configuration working set for global configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getGlobalCheckConfigWorkingSet() {\n        return mGlobalConfigWorkingSet;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getLocalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mLocalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getGlobalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mGlobalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Sets if the simple configuration should be used.\n     *\n     * @param useSimpleConfig true if the project uses the simple fileset\n     *            configuration\n     */\n    public void setUseSimpleConfig(boolean useSimpleConfig) {\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    /**\n     * Determines if the project configuration changed.\n     *\n     * @return <code>true</code> if changed\n     */\n    public boolean isDirty() {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.isDirty();\n    }\n\n    /**\n     * Determines if a rebuild is needed for the project of this project\n     * configuration. A rebuild is not needed when only some local config was\n     * added which is not used by the project.\n     *\n     * @return <code>true</code> if rebuild is needed.\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public boolean isRebuildNeeded() throws CheckstylePluginException {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.getAffectedProjects().contains(getProject()) || mGlobalConfigWorkingSet.getAffectedProjects().contains(getProject());\n    }\n\n    /**\n     * Stores the project configuration.\n     *\n     * @throws CheckstylePluginException error while storing the project\n     *             configuration\n     */\n    public void store() throws CheckstylePluginException {\n        storeToPersistence(this);\n    }\n\n    //\n    // implementation of IProjectConfiguration interface\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return Arrays.asList(mLocalConfigWorkingSet.getWorkingCopies());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfigurationWorkingCopy clone = null;\n        try {\n            clone = (ProjectConfigurationWorkingCopy) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.setUseSimpleConfig(this.isUseSimpleConfig());\n            // clone file sets\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clone.getFileSets().add(((FileSet) iter.next()).clone());\n            }\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof IProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        IProjectConfiguration rhs = (IProjectConfiguration) obj;\n        return new EqualsBuilder().append(getProject(), rhs.getProject()).append(isUseSimpleConfig(), rhs.isUseSimpleConfig()).append(getFileSets(), rhs.getFileSets()).append(getFilters(), rhs.getFilters()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProjectConfig).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * Store the audit configurations to the persistent state storage.\n     */\n    private void storeToPersistence(ProjectConfigurationWorkingCopy config) throws CheckstylePluginException {\n        ByteArrayOutputStream pipeOut = null;\n        InputStream pipeIn = null;\n        try {\n            pipeOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(pipeOut, null, null);\n            writeProjectConfig(config, xmlOut);\n            pipeIn = new ByteArrayInputStream(pipeOut.toByteArray());\n            // create or overwrite the .checkstyle file\n            IProject project = config.getProject();\n            IFile file = project.getFile(ProjectConfigurationFactory.PROJECT_CONFIGURATION_FILE);\n            if (!file.exists()) {\n                file.create(pipeIn, true, null);\n                file.setLocal(true, IResource.DEPTH_INFINITE, null);\n            } else {\n                file.setContents(pipeIn, true, true, null);\n            }\n            config.getLocalCheckConfigWorkingSet().store();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorWritingCheckConfigurations, e.getLocalizedMessage()));\n        } finally {\n            IOUtils.closeQuietly(pipeIn);\n            IOUtils.closeQuietly(pipeOut);\n        }\n    }\n\n    /**\n     * Produces the sax events to write a project configuration.\n     *\n     * @param config the configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeProjectConfig(ProjectConfigurationWorkingCopy config, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        xmlOut.startDocument();\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.FORMAT_VERSION_TAG, XMLTags.FORMAT_VERSION_TAG, emptyString, ProjectConfigurationFactory.CURRENT_FILE_FORMAT_VERSION);\n        attr.addAttribute(emptyString, XMLTags.SIMPLE_CONFIG_TAG, XMLTags.SIMPLE_CONFIG_TAG, emptyString, emptyString + config.isUseSimpleConfig());\n        xmlOut.startElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG, attr);\n        ICheckConfiguration[] workingCopies = config.getLocalCheckConfigWorkingSet().getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            writeLocalConfiguration(workingCopies[i], xmlOut);\n        }\n        List fileSets = config.getFileSets();\n        int size = fileSets != null ? fileSets.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFileSet((FileSet) fileSets.get(i), config.getProject(), xmlOut);\n        }\n        // write filters\n        List filters = config.getFilters();\n        size = filters != null ? filters.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFilter((IFilter) filters.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG);\n        xmlOut.endDocument();\n    }\n\n    /**\n     * Writes a local check configuration.\n     *\n     * @param checkConfig the local check configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     * @throws CheckstylePluginException\n     */\n    private void writeLocalConfiguration(ICheckConfiguration checkConfig, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        // TODO refactor to avoid code duplication with\n        // GlobalCheckConfigurationWorkingSet\n        // don't store built-in configurations to persistence or local\n        // configurations\n        if (checkConfig.getType() instanceof BuiltInConfigurationType || checkConfig.isGlobal()) {\n            return;\n        }\n        // RFE 1420212\n        String location = checkConfig.getLocation();\n        if (checkConfig.getType() instanceof ProjectConfigurationType) {\n            IProject project = mProjectConfig.getProject();\n            IWorkspaceRoot root = project.getWorkspace().getRoot();\n            IFile configFile = root.getFile(new Path(location));\n            IProject configFileProject = configFile.getProject();\n            // if the configuration is in *same* project don't store project\n            // path part\n            if (project.equals(configFileProject)) {\n                location = configFile.getProjectRelativePath().toString();\n            }\n        }\n        String emptyString = new String();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, checkConfig.getName());\n        attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, location);\n        attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, checkConfig.getType().getInternalName());\n        if (checkConfig.getDescription() != null) {\n            attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, checkConfig.getDescription());\n        }\n        xmlOut.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n        // Write resolvable properties\n        Iterator propsIterator = checkConfig.getResolvableProperties().iterator();\n        while (propsIterator.hasNext()) {\n            ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n            xmlOut.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n        }\n        Iterator addDataIterator = checkConfig.getAdditionalData().keySet().iterator();\n        while (addDataIterator.hasNext()) {\n            String key = (String) addDataIterator.next();\n            String value = (String) checkConfig.getAdditionalData().get(key);\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n            xmlOut.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a file set to xml.\n     *\n     * @param fileSet the file set\n     * @param project the project\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFileSet(FileSet fileSet, IProject project, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        if (fileSet.getCheckConfig() == null) {\n            throw new CheckstylePluginException(ErrorMessages.bind(ErrorMessages.errorFilesetWithoutCheckConfig, fileSet.getName(), project.getName()));\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, fileSet.getName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + fileSet.isEnabled());\n        ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n        if (checkConfig != null) {\n            attr.addAttribute(emptyString, XMLTags.CHECK_CONFIG_NAME_TAG, XMLTags.CHECK_CONFIG_NAME_TAG, emptyString, checkConfig.getName());\n            attr.addAttribute(emptyString, XMLTags.LOCAL_TAG, XMLTags.LOCAL_TAG, emptyString, emptyString + !checkConfig.isGlobal());\n        }\n        xmlOut.startElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG, attr);\n        // write patterns\n        List patterns = fileSet.getFileMatchPatterns();\n        int size = patterns != null ? patterns.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeMatchPattern((FileMatchPattern) patterns.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG);\n    }\n\n    /**\n     * Produces the sax events to write the file match pattern to xml.\n     *\n     * @param pattern the pattern\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeMatchPattern(FileMatchPattern pattern, TransformerHandler xmlOut) throws SAXException {\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.MATCH_PATTERN_TAG, XMLTags.MATCH_PATTERN_TAG, emptyString, pattern.getMatchPattern() != null ? pattern.getMatchPattern() : emptyString);\n        attr.addAttribute(emptyString, XMLTags.INCLUDE_PATTERN_TAG, XMLTags.INCLUDE_PATTERN_TAG, emptyString, emptyString + pattern.isIncludePattern());\n        xmlOut.startElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG, attr);\n        xmlOut.endElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a filter to xml.\n     *\n     * @param filter the filter\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFilter(IFilter filter, TransformerHandler xmlOut) throws SAXException {\n        // write only filters that are actually changed\n        // (enabled or contain data)\n        IFilter prototype = PluginFilters.getByInternalName(filter.getInternalName());\n        if (prototype.equals(filter)) {\n            return;\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, filter.getInternalName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + filter.isEnabled());\n        xmlOut.startElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG, attr);\n        List data = filter.getFilterData();\n        int size = data != null ? data.size() : 0;\n        for (int i = 0; i < size; i++) {\n            attr = new AttributesImpl();\n            attr.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, (String) data.get(i));\n            xmlOut.startElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG, attr);\n            xmlOut.endElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationWorkingCopy_2Test.java",
		"test_prompt": "// ProjectConfigurationWorkingCopy_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link ProjectConfigurationWorkingCopy#isUseSimpleConfig()} method.\n*/\nclass ProjectConfigurationWorkingCopy_2Test {"
	},
	{
		"original_code": "// ProjectConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * A modifiable project configuration implementation.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationWorkingCopy implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The original, unmodified project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The local check configurations.\n     */\n    private ICheckConfigurationWorkingSet mLocalConfigWorkingSet;\n\n    /**\n     * The global check configurations.\n     */\n    private ICheckConfigurationWorkingSet mGlobalConfigWorkingSet;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets = new LinkedList();\n\n    /**\n     * the filters.\n     */\n    private List mFilters = new LinkedList();\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working copy of a given project configuration.\n     *\n     * @param projectConfig the project configuration\n     */\n    public ProjectConfigurationWorkingCopy(IProjectConfiguration projectConfig) {\n        mProjectConfig = projectConfig;\n        mLocalConfigWorkingSet = new LocalCheckConfigurationWorkingSet(this, projectConfig.getLocalCheckConfigurations());\n        mGlobalConfigWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        // clone file sets of the original config\n        Iterator it = projectConfig.getFileSets().iterator();\n        while (it.hasNext()) {\n            mFileSets.add(((FileSet) it.next()).clone());\n        }\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        // merge with filters configured for the project\n        List configuredFilters = projectConfig.getFilters();\n        for (int i = 0, size = mFilters.size(); i < size; i++) {\n            IFilter standardFilter = (IFilter) mFilters.get(i);\n            for (int j = 0, size2 = configuredFilters.size(); j < size2; j++) {\n                IFilter configuredFilter = (IFilter) configuredFilters.get(j);\n                if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                    mFilters.set(i, configuredFilter.clone());\n                }\n            }\n        }\n        mUseSimpleConfig = projectConfig.isUseSimpleConfig();\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the check configuration working set for local configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getLocalCheckConfigWorkingSet() {\n        return mLocalConfigWorkingSet;\n    }\n\n    /**\n     * Returns the check configuration working set for global configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getGlobalCheckConfigWorkingSet() {\n        return mGlobalConfigWorkingSet;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getLocalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mLocalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getGlobalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mGlobalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Sets if the simple configuration should be used.\n     *\n     * @param useSimpleConfig true if the project uses the simple fileset\n     *            configuration\n     */\n    public void setUseSimpleConfig(boolean useSimpleConfig) {\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    /**\n     * Determines if the project configuration changed.\n     *\n     * @return <code>true</code> if changed\n     */\n    public boolean isDirty() {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.isDirty();\n    }\n\n    /**\n     * Determines if a rebuild is needed for the project of this project\n     * configuration. A rebuild is not needed when only some local config was\n     * added which is not used by the project.\n     *\n     * @return <code>true</code> if rebuild is needed.\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public boolean isRebuildNeeded() throws CheckstylePluginException {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.getAffectedProjects().contains(getProject()) || mGlobalConfigWorkingSet.getAffectedProjects().contains(getProject());\n    }\n\n    /**\n     * Stores the project configuration.\n     *\n     * @throws CheckstylePluginException error while storing the project\n     *             configuration\n     */\n    public void store() throws CheckstylePluginException {\n        storeToPersistence(this);\n    }\n\n    //\n    // implementation of IProjectConfiguration interface\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return Arrays.asList(mLocalConfigWorkingSet.getWorkingCopies());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfigurationWorkingCopy clone = null;\n        try {\n            clone = (ProjectConfigurationWorkingCopy) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.setUseSimpleConfig(this.isUseSimpleConfig());\n            // clone file sets\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clone.getFileSets().add(((FileSet) iter.next()).clone());\n            }\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof IProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        IProjectConfiguration rhs = (IProjectConfiguration) obj;\n        return new EqualsBuilder().append(getProject(), rhs.getProject()).append(isUseSimpleConfig(), rhs.isUseSimpleConfig()).append(getFileSets(), rhs.getFileSets()).append(getFilters(), rhs.getFilters()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProjectConfig).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * Store the audit configurations to the persistent state storage.\n     */\n    private void storeToPersistence(ProjectConfigurationWorkingCopy config) throws CheckstylePluginException {\n        ByteArrayOutputStream pipeOut = null;\n        InputStream pipeIn = null;\n        try {\n            pipeOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(pipeOut, null, null);\n            writeProjectConfig(config, xmlOut);\n            pipeIn = new ByteArrayInputStream(pipeOut.toByteArray());\n            // create or overwrite the .checkstyle file\n            IProject project = config.getProject();\n            IFile file = project.getFile(ProjectConfigurationFactory.PROJECT_CONFIGURATION_FILE);\n            if (!file.exists()) {\n                file.create(pipeIn, true, null);\n                file.setLocal(true, IResource.DEPTH_INFINITE, null);\n            } else {\n                file.setContents(pipeIn, true, true, null);\n            }\n            config.getLocalCheckConfigWorkingSet().store();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorWritingCheckConfigurations, e.getLocalizedMessage()));\n        } finally {\n            IOUtils.closeQuietly(pipeIn);\n            IOUtils.closeQuietly(pipeOut);\n        }\n    }\n\n    /**\n     * Produces the sax events to write a project configuration.\n     *\n     * @param config the configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeProjectConfig(ProjectConfigurationWorkingCopy config, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        xmlOut.startDocument();\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.FORMAT_VERSION_TAG, XMLTags.FORMAT_VERSION_TAG, emptyString, ProjectConfigurationFactory.CURRENT_FILE_FORMAT_VERSION);\n        attr.addAttribute(emptyString, XMLTags.SIMPLE_CONFIG_TAG, XMLTags.SIMPLE_CONFIG_TAG, emptyString, emptyString + config.isUseSimpleConfig());\n        xmlOut.startElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG, attr);\n        ICheckConfiguration[] workingCopies = config.getLocalCheckConfigWorkingSet().getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            writeLocalConfiguration(workingCopies[i], xmlOut);\n        }\n        List fileSets = config.getFileSets();\n        int size = fileSets != null ? fileSets.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFileSet((FileSet) fileSets.get(i), config.getProject(), xmlOut);\n        }\n        // write filters\n        List filters = config.getFilters();\n        size = filters != null ? filters.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFilter((IFilter) filters.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG);\n        xmlOut.endDocument();\n    }\n\n    /**\n     * Writes a local check configuration.\n     *\n     * @param checkConfig the local check configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     * @throws CheckstylePluginException\n     */\n    private void writeLocalConfiguration(ICheckConfiguration checkConfig, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        // TODO refactor to avoid code duplication with\n        // GlobalCheckConfigurationWorkingSet\n        // don't store built-in configurations to persistence or local\n        // configurations\n        if (checkConfig.getType() instanceof BuiltInConfigurationType || checkConfig.isGlobal()) {\n            return;\n        }\n        // RFE 1420212\n        String location = checkConfig.getLocation();\n        if (checkConfig.getType() instanceof ProjectConfigurationType) {\n            IProject project = mProjectConfig.getProject();\n            IWorkspaceRoot root = project.getWorkspace().getRoot();\n            IFile configFile = root.getFile(new Path(location));\n            IProject configFileProject = configFile.getProject();\n            // if the configuration is in *same* project don't store project\n            // path part\n            if (project.equals(configFileProject)) {\n                location = configFile.getProjectRelativePath().toString();\n            }\n        }\n        String emptyString = new String();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, checkConfig.getName());\n        attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, location);\n        attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, checkConfig.getType().getInternalName());\n        if (checkConfig.getDescription() != null) {\n            attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, checkConfig.getDescription());\n        }\n        xmlOut.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n        // Write resolvable properties\n        Iterator propsIterator = checkConfig.getResolvableProperties().iterator();\n        while (propsIterator.hasNext()) {\n            ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n            xmlOut.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n        }\n        Iterator addDataIterator = checkConfig.getAdditionalData().keySet().iterator();\n        while (addDataIterator.hasNext()) {\n            String key = (String) addDataIterator.next();\n            String value = (String) checkConfig.getAdditionalData().get(key);\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n            xmlOut.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a file set to xml.\n     *\n     * @param fileSet the file set\n     * @param project the project\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFileSet(FileSet fileSet, IProject project, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        if (fileSet.getCheckConfig() == null) {\n            throw new CheckstylePluginException(ErrorMessages.bind(ErrorMessages.errorFilesetWithoutCheckConfig, fileSet.getName(), project.getName()));\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, fileSet.getName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + fileSet.isEnabled());\n        ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n        if (checkConfig != null) {\n            attr.addAttribute(emptyString, XMLTags.CHECK_CONFIG_NAME_TAG, XMLTags.CHECK_CONFIG_NAME_TAG, emptyString, checkConfig.getName());\n            attr.addAttribute(emptyString, XMLTags.LOCAL_TAG, XMLTags.LOCAL_TAG, emptyString, emptyString + !checkConfig.isGlobal());\n        }\n        xmlOut.startElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG, attr);\n        // write patterns\n        List patterns = fileSet.getFileMatchPatterns();\n        int size = patterns != null ? patterns.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeMatchPattern((FileMatchPattern) patterns.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG);\n    }\n\n    /**\n     * Produces the sax events to write the file match pattern to xml.\n     *\n     * @param pattern the pattern\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeMatchPattern(FileMatchPattern pattern, TransformerHandler xmlOut) throws SAXException {\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.MATCH_PATTERN_TAG, XMLTags.MATCH_PATTERN_TAG, emptyString, pattern.getMatchPattern() != null ? pattern.getMatchPattern() : emptyString);\n        attr.addAttribute(emptyString, XMLTags.INCLUDE_PATTERN_TAG, XMLTags.INCLUDE_PATTERN_TAG, emptyString, emptyString + pattern.isIncludePattern());\n        xmlOut.startElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG, attr);\n        xmlOut.endElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a filter to xml.\n     *\n     * @param filter the filter\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFilter(IFilter filter, TransformerHandler xmlOut) throws SAXException {\n        // write only filters that are actually changed\n        // (enabled or contain data)\n        IFilter prototype = PluginFilters.getByInternalName(filter.getInternalName());\n        if (prototype.equals(filter)) {\n            return;\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, filter.getInternalName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + filter.isEnabled());\n        xmlOut.startElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG, attr);\n        List data = filter.getFilterData();\n        int size = data != null ? data.size() : 0;\n        for (int i = 0; i < size; i++) {\n            attr = new AttributesImpl();\n            attr.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, (String) data.get(i));\n            xmlOut.startElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG, attr);\n            xmlOut.endElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationWorkingCopy_3Test.java",
		"test_prompt": "// ProjectConfigurationWorkingCopy_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link ProjectConfigurationWorkingCopy#isConfigInUse(ICheckConfiguration)} method.\n*/\nclass ProjectConfigurationWorkingCopy_3Test {"
	},
	{
		"original_code": "// ProjectConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * A modifiable project configuration implementation.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationWorkingCopy implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The original, unmodified project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The local check configurations.\n     */\n    private ICheckConfigurationWorkingSet mLocalConfigWorkingSet;\n\n    /**\n     * The global check configurations.\n     */\n    private ICheckConfigurationWorkingSet mGlobalConfigWorkingSet;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets = new LinkedList();\n\n    /**\n     * the filters.\n     */\n    private List mFilters = new LinkedList();\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working copy of a given project configuration.\n     *\n     * @param projectConfig the project configuration\n     */\n    public ProjectConfigurationWorkingCopy(IProjectConfiguration projectConfig) {\n        mProjectConfig = projectConfig;\n        mLocalConfigWorkingSet = new LocalCheckConfigurationWorkingSet(this, projectConfig.getLocalCheckConfigurations());\n        mGlobalConfigWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        // clone file sets of the original config\n        Iterator it = projectConfig.getFileSets().iterator();\n        while (it.hasNext()) {\n            mFileSets.add(((FileSet) it.next()).clone());\n        }\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        // merge with filters configured for the project\n        List configuredFilters = projectConfig.getFilters();\n        for (int i = 0, size = mFilters.size(); i < size; i++) {\n            IFilter standardFilter = (IFilter) mFilters.get(i);\n            for (int j = 0, size2 = configuredFilters.size(); j < size2; j++) {\n                IFilter configuredFilter = (IFilter) configuredFilters.get(j);\n                if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                    mFilters.set(i, configuredFilter.clone());\n                }\n            }\n        }\n        mUseSimpleConfig = projectConfig.isUseSimpleConfig();\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the check configuration working set for local configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getLocalCheckConfigWorkingSet() {\n        return mLocalConfigWorkingSet;\n    }\n\n    /**\n     * Returns the check configuration working set for global configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getGlobalCheckConfigWorkingSet() {\n        return mGlobalConfigWorkingSet;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getLocalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mLocalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getGlobalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mGlobalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Sets if the simple configuration should be used.\n     *\n     * @param useSimpleConfig true if the project uses the simple fileset\n     *            configuration\n     */\n    public void setUseSimpleConfig(boolean useSimpleConfig) {\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    /**\n     * Determines if the project configuration changed.\n     *\n     * @return <code>true</code> if changed\n     */\n    public boolean isDirty() {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.isDirty();\n    }\n\n    /**\n     * Determines if a rebuild is needed for the project of this project\n     * configuration. A rebuild is not needed when only some local config was\n     * added which is not used by the project.\n     *\n     * @return <code>true</code> if rebuild is needed.\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public boolean isRebuildNeeded() throws CheckstylePluginException {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.getAffectedProjects().contains(getProject()) || mGlobalConfigWorkingSet.getAffectedProjects().contains(getProject());\n    }\n\n    /**\n     * Stores the project configuration.\n     *\n     * @throws CheckstylePluginException error while storing the project\n     *             configuration\n     */\n    public void store() throws CheckstylePluginException {\n        storeToPersistence(this);\n    }\n\n    //\n    // implementation of IProjectConfiguration interface\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return Arrays.asList(mLocalConfigWorkingSet.getWorkingCopies());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfigurationWorkingCopy clone = null;\n        try {\n            clone = (ProjectConfigurationWorkingCopy) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.setUseSimpleConfig(this.isUseSimpleConfig());\n            // clone file sets\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clone.getFileSets().add(((FileSet) iter.next()).clone());\n            }\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof IProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        IProjectConfiguration rhs = (IProjectConfiguration) obj;\n        return new EqualsBuilder().append(getProject(), rhs.getProject()).append(isUseSimpleConfig(), rhs.isUseSimpleConfig()).append(getFileSets(), rhs.getFileSets()).append(getFilters(), rhs.getFilters()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProjectConfig).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * Store the audit configurations to the persistent state storage.\n     */\n    private void storeToPersistence(ProjectConfigurationWorkingCopy config) throws CheckstylePluginException {\n        ByteArrayOutputStream pipeOut = null;\n        InputStream pipeIn = null;\n        try {\n            pipeOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(pipeOut, null, null);\n            writeProjectConfig(config, xmlOut);\n            pipeIn = new ByteArrayInputStream(pipeOut.toByteArray());\n            // create or overwrite the .checkstyle file\n            IProject project = config.getProject();\n            IFile file = project.getFile(ProjectConfigurationFactory.PROJECT_CONFIGURATION_FILE);\n            if (!file.exists()) {\n                file.create(pipeIn, true, null);\n                file.setLocal(true, IResource.DEPTH_INFINITE, null);\n            } else {\n                file.setContents(pipeIn, true, true, null);\n            }\n            config.getLocalCheckConfigWorkingSet().store();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorWritingCheckConfigurations, e.getLocalizedMessage()));\n        } finally {\n            IOUtils.closeQuietly(pipeIn);\n            IOUtils.closeQuietly(pipeOut);\n        }\n    }\n\n    /**\n     * Produces the sax events to write a project configuration.\n     *\n     * @param config the configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeProjectConfig(ProjectConfigurationWorkingCopy config, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        xmlOut.startDocument();\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.FORMAT_VERSION_TAG, XMLTags.FORMAT_VERSION_TAG, emptyString, ProjectConfigurationFactory.CURRENT_FILE_FORMAT_VERSION);\n        attr.addAttribute(emptyString, XMLTags.SIMPLE_CONFIG_TAG, XMLTags.SIMPLE_CONFIG_TAG, emptyString, emptyString + config.isUseSimpleConfig());\n        xmlOut.startElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG, attr);\n        ICheckConfiguration[] workingCopies = config.getLocalCheckConfigWorkingSet().getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            writeLocalConfiguration(workingCopies[i], xmlOut);\n        }\n        List fileSets = config.getFileSets();\n        int size = fileSets != null ? fileSets.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFileSet((FileSet) fileSets.get(i), config.getProject(), xmlOut);\n        }\n        // write filters\n        List filters = config.getFilters();\n        size = filters != null ? filters.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFilter((IFilter) filters.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG);\n        xmlOut.endDocument();\n    }\n\n    /**\n     * Writes a local check configuration.\n     *\n     * @param checkConfig the local check configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     * @throws CheckstylePluginException\n     */\n    private void writeLocalConfiguration(ICheckConfiguration checkConfig, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        // TODO refactor to avoid code duplication with\n        // GlobalCheckConfigurationWorkingSet\n        // don't store built-in configurations to persistence or local\n        // configurations\n        if (checkConfig.getType() instanceof BuiltInConfigurationType || checkConfig.isGlobal()) {\n            return;\n        }\n        // RFE 1420212\n        String location = checkConfig.getLocation();\n        if (checkConfig.getType() instanceof ProjectConfigurationType) {\n            IProject project = mProjectConfig.getProject();\n            IWorkspaceRoot root = project.getWorkspace().getRoot();\n            IFile configFile = root.getFile(new Path(location));\n            IProject configFileProject = configFile.getProject();\n            // if the configuration is in *same* project don't store project\n            // path part\n            if (project.equals(configFileProject)) {\n                location = configFile.getProjectRelativePath().toString();\n            }\n        }\n        String emptyString = new String();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, checkConfig.getName());\n        attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, location);\n        attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, checkConfig.getType().getInternalName());\n        if (checkConfig.getDescription() != null) {\n            attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, checkConfig.getDescription());\n        }\n        xmlOut.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n        // Write resolvable properties\n        Iterator propsIterator = checkConfig.getResolvableProperties().iterator();\n        while (propsIterator.hasNext()) {\n            ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n            xmlOut.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n        }\n        Iterator addDataIterator = checkConfig.getAdditionalData().keySet().iterator();\n        while (addDataIterator.hasNext()) {\n            String key = (String) addDataIterator.next();\n            String value = (String) checkConfig.getAdditionalData().get(key);\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n            xmlOut.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a file set to xml.\n     *\n     * @param fileSet the file set\n     * @param project the project\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFileSet(FileSet fileSet, IProject project, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        if (fileSet.getCheckConfig() == null) {\n            throw new CheckstylePluginException(ErrorMessages.bind(ErrorMessages.errorFilesetWithoutCheckConfig, fileSet.getName(), project.getName()));\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, fileSet.getName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + fileSet.isEnabled());\n        ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n        if (checkConfig != null) {\n            attr.addAttribute(emptyString, XMLTags.CHECK_CONFIG_NAME_TAG, XMLTags.CHECK_CONFIG_NAME_TAG, emptyString, checkConfig.getName());\n            attr.addAttribute(emptyString, XMLTags.LOCAL_TAG, XMLTags.LOCAL_TAG, emptyString, emptyString + !checkConfig.isGlobal());\n        }\n        xmlOut.startElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG, attr);\n        // write patterns\n        List patterns = fileSet.getFileMatchPatterns();\n        int size = patterns != null ? patterns.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeMatchPattern((FileMatchPattern) patterns.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG);\n    }\n\n    /**\n     * Produces the sax events to write the file match pattern to xml.\n     *\n     * @param pattern the pattern\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeMatchPattern(FileMatchPattern pattern, TransformerHandler xmlOut) throws SAXException {\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.MATCH_PATTERN_TAG, XMLTags.MATCH_PATTERN_TAG, emptyString, pattern.getMatchPattern() != null ? pattern.getMatchPattern() : emptyString);\n        attr.addAttribute(emptyString, XMLTags.INCLUDE_PATTERN_TAG, XMLTags.INCLUDE_PATTERN_TAG, emptyString, emptyString + pattern.isIncludePattern());\n        xmlOut.startElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG, attr);\n        xmlOut.endElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a filter to xml.\n     *\n     * @param filter the filter\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFilter(IFilter filter, TransformerHandler xmlOut) throws SAXException {\n        // write only filters that are actually changed\n        // (enabled or contain data)\n        IFilter prototype = PluginFilters.getByInternalName(filter.getInternalName());\n        if (prototype.equals(filter)) {\n            return;\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, filter.getInternalName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + filter.isEnabled());\n        xmlOut.startElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG, attr);\n        List data = filter.getFilterData();\n        int size = data != null ? data.size() : 0;\n        for (int i = 0; i < size; i++) {\n            attr = new AttributesImpl();\n            attr.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, (String) data.get(i));\n            xmlOut.startElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG, attr);\n            xmlOut.endElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationWorkingCopy_4Test.java",
		"test_prompt": "// ProjectConfigurationWorkingCopy_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link ProjectConfigurationWorkingCopy#clone()} method.\n*/\nclass ProjectConfigurationWorkingCopy_4Test {"
	},
	{
		"original_code": "// ProjectConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * A modifiable project configuration implementation.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationWorkingCopy implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The original, unmodified project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The local check configurations.\n     */\n    private ICheckConfigurationWorkingSet mLocalConfigWorkingSet;\n\n    /**\n     * The global check configurations.\n     */\n    private ICheckConfigurationWorkingSet mGlobalConfigWorkingSet;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets = new LinkedList();\n\n    /**\n     * the filters.\n     */\n    private List mFilters = new LinkedList();\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working copy of a given project configuration.\n     *\n     * @param projectConfig the project configuration\n     */\n    public ProjectConfigurationWorkingCopy(IProjectConfiguration projectConfig) {\n        mProjectConfig = projectConfig;\n        mLocalConfigWorkingSet = new LocalCheckConfigurationWorkingSet(this, projectConfig.getLocalCheckConfigurations());\n        mGlobalConfigWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        // clone file sets of the original config\n        Iterator it = projectConfig.getFileSets().iterator();\n        while (it.hasNext()) {\n            mFileSets.add(((FileSet) it.next()).clone());\n        }\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        // merge with filters configured for the project\n        List configuredFilters = projectConfig.getFilters();\n        for (int i = 0, size = mFilters.size(); i < size; i++) {\n            IFilter standardFilter = (IFilter) mFilters.get(i);\n            for (int j = 0, size2 = configuredFilters.size(); j < size2; j++) {\n                IFilter configuredFilter = (IFilter) configuredFilters.get(j);\n                if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                    mFilters.set(i, configuredFilter.clone());\n                }\n            }\n        }\n        mUseSimpleConfig = projectConfig.isUseSimpleConfig();\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the check configuration working set for local configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getLocalCheckConfigWorkingSet() {\n        return mLocalConfigWorkingSet;\n    }\n\n    /**\n     * Returns the check configuration working set for global configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getGlobalCheckConfigWorkingSet() {\n        return mGlobalConfigWorkingSet;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getLocalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mLocalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getGlobalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mGlobalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Sets if the simple configuration should be used.\n     *\n     * @param useSimpleConfig true if the project uses the simple fileset\n     *            configuration\n     */\n    public void setUseSimpleConfig(boolean useSimpleConfig) {\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    /**\n     * Determines if the project configuration changed.\n     *\n     * @return <code>true</code> if changed\n     */\n    public boolean isDirty() {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.isDirty();\n    }\n\n    /**\n     * Determines if a rebuild is needed for the project of this project\n     * configuration. A rebuild is not needed when only some local config was\n     * added which is not used by the project.\n     *\n     * @return <code>true</code> if rebuild is needed.\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public boolean isRebuildNeeded() throws CheckstylePluginException {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.getAffectedProjects().contains(getProject()) || mGlobalConfigWorkingSet.getAffectedProjects().contains(getProject());\n    }\n\n    /**\n     * Stores the project configuration.\n     *\n     * @throws CheckstylePluginException error while storing the project\n     *             configuration\n     */\n    public void store() throws CheckstylePluginException {\n        storeToPersistence(this);\n    }\n\n    //\n    // implementation of IProjectConfiguration interface\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return Arrays.asList(mLocalConfigWorkingSet.getWorkingCopies());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfigurationWorkingCopy clone = null;\n        try {\n            clone = (ProjectConfigurationWorkingCopy) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.setUseSimpleConfig(this.isUseSimpleConfig());\n            // clone file sets\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clone.getFileSets().add(((FileSet) iter.next()).clone());\n            }\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof IProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        IProjectConfiguration rhs = (IProjectConfiguration) obj;\n        return new EqualsBuilder().append(getProject(), rhs.getProject()).append(isUseSimpleConfig(), rhs.isUseSimpleConfig()).append(getFileSets(), rhs.getFileSets()).append(getFilters(), rhs.getFilters()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProjectConfig).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * Store the audit configurations to the persistent state storage.\n     */\n    private void storeToPersistence(ProjectConfigurationWorkingCopy config) throws CheckstylePluginException {\n        ByteArrayOutputStream pipeOut = null;\n        InputStream pipeIn = null;\n        try {\n            pipeOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(pipeOut, null, null);\n            writeProjectConfig(config, xmlOut);\n            pipeIn = new ByteArrayInputStream(pipeOut.toByteArray());\n            // create or overwrite the .checkstyle file\n            IProject project = config.getProject();\n            IFile file = project.getFile(ProjectConfigurationFactory.PROJECT_CONFIGURATION_FILE);\n            if (!file.exists()) {\n                file.create(pipeIn, true, null);\n                file.setLocal(true, IResource.DEPTH_INFINITE, null);\n            } else {\n                file.setContents(pipeIn, true, true, null);\n            }\n            config.getLocalCheckConfigWorkingSet().store();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorWritingCheckConfigurations, e.getLocalizedMessage()));\n        } finally {\n            IOUtils.closeQuietly(pipeIn);\n            IOUtils.closeQuietly(pipeOut);\n        }\n    }\n\n    /**\n     * Produces the sax events to write a project configuration.\n     *\n     * @param config the configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeProjectConfig(ProjectConfigurationWorkingCopy config, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        xmlOut.startDocument();\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.FORMAT_VERSION_TAG, XMLTags.FORMAT_VERSION_TAG, emptyString, ProjectConfigurationFactory.CURRENT_FILE_FORMAT_VERSION);\n        attr.addAttribute(emptyString, XMLTags.SIMPLE_CONFIG_TAG, XMLTags.SIMPLE_CONFIG_TAG, emptyString, emptyString + config.isUseSimpleConfig());\n        xmlOut.startElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG, attr);\n        ICheckConfiguration[] workingCopies = config.getLocalCheckConfigWorkingSet().getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            writeLocalConfiguration(workingCopies[i], xmlOut);\n        }\n        List fileSets = config.getFileSets();\n        int size = fileSets != null ? fileSets.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFileSet((FileSet) fileSets.get(i), config.getProject(), xmlOut);\n        }\n        // write filters\n        List filters = config.getFilters();\n        size = filters != null ? filters.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFilter((IFilter) filters.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG);\n        xmlOut.endDocument();\n    }\n\n    /**\n     * Writes a local check configuration.\n     *\n     * @param checkConfig the local check configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     * @throws CheckstylePluginException\n     */\n    private void writeLocalConfiguration(ICheckConfiguration checkConfig, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        // TODO refactor to avoid code duplication with\n        // GlobalCheckConfigurationWorkingSet\n        // don't store built-in configurations to persistence or local\n        // configurations\n        if (checkConfig.getType() instanceof BuiltInConfigurationType || checkConfig.isGlobal()) {\n            return;\n        }\n        // RFE 1420212\n        String location = checkConfig.getLocation();\n        if (checkConfig.getType() instanceof ProjectConfigurationType) {\n            IProject project = mProjectConfig.getProject();\n            IWorkspaceRoot root = project.getWorkspace().getRoot();\n            IFile configFile = root.getFile(new Path(location));\n            IProject configFileProject = configFile.getProject();\n            // if the configuration is in *same* project don't store project\n            // path part\n            if (project.equals(configFileProject)) {\n                location = configFile.getProjectRelativePath().toString();\n            }\n        }\n        String emptyString = new String();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, checkConfig.getName());\n        attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, location);\n        attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, checkConfig.getType().getInternalName());\n        if (checkConfig.getDescription() != null) {\n            attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, checkConfig.getDescription());\n        }\n        xmlOut.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n        // Write resolvable properties\n        Iterator propsIterator = checkConfig.getResolvableProperties().iterator();\n        while (propsIterator.hasNext()) {\n            ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n            xmlOut.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n        }\n        Iterator addDataIterator = checkConfig.getAdditionalData().keySet().iterator();\n        while (addDataIterator.hasNext()) {\n            String key = (String) addDataIterator.next();\n            String value = (String) checkConfig.getAdditionalData().get(key);\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n            xmlOut.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a file set to xml.\n     *\n     * @param fileSet the file set\n     * @param project the project\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFileSet(FileSet fileSet, IProject project, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        if (fileSet.getCheckConfig() == null) {\n            throw new CheckstylePluginException(ErrorMessages.bind(ErrorMessages.errorFilesetWithoutCheckConfig, fileSet.getName(), project.getName()));\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, fileSet.getName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + fileSet.isEnabled());\n        ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n        if (checkConfig != null) {\n            attr.addAttribute(emptyString, XMLTags.CHECK_CONFIG_NAME_TAG, XMLTags.CHECK_CONFIG_NAME_TAG, emptyString, checkConfig.getName());\n            attr.addAttribute(emptyString, XMLTags.LOCAL_TAG, XMLTags.LOCAL_TAG, emptyString, emptyString + !checkConfig.isGlobal());\n        }\n        xmlOut.startElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG, attr);\n        // write patterns\n        List patterns = fileSet.getFileMatchPatterns();\n        int size = patterns != null ? patterns.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeMatchPattern((FileMatchPattern) patterns.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG);\n    }\n\n    /**\n     * Produces the sax events to write the file match pattern to xml.\n     *\n     * @param pattern the pattern\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeMatchPattern(FileMatchPattern pattern, TransformerHandler xmlOut) throws SAXException {\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.MATCH_PATTERN_TAG, XMLTags.MATCH_PATTERN_TAG, emptyString, pattern.getMatchPattern() != null ? pattern.getMatchPattern() : emptyString);\n        attr.addAttribute(emptyString, XMLTags.INCLUDE_PATTERN_TAG, XMLTags.INCLUDE_PATTERN_TAG, emptyString, emptyString + pattern.isIncludePattern());\n        xmlOut.startElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG, attr);\n        xmlOut.endElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a filter to xml.\n     *\n     * @param filter the filter\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFilter(IFilter filter, TransformerHandler xmlOut) throws SAXException {\n        // write only filters that are actually changed\n        // (enabled or contain data)\n        IFilter prototype = PluginFilters.getByInternalName(filter.getInternalName());\n        if (prototype.equals(filter)) {\n            return;\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, filter.getInternalName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + filter.isEnabled());\n        xmlOut.startElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG, attr);\n        List data = filter.getFilterData();\n        int size = data != null ? data.size() : 0;\n        for (int i = 0; i < size; i++) {\n            attr = new AttributesImpl();\n            attr.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, (String) data.get(i));\n            xmlOut.startElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG, attr);\n            xmlOut.endElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationWorkingCopy_5Test.java",
		"test_prompt": "// ProjectConfigurationWorkingCopy_5Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link ProjectConfigurationWorkingCopy#equals(Object)} method.\n*/\nclass ProjectConfigurationWorkingCopy_5Test {"
	},
	{
		"original_code": "// ProjectConfigurationWorkingCopy.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\n\n/**\n * A modifiable project configuration implementation.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectConfigurationWorkingCopy implements Cloneable, IProjectConfiguration {\n\n    //\n    // attributes\n    //\n    /**\n     * The original, unmodified project configuration.\n     */\n    private IProjectConfiguration mProjectConfig;\n\n    /**\n     * The local check configurations.\n     */\n    private ICheckConfigurationWorkingSet mLocalConfigWorkingSet;\n\n    /**\n     * The global check configurations.\n     */\n    private ICheckConfigurationWorkingSet mGlobalConfigWorkingSet;\n\n    /**\n     * the file sets.\n     */\n    private List mFileSets = new LinkedList();\n\n    /**\n     * the filters.\n     */\n    private List mFilters = new LinkedList();\n\n    /**\n     * Flags if the simple file set editor should be used.\n     */\n    private boolean mUseSimpleConfig;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates a working copy of a given project configuration.\n     *\n     * @param projectConfig the project configuration\n     */\n    public ProjectConfigurationWorkingCopy(IProjectConfiguration projectConfig) {\n        mProjectConfig = projectConfig;\n        mLocalConfigWorkingSet = new LocalCheckConfigurationWorkingSet(this, projectConfig.getLocalCheckConfigurations());\n        mGlobalConfigWorkingSet = CheckConfigurationFactory.newWorkingSet();\n        // clone file sets of the original config\n        Iterator it = projectConfig.getFileSets().iterator();\n        while (it.hasNext()) {\n            mFileSets.add(((FileSet) it.next()).clone());\n        }\n        // build list of filters\n        List standardFilters = Arrays.asList(PluginFilters.getConfiguredFilters());\n        mFilters = new ArrayList(standardFilters);\n        // merge with filters configured for the project\n        List configuredFilters = projectConfig.getFilters();\n        for (int i = 0, size = mFilters.size(); i < size; i++) {\n            IFilter standardFilter = (IFilter) mFilters.get(i);\n            for (int j = 0, size2 = configuredFilters.size(); j < size2; j++) {\n                IFilter configuredFilter = (IFilter) configuredFilters.get(j);\n                if (standardFilter.getInternalName().equals(configuredFilter.getInternalName())) {\n                    mFilters.set(i, configuredFilter.clone());\n                }\n            }\n        }\n        mUseSimpleConfig = projectConfig.isUseSimpleConfig();\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Returns the check configuration working set for local configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getLocalCheckConfigWorkingSet() {\n        return mLocalConfigWorkingSet;\n    }\n\n    /**\n     * Returns the check configuration working set for global configurations.\n     *\n     * @return the local configurations working set\n     */\n    public ICheckConfigurationWorkingSet getGlobalCheckConfigWorkingSet() {\n        return mGlobalConfigWorkingSet;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getLocalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mLocalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Returns a project local check configuration by its name.\n     *\n     * @param name the configurations name\n     * @return the check configuration or <code>null</code>, if no local\n     *         configuration with this name exists\n     */\n    public ICheckConfiguration getGlobalCheckConfigByName(String name) {\n        ICheckConfiguration config = null;\n        ICheckConfiguration[] configs = mGlobalConfigWorkingSet.getWorkingCopies();\n        for (int i = 0; i < configs.length; i++) {\n            if (configs[i].getName().equals(name)) {\n                config = configs[i];\n                break;\n            }\n        }\n        return config;\n    }\n\n    /**\n     * Sets if the simple configuration should be used.\n     *\n     * @param useSimpleConfig true if the project uses the simple fileset\n     *            configuration\n     */\n    public void setUseSimpleConfig(boolean useSimpleConfig) {\n        mUseSimpleConfig = useSimpleConfig;\n    }\n\n    /**\n     * Determines if the project configuration changed.\n     *\n     * @return <code>true</code> if changed\n     */\n    public boolean isDirty() {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.isDirty();\n    }\n\n    /**\n     * Determines if a rebuild is needed for the project of this project\n     * configuration. A rebuild is not needed when only some local config was\n     * added which is not used by the project.\n     *\n     * @return <code>true</code> if rebuild is needed.\n     * @throws CheckstylePluginException an unexpected exception occurred\n     */\n    public boolean isRebuildNeeded() throws CheckstylePluginException {\n        return !this.equals(mProjectConfig) || mLocalConfigWorkingSet.getAffectedProjects().contains(getProject()) || mGlobalConfigWorkingSet.getAffectedProjects().contains(getProject());\n    }\n\n    /**\n     * Stores the project configuration.\n     *\n     * @throws CheckstylePluginException error while storing the project\n     *             configuration\n     */\n    public void store() throws CheckstylePluginException {\n        storeToPersistence(this);\n    }\n\n    //\n    // implementation of IProjectConfiguration interface\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IProject getProject() {\n        return mProjectConfig.getProject();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getLocalCheckConfigurations() {\n        return Arrays.asList(mLocalConfigWorkingSet.getWorkingCopies());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFileSets() {\n        return mFileSets;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public List getFilters() {\n        return mFilters;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isUseSimpleConfig() {\n        return mUseSimpleConfig;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean isConfigInUse(ICheckConfiguration configuration) {\n        boolean result = false;\n        Iterator iter = getFileSets().iterator();\n        while (iter.hasNext()) {\n            FileSet fileSet = (FileSet) iter.next();\n            ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n            if (configuration.equals(checkConfig) || (checkConfig instanceof CheckConfigurationWorkingCopy && configuration.equals(((CheckConfigurationWorkingCopy) checkConfig).getSourceCheckConfiguration()))) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Object clone() {\n        ProjectConfigurationWorkingCopy clone = null;\n        try {\n            clone = (ProjectConfigurationWorkingCopy) super.clone();\n            clone.mFileSets = new LinkedList();\n            clone.setUseSimpleConfig(this.isUseSimpleConfig());\n            // clone file sets\n            Iterator iter = getFileSets().iterator();\n            while (iter.hasNext()) {\n                clone.getFileSets().add(((FileSet) iter.next()).clone());\n            }\n            // clone filters\n            List clonedFilters = new ArrayList();\n            iter = getFilters().iterator();\n            while (iter.hasNext()) {\n                clonedFilters.add(((IFilter) iter.next()).clone());\n            }\n            clone.mFilters = clonedFilters;\n        } catch (CloneNotSupportedException e) {\n            throw new InternalError();\n        }\n        return clone;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof IProjectConfiguration)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        IProjectConfiguration rhs = (IProjectConfiguration) obj;\n        return new EqualsBuilder().append(getProject(), rhs.getProject()).append(isUseSimpleConfig(), rhs.isUseSimpleConfig()).append(getFileSets(), rhs.getFileSets()).append(getFilters(), rhs.getFilters()).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(984759323, 1000003).append(mProjectConfig).append(mUseSimpleConfig).append(mFileSets).append(mFilters).toHashCode();\n    }\n\n    /**\n     * Store the audit configurations to the persistent state storage.\n     */\n    private void storeToPersistence(ProjectConfigurationWorkingCopy config) throws CheckstylePluginException {\n        ByteArrayOutputStream pipeOut = null;\n        InputStream pipeIn = null;\n        try {\n            pipeOut = new ByteArrayOutputStream();\n            // Write the configuration document by pushing sax events through\n            // the transformer handler\n            TransformerHandler xmlOut = XMLUtil.writeWithSax(pipeOut, null, null);\n            writeProjectConfig(config, xmlOut);\n            pipeIn = new ByteArrayInputStream(pipeOut.toByteArray());\n            // create or overwrite the .checkstyle file\n            IProject project = config.getProject();\n            IFile file = project.getFile(ProjectConfigurationFactory.PROJECT_CONFIGURATION_FILE);\n            if (!file.exists()) {\n                file.create(pipeIn, true, null);\n                file.setLocal(true, IResource.DEPTH_INFINITE, null);\n            } else {\n                file.setContents(pipeIn, true, true, null);\n            }\n            config.getLocalCheckConfigWorkingSet().store();\n        } catch (Exception e) {\n            CheckstylePluginException.rethrow(e, NLS.bind(ErrorMessages.errorWritingCheckConfigurations, e.getLocalizedMessage()));\n        } finally {\n            IOUtils.closeQuietly(pipeIn);\n            IOUtils.closeQuietly(pipeOut);\n        }\n    }\n\n    /**\n     * Produces the sax events to write a project configuration.\n     *\n     * @param config the configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeProjectConfig(ProjectConfigurationWorkingCopy config, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        xmlOut.startDocument();\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.FORMAT_VERSION_TAG, XMLTags.FORMAT_VERSION_TAG, emptyString, ProjectConfigurationFactory.CURRENT_FILE_FORMAT_VERSION);\n        attr.addAttribute(emptyString, XMLTags.SIMPLE_CONFIG_TAG, XMLTags.SIMPLE_CONFIG_TAG, emptyString, emptyString + config.isUseSimpleConfig());\n        xmlOut.startElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG, attr);\n        ICheckConfiguration[] workingCopies = config.getLocalCheckConfigWorkingSet().getWorkingCopies();\n        for (int i = 0; i < workingCopies.length; i++) {\n            writeLocalConfiguration(workingCopies[i], xmlOut);\n        }\n        List fileSets = config.getFileSets();\n        int size = fileSets != null ? fileSets.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFileSet((FileSet) fileSets.get(i), config.getProject(), xmlOut);\n        }\n        // write filters\n        List filters = config.getFilters();\n        size = filters != null ? filters.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeFilter((IFilter) filters.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_CONFIG_TAG, XMLTags.FILESET_CONFIG_TAG);\n        xmlOut.endDocument();\n    }\n\n    /**\n     * Writes a local check configuration.\n     *\n     * @param checkConfig the local check configuration\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     * @throws CheckstylePluginException\n     */\n    private void writeLocalConfiguration(ICheckConfiguration checkConfig, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        // TODO refactor to avoid code duplication with\n        // GlobalCheckConfigurationWorkingSet\n        // don't store built-in configurations to persistence or local\n        // configurations\n        if (checkConfig.getType() instanceof BuiltInConfigurationType || checkConfig.isGlobal()) {\n            return;\n        }\n        // RFE 1420212\n        String location = checkConfig.getLocation();\n        if (checkConfig.getType() instanceof ProjectConfigurationType) {\n            IProject project = mProjectConfig.getProject();\n            IWorkspaceRoot root = project.getWorkspace().getRoot();\n            IFile configFile = root.getFile(new Path(location));\n            IProject configFileProject = configFile.getProject();\n            // if the configuration is in *same* project don't store project\n            // path part\n            if (project.equals(configFileProject)) {\n                location = configFile.getProjectRelativePath().toString();\n            }\n        }\n        String emptyString = new String();\n        AttributesImpl attrs = new AttributesImpl();\n        attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, checkConfig.getName());\n        attrs.addAttribute(emptyString, XMLTags.LOCATION_TAG, XMLTags.LOCATION_TAG, emptyString, location);\n        attrs.addAttribute(emptyString, XMLTags.TYPE_TAG, XMLTags.TYPE_TAG, emptyString, checkConfig.getType().getInternalName());\n        if (checkConfig.getDescription() != null) {\n            attrs.addAttribute(emptyString, XMLTags.DESCRIPTION_TAG, XMLTags.DESCRIPTION_TAG, emptyString, checkConfig.getDescription());\n        }\n        xmlOut.startElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG, attrs);\n        // Write resolvable properties\n        Iterator propsIterator = checkConfig.getResolvableProperties().iterator();\n        while (propsIterator.hasNext()) {\n            ResolvableProperty prop = (ResolvableProperty) propsIterator.next();\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, prop.getPropertyName());\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, prop.getValue());\n            xmlOut.startElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.PROPERTY_TAG, XMLTags.PROPERTY_TAG);\n        }\n        Iterator addDataIterator = checkConfig.getAdditionalData().keySet().iterator();\n        while (addDataIterator.hasNext()) {\n            String key = (String) addDataIterator.next();\n            String value = (String) checkConfig.getAdditionalData().get(key);\n            attrs = new AttributesImpl();\n            attrs.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, key);\n            attrs.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, value);\n            xmlOut.startElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG, attrs);\n            xmlOut.endElement(emptyString, XMLTags.ADDITIONAL_DATA_TAG, XMLTags.ADDITIONAL_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.CHECK_CONFIG_TAG, XMLTags.CHECK_CONFIG_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a file set to xml.\n     *\n     * @param fileSet the file set\n     * @param project the project\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFileSet(FileSet fileSet, IProject project, TransformerHandler xmlOut) throws SAXException, CheckstylePluginException {\n        if (fileSet.getCheckConfig() == null) {\n            throw new CheckstylePluginException(ErrorMessages.bind(ErrorMessages.errorFilesetWithoutCheckConfig, fileSet.getName(), project.getName()));\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, fileSet.getName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + fileSet.isEnabled());\n        ICheckConfiguration checkConfig = fileSet.getCheckConfig();\n        if (checkConfig != null) {\n            attr.addAttribute(emptyString, XMLTags.CHECK_CONFIG_NAME_TAG, XMLTags.CHECK_CONFIG_NAME_TAG, emptyString, checkConfig.getName());\n            attr.addAttribute(emptyString, XMLTags.LOCAL_TAG, XMLTags.LOCAL_TAG, emptyString, emptyString + !checkConfig.isGlobal());\n        }\n        xmlOut.startElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG, attr);\n        // write patterns\n        List patterns = fileSet.getFileMatchPatterns();\n        int size = patterns != null ? patterns.size() : 0;\n        for (int i = 0; i < size; i++) {\n            writeMatchPattern((FileMatchPattern) patterns.get(i), xmlOut);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILESET_TAG, XMLTags.FILESET_TAG);\n    }\n\n    /**\n     * Produces the sax events to write the file match pattern to xml.\n     *\n     * @param pattern the pattern\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeMatchPattern(FileMatchPattern pattern, TransformerHandler xmlOut) throws SAXException {\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.MATCH_PATTERN_TAG, XMLTags.MATCH_PATTERN_TAG, emptyString, pattern.getMatchPattern() != null ? pattern.getMatchPattern() : emptyString);\n        attr.addAttribute(emptyString, XMLTags.INCLUDE_PATTERN_TAG, XMLTags.INCLUDE_PATTERN_TAG, emptyString, emptyString + pattern.isIncludePattern());\n        xmlOut.startElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG, attr);\n        xmlOut.endElement(emptyString, XMLTags.FILE_MATCH_PATTERN_TAG, XMLTags.FILE_MATCH_PATTERN_TAG);\n    }\n\n    /**\n     * Produces the sax events to write a filter to xml.\n     *\n     * @param filter the filter\n     * @param xmlOut the transformer handler receiving the events\n     * @throws SAXException error writing\n     */\n    private void writeFilter(IFilter filter, TransformerHandler xmlOut) throws SAXException {\n        // write only filters that are actually changed\n        // (enabled or contain data)\n        IFilter prototype = PluginFilters.getByInternalName(filter.getInternalName());\n        if (prototype.equals(filter)) {\n            return;\n        }\n        String emptyString = new String();\n        AttributesImpl attr = new AttributesImpl();\n        attr.addAttribute(emptyString, XMLTags.NAME_TAG, XMLTags.NAME_TAG, emptyString, filter.getInternalName());\n        attr.addAttribute(emptyString, XMLTags.ENABLED_TAG, XMLTags.ENABLED_TAG, emptyString, emptyString + filter.isEnabled());\n        xmlOut.startElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG, attr);\n        List data = filter.getFilterData();\n        int size = data != null ? data.size() : 0;\n        for (int i = 0; i < size; i++) {\n            attr = new AttributesImpl();\n            attr.addAttribute(emptyString, XMLTags.VALUE_TAG, XMLTags.VALUE_TAG, emptyString, (String) data.get(i));\n            xmlOut.startElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG, attr);\n            xmlOut.endElement(emptyString, XMLTags.FILTER_DATA_TAG, XMLTags.FILTER_DATA_TAG);\n        }\n        xmlOut.endElement(emptyString, XMLTags.FILTER_TAG, XMLTags.FILTER_TAG);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/ProjectConfigurationWorkingCopy_6Test.java",
		"test_prompt": "// ProjectConfigurationWorkingCopy_6Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport javax.xml.transform.sax.TransformerHandler;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.runtime.Path;\nimport org.eclipse.osgi.util.NLS;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.AttributesImpl;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckConfigurationWorkingCopy;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfigurationWorkingSet;\nimport com.atlassw.tools.eclipse.checkstyle.config.ResolvableProperty;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.BuiltInConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.ProjectConfigurationType;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.atlassw.tools.eclipse.checkstyle.util.XMLUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectConfigurationWorkingCopy}.\n* It contains ten unit test cases for the {@link ProjectConfigurationWorkingCopy#hashCode()} method.\n*/\nclass ProjectConfigurationWorkingCopy_6Test {"
	},
	{
		"original_code": "// FileMatchPattern.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * A file match pattern is a pattern used in a regular express to check for\n * matching file names.\n */\npublic class FileMatchPattern implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private boolean mIsIncludePattern = true;\n\n    private Pattern mRegexPattern;\n\n    private String mPatternString;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Construct a new <code>FileMatchPattern</code>.\n     *\n     * @param pattern The new pattern.\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public FileMatchPattern(String pattern) throws CheckstylePluginException {\n        setMatchPattern(pattern);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns the match pattern.\n     *\n     * @return String\n     */\n    public String getMatchPattern() {\n        return mRegexPattern.pattern();\n    }\n\n    /**\n     * Sets the match pattern.\n     *\n     * @param pattern The match pattern to set\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public void setMatchPattern(String pattern) throws CheckstylePluginException {\n        if ((pattern == null) || (pattern.trim().length() == 0)) {\n            throw new CheckstylePluginException(ErrorMessages.errorEmptyPattern);\n        }\n        try {\n            mRegexPattern = Pattern.compile(pattern);\n            mPatternString = pattern;\n        } catch (PatternSyntaxException e) {\n            // wrap the exception\n            CheckstylePluginException.rethrow(e);\n        }\n    }\n\n    /**\n     * Tests a file name to see if it matches the pattern.\n     *\n     * @param fileName File name to be tested.\n     *\n     * @return <code>true</code>= match, <code>false</code>= no match.\n     */\n    public boolean isMatch(String fileName) {\n        boolean result = false;\n        Matcher matcher = mRegexPattern.matcher(fileName);\n        result = matcher.find();\n        return result;\n    }\n\n    /**\n     * Returns the isIncludePattern.\n     *\n     * @return boolean\n     */\n    public boolean isIncludePattern() {\n        return mIsIncludePattern;\n    }\n\n    /**\n     * Sets the isIncludePattern.\n     *\n     * @param isIncludePattern The isIncludePattern to set\n     */\n    public void setIsIncludePattern(boolean isIncludePattern) {\n        mIsIncludePattern = isIncludePattern;\n    }\n\n    /**\n     * Clone the object.\n     *\n     * @return The clone\n     */\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileMatchPattern)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileMatchPattern rhs = (FileMatchPattern) obj;\n        return new EqualsBuilder().append(mIsIncludePattern, rhs.mIsIncludePattern).append(mPatternString, rhs.mPatternString).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7687, 1000003).append(mIsIncludePattern).append(mPatternString).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileMatchPattern_0Test.java",
		"test_prompt": "// FileMatchPattern_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileMatchPattern}.\n* It contains ten unit test cases for the {@link FileMatchPattern#isMatch(String)} method.\n*/\nclass FileMatchPattern_0Test {"
	},
	{
		"original_code": "// FileMatchPattern.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * A file match pattern is a pattern used in a regular express to check for\n * matching file names.\n */\npublic class FileMatchPattern implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private boolean mIsIncludePattern = true;\n\n    private Pattern mRegexPattern;\n\n    private String mPatternString;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Construct a new <code>FileMatchPattern</code>.\n     *\n     * @param pattern The new pattern.\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public FileMatchPattern(String pattern) throws CheckstylePluginException {\n        setMatchPattern(pattern);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns the match pattern.\n     *\n     * @return String\n     */\n    public String getMatchPattern() {\n        return mRegexPattern.pattern();\n    }\n\n    /**\n     * Sets the match pattern.\n     *\n     * @param pattern The match pattern to set\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public void setMatchPattern(String pattern) throws CheckstylePluginException {\n        if ((pattern == null) || (pattern.trim().length() == 0)) {\n            throw new CheckstylePluginException(ErrorMessages.errorEmptyPattern);\n        }\n        try {\n            mRegexPattern = Pattern.compile(pattern);\n            mPatternString = pattern;\n        } catch (PatternSyntaxException e) {\n            // wrap the exception\n            CheckstylePluginException.rethrow(e);\n        }\n    }\n\n    /**\n     * Tests a file name to see if it matches the pattern.\n     *\n     * @param fileName File name to be tested.\n     *\n     * @return <code>true</code>= match, <code>false</code>= no match.\n     */\n    public boolean isMatch(String fileName) {\n        boolean result = false;\n        Matcher matcher = mRegexPattern.matcher(fileName);\n        result = matcher.find();\n        return result;\n    }\n\n    /**\n     * Returns the isIncludePattern.\n     *\n     * @return boolean\n     */\n    public boolean isIncludePattern() {\n        return mIsIncludePattern;\n    }\n\n    /**\n     * Sets the isIncludePattern.\n     *\n     * @param isIncludePattern The isIncludePattern to set\n     */\n    public void setIsIncludePattern(boolean isIncludePattern) {\n        mIsIncludePattern = isIncludePattern;\n    }\n\n    /**\n     * Clone the object.\n     *\n     * @return The clone\n     */\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileMatchPattern)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileMatchPattern rhs = (FileMatchPattern) obj;\n        return new EqualsBuilder().append(mIsIncludePattern, rhs.mIsIncludePattern).append(mPatternString, rhs.mPatternString).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7687, 1000003).append(mIsIncludePattern).append(mPatternString).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileMatchPattern_1Test.java",
		"test_prompt": "// FileMatchPattern_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileMatchPattern}.\n* It contains ten unit test cases for the {@link FileMatchPattern#isIncludePattern()} method.\n*/\nclass FileMatchPattern_1Test {"
	},
	{
		"original_code": "// FileMatchPattern.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * A file match pattern is a pattern used in a regular express to check for\n * matching file names.\n */\npublic class FileMatchPattern implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private boolean mIsIncludePattern = true;\n\n    private Pattern mRegexPattern;\n\n    private String mPatternString;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Construct a new <code>FileMatchPattern</code>.\n     *\n     * @param pattern The new pattern.\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public FileMatchPattern(String pattern) throws CheckstylePluginException {\n        setMatchPattern(pattern);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns the match pattern.\n     *\n     * @return String\n     */\n    public String getMatchPattern() {\n        return mRegexPattern.pattern();\n    }\n\n    /**\n     * Sets the match pattern.\n     *\n     * @param pattern The match pattern to set\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public void setMatchPattern(String pattern) throws CheckstylePluginException {\n        if ((pattern == null) || (pattern.trim().length() == 0)) {\n            throw new CheckstylePluginException(ErrorMessages.errorEmptyPattern);\n        }\n        try {\n            mRegexPattern = Pattern.compile(pattern);\n            mPatternString = pattern;\n        } catch (PatternSyntaxException e) {\n            // wrap the exception\n            CheckstylePluginException.rethrow(e);\n        }\n    }\n\n    /**\n     * Tests a file name to see if it matches the pattern.\n     *\n     * @param fileName File name to be tested.\n     *\n     * @return <code>true</code>= match, <code>false</code>= no match.\n     */\n    public boolean isMatch(String fileName) {\n        boolean result = false;\n        Matcher matcher = mRegexPattern.matcher(fileName);\n        result = matcher.find();\n        return result;\n    }\n\n    /**\n     * Returns the isIncludePattern.\n     *\n     * @return boolean\n     */\n    public boolean isIncludePattern() {\n        return mIsIncludePattern;\n    }\n\n    /**\n     * Sets the isIncludePattern.\n     *\n     * @param isIncludePattern The isIncludePattern to set\n     */\n    public void setIsIncludePattern(boolean isIncludePattern) {\n        mIsIncludePattern = isIncludePattern;\n    }\n\n    /**\n     * Clone the object.\n     *\n     * @return The clone\n     */\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileMatchPattern)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileMatchPattern rhs = (FileMatchPattern) obj;\n        return new EqualsBuilder().append(mIsIncludePattern, rhs.mIsIncludePattern).append(mPatternString, rhs.mPatternString).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7687, 1000003).append(mIsIncludePattern).append(mPatternString).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileMatchPattern_2Test.java",
		"test_prompt": "// FileMatchPattern_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileMatchPattern}.\n* It contains ten unit test cases for the {@link FileMatchPattern#clone()} method.\n*/\nclass FileMatchPattern_2Test {"
	},
	{
		"original_code": "// FileMatchPattern.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * A file match pattern is a pattern used in a regular express to check for\n * matching file names.\n */\npublic class FileMatchPattern implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private boolean mIsIncludePattern = true;\n\n    private Pattern mRegexPattern;\n\n    private String mPatternString;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Construct a new <code>FileMatchPattern</code>.\n     *\n     * @param pattern The new pattern.\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public FileMatchPattern(String pattern) throws CheckstylePluginException {\n        setMatchPattern(pattern);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns the match pattern.\n     *\n     * @return String\n     */\n    public String getMatchPattern() {\n        return mRegexPattern.pattern();\n    }\n\n    /**\n     * Sets the match pattern.\n     *\n     * @param pattern The match pattern to set\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public void setMatchPattern(String pattern) throws CheckstylePluginException {\n        if ((pattern == null) || (pattern.trim().length() == 0)) {\n            throw new CheckstylePluginException(ErrorMessages.errorEmptyPattern);\n        }\n        try {\n            mRegexPattern = Pattern.compile(pattern);\n            mPatternString = pattern;\n        } catch (PatternSyntaxException e) {\n            // wrap the exception\n            CheckstylePluginException.rethrow(e);\n        }\n    }\n\n    /**\n     * Tests a file name to see if it matches the pattern.\n     *\n     * @param fileName File name to be tested.\n     *\n     * @return <code>true</code>= match, <code>false</code>= no match.\n     */\n    public boolean isMatch(String fileName) {\n        boolean result = false;\n        Matcher matcher = mRegexPattern.matcher(fileName);\n        result = matcher.find();\n        return result;\n    }\n\n    /**\n     * Returns the isIncludePattern.\n     *\n     * @return boolean\n     */\n    public boolean isIncludePattern() {\n        return mIsIncludePattern;\n    }\n\n    /**\n     * Sets the isIncludePattern.\n     *\n     * @param isIncludePattern The isIncludePattern to set\n     */\n    public void setIsIncludePattern(boolean isIncludePattern) {\n        mIsIncludePattern = isIncludePattern;\n    }\n\n    /**\n     * Clone the object.\n     *\n     * @return The clone\n     */\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileMatchPattern)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileMatchPattern rhs = (FileMatchPattern) obj;\n        return new EqualsBuilder().append(mIsIncludePattern, rhs.mIsIncludePattern).append(mPatternString, rhs.mPatternString).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7687, 1000003).append(mIsIncludePattern).append(mPatternString).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileMatchPattern_3Test.java",
		"test_prompt": "// FileMatchPattern_3Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileMatchPattern}.\n* It contains ten unit test cases for the {@link FileMatchPattern#equals(Object)} method.\n*/\nclass FileMatchPattern_3Test {"
	},
	{
		"original_code": "// FileMatchPattern.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * A file match pattern is a pattern used in a regular express to check for\n * matching file names.\n */\npublic class FileMatchPattern implements Cloneable {\n\n    // =================================================\n    // Public static final variables.\n    // =================================================\n    // =================================================\n    // Static class variables.\n    // =================================================\n    // =================================================\n    // Instance member variables.\n    // =================================================\n    private boolean mIsIncludePattern = true;\n\n    private Pattern mRegexPattern;\n\n    private String mPatternString;\n\n    // =================================================\n    // Constructors & finalizer.\n    // =================================================\n    /**\n     * Construct a new <code>FileMatchPattern</code>.\n     *\n     * @param pattern The new pattern.\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public FileMatchPattern(String pattern) throws CheckstylePluginException {\n        setMatchPattern(pattern);\n    }\n\n    // =================================================\n    // Methods.\n    // =================================================\n    /**\n     * Returns the match pattern.\n     *\n     * @return String\n     */\n    public String getMatchPattern() {\n        return mRegexPattern.pattern();\n    }\n\n    /**\n     * Sets the match pattern.\n     *\n     * @param pattern The match pattern to set\n     *\n     * @throws CheckstylePluginException Error during processing\n     */\n    public void setMatchPattern(String pattern) throws CheckstylePluginException {\n        if ((pattern == null) || (pattern.trim().length() == 0)) {\n            throw new CheckstylePluginException(ErrorMessages.errorEmptyPattern);\n        }\n        try {\n            mRegexPattern = Pattern.compile(pattern);\n            mPatternString = pattern;\n        } catch (PatternSyntaxException e) {\n            // wrap the exception\n            CheckstylePluginException.rethrow(e);\n        }\n    }\n\n    /**\n     * Tests a file name to see if it matches the pattern.\n     *\n     * @param fileName File name to be tested.\n     *\n     * @return <code>true</code>= match, <code>false</code>= no match.\n     */\n    public boolean isMatch(String fileName) {\n        boolean result = false;\n        Matcher matcher = mRegexPattern.matcher(fileName);\n        result = matcher.find();\n        return result;\n    }\n\n    /**\n     * Returns the isIncludePattern.\n     *\n     * @return boolean\n     */\n    public boolean isIncludePattern() {\n        return mIsIncludePattern;\n    }\n\n    /**\n     * Sets the isIncludePattern.\n     *\n     * @param isIncludePattern The isIncludePattern to set\n     */\n    public void setIsIncludePattern(boolean isIncludePattern) {\n        mIsIncludePattern = isIncludePattern;\n    }\n\n    /**\n     * Clone the object.\n     *\n     * @return The clone\n     */\n    public Object clone() {\n        try {\n            return super.clone();\n        } catch (CloneNotSupportedException e) {\n            // should never happen\n            throw new InternalError();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public boolean equals(Object obj) {\n        if (obj == null || !(obj instanceof FileMatchPattern)) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        FileMatchPattern rhs = (FileMatchPattern) obj;\n        return new EqualsBuilder().append(mIsIncludePattern, rhs.mIsIncludePattern).append(mPatternString, rhs.mPatternString).isEquals();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public int hashCode() {\n        return new HashCodeBuilder(7687, 1000003).append(mIsIncludePattern).append(mPatternString).toHashCode();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this, ToStringStyle.MULTI_LINE_STYLE);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/projectconfig/FileMatchPattern_4Test.java",
		"test_prompt": "// FileMatchPattern_4Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.projectconfig;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileMatchPattern}.\n* It contains ten unit test cases for the {@link FileMatchPattern#hashCode()} method.\n*/\nclass FileMatchPattern_4Test {"
	},
	{
		"original_code": "// PackageObjectFactory.java\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2005  Oliver Burn\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.util.List;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * A factory for creating objects from package names and names.\n *\n * @author Rick Giles\n * @author lkuehne\n * @version $Revision: 1.2 $\n */\nclass PackageObjectFactory implements ModuleFactory {\n\n    /**\n     * a list of package names to prepend to class names.\n     */\n    private List mPackages;\n\n    /**\n     * Creates a new <code>PackageObjectFactory</code> instance.\n     */\n    public PackageObjectFactory(List packages) {\n        mPackages = packages;\n    }\n\n    /**\n     * Helper for testing.\n     *\n     * @return the package names that have been added\n     */\n    String[] getPackages() {\n        return (String[]) mPackages.toArray(new String[mPackages.size()]);\n    }\n\n    /**\n     * Registers a package name to use for shortName resolution.\n     *\n     * @param aPackageName the package name\n     */\n    void addPackage(String aPackageName) {\n        mPackages.add(aPackageName);\n    }\n\n    /**\n     * Creates a new instance of a class from a given name. If the name is a\n     * classname, creates an instance of the named class. Otherwise, creates an\n     * instance of a classname obtained by concatenating the given to a package\n     * name from a given list of package names.\n     *\n     * @param aName the name of a class.\n     * @return the <code>Object</code>\n     * @throws CheckstyleException if an error occurs.\n     */\n    private Object doMakeObject(String aName) throws CheckstyleException {\n        // try aName first\n        try {\n            return createObject(aName);\n        } catch (CheckstyleException ex) {\n            // keep looking\n            ;\n        }\n        // now try packages\n        for (int i = 0; i < mPackages.size(); i++) {\n            final String packageName = (String) mPackages.get(i);\n            final String className = packageName + aName;\n            try {\n                return createObject(className);\n            } catch (CheckstyleException ex) {\n                // keep looking\n                ;\n            }\n        }\n        //$NON-NLS-1$\n        throw new CheckstyleException(\"Unable to instantiate \" + aName);\n    }\n\n    /**\n     * Creates a new instance of a named class.\n     *\n     * @param aClassName the name of the class to instantiate.\n     * @return the <code>Object</code> created by mLoader.\n     * @throws CheckstyleException if an error occurs.\n     */\n    private Object createObject(String aClassName) throws CheckstyleException {\n        try {\n            final ClassLoader loader = Thread.currentThread().getContextClassLoader();\n            final Class clazz = Class.forName(aClassName, true, loader);\n            return clazz.newInstance();\n        } catch (ClassNotFoundException e) {\n            //$NON-NLS-1$\n            throw new CheckstyleException(\"Unable to find class for \" + aClassName, e);\n        } catch (InstantiationException e) {\n            // /CLOVER:OFF\n            //$NON-NLS-1$\n            throw new CheckstyleException(\"Unable to instantiate \" + aClassName, e);\n            // /CLOVER:ON\n        } catch (IllegalAccessException e) {\n            // /CLOVER:OFF\n            //$NON-NLS-1$\n            throw new CheckstyleException(\"Unable to instantiate \" + aClassName, e);\n            // /CLOVER:ON\n        }\n    }\n\n    /**\n     * Creates a new instance of a class from a given name, or that name\n     * concatenated with &quot;Check&quot;. If the name is a classname, creates\n     * an instance of the named class. Otherwise, creates an instance of a\n     * classname obtained by concatenating the given name to a package name from\n     * a given list of package names.\n     *\n     * @param aName the name of a class.\n     * @return the <code>Object</code> created by aLoader.\n     * @throws CheckstyleException if an error occurs.\n     */\n    public Object createModule(String aName) throws CheckstyleException {\n        try {\n            return doMakeObject(aName);\n        } catch (CheckstyleException ex) {\n            // try again with suffix \"Check\"\n            try {\n                //$NON-NLS-1$\n                return doMakeObject(aName + \"Check\");\n            } catch (CheckstyleException ex2) {\n                //$NON-NLS-1$\n                throw new CheckstyleException(\"Unable to instantiate \" + aName, ex2);\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/builder/PackageObjectFactory.java",
		"test_prompt": "// PackageObjectFactoryTest.java\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2005  Oliver Burn\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.util.List;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PackageObjectFactory}.\n* It contains ten unit test cases for the {@link PackageObjectFactory#createModule(String)} method.\n*/\nclass PackageObjectFactoryTest {"
	},
	{
		"original_code": "// CheckerFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport org.apache.commons.collections.ReferenceMap;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckstyleConfigurationFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader.AdditionalConfigData;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IContextAware;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\n\n/**\n * Factory class to create (and cache) checker objects.\n *\n * @author Lars K�dderitzsch\n */\npublic final class CheckerFactory {\n\n    //\n    // class attributes\n    //\n    /**\n     * Map containing the configured checkers.\n     */\n    private static Map sCheckerMap;\n\n    /**\n     * Map containing the modification times of configs.\n     */\n    private static Map sModifiedMap;\n\n    /**\n     * Map containing additional data about the check configurations.\n     */\n    private static Map sAdditionalDataMap;\n\n    /**\n     * the shared classloader for the checkers.\n     */\n    private static ProjectClassLoader sSharedClassLoader;\n\n    //\n    // static initializer\n    //\n    /**\n     * Initialize the cache.\n     */\n    static {\n        // Use synchronized collections to avoid concurrent modification\n        sCheckerMap = Collections.synchronizedMap(new ReferenceMap());\n        sModifiedMap = Collections.synchronizedMap(new HashMap());\n        sAdditionalDataMap = Collections.synchronizedMap(new HashMap());\n        sSharedClassLoader = new ProjectClassLoader();\n    }\n\n    //\n    // constructors\n    //\n    /**\n     * Hidden utility class constructor.\n     */\n    private CheckerFactory() {\n        // noop\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Creates a checker for a given configuration file.\n     *\n     * @param config the check configuration data\n     * @param project the project to create the checker for\n     * @return the checker for the given configuration file\n     * @throws CheckstyleException the configuration file had errors\n     * @throws IOException the config file could not be read\n     * @throws CheckstylePluginException the configuration could not be read\n     */\n    public static Checker createChecker(ICheckConfiguration config, IProject project) throws CheckstyleException, IOException, CheckstylePluginException {\n        String cacheKey = getCacheKey(config, project);\n        CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n        Checker checker = tryCheckerCache(cacheKey, configFileData.getModificationStamp());\n        // no cache hit\n        if (checker == null) {\n            PropertyResolver resolver = configFileData.getPropertyResolver();\n            // set the project context if the property resolver needs the\n            // context\n            if (resolver instanceof IContextAware) {\n                ((IContextAware) resolver).setProjectContext(project);\n            }\n            InputStream in = null;\n            try {\n                in = configFileData.getCheckConfigFileStream();\n                checker = createCheckerInternal(in, resolver);\n            } finally {\n                IOUtils.closeQuietly(in);\n            }\n            // store checker in cache\n            Long modified = new Long(configFileData.getModificationStamp());\n            sCheckerMap.put(cacheKey, checker);\n            sModifiedMap.put(cacheKey, modified);\n        }\n        return checker;\n    }\n\n    /**\n     * Determines the additional data for a given configuration file.\n     *\n     * @param config the check configuration\n     * @param project the project to create the checker for\n     * @return the checker for the given configuration file\n     * @throws CheckstyleException the configuration file had errors\n     * @throws IOException the config file could not be read\n     * @throws CheckstylePluginException the configuration could not be read\n     */\n    public static ConfigurationReader.AdditionalConfigData getAdditionalData(ICheckConfiguration config, IProject project) throws CheckstyleException, IOException, CheckstylePluginException {\n        String cacheKey = getCacheKey(config, project);\n        ConfigurationReader.AdditionalConfigData additionalData = (AdditionalConfigData) sAdditionalDataMap.get(cacheKey);\n        // no cache hit - create the additional data\n        if (additionalData == null) {\n            CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n            additionalData = ConfigurationReader.getAdditionalConfigData(configFileData.getCheckConfigFileStream());\n            sAdditionalDataMap.put(cacheKey, additionalData);\n        }\n        return additionalData;\n    }\n\n    /**\n     * Returns the shared classloader which is used by all checkers created by\n     * this factory.\n     *\n     * @return the shared classloader\n     */\n    public static ProjectClassLoader getSharedClassLoader() {\n        return sSharedClassLoader;\n    }\n\n    /**\n     * Cleans up the checker cache.\n     */\n    public static void cleanup() {\n        sCheckerMap.clear();\n        sModifiedMap.clear();\n        sAdditionalDataMap.clear();\n    }\n\n    /**\n     * Build a unique cache key for the check configuration.\n     *\n     * @param config the check configuration\n     * @param project the project being checked\n     * @return the unique cache key\n     * @throws CheckstylePluginException error getting configuration file data\n     */\n    private static String getCacheKey(ICheckConfiguration config, IProject project) throws CheckstylePluginException {\n        CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n        URL configLocation = configFileData.getResolvedConfigFileURL();\n        String checkConfigName = config.getName() + \"#\" + (config.isGlobal() ? \"Global\" : \"Local\");\n        //$NON-NLS-1$\n        String cacheKey = project.getName() + \"#\" + configLocation + \"#\" + checkConfigName;\n        return cacheKey;\n    }\n\n    /**\n     * Tries to reuse an already configured checker for this configuration.\n     *\n     * @param config the configuration file\n     * @param cacheKey the key for cache access\n     * @return the cached checker or null\n     * @throws IOException the config file could not be read\n     */\n    private static Checker tryCheckerCache(String cacheKey, long modificationStamp) throws IOException {\n        // try the cache\n        Checker checker = (Checker) sCheckerMap.get(cacheKey);\n        // if cache hit\n        if (checker != null) {\n            // compare modification times of the configs\n            Long oldTime = (Long) sModifiedMap.get(cacheKey);\n            Long newTime = new Long(modificationStamp);\n            // no match - remove checker from cache\n            if (oldTime == null || oldTime.compareTo(newTime) != 0) {\n                checker = null;\n                sCheckerMap.remove(cacheKey);\n                sModifiedMap.remove(cacheKey);\n                sAdditionalDataMap.remove(cacheKey);\n            }\n        }\n        return checker;\n    }\n\n    /**\n     * Creates a new checker and configures it with the given configuration\n     * file.\n     *\n     * @param inStream stream to the configuration file\n     * @param propResolver a property resolver null\n     * @return the newly created Checker\n     * @throws CheckstyleException an exception during the creation of the\n     *             checker occured\n     * @throws CheckstylePluginException an exception during the creation of the\n     *             checker occured\n     */\n    private static Checker createCheckerInternal(InputStream inStream, PropertyResolver propResolver) throws CheckstyleException, CheckstylePluginException {\n        // load configuration\n        Configuration configuration = ConfigurationLoader.loadConfiguration(inStream, propResolver, true);\n        // create and configure checker\n        Checker checker = new Checker();\n        // load the package name files and create the module factory\n        List packages = com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader.getPackageNames(Thread.currentThread().getContextClassLoader());\n        checker.setModuleFactory(new PackageObjectFactory(packages));\n        // set the eclipse platform locale\n        Locale platformLocale = CheckstylePlugin.getPlatformLocale();\n        checker.setLocaleLanguage(platformLocale.getLanguage());\n        checker.setLocaleCountry(platformLocale.getCountry());\n        IPreferencesService prefStore = Platform.getPreferencesService();\n        if (!prefStore.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_DISABLE_PROJ_CLASSLOADER, false, null)) {\n            checker.setClassloader(sSharedClassLoader);\n        }\n        checker.configure(configuration);\n        return checker;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/builder/CheckerFactory_0Test.java",
		"test_prompt": "// CheckerFactory_0Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport org.apache.commons.collections.ReferenceMap;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckstyleConfigurationFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader.AdditionalConfigData;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IContextAware;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckerFactory}.\n* It contains ten unit test cases for the {@link CheckerFactory#createChecker(ICheckConfiguration, IProject)} method.\n*/\nclass CheckerFactory_0Test {"
	},
	{
		"original_code": "// CheckerFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport org.apache.commons.collections.ReferenceMap;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckstyleConfigurationFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader.AdditionalConfigData;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IContextAware;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\n\n/**\n * Factory class to create (and cache) checker objects.\n *\n * @author Lars K�dderitzsch\n */\npublic final class CheckerFactory {\n\n    //\n    // class attributes\n    //\n    /**\n     * Map containing the configured checkers.\n     */\n    private static Map sCheckerMap;\n\n    /**\n     * Map containing the modification times of configs.\n     */\n    private static Map sModifiedMap;\n\n    /**\n     * Map containing additional data about the check configurations.\n     */\n    private static Map sAdditionalDataMap;\n\n    /**\n     * the shared classloader for the checkers.\n     */\n    private static ProjectClassLoader sSharedClassLoader;\n\n    //\n    // static initializer\n    //\n    /**\n     * Initialize the cache.\n     */\n    static {\n        // Use synchronized collections to avoid concurrent modification\n        sCheckerMap = Collections.synchronizedMap(new ReferenceMap());\n        sModifiedMap = Collections.synchronizedMap(new HashMap());\n        sAdditionalDataMap = Collections.synchronizedMap(new HashMap());\n        sSharedClassLoader = new ProjectClassLoader();\n    }\n\n    //\n    // constructors\n    //\n    /**\n     * Hidden utility class constructor.\n     */\n    private CheckerFactory() {\n        // noop\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Creates a checker for a given configuration file.\n     *\n     * @param config the check configuration data\n     * @param project the project to create the checker for\n     * @return the checker for the given configuration file\n     * @throws CheckstyleException the configuration file had errors\n     * @throws IOException the config file could not be read\n     * @throws CheckstylePluginException the configuration could not be read\n     */\n    public static Checker createChecker(ICheckConfiguration config, IProject project) throws CheckstyleException, IOException, CheckstylePluginException {\n        String cacheKey = getCacheKey(config, project);\n        CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n        Checker checker = tryCheckerCache(cacheKey, configFileData.getModificationStamp());\n        // no cache hit\n        if (checker == null) {\n            PropertyResolver resolver = configFileData.getPropertyResolver();\n            // set the project context if the property resolver needs the\n            // context\n            if (resolver instanceof IContextAware) {\n                ((IContextAware) resolver).setProjectContext(project);\n            }\n            InputStream in = null;\n            try {\n                in = configFileData.getCheckConfigFileStream();\n                checker = createCheckerInternal(in, resolver);\n            } finally {\n                IOUtils.closeQuietly(in);\n            }\n            // store checker in cache\n            Long modified = new Long(configFileData.getModificationStamp());\n            sCheckerMap.put(cacheKey, checker);\n            sModifiedMap.put(cacheKey, modified);\n        }\n        return checker;\n    }\n\n    /**\n     * Determines the additional data for a given configuration file.\n     *\n     * @param config the check configuration\n     * @param project the project to create the checker for\n     * @return the checker for the given configuration file\n     * @throws CheckstyleException the configuration file had errors\n     * @throws IOException the config file could not be read\n     * @throws CheckstylePluginException the configuration could not be read\n     */\n    public static ConfigurationReader.AdditionalConfigData getAdditionalData(ICheckConfiguration config, IProject project) throws CheckstyleException, IOException, CheckstylePluginException {\n        String cacheKey = getCacheKey(config, project);\n        ConfigurationReader.AdditionalConfigData additionalData = (AdditionalConfigData) sAdditionalDataMap.get(cacheKey);\n        // no cache hit - create the additional data\n        if (additionalData == null) {\n            CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n            additionalData = ConfigurationReader.getAdditionalConfigData(configFileData.getCheckConfigFileStream());\n            sAdditionalDataMap.put(cacheKey, additionalData);\n        }\n        return additionalData;\n    }\n\n    /**\n     * Returns the shared classloader which is used by all checkers created by\n     * this factory.\n     *\n     * @return the shared classloader\n     */\n    public static ProjectClassLoader getSharedClassLoader() {\n        return sSharedClassLoader;\n    }\n\n    /**\n     * Cleans up the checker cache.\n     */\n    public static void cleanup() {\n        sCheckerMap.clear();\n        sModifiedMap.clear();\n        sAdditionalDataMap.clear();\n    }\n\n    /**\n     * Build a unique cache key for the check configuration.\n     *\n     * @param config the check configuration\n     * @param project the project being checked\n     * @return the unique cache key\n     * @throws CheckstylePluginException error getting configuration file data\n     */\n    private static String getCacheKey(ICheckConfiguration config, IProject project) throws CheckstylePluginException {\n        CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n        URL configLocation = configFileData.getResolvedConfigFileURL();\n        String checkConfigName = config.getName() + \"#\" + (config.isGlobal() ? \"Global\" : \"Local\");\n        //$NON-NLS-1$\n        String cacheKey = project.getName() + \"#\" + configLocation + \"#\" + checkConfigName;\n        return cacheKey;\n    }\n\n    /**\n     * Tries to reuse an already configured checker for this configuration.\n     *\n     * @param config the configuration file\n     * @param cacheKey the key for cache access\n     * @return the cached checker or null\n     * @throws IOException the config file could not be read\n     */\n    private static Checker tryCheckerCache(String cacheKey, long modificationStamp) throws IOException {\n        // try the cache\n        Checker checker = (Checker) sCheckerMap.get(cacheKey);\n        // if cache hit\n        if (checker != null) {\n            // compare modification times of the configs\n            Long oldTime = (Long) sModifiedMap.get(cacheKey);\n            Long newTime = new Long(modificationStamp);\n            // no match - remove checker from cache\n            if (oldTime == null || oldTime.compareTo(newTime) != 0) {\n                checker = null;\n                sCheckerMap.remove(cacheKey);\n                sModifiedMap.remove(cacheKey);\n                sAdditionalDataMap.remove(cacheKey);\n            }\n        }\n        return checker;\n    }\n\n    /**\n     * Creates a new checker and configures it with the given configuration\n     * file.\n     *\n     * @param inStream stream to the configuration file\n     * @param propResolver a property resolver null\n     * @return the newly created Checker\n     * @throws CheckstyleException an exception during the creation of the\n     *             checker occured\n     * @throws CheckstylePluginException an exception during the creation of the\n     *             checker occured\n     */\n    private static Checker createCheckerInternal(InputStream inStream, PropertyResolver propResolver) throws CheckstyleException, CheckstylePluginException {\n        // load configuration\n        Configuration configuration = ConfigurationLoader.loadConfiguration(inStream, propResolver, true);\n        // create and configure checker\n        Checker checker = new Checker();\n        // load the package name files and create the module factory\n        List packages = com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader.getPackageNames(Thread.currentThread().getContextClassLoader());\n        checker.setModuleFactory(new PackageObjectFactory(packages));\n        // set the eclipse platform locale\n        Locale platformLocale = CheckstylePlugin.getPlatformLocale();\n        checker.setLocaleLanguage(platformLocale.getLanguage());\n        checker.setLocaleCountry(platformLocale.getCountry());\n        IPreferencesService prefStore = Platform.getPreferencesService();\n        if (!prefStore.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_DISABLE_PROJ_CLASSLOADER, false, null)) {\n            checker.setClassloader(sSharedClassLoader);\n        }\n        checker.configure(configuration);\n        return checker;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/builder/CheckerFactory_1Test.java",
		"test_prompt": "// CheckerFactory_1Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport org.apache.commons.collections.ReferenceMap;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckstyleConfigurationFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader.AdditionalConfigData;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IContextAware;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckerFactory}.\n* It contains ten unit test cases for the {@link CheckerFactory#getAdditionalData(ICheckConfiguration, IProject)} method.\n*/\nclass CheckerFactory_1Test {"
	},
	{
		"original_code": "// CheckerFactory.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport org.apache.commons.collections.ReferenceMap;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckstyleConfigurationFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader.AdditionalConfigData;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IContextAware;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\n\n/**\n * Factory class to create (and cache) checker objects.\n *\n * @author Lars K�dderitzsch\n */\npublic final class CheckerFactory {\n\n    //\n    // class attributes\n    //\n    /**\n     * Map containing the configured checkers.\n     */\n    private static Map sCheckerMap;\n\n    /**\n     * Map containing the modification times of configs.\n     */\n    private static Map sModifiedMap;\n\n    /**\n     * Map containing additional data about the check configurations.\n     */\n    private static Map sAdditionalDataMap;\n\n    /**\n     * the shared classloader for the checkers.\n     */\n    private static ProjectClassLoader sSharedClassLoader;\n\n    //\n    // static initializer\n    //\n    /**\n     * Initialize the cache.\n     */\n    static {\n        // Use synchronized collections to avoid concurrent modification\n        sCheckerMap = Collections.synchronizedMap(new ReferenceMap());\n        sModifiedMap = Collections.synchronizedMap(new HashMap());\n        sAdditionalDataMap = Collections.synchronizedMap(new HashMap());\n        sSharedClassLoader = new ProjectClassLoader();\n    }\n\n    //\n    // constructors\n    //\n    /**\n     * Hidden utility class constructor.\n     */\n    private CheckerFactory() {\n        // noop\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Creates a checker for a given configuration file.\n     *\n     * @param config the check configuration data\n     * @param project the project to create the checker for\n     * @return the checker for the given configuration file\n     * @throws CheckstyleException the configuration file had errors\n     * @throws IOException the config file could not be read\n     * @throws CheckstylePluginException the configuration could not be read\n     */\n    public static Checker createChecker(ICheckConfiguration config, IProject project) throws CheckstyleException, IOException, CheckstylePluginException {\n        String cacheKey = getCacheKey(config, project);\n        CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n        Checker checker = tryCheckerCache(cacheKey, configFileData.getModificationStamp());\n        // no cache hit\n        if (checker == null) {\n            PropertyResolver resolver = configFileData.getPropertyResolver();\n            // set the project context if the property resolver needs the\n            // context\n            if (resolver instanceof IContextAware) {\n                ((IContextAware) resolver).setProjectContext(project);\n            }\n            InputStream in = null;\n            try {\n                in = configFileData.getCheckConfigFileStream();\n                checker = createCheckerInternal(in, resolver);\n            } finally {\n                IOUtils.closeQuietly(in);\n            }\n            // store checker in cache\n            Long modified = new Long(configFileData.getModificationStamp());\n            sCheckerMap.put(cacheKey, checker);\n            sModifiedMap.put(cacheKey, modified);\n        }\n        return checker;\n    }\n\n    /**\n     * Determines the additional data for a given configuration file.\n     *\n     * @param config the check configuration\n     * @param project the project to create the checker for\n     * @return the checker for the given configuration file\n     * @throws CheckstyleException the configuration file had errors\n     * @throws IOException the config file could not be read\n     * @throws CheckstylePluginException the configuration could not be read\n     */\n    public static ConfigurationReader.AdditionalConfigData getAdditionalData(ICheckConfiguration config, IProject project) throws CheckstyleException, IOException, CheckstylePluginException {\n        String cacheKey = getCacheKey(config, project);\n        ConfigurationReader.AdditionalConfigData additionalData = (AdditionalConfigData) sAdditionalDataMap.get(cacheKey);\n        // no cache hit - create the additional data\n        if (additionalData == null) {\n            CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n            additionalData = ConfigurationReader.getAdditionalConfigData(configFileData.getCheckConfigFileStream());\n            sAdditionalDataMap.put(cacheKey, additionalData);\n        }\n        return additionalData;\n    }\n\n    /**\n     * Returns the shared classloader which is used by all checkers created by\n     * this factory.\n     *\n     * @return the shared classloader\n     */\n    public static ProjectClassLoader getSharedClassLoader() {\n        return sSharedClassLoader;\n    }\n\n    /**\n     * Cleans up the checker cache.\n     */\n    public static void cleanup() {\n        sCheckerMap.clear();\n        sModifiedMap.clear();\n        sAdditionalDataMap.clear();\n    }\n\n    /**\n     * Build a unique cache key for the check configuration.\n     *\n     * @param config the check configuration\n     * @param project the project being checked\n     * @return the unique cache key\n     * @throws CheckstylePluginException error getting configuration file data\n     */\n    private static String getCacheKey(ICheckConfiguration config, IProject project) throws CheckstylePluginException {\n        CheckstyleConfigurationFile configFileData = config.getCheckstyleConfiguration();\n        URL configLocation = configFileData.getResolvedConfigFileURL();\n        String checkConfigName = config.getName() + \"#\" + (config.isGlobal() ? \"Global\" : \"Local\");\n        //$NON-NLS-1$\n        String cacheKey = project.getName() + \"#\" + configLocation + \"#\" + checkConfigName;\n        return cacheKey;\n    }\n\n    /**\n     * Tries to reuse an already configured checker for this configuration.\n     *\n     * @param config the configuration file\n     * @param cacheKey the key for cache access\n     * @return the cached checker or null\n     * @throws IOException the config file could not be read\n     */\n    private static Checker tryCheckerCache(String cacheKey, long modificationStamp) throws IOException {\n        // try the cache\n        Checker checker = (Checker) sCheckerMap.get(cacheKey);\n        // if cache hit\n        if (checker != null) {\n            // compare modification times of the configs\n            Long oldTime = (Long) sModifiedMap.get(cacheKey);\n            Long newTime = new Long(modificationStamp);\n            // no match - remove checker from cache\n            if (oldTime == null || oldTime.compareTo(newTime) != 0) {\n                checker = null;\n                sCheckerMap.remove(cacheKey);\n                sModifiedMap.remove(cacheKey);\n                sAdditionalDataMap.remove(cacheKey);\n            }\n        }\n        return checker;\n    }\n\n    /**\n     * Creates a new checker and configures it with the given configuration\n     * file.\n     *\n     * @param inStream stream to the configuration file\n     * @param propResolver a property resolver null\n     * @return the newly created Checker\n     * @throws CheckstyleException an exception during the creation of the\n     *             checker occured\n     * @throws CheckstylePluginException an exception during the creation of the\n     *             checker occured\n     */\n    private static Checker createCheckerInternal(InputStream inStream, PropertyResolver propResolver) throws CheckstyleException, CheckstylePluginException {\n        // load configuration\n        Configuration configuration = ConfigurationLoader.loadConfiguration(inStream, propResolver, true);\n        // create and configure checker\n        Checker checker = new Checker();\n        // load the package name files and create the module factory\n        List packages = com.atlassw.tools.eclipse.checkstyle.builder.PackageNamesLoader.getPackageNames(Thread.currentThread().getContextClassLoader());\n        checker.setModuleFactory(new PackageObjectFactory(packages));\n        // set the eclipse platform locale\n        Locale platformLocale = CheckstylePlugin.getPlatformLocale();\n        checker.setLocaleLanguage(platformLocale.getLanguage());\n        checker.setLocaleCountry(platformLocale.getCountry());\n        IPreferencesService prefStore = Platform.getPreferencesService();\n        if (!prefStore.getBoolean(CheckstylePlugin.PLUGIN_ID, CheckstylePlugin.PREF_DISABLE_PROJ_CLASSLOADER, false, null)) {\n            checker.setClassloader(sSharedClassLoader);\n        }\n        checker.configure(configuration);\n        return checker;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/builder/CheckerFactory_2Test.java",
		"test_prompt": "// CheckerFactory_2Test.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport org.apache.commons.collections.ReferenceMap;\nimport org.apache.commons.io.IOUtils;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.Platform;\nimport org.eclipse.core.runtime.preferences.IPreferencesService;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.config.CheckstyleConfigurationFile;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader;\nimport com.atlassw.tools.eclipse.checkstyle.config.ICheckConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.config.ConfigurationReader.AdditionalConfigData;\nimport com.atlassw.tools.eclipse.checkstyle.config.configtypes.IContextAware;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.PropertyResolver;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CheckerFactory}.\n* It contains ten unit test cases for the {@link CheckerFactory#getSharedClassLoader()} method.\n*/\nclass CheckerFactory_2Test {"
	},
	{
		"original_code": "// RunCheckstyleOnFilesJob.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IncrementalProjectBuilder;\nimport org.eclipse.core.resources.WorkspaceJob;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * Job that invokes Checkstyle on a list of workspace files.\n *\n * @author Lars K�dderitzsch\n */\npublic class RunCheckstyleOnFilesJob extends WorkspaceJob {\n\n    private List mFilesToCheck;\n\n    /**\n     * Creates the job for a list of <code>IFile</code> objects.\n     *\n     * @param files the files to check\n     */\n    public RunCheckstyleOnFilesJob(List files) {\n        super(Messages.RunCheckstyleOnFilesJob_title);\n        mFilesToCheck = files;\n    }\n\n    /**\n     * Creates the job for a single file.\n     *\n     * @param file the file to check\n     */\n    public RunCheckstyleOnFilesJob(IFile file) {\n        super(Messages.RunCheckstyleOnFilesJob_title);\n        mFilesToCheck = new ArrayList();\n        mFilesToCheck.add(file);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public IStatus runInWorkspace(IProgressMonitor monitor) throws CoreException {\n        try {\n            Map projectFilesMap = getFilesSortedToProject(mFilesToCheck);\n            Iterator it = projectFilesMap.keySet().iterator();\n            while (it.hasNext()) {\n                IProject project = (IProject) it.next();\n                List files = (List) projectFilesMap.get(project);\n                IProjectConfiguration checkConfig = ProjectConfigurationFactory.getConfiguration(project);\n                filter(files, checkConfig);\n                CheckstyleBuilder builder = new CheckstyleBuilder();\n                builder.handleBuildSelection(files, checkConfig, monitor, project, IncrementalProjectBuilder.INCREMENTAL_BUILD);\n            }\n        } catch (CheckstylePluginException e) {\n            Status status = new Status(IStatus.ERROR, CheckstylePlugin.PLUGIN_ID, IStatus.ERROR, e.getLocalizedMessage(), e);\n            throw new CoreException(status);\n        }\n        return Status.OK_STATUS;\n    }\n\n    private Map getFilesSortedToProject(List filesToCheck) {\n        Map projectFilesMap = new HashMap();\n        for (int i = 0, size = filesToCheck.size(); i < size; i++) {\n            IFile file = (IFile) filesToCheck.get(i);\n            IProject project = file.getProject();\n            List projectFiles = (List) projectFilesMap.get(project);\n            if (projectFiles == null) {\n                projectFiles = new ArrayList();\n                projectFilesMap.put(project, projectFiles);\n            }\n            projectFiles.add(file);\n        }\n        return projectFilesMap;\n    }\n\n    private void filter(List files, IProjectConfiguration projectConfig) {\n        List filters = projectConfig.getFilters();\n        Iterator it = filters.iterator();\n        while (it.hasNext()) {\n            IFilter filter = (IFilter) it.next();\n            Iterator filesIt = files.iterator();\n            while (filesIt.hasNext()) {\n                IResource file = (IResource) filesIt.next();\n                if (filter.isEnabled() && !filter.accept(file)) {\n                    filesIt.remove();\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/builder/RunCheckstyleOnFilesJob.java",
		"test_prompt": "// RunCheckstyleOnFilesJobTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IncrementalProjectBuilder;\nimport org.eclipse.core.resources.WorkspaceJob;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.IProjectConfiguration;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.ProjectConfigurationFactory;\nimport com.atlassw.tools.eclipse.checkstyle.projectconfig.filters.IFilter;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RunCheckstyleOnFilesJob}.\n* It contains ten unit test cases for the {@link RunCheckstyleOnFilesJob#runInWorkspace(IProgressMonitor)} method.\n*/\nclass RunCheckstyleOnFilesJobTest {"
	},
	{
		"original_code": "// PackageNamesLoader.java\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2005  Oliver Burn\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.api.AbstractLoader;\n\n/**\n * Loads a list of package names from a package name XML file.\n *\n * @author Rick Giles\n * @version 4-Dec-2002\n */\npublic final class PackageNamesLoader extends AbstractLoader {\n\n    /**\n     * the public ID for the configuration dtd.\n     */\n    //$NON-NLS-1$\n    private static final String DTD_PUBLIC_ID = \"-//Puppy Crawl//DTD Package Names 1.0//EN\";\n\n    /**\n     * the resource for the configuration dtd.\n     */\n    //$NON-NLS-1$\n    private static final String DTD_RESOURCE_NAME = \"com/puppycrawl/tools/checkstyle/packages_1_0.dtd\";\n\n    /**\n     * Name of default checkstyle package names resource file. The file must be\n     * in the classpath.\n     */\n    //$NON-NLS-1$\n    private static final String DEFAULT_PACKAGES = \"com/puppycrawl/tools/checkstyle/checkstyle_packages.xml\";\n\n    /**\n     * The loaded package names.\n     */\n    private Stack mPackageStack = new Stack();\n\n    private static List sPackages;\n\n    /**\n     * Creates a new <code>PackageNamesLoader</code> instance.\n     *\n     * @throws ParserConfigurationException if an error occurs\n     * @throws SAXException if an error occurs\n     */\n    private PackageNamesLoader() throws ParserConfigurationException, SAXException {\n        super(DTD_PUBLIC_ID, DTD_RESOURCE_NAME);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void startElement(String aNamespaceURI, String aLocalName, String aQName, Attributes aAtts) throws SAXException {\n        if (//$NON-NLS-1$\n        aQName.equals(\"package\")) {\n            // push package name\n            //$NON-NLS-1$\n            final String name = aAtts.getValue(\"name\");\n            if (name == null) {\n                //$NON-NLS-1$\n                throw new SAXException(\"missing package name\");\n            }\n            mPackageStack.push(name);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void endElement(String aNamespaceURI, String aLocalName, String aQName) {\n        if (//$NON-NLS-1$\n        aQName.equals(\"package\")) {\n            String packageName = getPackageName();\n            if (!sPackages.contains(packageName)) {\n                sPackages.add(packageName);\n            }\n            mPackageStack.pop();\n        }\n    }\n\n    /**\n     * Creates a full package name from the package names on the stack.\n     *\n     * @return the full name of the current package.\n     */\n    private String getPackageName() {\n        final StringBuffer buf = new StringBuffer();\n        final Iterator it = mPackageStack.iterator();\n        while (it.hasNext()) {\n            final String subPackage = (String) it.next();\n            buf.append(subPackage);\n            if (//$NON-NLS-1$\n            !subPackage.endsWith(\".\")) {\n                //$NON-NLS-1$\n                buf.append(\".\");\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Returns the default list of package names.\n     *\n     * @param aClassLoader the class loader that gets the default package names.\n     * @return the default list of package names.\n     * @throws CheckstylePluginException if an error occurs.\n     */\n    public static List getPackageNames(ClassLoader aClassLoader) throws CheckstylePluginException {\n        if (sPackages == null) {\n            sPackages = new ArrayList();\n            PackageNamesLoader nameLoader = null;\n            try {\n                nameLoader = new PackageNamesLoader();\n                final InputStream stream = aClassLoader.getResourceAsStream(DEFAULT_PACKAGES);\n                InputSource source = new InputSource(stream);\n                nameLoader.parseInputSource(source);\n            } catch (ParserConfigurationException e) {\n                //$NON-NLS-1$\n                CheckstylePluginException.rethrow(e, \"unable to parse \" + DEFAULT_PACKAGES);\n            } catch (SAXException e) {\n                CheckstylePluginException.rethrow(e, //$NON-NLS-1$ //$NON-NLS-2$\n                \"unable to parse \" + DEFAULT_PACKAGES + \" - \" + e.getMessage());\n            } catch (IOException e) {\n                //$NON-NLS-1$\n                CheckstylePluginException.rethrow(e, \"unable to read \" + DEFAULT_PACKAGES);\n            }\n            // load custom package files\n            try {\n                //$NON-NLS-1$\n                Enumeration packageFiles = aClassLoader.getResources(\"checkstyle_packages.xml\");\n                while (packageFiles.hasMoreElements()) {\n                    URL aPackageFile = (URL) packageFiles.nextElement();\n                    InputStream iStream = null;\n                    try {\n                        iStream = new BufferedInputStream(aPackageFile.openStream());\n                        InputSource source = new InputSource(iStream);\n                        nameLoader.parseInputSource(source);\n                    } catch (SAXException e) {\n                        CheckstyleLog.log(e, //$NON-NLS-1$\n                        \"unable to parse \" + aPackageFile.toExternalForm() + \" - \" + //$NON-NLS-1$\n                        e.getLocalizedMessage());\n                    } catch (IOException e) {\n                        //$NON-NLS-1$\n                        CheckstyleLog.log(e, \"unable to read \" + aPackageFile.toExternalForm());\n                    } finally {\n                        IOUtils.closeQuietly(iStream);\n                    }\n                }\n            } catch (IOException e1) {\n                CheckstylePluginException.rethrow(e1);\n            }\n        }\n        return sPackages;\n    }\n\n    /**\n     * Refreshes the cached package names.\n     */\n    public static void refresh() {\n        sPackages = null;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/builder/PackageNamesLoader.java",
		"test_prompt": "// PackageNamesLoaderTest.java\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2005  Oliver Burn\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.apache.commons.io.IOUtils;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport com.puppycrawl.tools.checkstyle.api.AbstractLoader;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PackageNamesLoader}.\n* It contains ten unit test cases for the {@link PackageNamesLoader#getPackageNames(ClassLoader)} method.\n*/\nclass PackageNamesLoaderTest {"
	},
	{
		"original_code": "// ProjectClassLoader.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.URLStreamHandlerFactory;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.HashSet;\nimport java.util.List;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IFolder;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.jdt.core.IClasspathEntry;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.JavaModelException;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\n\n/**\n * ClassLoader to make the contents of a eclipse project accessible for the\n * style checking process. <br/>After construction the classloader can be\n * initialized with a eclipse project. Reinitialization and reuse of the\n * classloader with another project is possible.\n *\n * @author Lars K�dderitzsch\n */\npublic class ProjectClassLoader extends ClassLoader {\n\n    //\n    // attributes\n    //\n    /**\n     * the classloader delegate.\n     */\n    private ClassLoader mDelegateClassLoader;\n\n    /**\n     * the parent classloader.\n     */\n    private ClassLoader mParentClassLoader;\n\n    /**\n     * the URLStreamHandlerFactory to provide support for non standard\n     * protocols.\n     */\n    private URLStreamHandlerFactory mStreamHandlerFactory;\n\n    //\n    // constructors\n    //\n    /**\n     * Constructs the classloader.\n     */\n    public ProjectClassLoader() {\n        this(null);\n    }\n\n    /**\n     * Constructs the classloader and uses a parent classloader.\n     *\n     * @param parent the parent classloader\n     */\n    public ProjectClassLoader(ClassLoader parent) {\n        this(parent, null);\n    }\n\n    /**\n     * Constructs the classloader and uses a parent classloader and a handler to\n     * support non-standard protocols.\n     *\n     * @param parent the parent classloader\n     * @param factory the streamhandler factory\n     */\n    public ProjectClassLoader(ClassLoader parent, URLStreamHandlerFactory factory) {\n        this.mParentClassLoader = parent;\n        this.mStreamHandlerFactory = factory;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * Initializes this classloader with a given eclipse project.\n     *\n     * @param project the project\n     */\n    public void intializeWithProject(IProject project) {\n        // Optimization if the project is the same as last\n        // if (project == this.mRecentProject)\n        // {\n        // return;\n        // }\n        URL[] projClassPath = getProjectClassPath(project);\n        //        // log the complete classpath to track down these pesky\n        //        // NoClassDefFound-Errors\n        //        StringBuffer buf = new StringBuffer();\n        //        buf.append(\"Checkstyle Classpath for project\\\"\").append(project.getName()).append(\"\\\":\");\n        //        for (int i = 0; i < projClassPath.length; i++)\n        //        {\n        //            buf.append(\"\\n\").append(projClassPath[i].toExternalForm());\n        //        }\n        //        IStatus status = new Status(IStatus.INFO, CheckstylePlugin.PLUGIN_ID, IStatus.OK, buf\n        //                .toString(), null);\n        //        CheckstylePlugin.getDefault().getLog().log(status);\n        this.mDelegateClassLoader = new URLClassLoader(projClassPath, this.mParentClassLoader, this.mStreamHandlerFactory);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Class loadClass(String name) throws ClassNotFoundException {\n        return this.mDelegateClassLoader.loadClass(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public URL getResource(String name) {\n        return this.mDelegateClassLoader.getResource(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public InputStream getResourceAsStream(String name) {\n        return this.mDelegateClassLoader.getResourceAsStream(name);\n    }\n\n    /**\n     * Since java.lang.ClassLoader#getResources(java.lang.String) is final\n     * (why?) this method is overridden as a workaround.\n     *\n     * @see java.lang.ClassLoader#findResources(java.lang.String)\n     */\n    protected Enumeration findResources(String name) throws IOException {\n        return this.mDelegateClassLoader.getResources(name);\n    }\n\n    /**\n     * Gets the complete classpath for a given project.\n     *\n     * @param project the project\n     * @return the classpath\n     */\n    private static URL[] getProjectClassPath(IProject project) {\n        // List to contain the classpath urls\n        List cpURLs = new ArrayList();\n        // add the projects contents to the classpath\n        addToClassPath(project, cpURLs, false, new HashSet());\n        URL[] urls = (URL[]) cpURLs.toArray(new URL[cpURLs.size()]);\n        return urls;\n    }\n\n    /**\n     * Adds the contents of a project to list of URLs.\n     *\n     * @param project the project\n     * @param cpURLs the resulting list\n     * @param isReferenced true if a referenced project is processed\n     */\n    private static void addToClassPath(IProject project, List cpURLs, boolean isReferenced, Collection processedProjects) {\n        try {\n            // this project has already been added\n            if (processedProjects.contains(project)) {\n                return;\n            } else {\n                processedProjects.add(project);\n            }\n            // get the java project\n            IJavaProject javaProject = JavaCore.create(project);\n            // get the resolved classpath of the project\n            IClasspathEntry[] cpEntries = javaProject.getResolvedClasspath(true);\n            // iterate over classpath to create classpath urls\n            int size = cpEntries.length;\n            for (int i = 0; i < size; i++) {\n                int entryKind = cpEntries[i].getEntryKind();\n                // handle a source path\n                if (IClasspathEntry.CPE_SOURCE == entryKind) {\n                    handleSourcePath(project, cpURLs, cpEntries[i], javaProject);\n                } else // handle a project reference\n                if (IClasspathEntry.CPE_PROJECT == entryKind) {\n                    handleRefProject(cpURLs, cpEntries[i], processedProjects);\n                } else // handle a library entry\n                if (IClasspathEntry.CPE_LIBRARY == entryKind) {\n                    handleLibrary(project, cpURLs, cpEntries[i]);\n                } else // cannot happen since we use a resolved classpath\n                {\n                    // log as exception\n                    CheckstylePluginException ex = new CheckstylePluginException(NLS.bind(ErrorMessages.errorUnknownClasspathEntry, cpEntries[i].getPath()));\n                    CheckstyleLog.log(ex);\n                }\n            }\n        } catch (JavaModelException jme) {\n            CheckstyleLog.log(jme);\n        }\n    }\n\n    /**\n     * Helper method to handle a source path.\n     *\n     * @param project the original project\n     * @param cpURLs the list that is to contain the projects classpath\n     * @param entry the actually processed classpath entry\n     * @param javapProject the java project\n     * @throws JavaModelException an exception with the java project occured\n     */\n    private static void handleSourcePath(IProject project, List cpURLs, IClasspathEntry entry, IJavaProject javapProject) throws JavaModelException {\n        IPath sourcePath = entry.getPath();\n        // check for if the output path is different to the source path\n        IPath outputPath = entry.getOutputLocation();\n        if (outputPath == null) {\n            sourcePath = javapProject.getOutputLocation();\n        } else if (!outputPath.equals(sourcePath)) {\n            // make the output path the relevant path since it contains the\n            // class files\n            sourcePath = outputPath;\n        }\n        // check if the sourcepath is relative to the project\n        IPath projPath = project.getFullPath();\n        if (!projPath.equals(sourcePath) && sourcePath.matchingFirstSegments(projPath) > 0) {\n            // remove the project part from the source path\n            sourcePath = sourcePath.removeFirstSegments(projPath.segmentCount());\n            // get the folder for the path\n            IFolder sourceFolder = project.getFolder(sourcePath);\n            // get the absolute path for the folder\n            sourcePath = sourceFolder.getLocation();\n        } else if (projPath.equals(sourcePath)) {\n            sourcePath = project.getLocation();\n        }\n        // try to add the path to the classpath\n        handlePath(sourcePath, cpURLs);\n    }\n\n    /**\n     * Helper method to handle a referenced project for the classpath.\n     *\n     * @param cpURLs the list that is to contain the projects classpath\n     * @param entry the actually processed classpath entry\n     */\n    private static void handleRefProject(List cpURLs, IClasspathEntry entry, Collection processedProjects) {\n        // get the referenced project from the workspace\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IProject referencedProject = root.getProject(entry.getPath().toString());\n        // add the referenced projects contents\n        if (referencedProject.exists()) {\n            addToClassPath(referencedProject, cpURLs, true, processedProjects);\n        }\n    }\n\n    /**\n     * Helper method to handle a library for the classpath.\n     *\n     * @param project the original project\n     * @param cpURLs the list that is to contain the projects classpath\n     * @param entry the actually processed classpath entry\n     */\n    private static void handleLibrary(IProject project, List cpURLs, IClasspathEntry entry) {\n        IPath libPath = entry.getPath();\n        // check if the library path is relative to the project\n        // can happen if the library is contained within the project\n        IPath projPath = project.getFullPath();\n        if (libPath.matchingFirstSegments(projPath) > 0) {\n            // remove the project part from the source path\n            libPath = libPath.removeFirstSegments(projPath.segmentCount());\n            // fixes 1422937 - Thanks to Peter Hendriks\n            if (// added check\n            !libPath.isEmpty()) {\n                // get the file handle for the library\n                IFile file = project.getFile(libPath);\n                // get the absolute path for the library file\n                libPath = file.getLocation();\n            } else {\n                // fallback to project root when libPath is empty\n                libPath = project.getLocation();\n            }\n        } else {\n            // Check if the resource is otherwise relative to the workspace\n            IResource resource = CheckstylePlugin.getWorkspace().getRoot().findMember(libPath);\n            if (resource != null && resource.exists()) {\n                libPath = resource.getLocation();\n            }\n        }\n        // try to add the path to the classpath\n        handlePath(libPath, cpURLs);\n    }\n\n    /**\n     * Helper method to handle an absolute path for the classpath.\n     *\n     * @param absolutePath the absolute path\n     * @param cpURLs the list that is to contain the projects classpath\n     */\n    private static void handlePath(IPath absolutePath, List cpURLs) {\n        if (absolutePath != null) {\n            File file = absolutePath.toFile();\n            // check if the file exists\n            if (file != null && file.exists()) {\n                try {\n                    URL url = file.toURL();\n                    if (!cpURLs.contains(url)) {\n                        cpURLs.add(url);\n                    }\n                } catch (MalformedURLException mfe) {\n                    // log the exception although this should not happen\n                    CheckstyleLog.log(mfe, mfe.getLocalizedMessage());\n                }\n            }\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/builder/ProjectClassLoader.java",
		"test_prompt": "// ProjectClassLoaderTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.URLStreamHandlerFactory;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.HashSet;\nimport java.util.List;\nimport org.eclipse.core.resources.IFile;\nimport org.eclipse.core.resources.IFolder;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.IWorkspaceRoot;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.jdt.core.IClasspathEntry;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.JavaCore;\nimport org.eclipse.jdt.core.JavaModelException;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.CheckstylePlugin;\nimport com.atlassw.tools.eclipse.checkstyle.ErrorMessages;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstyleLog;\nimport com.atlassw.tools.eclipse.checkstyle.util.CheckstylePluginException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProjectClassLoader}.\n* It contains ten unit test cases for the {@link ProjectClassLoader#loadClass(String)} method.\n*/\nclass ProjectClassLoaderTest {"
	},
	{
		"original_code": "// BuildProjectJob.java\n//============================================================================\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.nature.CheckstyleNature;\n\n/**\n * Operation which builds a project.\n *\n * @author Lars K�dderitzsch\n */\npublic class BuildProjectJob extends Job {\n\n    //\n    // attributes\n    //\n    /**\n     * the project to build.\n     */\n    private IProject[] mProjects;\n\n    /**\n     * the build kind.\n     */\n    private int mKind;\n\n    //\n    // constructors\n    //\n    /**\n     * Creates an operation which builds a project.\n     *\n     * @param project the project to build\n     * @param buildKind the kind of build to do\n     */\n    public BuildProjectJob(IProject project, int buildKind) {\n        super(NLS.bind(Messages.BuildProjectJob_msgBuildProject, project.getName()));\n        mProjects = new IProject[] { project };\n        mKind = buildKind;\n    }\n\n    /**\n     * Creates an operation which builds a set of project.\n     *\n     * @param projects the projects to build\n     * @param buildKind the kind of build to do\n     */\n    public BuildProjectJob(IProject[] projects, int buildKind) {\n        super(Messages.BuildProjectJob_msgBuildAllProjects);\n        mProjects = projects;\n        mKind = buildKind;\n    }\n\n    //\n    // methods\n    //\n    /**\n     * {@inheritDoc}\n     */\n    public IStatus run(IProgressMonitor monitor) {\n        IStatus status = null;\n        try {\n            for (int i = 0; i < mProjects.length; i++) {\n                // build only if open and checkstyle active for the project\n                if (mProjects[i].isOpen() && mProjects[i].hasNature(CheckstyleNature.NATURE_ID)) {\n                    mProjects[i].build(mKind, monitor);\n                }\n            }\n            status = Status.OK_STATUS;\n        } catch (CoreException e) {\n            status = e.getStatus();\n        } finally {\n            monitor.done();\n        }\n        return status;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/106_checkstyle/src/main/java/com/atlassw/tools/eclipse/checkstyle/builder/BuildProjectJob.java",
		"test_prompt": "// BuildProjectJobTest.java\n//\n// Copyright (C) 2002-2007  David Schneider, Lars K�dderitzsch\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n//============================================================================\npackage com.atlassw.tools.eclipse.checkstyle.builder;\n\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.osgi.util.NLS;\nimport com.atlassw.tools.eclipse.checkstyle.Messages;\nimport com.atlassw.tools.eclipse.checkstyle.nature.CheckstyleNature;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BuildProjectJob}.\n* It contains ten unit test cases for the {@link BuildProjectJob#run(IProgressMonitor)} method.\n*/\nclass BuildProjectJobTest {"
	}
]