[
	{
		"original_code": "// BinaryParser.java\npackage sf.noen.server.parser;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * @author Teemu Kanstrén\r\n */\r\npublic class BinaryParser implements Runnable {\r\n\r\n    private final InputStream in;\r\n\r\n    private boolean running = true;\r\n\r\n    public BinaryParser(InputStream in) {\r\n        this.in = new BufferedInputStream(in);\r\n    }\r\n\r\n    //parse each msg andstore to db.. is there some point to do this actually? it becomes the same as the python one\r\n    //and implementing anything else is hard...\r\n    public void stop() {\r\n        running = false;\r\n    }\r\n\r\n    public void run() {\r\n        while (running) {\r\n            try {\r\n                int b = in.read();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public int parseInteger() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseBoolean() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseByte() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseText() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/sf/noen/server/parser/BinaryParser_0Test.java",
		"test_prompt": "// BinaryParser_0Test.java\npackage sf.noen.server.parser;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryParser}.\n* It contains ten unit test cases for the {@link BinaryParser#parseInteger()} method.\n*/\nclass BinaryParser_0Test {"
	},
	{
		"original_code": "// BinaryParser.java\npackage sf.noen.server.parser;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * @author Teemu Kanstrén\r\n */\r\npublic class BinaryParser implements Runnable {\r\n\r\n    private final InputStream in;\r\n\r\n    private boolean running = true;\r\n\r\n    public BinaryParser(InputStream in) {\r\n        this.in = new BufferedInputStream(in);\r\n    }\r\n\r\n    //parse each msg andstore to db.. is there some point to do this actually? it becomes the same as the python one\r\n    //and implementing anything else is hard...\r\n    public void stop() {\r\n        running = false;\r\n    }\r\n\r\n    public void run() {\r\n        while (running) {\r\n            try {\r\n                int b = in.read();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public int parseInteger() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseBoolean() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseByte() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseText() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/sf/noen/server/parser/BinaryParser_1Test.java",
		"test_prompt": "// BinaryParser_1Test.java\npackage sf.noen.server.parser;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryParser}.\n* It contains ten unit test cases for the {@link BinaryParser#parseBoolean()} method.\n*/\nclass BinaryParser_1Test {"
	},
	{
		"original_code": "// BinaryParser.java\npackage sf.noen.server.parser;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * @author Teemu Kanstrén\r\n */\r\npublic class BinaryParser implements Runnable {\r\n\r\n    private final InputStream in;\r\n\r\n    private boolean running = true;\r\n\r\n    public BinaryParser(InputStream in) {\r\n        this.in = new BufferedInputStream(in);\r\n    }\r\n\r\n    //parse each msg andstore to db.. is there some point to do this actually? it becomes the same as the python one\r\n    //and implementing anything else is hard...\r\n    public void stop() {\r\n        running = false;\r\n    }\r\n\r\n    public void run() {\r\n        while (running) {\r\n            try {\r\n                int b = in.read();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public int parseInteger() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseBoolean() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseByte() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseText() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/sf/noen/server/parser/BinaryParser_2Test.java",
		"test_prompt": "// BinaryParser_2Test.java\npackage sf.noen.server.parser;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryParser}.\n* It contains ten unit test cases for the {@link BinaryParser#parseByte()} method.\n*/\nclass BinaryParser_2Test {"
	},
	{
		"original_code": "// BinaryParser.java\npackage sf.noen.server.parser;\r\n\r\nimport java.io.BufferedInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\n\r\n/**\r\n * @author Teemu Kanstrén\r\n */\r\npublic class BinaryParser implements Runnable {\r\n\r\n    private final InputStream in;\r\n\r\n    private boolean running = true;\r\n\r\n    public BinaryParser(InputStream in) {\r\n        this.in = new BufferedInputStream(in);\r\n    }\r\n\r\n    //parse each msg andstore to db.. is there some point to do this actually? it becomes the same as the python one\r\n    //and implementing anything else is hard...\r\n    public void stop() {\r\n        running = false;\r\n    }\r\n\r\n    public void run() {\r\n        while (running) {\r\n            try {\r\n                int b = in.read();\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public int parseInteger() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseBoolean() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseByte() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n\r\n    public boolean parseText() {\r\n        throw new RuntimeException(\"Not implemented\");\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/sf/noen/server/parser/BinaryParser_3Test.java",
		"test_prompt": "// BinaryParser_3Test.java\npackage sf.noen.server.parser;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BinaryParser}.\n* It contains ten unit test cases for the {@link BinaryParser#parseText()} method.\n*/\nclass BinaryParser_3Test {"
	},
	{
		"original_code": "// WicketApplication.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage sf.noen.webui.wicket;\r\n\r\nimport org.apache.wicket.protocol.http.WebApplication;\r\nimport org.apache.wicket.Page;\r\nimport org.apache.wicket.Session;\r\nimport org.apache.wicket.Request;\r\nimport org.apache.wicket.Response;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class WicketApplication extends WebApplication {\r\n\r\n    public Class<? extends Page> getHomePage() {\r\n        return StartPage.class;\r\n    }\r\n\r\n    @Override\r\n    public Session newSession(Request request, Response response) {\r\n        return new NoenSession(request);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/sf/noen/webui/wicket/WicketApplication.java",
		"test_prompt": "// WicketApplicationTest.java\npackage sf.noen.webui.wicket;\n\nimport org.apache.wicket.protocol.http.WebApplication;\nimport org.apache.wicket.Page;\nimport org.apache.wicket.Session;\nimport org.apache.wicket.Request;\nimport org.apache.wicket.Response;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WicketApplication}.\n* It contains ten unit test cases for the {@link WicketApplication#newSession(Request, Response)} method.\n*/\nclass WicketApplicationTest {"
	},
	{
		"original_code": "// Update.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage sf.noen.webui.model;\r\n\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * Describes an update for the table of test results in the web UI.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class Update implements Serializable {\r\n\r\n    private final String name;\r\n\r\n    private final String status;\r\n\r\n    private final String description;\r\n\r\n    public final UpdateType type;\r\n\r\n    public final String style;\r\n\r\n    public Update(String name, String status, String description, UpdateType type, String style) {\r\n        this.name = name;\r\n        this.status = status;\r\n        this.description = description;\r\n        this.type = type;\r\n        this.style = style;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getStatus() {\r\n        return status;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    public boolean isNew() {\r\n        if (type == UpdateType.TEST_STARTED || type == UpdateType.SUITE_STARTED || type == UpdateType.TEST_IGNORED) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/sf/noen/webui/model/Update.java",
		"test_prompt": "// UpdateTest.java\npackage sf.noen.webui.model;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Update}.\n* It contains ten unit test cases for the {@link Update#isNew()} method.\n*/\nclass UpdateTest {"
	},
	{
		"original_code": "// UpdateStatus.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage sf.noen.webui.model;\r\n\r\nimport org.junit.runner.Description;\r\nimport org.junit.runner.Result;\r\nimport org.junit.runner.notification.RunListener;\r\nimport org.junit.runner.notification.Failure;\r\nimport java.util.*;\r\nimport java.io.Serializable;\r\nimport java.io.PrintWriter;\r\nimport java.io.StringWriter;\r\nimport java.io.Writer;\r\n\r\n/**\r\n * Holds a collection of updates that have not yet been processed (shown) by the UI manager.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class UpdateStatus extends RunListener implements Serializable {\r\n\r\n    private Collection<Update> updates = new Vector<Update>();\r\n\r\n    private Map<String, String> failedTests = new HashMap<String, String>();\r\n\r\n    public Collection<Update> getUpdates() {\r\n        ArrayList<Update> updatesClone = new ArrayList<Update>();\r\n        updatesClone.addAll(updates);\r\n        return updatesClone;\r\n    }\r\n\r\n    public void processed(Update update) {\r\n        updates.remove(update);\r\n    }\r\n\r\n    @Override\r\n    public void testRunStarted(Description description) throws Exception {\r\n        update(\"Suite\", \"Started\", \"Tests being executed\", UpdateType.SUITE_STARTED);\r\n    }\r\n\r\n    @Override\r\n    public void testRunFinished(Result result) throws Exception {\r\n        update(\"Suite\", \"Finished\", \"All tests done\", UpdateType.SUITE_FINISHED);\r\n    }\r\n\r\n    @Override\r\n    public void testStarted(Description description) throws Exception {\r\n        update(description.getDisplayName(), \"Started\", \"Test started\", UpdateType.TEST_STARTED);\r\n    }\r\n\r\n    @Override\r\n    public void testFinished(Description description) throws Exception {\r\n        String name = description.getDisplayName();\r\n        if (failedTests.get(name) != null) {\r\n            update(name, \"Failed\", failedTests.get(name), UpdateType.TEST_FAILED);\r\n        } else {\r\n            update(name, \"OK\", \"Test passed\", UpdateType.TEST_FINISHED);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void testFailure(Failure failure) throws Exception {\r\n        String name = failure.getDescription().getDisplayName();\r\n        //    update(name, \"Failed:\"+failure.getMessage(), UpdateType.TEST_FAILED);\r\n        String msg = getStackTrace(failure.getException());\r\n        failedTests.put(name, msg);\r\n    }\r\n\r\n    @Override\r\n    public void testAssumptionFailure(Failure failure) {\r\n        update(failure.getDescription().getDisplayName(), \"Assumption failure:\", failure.getMessage(), UpdateType.ASSUMPTION_FAILED);\r\n    }\r\n\r\n    @Override\r\n    public void testIgnored(Description description) throws Exception {\r\n        update(description.getDisplayName(), \"Ignored\", \"Test not executed\", UpdateType.TEST_IGNORED);\r\n    }\r\n\r\n    private void update(String name, String status, String description, UpdateType type) {\r\n        Update update = new Update(name, status, description, type, type.css);\r\n        updates.add(update);\r\n    }\r\n\r\n    public static String getStackTrace(Throwable aThrowable) {\r\n        final Writer result = new StringWriter();\r\n        final PrintWriter printWriter = new PrintWriter(result);\r\n        aThrowable.printStackTrace(printWriter);\r\n        return result.toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/sf/noen/webui/model/UpdateStatus.java",
		"test_prompt": "// UpdateStatusTest.java\npackage sf.noen.webui.model;\n\nimport org.junit.runner.Description;\nimport org.junit.runner.Result;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runner.notification.Failure;\nimport java.util.*;\nimport java.io.Serializable;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link UpdateStatus}.\n* It contains ten unit test cases for the {@link UpdateStatus#getStackTrace(Throwable)} method.\n*/\nclass UpdateStatusTest {"
	},
	{
		"original_code": "// Configuration.java\n/*\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\n *\n * This file is part of NOEN framework.\n *\n * NOEN framework is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2.\n *\n * NOEN framework is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage sf.noen.webui.model;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\n/**\n * @author Teemu Kanstrén\n */\npublic class Configuration {\n\n    /**\n     * Class to test, should contain JUnit tests/suite.\n     */\n    private static String testClassName = null;\n\n    private static Properties properties = null;\n\n    public static synchronized String getTestClassName() {\n        if (testClassName == null) {\n            testClassName = property(\"testclass\");\n        }\n        return testClassName;\n    }\n\n    private static synchronized String property(String key) {\n        try {\n            if (properties == null) {\n                properties = new Properties();\n                properties.load(Configuration.class.getClassLoader().getResourceAsStream(\"noen-testui.properties\"));\n            }\n            return properties.getProperty(key);\n        } catch (IOException e) {\n            throw new RuntimeException(\"UNable to load configuration file 'noen-testui.properties'\", e);\n        }\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/sf/noen/webui/model/Configuration.java",
		"test_prompt": "// ConfigurationTest.java\npackage sf.noen.webui.model;\n\nimport java.io.IOException;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Configuration}.\n* It contains ten unit test cases for the {@link Configuration#getTestClassName()} method.\n*/\nclass ConfigurationTest {"
	},
	{
		"original_code": "// StringUtils.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen;\r\n\r\nimport java.io.InputStream;\r\nimport java.io.IOException;\r\nimport java.io.ByteArrayOutputStream;\r\n\r\n/**\r\n * Some utilities for handling of strings.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StringUtils {\r\n\r\n    public static final String ln = \"\\n\";\r\n\r\n    public static String prefixWith(String content, String prefix) {\r\n        String[] lines = content.split(ln);\r\n        String result = \"\";\r\n        for (String line : lines) {\r\n            result += prefix + line + ln;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Capitalizes the first letter of given string.\r\n     *\r\n     * @param text The text to capitalize.\r\n     * @return Same stuff as given in input, but with first letter in uppercase.\r\n     */\r\n    public static String capitalizeFirstLetter(String text) {\r\n        String temp = text.substring(0, 1).toUpperCase();\r\n        text = temp + text.substring(1);\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Lowercases the first letter of given string.\r\n     *\r\n     * @param text The text to lowercase.\r\n     * @return Same stuff as given in input, but with first letter in lowercase.\r\n     */\r\n    public static String lowerCaseFirstLetter(String text) {\r\n        String temp = text.substring(0, 1).toLowerCase();\r\n        text = temp + text.substring(1);\r\n        return text;\r\n    }\r\n\r\n    public static String stringForStream(InputStream in) throws IOException {\r\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n        byte[] bytes = new byte[512];\r\n        int readBytes;\r\n        while ((readBytes = in.read(bytes)) > 0) {\r\n            out.write(bytes, 0, readBytes);\r\n        }\r\n        return new String(out.toByteArray());\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/StringUtils_0Test.java",
		"test_prompt": "// StringUtils_0Test.java\npackage fi.vtt.noen.testgen;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.ByteArrayOutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#prefixWith(String, String)} method.\n*/\nclass StringUtils_0Test {"
	},
	{
		"original_code": "// StringUtils.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen;\r\n\r\nimport java.io.InputStream;\r\nimport java.io.IOException;\r\nimport java.io.ByteArrayOutputStream;\r\n\r\n/**\r\n * Some utilities for handling of strings.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StringUtils {\r\n\r\n    public static final String ln = \"\\n\";\r\n\r\n    public static String prefixWith(String content, String prefix) {\r\n        String[] lines = content.split(ln);\r\n        String result = \"\";\r\n        for (String line : lines) {\r\n            result += prefix + line + ln;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Capitalizes the first letter of given string.\r\n     *\r\n     * @param text The text to capitalize.\r\n     * @return Same stuff as given in input, but with first letter in uppercase.\r\n     */\r\n    public static String capitalizeFirstLetter(String text) {\r\n        String temp = text.substring(0, 1).toUpperCase();\r\n        text = temp + text.substring(1);\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Lowercases the first letter of given string.\r\n     *\r\n     * @param text The text to lowercase.\r\n     * @return Same stuff as given in input, but with first letter in lowercase.\r\n     */\r\n    public static String lowerCaseFirstLetter(String text) {\r\n        String temp = text.substring(0, 1).toLowerCase();\r\n        text = temp + text.substring(1);\r\n        return text;\r\n    }\r\n\r\n    public static String stringForStream(InputStream in) throws IOException {\r\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n        byte[] bytes = new byte[512];\r\n        int readBytes;\r\n        while ((readBytes = in.read(bytes)) > 0) {\r\n            out.write(bytes, 0, readBytes);\r\n        }\r\n        return new String(out.toByteArray());\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/StringUtils_1Test.java",
		"test_prompt": "// StringUtils_1Test.java\npackage fi.vtt.noen.testgen;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.ByteArrayOutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#capitalizeFirstLetter(String)} method.\n*/\nclass StringUtils_1Test {"
	},
	{
		"original_code": "// StringUtils.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen;\r\n\r\nimport java.io.InputStream;\r\nimport java.io.IOException;\r\nimport java.io.ByteArrayOutputStream;\r\n\r\n/**\r\n * Some utilities for handling of strings.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StringUtils {\r\n\r\n    public static final String ln = \"\\n\";\r\n\r\n    public static String prefixWith(String content, String prefix) {\r\n        String[] lines = content.split(ln);\r\n        String result = \"\";\r\n        for (String line : lines) {\r\n            result += prefix + line + ln;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Capitalizes the first letter of given string.\r\n     *\r\n     * @param text The text to capitalize.\r\n     * @return Same stuff as given in input, but with first letter in uppercase.\r\n     */\r\n    public static String capitalizeFirstLetter(String text) {\r\n        String temp = text.substring(0, 1).toUpperCase();\r\n        text = temp + text.substring(1);\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Lowercases the first letter of given string.\r\n     *\r\n     * @param text The text to lowercase.\r\n     * @return Same stuff as given in input, but with first letter in lowercase.\r\n     */\r\n    public static String lowerCaseFirstLetter(String text) {\r\n        String temp = text.substring(0, 1).toLowerCase();\r\n        text = temp + text.substring(1);\r\n        return text;\r\n    }\r\n\r\n    public static String stringForStream(InputStream in) throws IOException {\r\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n        byte[] bytes = new byte[512];\r\n        int readBytes;\r\n        while ((readBytes = in.read(bytes)) > 0) {\r\n            out.write(bytes, 0, readBytes);\r\n        }\r\n        return new String(out.toByteArray());\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/StringUtils_2Test.java",
		"test_prompt": "// StringUtils_2Test.java\npackage fi.vtt.noen.testgen;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.ByteArrayOutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#lowerCaseFirstLetter(String)} method.\n*/\nclass StringUtils_2Test {"
	},
	{
		"original_code": "// StringUtils.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen;\r\n\r\nimport java.io.InputStream;\r\nimport java.io.IOException;\r\nimport java.io.ByteArrayOutputStream;\r\n\r\n/**\r\n * Some utilities for handling of strings.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StringUtils {\r\n\r\n    public static final String ln = \"\\n\";\r\n\r\n    public static String prefixWith(String content, String prefix) {\r\n        String[] lines = content.split(ln);\r\n        String result = \"\";\r\n        for (String line : lines) {\r\n            result += prefix + line + ln;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Capitalizes the first letter of given string.\r\n     *\r\n     * @param text The text to capitalize.\r\n     * @return Same stuff as given in input, but with first letter in uppercase.\r\n     */\r\n    public static String capitalizeFirstLetter(String text) {\r\n        String temp = text.substring(0, 1).toUpperCase();\r\n        text = temp + text.substring(1);\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Lowercases the first letter of given string.\r\n     *\r\n     * @param text The text to lowercase.\r\n     * @return Same stuff as given in input, but with first letter in lowercase.\r\n     */\r\n    public static String lowerCaseFirstLetter(String text) {\r\n        String temp = text.substring(0, 1).toLowerCase();\r\n        text = temp + text.substring(1);\r\n        return text;\r\n    }\r\n\r\n    public static String stringForStream(InputStream in) throws IOException {\r\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n        byte[] bytes = new byte[512];\r\n        int readBytes;\r\n        while ((readBytes = in.read(bytes)) > 0) {\r\n            out.write(bytes, 0, readBytes);\r\n        }\r\n        return new String(out.toByteArray());\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/StringUtils_3Test.java",
		"test_prompt": "// StringUtils_3Test.java\npackage fi.vtt.noen.testgen;\n\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.ByteArrayOutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringUtils}.\n* It contains ten unit test cases for the {@link StringUtils#stringForStream(InputStream)} method.\n*/\nclass StringUtils_3Test {"
	},
	{
		"original_code": "// InterfaceParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses method names from an interface to be used to identify which methods\r\n * are part of input and which are part of output.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class InterfaceParser {\r\n\r\n    public static Collection<String> methodNames(Class clazz) {\r\n        Collection<String> names = new ArrayList<String>();\r\n        Method[] methods = clazz.getMethods();\r\n        for (int i = 0; i < methods.length; i++) {\r\n            Method method = methods[i];\r\n            names.add(method.getName());\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public static Collection<String> methodNames(Collection<Class> interfaces) {\r\n        Collection<String> methods = new HashSet<String>();\r\n        for (Iterator<Class> i = interfaces.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            methods.addAll(methodNames(clazz));\r\n        }\r\n        return methods;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/InterfaceParser_0Test.java",
		"test_prompt": "// InterfaceParser_0Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InterfaceParser}.\n* It contains ten unit test cases for the {@link InterfaceParser#methodNames(Class)} method.\n*/\nclass InterfaceParser_0Test {"
	},
	{
		"original_code": "// InterfaceParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses method names from an interface to be used to identify which methods\r\n * are part of input and which are part of output.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class InterfaceParser {\r\n\r\n    public static Collection<String> methodNames(Class clazz) {\r\n        Collection<String> names = new ArrayList<String>();\r\n        Method[] methods = clazz.getMethods();\r\n        for (int i = 0; i < methods.length; i++) {\r\n            Method method = methods[i];\r\n            names.add(method.getName());\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public static Collection<String> methodNames(Collection<Class> interfaces) {\r\n        Collection<String> methods = new HashSet<String>();\r\n        for (Iterator<Class> i = interfaces.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            methods.addAll(methodNames(clazz));\r\n        }\r\n        return methods;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/InterfaceParser_1Test.java",
		"test_prompt": "// InterfaceParser_1Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InterfaceParser}.\n* It contains ten unit test cases for the {@link InterfaceParser#methodNames(Collection)} method.\n*/\nclass InterfaceParser_1Test {"
	},
	{
		"original_code": "// DaikonParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.*;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * A parser for Daikon log files. Reads the Daikon log file and parses it into blocks, where each\r\n * block represents a monitored point of execution. Each block is taken to describe a state in the\r\n * generated state-machine. The invariants for this block are then turned into\r\n * invariant constraint objects describing when these states can be entered. Block sequences are also\r\n * considered, and considered to describe transition constraints between two blocks where one\r\n * follows another. These are then turned into transition invariant constraints for when this\r\n * transition can occur.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonParser {\r\n\r\n    private static final String EOF = \"Exiting Daikon.\";\r\n\r\n    //  private static final String ln = System.getProperty(\"line.separator\");\r\n    private String itemSeparator;\r\n\r\n    private final String text;\r\n\r\n    private int index = 0;\r\n\r\n    public DaikonParser(String text) {\r\n        this.text = text;\r\n        trySeparator(\"\\r\\n\");\r\n        trySeparator(\"\\n\");\r\n        trySeparator(\"\\r\");\r\n        index = text.indexOf(itemSeparator) + itemSeparator.length();\r\n    }\r\n\r\n    private void trySeparator(String lineChange) {\r\n        if (itemSeparator != null) {\r\n            //already found and set\r\n            return;\r\n        }\r\n        String test = \"===========================================================================\" + lineChange;\r\n        if (text.indexOf(test) > 0) {\r\n            itemSeparator = test;\r\n        }\r\n    }\r\n\r\n    public DaikonModel parseAll() {\r\n        String block = nextBlock();\r\n        DaikonModel model = new DaikonModel();\r\n        while (block != null) {\r\n            //      System.out.println(\"block:\"+block);\r\n            Collection<String> items = items(block);\r\n            Iterator<String> i = items.iterator();\r\n            String name = parseEventName(i.next());\r\n            DaikonModelElement me = DaikonModelElement.create(name);\r\n            model.add(me);\r\n            while (i.hasNext()) {\r\n                DaikonConstraint daikonConstraint = constraint(i.next());\r\n                if (daikonConstraint != null && daikonConstraint.isEnabled()) {\r\n                    //some logs had empty lines which now give null, so add this paranoia..\r\n                    me.addConstraint(daikonConstraint);\r\n                }\r\n            }\r\n            block = nextBlock();\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public String nextBlock() {\r\n        int endIndex = text.indexOf(itemSeparator, index);\r\n        if (endIndex < 0) {\r\n            endIndex = text.indexOf(EOF, index);\r\n        }\r\n        if (endIndex < 0) {\r\n            return null;\r\n        }\r\n        String result = text.substring(index, endIndex);\r\n        index = endIndex + itemSeparator.length();\r\n        return result;\r\n    }\r\n\r\n    public static Collection<String> items(String block) {\r\n        Collection<String> items = new ArrayList<String>();\r\n        int index = 0;\r\n        int endIndex = block.indexOf(\"\\n\");\r\n        while (endIndex > 0) {\r\n            String item = block.substring(index, endIndex);\r\n            items.add(item);\r\n            index = endIndex + 1;\r\n            endIndex = block.indexOf(\"\\n\", index);\r\n        }\r\n        return items;\r\n    }\r\n\r\n    public static DaikonConstraint constraint(String item) {\r\n        //    System.out.println(\"item:\"+item);\r\n        if (item.trim().length() == 0) {\r\n            //some daikon logs had empty lines so we do this now..\r\n            return null;\r\n        }\r\n        if (item.split(\"%\").length > 1) {\r\n            //some things just are not to be supported..\r\n            return null;\r\n        }\r\n        String[] parts = item.split(\" >= \");\r\n        if (parts.length == 2) {\r\n            return new GreaterOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" > \");\r\n        if (parts.length == 2) {\r\n            return new GreaterConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" <= \");\r\n        if (parts.length == 2) {\r\n            return new LesserOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" < \");\r\n        if (parts.length == 2) {\r\n            return new LesserConstraint(parts[0], parts[1]);\r\n        }\r\n        if (item.startsWith(\"size(\")) {\r\n            parts = item.split(\" == \");\r\n            if (parts.length == 2) {\r\n                return new ConstantSizeConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" != \");\r\n            if (parts.length == 2) {\r\n                return new NonEqualConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" one of \\\\{\");\r\n            return new ConstantSizeConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] == \\\\[\");\r\n        if (parts.length == 2) {\r\n            return new ArrayContentsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] elements == \");\r\n        if (parts.length == 2) {\r\n            return new ArrayElementsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\" == size\\\\(\");\r\n        if (parts.length == 2) {\r\n            return new SizeOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" == \");\r\n        if (parts.length == 2) {\r\n            return new EqualsConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" != \");\r\n        if (parts.length == 2) {\r\n            return new NonEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        // { is a special char in java regep so we must escape it \\\\{ or we get regexp error\r\n        parts = item.split(\" one of \\\\{\");\r\n        if (parts.length == 2) {\r\n            return new OneOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" in \");\r\n        if (parts.length == 2) {\r\n            return new AlwaysInArrayConstraint(parts[0], parts[1]);\r\n        }\r\n        throw new IllegalArgumentException(\"Unsupported contraint:\" + item);\r\n    }\r\n\r\n    public static Object parseValueObject(String obj) {\r\n        //remove any whitespace, line endings etc that will cause failure of startwith and endswith\r\n        obj = obj.trim();\r\n        if (obj.startsWith(\"[\") && obj.endsWith(\"]\")) {\r\n            return parseStringList(obj);\r\n        }\r\n        boolean array = false;\r\n        if (obj.endsWith(\"[]\")) {\r\n            array = true;\r\n            obj = obj.substring(0, obj.length() - 2);\r\n        }\r\n        if (obj.length() == 0) {\r\n            throw new IllegalArgumentException(\"Cannot parseLexical value from empty string\");\r\n        }\r\n        if (obj.startsWith(\"\\\"\") && obj.endsWith(\"\\\"\")) {\r\n            //in this case it is of form \"value\" and is a STRING so we remove the surrounding \"\"\r\n            String value = obj.substring(1, obj.length() - 1);\r\n            return value;\r\n        }\r\n        if (obj.equals(\"true\") || obj.equals(\"false\")) {\r\n            //in this case we have a BOOLEAN variable\r\n            boolean value = Boolean.parseBoolean(obj);\r\n            return value;\r\n        }\r\n        try {\r\n            //we try to parseLexical it as a NUMBER, if we succeed we are happy\r\n            double value = Double.parseDouble(obj);\r\n            return value;\r\n        } catch (NumberFormatException e) {\r\n            //if we come here, it was not a number and we ignore this exception\r\n        }\r\n        if (obj.indexOf(\"?\") == -1) {\r\n            //parameter index with ? separator is needed for reference objects, otherwise we consider it a string\r\n            //this can happen for array content values\r\n            return obj;\r\n        }\r\n        //    System.out.println(\"creating reference object for:\"+obj);\r\n        //the only possibility left is that it is a REFERENCE TO ANOTHER VARIABLE\r\n        //meaning it has a certain relation with the other variable, such as they are always equal\r\n        return new ReferenceValue(obj, array);\r\n    }\r\n\r\n    public static Collection<String> parseStringList(String obj) {\r\n        Collection<String> result = new ArrayList<String>();\r\n        //trim [ from start and ] from end\r\n        obj = obj.substring(1, obj.length() - 1);\r\n        String[] values = obj.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        result.addAll(Arrays.asList(values));\r\n        return result;\r\n    }\r\n\r\n    public static Collection parseObjectList(String value) {\r\n        if (value.length() == 0) {\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        Collection contents = new ArrayList();\r\n        String[] valueArray = value.split(\",\");\r\n        for (String s : valueArray) {\r\n            Object obj = DaikonParser.parseValueObject(s);\r\n            contents.add(obj);\r\n        }\r\n        return contents;\r\n    }\r\n\r\n    public static String parseEventName(String text) {\r\n        String[] parts = text.split(\":::\");\r\n        return parts[0];\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/DaikonParser_0Test.java",
		"test_prompt": "// DaikonParser_0Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport fi.vtt.noen.testgen.model.daikon.*;\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonParser}.\n* It contains ten unit test cases for the {@link DaikonParser#parseAll()} method.\n*/\nclass DaikonParser_0Test {"
	},
	{
		"original_code": "// DaikonParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.*;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * A parser for Daikon log files. Reads the Daikon log file and parses it into blocks, where each\r\n * block represents a monitored point of execution. Each block is taken to describe a state in the\r\n * generated state-machine. The invariants for this block are then turned into\r\n * invariant constraint objects describing when these states can be entered. Block sequences are also\r\n * considered, and considered to describe transition constraints between two blocks where one\r\n * follows another. These are then turned into transition invariant constraints for when this\r\n * transition can occur.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonParser {\r\n\r\n    private static final String EOF = \"Exiting Daikon.\";\r\n\r\n    //  private static final String ln = System.getProperty(\"line.separator\");\r\n    private String itemSeparator;\r\n\r\n    private final String text;\r\n\r\n    private int index = 0;\r\n\r\n    public DaikonParser(String text) {\r\n        this.text = text;\r\n        trySeparator(\"\\r\\n\");\r\n        trySeparator(\"\\n\");\r\n        trySeparator(\"\\r\");\r\n        index = text.indexOf(itemSeparator) + itemSeparator.length();\r\n    }\r\n\r\n    private void trySeparator(String lineChange) {\r\n        if (itemSeparator != null) {\r\n            //already found and set\r\n            return;\r\n        }\r\n        String test = \"===========================================================================\" + lineChange;\r\n        if (text.indexOf(test) > 0) {\r\n            itemSeparator = test;\r\n        }\r\n    }\r\n\r\n    public DaikonModel parseAll() {\r\n        String block = nextBlock();\r\n        DaikonModel model = new DaikonModel();\r\n        while (block != null) {\r\n            //      System.out.println(\"block:\"+block);\r\n            Collection<String> items = items(block);\r\n            Iterator<String> i = items.iterator();\r\n            String name = parseEventName(i.next());\r\n            DaikonModelElement me = DaikonModelElement.create(name);\r\n            model.add(me);\r\n            while (i.hasNext()) {\r\n                DaikonConstraint daikonConstraint = constraint(i.next());\r\n                if (daikonConstraint != null && daikonConstraint.isEnabled()) {\r\n                    //some logs had empty lines which now give null, so add this paranoia..\r\n                    me.addConstraint(daikonConstraint);\r\n                }\r\n            }\r\n            block = nextBlock();\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public String nextBlock() {\r\n        int endIndex = text.indexOf(itemSeparator, index);\r\n        if (endIndex < 0) {\r\n            endIndex = text.indexOf(EOF, index);\r\n        }\r\n        if (endIndex < 0) {\r\n            return null;\r\n        }\r\n        String result = text.substring(index, endIndex);\r\n        index = endIndex + itemSeparator.length();\r\n        return result;\r\n    }\r\n\r\n    public static Collection<String> items(String block) {\r\n        Collection<String> items = new ArrayList<String>();\r\n        int index = 0;\r\n        int endIndex = block.indexOf(\"\\n\");\r\n        while (endIndex > 0) {\r\n            String item = block.substring(index, endIndex);\r\n            items.add(item);\r\n            index = endIndex + 1;\r\n            endIndex = block.indexOf(\"\\n\", index);\r\n        }\r\n        return items;\r\n    }\r\n\r\n    public static DaikonConstraint constraint(String item) {\r\n        //    System.out.println(\"item:\"+item);\r\n        if (item.trim().length() == 0) {\r\n            //some daikon logs had empty lines so we do this now..\r\n            return null;\r\n        }\r\n        if (item.split(\"%\").length > 1) {\r\n            //some things just are not to be supported..\r\n            return null;\r\n        }\r\n        String[] parts = item.split(\" >= \");\r\n        if (parts.length == 2) {\r\n            return new GreaterOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" > \");\r\n        if (parts.length == 2) {\r\n            return new GreaterConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" <= \");\r\n        if (parts.length == 2) {\r\n            return new LesserOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" < \");\r\n        if (parts.length == 2) {\r\n            return new LesserConstraint(parts[0], parts[1]);\r\n        }\r\n        if (item.startsWith(\"size(\")) {\r\n            parts = item.split(\" == \");\r\n            if (parts.length == 2) {\r\n                return new ConstantSizeConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" != \");\r\n            if (parts.length == 2) {\r\n                return new NonEqualConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" one of \\\\{\");\r\n            return new ConstantSizeConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] == \\\\[\");\r\n        if (parts.length == 2) {\r\n            return new ArrayContentsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] elements == \");\r\n        if (parts.length == 2) {\r\n            return new ArrayElementsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\" == size\\\\(\");\r\n        if (parts.length == 2) {\r\n            return new SizeOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" == \");\r\n        if (parts.length == 2) {\r\n            return new EqualsConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" != \");\r\n        if (parts.length == 2) {\r\n            return new NonEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        // { is a special char in java regep so we must escape it \\\\{ or we get regexp error\r\n        parts = item.split(\" one of \\\\{\");\r\n        if (parts.length == 2) {\r\n            return new OneOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" in \");\r\n        if (parts.length == 2) {\r\n            return new AlwaysInArrayConstraint(parts[0], parts[1]);\r\n        }\r\n        throw new IllegalArgumentException(\"Unsupported contraint:\" + item);\r\n    }\r\n\r\n    public static Object parseValueObject(String obj) {\r\n        //remove any whitespace, line endings etc that will cause failure of startwith and endswith\r\n        obj = obj.trim();\r\n        if (obj.startsWith(\"[\") && obj.endsWith(\"]\")) {\r\n            return parseStringList(obj);\r\n        }\r\n        boolean array = false;\r\n        if (obj.endsWith(\"[]\")) {\r\n            array = true;\r\n            obj = obj.substring(0, obj.length() - 2);\r\n        }\r\n        if (obj.length() == 0) {\r\n            throw new IllegalArgumentException(\"Cannot parseLexical value from empty string\");\r\n        }\r\n        if (obj.startsWith(\"\\\"\") && obj.endsWith(\"\\\"\")) {\r\n            //in this case it is of form \"value\" and is a STRING so we remove the surrounding \"\"\r\n            String value = obj.substring(1, obj.length() - 1);\r\n            return value;\r\n        }\r\n        if (obj.equals(\"true\") || obj.equals(\"false\")) {\r\n            //in this case we have a BOOLEAN variable\r\n            boolean value = Boolean.parseBoolean(obj);\r\n            return value;\r\n        }\r\n        try {\r\n            //we try to parseLexical it as a NUMBER, if we succeed we are happy\r\n            double value = Double.parseDouble(obj);\r\n            return value;\r\n        } catch (NumberFormatException e) {\r\n            //if we come here, it was not a number and we ignore this exception\r\n        }\r\n        if (obj.indexOf(\"?\") == -1) {\r\n            //parameter index with ? separator is needed for reference objects, otherwise we consider it a string\r\n            //this can happen for array content values\r\n            return obj;\r\n        }\r\n        //    System.out.println(\"creating reference object for:\"+obj);\r\n        //the only possibility left is that it is a REFERENCE TO ANOTHER VARIABLE\r\n        //meaning it has a certain relation with the other variable, such as they are always equal\r\n        return new ReferenceValue(obj, array);\r\n    }\r\n\r\n    public static Collection<String> parseStringList(String obj) {\r\n        Collection<String> result = new ArrayList<String>();\r\n        //trim [ from start and ] from end\r\n        obj = obj.substring(1, obj.length() - 1);\r\n        String[] values = obj.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        result.addAll(Arrays.asList(values));\r\n        return result;\r\n    }\r\n\r\n    public static Collection parseObjectList(String value) {\r\n        if (value.length() == 0) {\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        Collection contents = new ArrayList();\r\n        String[] valueArray = value.split(\",\");\r\n        for (String s : valueArray) {\r\n            Object obj = DaikonParser.parseValueObject(s);\r\n            contents.add(obj);\r\n        }\r\n        return contents;\r\n    }\r\n\r\n    public static String parseEventName(String text) {\r\n        String[] parts = text.split(\":::\");\r\n        return parts[0];\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/DaikonParser_1Test.java",
		"test_prompt": "// DaikonParser_1Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport fi.vtt.noen.testgen.model.daikon.*;\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonParser}.\n* It contains ten unit test cases for the {@link DaikonParser#nextBlock()} method.\n*/\nclass DaikonParser_1Test {"
	},
	{
		"original_code": "// DaikonParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.*;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * A parser for Daikon log files. Reads the Daikon log file and parses it into blocks, where each\r\n * block represents a monitored point of execution. Each block is taken to describe a state in the\r\n * generated state-machine. The invariants for this block are then turned into\r\n * invariant constraint objects describing when these states can be entered. Block sequences are also\r\n * considered, and considered to describe transition constraints between two blocks where one\r\n * follows another. These are then turned into transition invariant constraints for when this\r\n * transition can occur.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonParser {\r\n\r\n    private static final String EOF = \"Exiting Daikon.\";\r\n\r\n    //  private static final String ln = System.getProperty(\"line.separator\");\r\n    private String itemSeparator;\r\n\r\n    private final String text;\r\n\r\n    private int index = 0;\r\n\r\n    public DaikonParser(String text) {\r\n        this.text = text;\r\n        trySeparator(\"\\r\\n\");\r\n        trySeparator(\"\\n\");\r\n        trySeparator(\"\\r\");\r\n        index = text.indexOf(itemSeparator) + itemSeparator.length();\r\n    }\r\n\r\n    private void trySeparator(String lineChange) {\r\n        if (itemSeparator != null) {\r\n            //already found and set\r\n            return;\r\n        }\r\n        String test = \"===========================================================================\" + lineChange;\r\n        if (text.indexOf(test) > 0) {\r\n            itemSeparator = test;\r\n        }\r\n    }\r\n\r\n    public DaikonModel parseAll() {\r\n        String block = nextBlock();\r\n        DaikonModel model = new DaikonModel();\r\n        while (block != null) {\r\n            //      System.out.println(\"block:\"+block);\r\n            Collection<String> items = items(block);\r\n            Iterator<String> i = items.iterator();\r\n            String name = parseEventName(i.next());\r\n            DaikonModelElement me = DaikonModelElement.create(name);\r\n            model.add(me);\r\n            while (i.hasNext()) {\r\n                DaikonConstraint daikonConstraint = constraint(i.next());\r\n                if (daikonConstraint != null && daikonConstraint.isEnabled()) {\r\n                    //some logs had empty lines which now give null, so add this paranoia..\r\n                    me.addConstraint(daikonConstraint);\r\n                }\r\n            }\r\n            block = nextBlock();\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public String nextBlock() {\r\n        int endIndex = text.indexOf(itemSeparator, index);\r\n        if (endIndex < 0) {\r\n            endIndex = text.indexOf(EOF, index);\r\n        }\r\n        if (endIndex < 0) {\r\n            return null;\r\n        }\r\n        String result = text.substring(index, endIndex);\r\n        index = endIndex + itemSeparator.length();\r\n        return result;\r\n    }\r\n\r\n    public static Collection<String> items(String block) {\r\n        Collection<String> items = new ArrayList<String>();\r\n        int index = 0;\r\n        int endIndex = block.indexOf(\"\\n\");\r\n        while (endIndex > 0) {\r\n            String item = block.substring(index, endIndex);\r\n            items.add(item);\r\n            index = endIndex + 1;\r\n            endIndex = block.indexOf(\"\\n\", index);\r\n        }\r\n        return items;\r\n    }\r\n\r\n    public static DaikonConstraint constraint(String item) {\r\n        //    System.out.println(\"item:\"+item);\r\n        if (item.trim().length() == 0) {\r\n            //some daikon logs had empty lines so we do this now..\r\n            return null;\r\n        }\r\n        if (item.split(\"%\").length > 1) {\r\n            //some things just are not to be supported..\r\n            return null;\r\n        }\r\n        String[] parts = item.split(\" >= \");\r\n        if (parts.length == 2) {\r\n            return new GreaterOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" > \");\r\n        if (parts.length == 2) {\r\n            return new GreaterConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" <= \");\r\n        if (parts.length == 2) {\r\n            return new LesserOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" < \");\r\n        if (parts.length == 2) {\r\n            return new LesserConstraint(parts[0], parts[1]);\r\n        }\r\n        if (item.startsWith(\"size(\")) {\r\n            parts = item.split(\" == \");\r\n            if (parts.length == 2) {\r\n                return new ConstantSizeConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" != \");\r\n            if (parts.length == 2) {\r\n                return new NonEqualConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" one of \\\\{\");\r\n            return new ConstantSizeConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] == \\\\[\");\r\n        if (parts.length == 2) {\r\n            return new ArrayContentsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] elements == \");\r\n        if (parts.length == 2) {\r\n            return new ArrayElementsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\" == size\\\\(\");\r\n        if (parts.length == 2) {\r\n            return new SizeOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" == \");\r\n        if (parts.length == 2) {\r\n            return new EqualsConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" != \");\r\n        if (parts.length == 2) {\r\n            return new NonEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        // { is a special char in java regep so we must escape it \\\\{ or we get regexp error\r\n        parts = item.split(\" one of \\\\{\");\r\n        if (parts.length == 2) {\r\n            return new OneOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" in \");\r\n        if (parts.length == 2) {\r\n            return new AlwaysInArrayConstraint(parts[0], parts[1]);\r\n        }\r\n        throw new IllegalArgumentException(\"Unsupported contraint:\" + item);\r\n    }\r\n\r\n    public static Object parseValueObject(String obj) {\r\n        //remove any whitespace, line endings etc that will cause failure of startwith and endswith\r\n        obj = obj.trim();\r\n        if (obj.startsWith(\"[\") && obj.endsWith(\"]\")) {\r\n            return parseStringList(obj);\r\n        }\r\n        boolean array = false;\r\n        if (obj.endsWith(\"[]\")) {\r\n            array = true;\r\n            obj = obj.substring(0, obj.length() - 2);\r\n        }\r\n        if (obj.length() == 0) {\r\n            throw new IllegalArgumentException(\"Cannot parseLexical value from empty string\");\r\n        }\r\n        if (obj.startsWith(\"\\\"\") && obj.endsWith(\"\\\"\")) {\r\n            //in this case it is of form \"value\" and is a STRING so we remove the surrounding \"\"\r\n            String value = obj.substring(1, obj.length() - 1);\r\n            return value;\r\n        }\r\n        if (obj.equals(\"true\") || obj.equals(\"false\")) {\r\n            //in this case we have a BOOLEAN variable\r\n            boolean value = Boolean.parseBoolean(obj);\r\n            return value;\r\n        }\r\n        try {\r\n            //we try to parseLexical it as a NUMBER, if we succeed we are happy\r\n            double value = Double.parseDouble(obj);\r\n            return value;\r\n        } catch (NumberFormatException e) {\r\n            //if we come here, it was not a number and we ignore this exception\r\n        }\r\n        if (obj.indexOf(\"?\") == -1) {\r\n            //parameter index with ? separator is needed for reference objects, otherwise we consider it a string\r\n            //this can happen for array content values\r\n            return obj;\r\n        }\r\n        //    System.out.println(\"creating reference object for:\"+obj);\r\n        //the only possibility left is that it is a REFERENCE TO ANOTHER VARIABLE\r\n        //meaning it has a certain relation with the other variable, such as they are always equal\r\n        return new ReferenceValue(obj, array);\r\n    }\r\n\r\n    public static Collection<String> parseStringList(String obj) {\r\n        Collection<String> result = new ArrayList<String>();\r\n        //trim [ from start and ] from end\r\n        obj = obj.substring(1, obj.length() - 1);\r\n        String[] values = obj.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        result.addAll(Arrays.asList(values));\r\n        return result;\r\n    }\r\n\r\n    public static Collection parseObjectList(String value) {\r\n        if (value.length() == 0) {\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        Collection contents = new ArrayList();\r\n        String[] valueArray = value.split(\",\");\r\n        for (String s : valueArray) {\r\n            Object obj = DaikonParser.parseValueObject(s);\r\n            contents.add(obj);\r\n        }\r\n        return contents;\r\n    }\r\n\r\n    public static String parseEventName(String text) {\r\n        String[] parts = text.split(\":::\");\r\n        return parts[0];\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/DaikonParser_2Test.java",
		"test_prompt": "// DaikonParser_2Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport fi.vtt.noen.testgen.model.daikon.*;\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonParser}.\n* It contains ten unit test cases for the {@link DaikonParser#items(String)} method.\n*/\nclass DaikonParser_2Test {"
	},
	{
		"original_code": "// DaikonParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.*;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * A parser for Daikon log files. Reads the Daikon log file and parses it into blocks, where each\r\n * block represents a monitored point of execution. Each block is taken to describe a state in the\r\n * generated state-machine. The invariants for this block are then turned into\r\n * invariant constraint objects describing when these states can be entered. Block sequences are also\r\n * considered, and considered to describe transition constraints between two blocks where one\r\n * follows another. These are then turned into transition invariant constraints for when this\r\n * transition can occur.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonParser {\r\n\r\n    private static final String EOF = \"Exiting Daikon.\";\r\n\r\n    //  private static final String ln = System.getProperty(\"line.separator\");\r\n    private String itemSeparator;\r\n\r\n    private final String text;\r\n\r\n    private int index = 0;\r\n\r\n    public DaikonParser(String text) {\r\n        this.text = text;\r\n        trySeparator(\"\\r\\n\");\r\n        trySeparator(\"\\n\");\r\n        trySeparator(\"\\r\");\r\n        index = text.indexOf(itemSeparator) + itemSeparator.length();\r\n    }\r\n\r\n    private void trySeparator(String lineChange) {\r\n        if (itemSeparator != null) {\r\n            //already found and set\r\n            return;\r\n        }\r\n        String test = \"===========================================================================\" + lineChange;\r\n        if (text.indexOf(test) > 0) {\r\n            itemSeparator = test;\r\n        }\r\n    }\r\n\r\n    public DaikonModel parseAll() {\r\n        String block = nextBlock();\r\n        DaikonModel model = new DaikonModel();\r\n        while (block != null) {\r\n            //      System.out.println(\"block:\"+block);\r\n            Collection<String> items = items(block);\r\n            Iterator<String> i = items.iterator();\r\n            String name = parseEventName(i.next());\r\n            DaikonModelElement me = DaikonModelElement.create(name);\r\n            model.add(me);\r\n            while (i.hasNext()) {\r\n                DaikonConstraint daikonConstraint = constraint(i.next());\r\n                if (daikonConstraint != null && daikonConstraint.isEnabled()) {\r\n                    //some logs had empty lines which now give null, so add this paranoia..\r\n                    me.addConstraint(daikonConstraint);\r\n                }\r\n            }\r\n            block = nextBlock();\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public String nextBlock() {\r\n        int endIndex = text.indexOf(itemSeparator, index);\r\n        if (endIndex < 0) {\r\n            endIndex = text.indexOf(EOF, index);\r\n        }\r\n        if (endIndex < 0) {\r\n            return null;\r\n        }\r\n        String result = text.substring(index, endIndex);\r\n        index = endIndex + itemSeparator.length();\r\n        return result;\r\n    }\r\n\r\n    public static Collection<String> items(String block) {\r\n        Collection<String> items = new ArrayList<String>();\r\n        int index = 0;\r\n        int endIndex = block.indexOf(\"\\n\");\r\n        while (endIndex > 0) {\r\n            String item = block.substring(index, endIndex);\r\n            items.add(item);\r\n            index = endIndex + 1;\r\n            endIndex = block.indexOf(\"\\n\", index);\r\n        }\r\n        return items;\r\n    }\r\n\r\n    public static DaikonConstraint constraint(String item) {\r\n        //    System.out.println(\"item:\"+item);\r\n        if (item.trim().length() == 0) {\r\n            //some daikon logs had empty lines so we do this now..\r\n            return null;\r\n        }\r\n        if (item.split(\"%\").length > 1) {\r\n            //some things just are not to be supported..\r\n            return null;\r\n        }\r\n        String[] parts = item.split(\" >= \");\r\n        if (parts.length == 2) {\r\n            return new GreaterOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" > \");\r\n        if (parts.length == 2) {\r\n            return new GreaterConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" <= \");\r\n        if (parts.length == 2) {\r\n            return new LesserOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" < \");\r\n        if (parts.length == 2) {\r\n            return new LesserConstraint(parts[0], parts[1]);\r\n        }\r\n        if (item.startsWith(\"size(\")) {\r\n            parts = item.split(\" == \");\r\n            if (parts.length == 2) {\r\n                return new ConstantSizeConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" != \");\r\n            if (parts.length == 2) {\r\n                return new NonEqualConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" one of \\\\{\");\r\n            return new ConstantSizeConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] == \\\\[\");\r\n        if (parts.length == 2) {\r\n            return new ArrayContentsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] elements == \");\r\n        if (parts.length == 2) {\r\n            return new ArrayElementsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\" == size\\\\(\");\r\n        if (parts.length == 2) {\r\n            return new SizeOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" == \");\r\n        if (parts.length == 2) {\r\n            return new EqualsConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" != \");\r\n        if (parts.length == 2) {\r\n            return new NonEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        // { is a special char in java regep so we must escape it \\\\{ or we get regexp error\r\n        parts = item.split(\" one of \\\\{\");\r\n        if (parts.length == 2) {\r\n            return new OneOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" in \");\r\n        if (parts.length == 2) {\r\n            return new AlwaysInArrayConstraint(parts[0], parts[1]);\r\n        }\r\n        throw new IllegalArgumentException(\"Unsupported contraint:\" + item);\r\n    }\r\n\r\n    public static Object parseValueObject(String obj) {\r\n        //remove any whitespace, line endings etc that will cause failure of startwith and endswith\r\n        obj = obj.trim();\r\n        if (obj.startsWith(\"[\") && obj.endsWith(\"]\")) {\r\n            return parseStringList(obj);\r\n        }\r\n        boolean array = false;\r\n        if (obj.endsWith(\"[]\")) {\r\n            array = true;\r\n            obj = obj.substring(0, obj.length() - 2);\r\n        }\r\n        if (obj.length() == 0) {\r\n            throw new IllegalArgumentException(\"Cannot parseLexical value from empty string\");\r\n        }\r\n        if (obj.startsWith(\"\\\"\") && obj.endsWith(\"\\\"\")) {\r\n            //in this case it is of form \"value\" and is a STRING so we remove the surrounding \"\"\r\n            String value = obj.substring(1, obj.length() - 1);\r\n            return value;\r\n        }\r\n        if (obj.equals(\"true\") || obj.equals(\"false\")) {\r\n            //in this case we have a BOOLEAN variable\r\n            boolean value = Boolean.parseBoolean(obj);\r\n            return value;\r\n        }\r\n        try {\r\n            //we try to parseLexical it as a NUMBER, if we succeed we are happy\r\n            double value = Double.parseDouble(obj);\r\n            return value;\r\n        } catch (NumberFormatException e) {\r\n            //if we come here, it was not a number and we ignore this exception\r\n        }\r\n        if (obj.indexOf(\"?\") == -1) {\r\n            //parameter index with ? separator is needed for reference objects, otherwise we consider it a string\r\n            //this can happen for array content values\r\n            return obj;\r\n        }\r\n        //    System.out.println(\"creating reference object for:\"+obj);\r\n        //the only possibility left is that it is a REFERENCE TO ANOTHER VARIABLE\r\n        //meaning it has a certain relation with the other variable, such as they are always equal\r\n        return new ReferenceValue(obj, array);\r\n    }\r\n\r\n    public static Collection<String> parseStringList(String obj) {\r\n        Collection<String> result = new ArrayList<String>();\r\n        //trim [ from start and ] from end\r\n        obj = obj.substring(1, obj.length() - 1);\r\n        String[] values = obj.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        result.addAll(Arrays.asList(values));\r\n        return result;\r\n    }\r\n\r\n    public static Collection parseObjectList(String value) {\r\n        if (value.length() == 0) {\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        Collection contents = new ArrayList();\r\n        String[] valueArray = value.split(\",\");\r\n        for (String s : valueArray) {\r\n            Object obj = DaikonParser.parseValueObject(s);\r\n            contents.add(obj);\r\n        }\r\n        return contents;\r\n    }\r\n\r\n    public static String parseEventName(String text) {\r\n        String[] parts = text.split(\":::\");\r\n        return parts[0];\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/DaikonParser_3Test.java",
		"test_prompt": "// DaikonParser_3Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport fi.vtt.noen.testgen.model.daikon.*;\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonParser}.\n* It contains ten unit test cases for the {@link DaikonParser#constraint(String)} method.\n*/\nclass DaikonParser_3Test {"
	},
	{
		"original_code": "// DaikonParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.*;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * A parser for Daikon log files. Reads the Daikon log file and parses it into blocks, where each\r\n * block represents a monitored point of execution. Each block is taken to describe a state in the\r\n * generated state-machine. The invariants for this block are then turned into\r\n * invariant constraint objects describing when these states can be entered. Block sequences are also\r\n * considered, and considered to describe transition constraints between two blocks where one\r\n * follows another. These are then turned into transition invariant constraints for when this\r\n * transition can occur.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonParser {\r\n\r\n    private static final String EOF = \"Exiting Daikon.\";\r\n\r\n    //  private static final String ln = System.getProperty(\"line.separator\");\r\n    private String itemSeparator;\r\n\r\n    private final String text;\r\n\r\n    private int index = 0;\r\n\r\n    public DaikonParser(String text) {\r\n        this.text = text;\r\n        trySeparator(\"\\r\\n\");\r\n        trySeparator(\"\\n\");\r\n        trySeparator(\"\\r\");\r\n        index = text.indexOf(itemSeparator) + itemSeparator.length();\r\n    }\r\n\r\n    private void trySeparator(String lineChange) {\r\n        if (itemSeparator != null) {\r\n            //already found and set\r\n            return;\r\n        }\r\n        String test = \"===========================================================================\" + lineChange;\r\n        if (text.indexOf(test) > 0) {\r\n            itemSeparator = test;\r\n        }\r\n    }\r\n\r\n    public DaikonModel parseAll() {\r\n        String block = nextBlock();\r\n        DaikonModel model = new DaikonModel();\r\n        while (block != null) {\r\n            //      System.out.println(\"block:\"+block);\r\n            Collection<String> items = items(block);\r\n            Iterator<String> i = items.iterator();\r\n            String name = parseEventName(i.next());\r\n            DaikonModelElement me = DaikonModelElement.create(name);\r\n            model.add(me);\r\n            while (i.hasNext()) {\r\n                DaikonConstraint daikonConstraint = constraint(i.next());\r\n                if (daikonConstraint != null && daikonConstraint.isEnabled()) {\r\n                    //some logs had empty lines which now give null, so add this paranoia..\r\n                    me.addConstraint(daikonConstraint);\r\n                }\r\n            }\r\n            block = nextBlock();\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public String nextBlock() {\r\n        int endIndex = text.indexOf(itemSeparator, index);\r\n        if (endIndex < 0) {\r\n            endIndex = text.indexOf(EOF, index);\r\n        }\r\n        if (endIndex < 0) {\r\n            return null;\r\n        }\r\n        String result = text.substring(index, endIndex);\r\n        index = endIndex + itemSeparator.length();\r\n        return result;\r\n    }\r\n\r\n    public static Collection<String> items(String block) {\r\n        Collection<String> items = new ArrayList<String>();\r\n        int index = 0;\r\n        int endIndex = block.indexOf(\"\\n\");\r\n        while (endIndex > 0) {\r\n            String item = block.substring(index, endIndex);\r\n            items.add(item);\r\n            index = endIndex + 1;\r\n            endIndex = block.indexOf(\"\\n\", index);\r\n        }\r\n        return items;\r\n    }\r\n\r\n    public static DaikonConstraint constraint(String item) {\r\n        //    System.out.println(\"item:\"+item);\r\n        if (item.trim().length() == 0) {\r\n            //some daikon logs had empty lines so we do this now..\r\n            return null;\r\n        }\r\n        if (item.split(\"%\").length > 1) {\r\n            //some things just are not to be supported..\r\n            return null;\r\n        }\r\n        String[] parts = item.split(\" >= \");\r\n        if (parts.length == 2) {\r\n            return new GreaterOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" > \");\r\n        if (parts.length == 2) {\r\n            return new GreaterConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" <= \");\r\n        if (parts.length == 2) {\r\n            return new LesserOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" < \");\r\n        if (parts.length == 2) {\r\n            return new LesserConstraint(parts[0], parts[1]);\r\n        }\r\n        if (item.startsWith(\"size(\")) {\r\n            parts = item.split(\" == \");\r\n            if (parts.length == 2) {\r\n                return new ConstantSizeConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" != \");\r\n            if (parts.length == 2) {\r\n                return new NonEqualConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" one of \\\\{\");\r\n            return new ConstantSizeConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] == \\\\[\");\r\n        if (parts.length == 2) {\r\n            return new ArrayContentsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] elements == \");\r\n        if (parts.length == 2) {\r\n            return new ArrayElementsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\" == size\\\\(\");\r\n        if (parts.length == 2) {\r\n            return new SizeOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" == \");\r\n        if (parts.length == 2) {\r\n            return new EqualsConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" != \");\r\n        if (parts.length == 2) {\r\n            return new NonEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        // { is a special char in java regep so we must escape it \\\\{ or we get regexp error\r\n        parts = item.split(\" one of \\\\{\");\r\n        if (parts.length == 2) {\r\n            return new OneOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" in \");\r\n        if (parts.length == 2) {\r\n            return new AlwaysInArrayConstraint(parts[0], parts[1]);\r\n        }\r\n        throw new IllegalArgumentException(\"Unsupported contraint:\" + item);\r\n    }\r\n\r\n    public static Object parseValueObject(String obj) {\r\n        //remove any whitespace, line endings etc that will cause failure of startwith and endswith\r\n        obj = obj.trim();\r\n        if (obj.startsWith(\"[\") && obj.endsWith(\"]\")) {\r\n            return parseStringList(obj);\r\n        }\r\n        boolean array = false;\r\n        if (obj.endsWith(\"[]\")) {\r\n            array = true;\r\n            obj = obj.substring(0, obj.length() - 2);\r\n        }\r\n        if (obj.length() == 0) {\r\n            throw new IllegalArgumentException(\"Cannot parseLexical value from empty string\");\r\n        }\r\n        if (obj.startsWith(\"\\\"\") && obj.endsWith(\"\\\"\")) {\r\n            //in this case it is of form \"value\" and is a STRING so we remove the surrounding \"\"\r\n            String value = obj.substring(1, obj.length() - 1);\r\n            return value;\r\n        }\r\n        if (obj.equals(\"true\") || obj.equals(\"false\")) {\r\n            //in this case we have a BOOLEAN variable\r\n            boolean value = Boolean.parseBoolean(obj);\r\n            return value;\r\n        }\r\n        try {\r\n            //we try to parseLexical it as a NUMBER, if we succeed we are happy\r\n            double value = Double.parseDouble(obj);\r\n            return value;\r\n        } catch (NumberFormatException e) {\r\n            //if we come here, it was not a number and we ignore this exception\r\n        }\r\n        if (obj.indexOf(\"?\") == -1) {\r\n            //parameter index with ? separator is needed for reference objects, otherwise we consider it a string\r\n            //this can happen for array content values\r\n            return obj;\r\n        }\r\n        //    System.out.println(\"creating reference object for:\"+obj);\r\n        //the only possibility left is that it is a REFERENCE TO ANOTHER VARIABLE\r\n        //meaning it has a certain relation with the other variable, such as they are always equal\r\n        return new ReferenceValue(obj, array);\r\n    }\r\n\r\n    public static Collection<String> parseStringList(String obj) {\r\n        Collection<String> result = new ArrayList<String>();\r\n        //trim [ from start and ] from end\r\n        obj = obj.substring(1, obj.length() - 1);\r\n        String[] values = obj.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        result.addAll(Arrays.asList(values));\r\n        return result;\r\n    }\r\n\r\n    public static Collection parseObjectList(String value) {\r\n        if (value.length() == 0) {\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        Collection contents = new ArrayList();\r\n        String[] valueArray = value.split(\",\");\r\n        for (String s : valueArray) {\r\n            Object obj = DaikonParser.parseValueObject(s);\r\n            contents.add(obj);\r\n        }\r\n        return contents;\r\n    }\r\n\r\n    public static String parseEventName(String text) {\r\n        String[] parts = text.split(\":::\");\r\n        return parts[0];\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/DaikonParser_4Test.java",
		"test_prompt": "// DaikonParser_4Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport fi.vtt.noen.testgen.model.daikon.*;\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonParser}.\n* It contains ten unit test cases for the {@link DaikonParser#parseValueObject(String)} method.\n*/\nclass DaikonParser_4Test {"
	},
	{
		"original_code": "// DaikonParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.*;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * A parser for Daikon log files. Reads the Daikon log file and parses it into blocks, where each\r\n * block represents a monitored point of execution. Each block is taken to describe a state in the\r\n * generated state-machine. The invariants for this block are then turned into\r\n * invariant constraint objects describing when these states can be entered. Block sequences are also\r\n * considered, and considered to describe transition constraints between two blocks where one\r\n * follows another. These are then turned into transition invariant constraints for when this\r\n * transition can occur.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonParser {\r\n\r\n    private static final String EOF = \"Exiting Daikon.\";\r\n\r\n    //  private static final String ln = System.getProperty(\"line.separator\");\r\n    private String itemSeparator;\r\n\r\n    private final String text;\r\n\r\n    private int index = 0;\r\n\r\n    public DaikonParser(String text) {\r\n        this.text = text;\r\n        trySeparator(\"\\r\\n\");\r\n        trySeparator(\"\\n\");\r\n        trySeparator(\"\\r\");\r\n        index = text.indexOf(itemSeparator) + itemSeparator.length();\r\n    }\r\n\r\n    private void trySeparator(String lineChange) {\r\n        if (itemSeparator != null) {\r\n            //already found and set\r\n            return;\r\n        }\r\n        String test = \"===========================================================================\" + lineChange;\r\n        if (text.indexOf(test) > 0) {\r\n            itemSeparator = test;\r\n        }\r\n    }\r\n\r\n    public DaikonModel parseAll() {\r\n        String block = nextBlock();\r\n        DaikonModel model = new DaikonModel();\r\n        while (block != null) {\r\n            //      System.out.println(\"block:\"+block);\r\n            Collection<String> items = items(block);\r\n            Iterator<String> i = items.iterator();\r\n            String name = parseEventName(i.next());\r\n            DaikonModelElement me = DaikonModelElement.create(name);\r\n            model.add(me);\r\n            while (i.hasNext()) {\r\n                DaikonConstraint daikonConstraint = constraint(i.next());\r\n                if (daikonConstraint != null && daikonConstraint.isEnabled()) {\r\n                    //some logs had empty lines which now give null, so add this paranoia..\r\n                    me.addConstraint(daikonConstraint);\r\n                }\r\n            }\r\n            block = nextBlock();\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public String nextBlock() {\r\n        int endIndex = text.indexOf(itemSeparator, index);\r\n        if (endIndex < 0) {\r\n            endIndex = text.indexOf(EOF, index);\r\n        }\r\n        if (endIndex < 0) {\r\n            return null;\r\n        }\r\n        String result = text.substring(index, endIndex);\r\n        index = endIndex + itemSeparator.length();\r\n        return result;\r\n    }\r\n\r\n    public static Collection<String> items(String block) {\r\n        Collection<String> items = new ArrayList<String>();\r\n        int index = 0;\r\n        int endIndex = block.indexOf(\"\\n\");\r\n        while (endIndex > 0) {\r\n            String item = block.substring(index, endIndex);\r\n            items.add(item);\r\n            index = endIndex + 1;\r\n            endIndex = block.indexOf(\"\\n\", index);\r\n        }\r\n        return items;\r\n    }\r\n\r\n    public static DaikonConstraint constraint(String item) {\r\n        //    System.out.println(\"item:\"+item);\r\n        if (item.trim().length() == 0) {\r\n            //some daikon logs had empty lines so we do this now..\r\n            return null;\r\n        }\r\n        if (item.split(\"%\").length > 1) {\r\n            //some things just are not to be supported..\r\n            return null;\r\n        }\r\n        String[] parts = item.split(\" >= \");\r\n        if (parts.length == 2) {\r\n            return new GreaterOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" > \");\r\n        if (parts.length == 2) {\r\n            return new GreaterConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" <= \");\r\n        if (parts.length == 2) {\r\n            return new LesserOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" < \");\r\n        if (parts.length == 2) {\r\n            return new LesserConstraint(parts[0], parts[1]);\r\n        }\r\n        if (item.startsWith(\"size(\")) {\r\n            parts = item.split(\" == \");\r\n            if (parts.length == 2) {\r\n                return new ConstantSizeConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" != \");\r\n            if (parts.length == 2) {\r\n                return new NonEqualConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" one of \\\\{\");\r\n            return new ConstantSizeConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] == \\\\[\");\r\n        if (parts.length == 2) {\r\n            return new ArrayContentsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] elements == \");\r\n        if (parts.length == 2) {\r\n            return new ArrayElementsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\" == size\\\\(\");\r\n        if (parts.length == 2) {\r\n            return new SizeOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" == \");\r\n        if (parts.length == 2) {\r\n            return new EqualsConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" != \");\r\n        if (parts.length == 2) {\r\n            return new NonEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        // { is a special char in java regep so we must escape it \\\\{ or we get regexp error\r\n        parts = item.split(\" one of \\\\{\");\r\n        if (parts.length == 2) {\r\n            return new OneOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" in \");\r\n        if (parts.length == 2) {\r\n            return new AlwaysInArrayConstraint(parts[0], parts[1]);\r\n        }\r\n        throw new IllegalArgumentException(\"Unsupported contraint:\" + item);\r\n    }\r\n\r\n    public static Object parseValueObject(String obj) {\r\n        //remove any whitespace, line endings etc that will cause failure of startwith and endswith\r\n        obj = obj.trim();\r\n        if (obj.startsWith(\"[\") && obj.endsWith(\"]\")) {\r\n            return parseStringList(obj);\r\n        }\r\n        boolean array = false;\r\n        if (obj.endsWith(\"[]\")) {\r\n            array = true;\r\n            obj = obj.substring(0, obj.length() - 2);\r\n        }\r\n        if (obj.length() == 0) {\r\n            throw new IllegalArgumentException(\"Cannot parseLexical value from empty string\");\r\n        }\r\n        if (obj.startsWith(\"\\\"\") && obj.endsWith(\"\\\"\")) {\r\n            //in this case it is of form \"value\" and is a STRING so we remove the surrounding \"\"\r\n            String value = obj.substring(1, obj.length() - 1);\r\n            return value;\r\n        }\r\n        if (obj.equals(\"true\") || obj.equals(\"false\")) {\r\n            //in this case we have a BOOLEAN variable\r\n            boolean value = Boolean.parseBoolean(obj);\r\n            return value;\r\n        }\r\n        try {\r\n            //we try to parseLexical it as a NUMBER, if we succeed we are happy\r\n            double value = Double.parseDouble(obj);\r\n            return value;\r\n        } catch (NumberFormatException e) {\r\n            //if we come here, it was not a number and we ignore this exception\r\n        }\r\n        if (obj.indexOf(\"?\") == -1) {\r\n            //parameter index with ? separator is needed for reference objects, otherwise we consider it a string\r\n            //this can happen for array content values\r\n            return obj;\r\n        }\r\n        //    System.out.println(\"creating reference object for:\"+obj);\r\n        //the only possibility left is that it is a REFERENCE TO ANOTHER VARIABLE\r\n        //meaning it has a certain relation with the other variable, such as they are always equal\r\n        return new ReferenceValue(obj, array);\r\n    }\r\n\r\n    public static Collection<String> parseStringList(String obj) {\r\n        Collection<String> result = new ArrayList<String>();\r\n        //trim [ from start and ] from end\r\n        obj = obj.substring(1, obj.length() - 1);\r\n        String[] values = obj.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        result.addAll(Arrays.asList(values));\r\n        return result;\r\n    }\r\n\r\n    public static Collection parseObjectList(String value) {\r\n        if (value.length() == 0) {\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        Collection contents = new ArrayList();\r\n        String[] valueArray = value.split(\",\");\r\n        for (String s : valueArray) {\r\n            Object obj = DaikonParser.parseValueObject(s);\r\n            contents.add(obj);\r\n        }\r\n        return contents;\r\n    }\r\n\r\n    public static String parseEventName(String text) {\r\n        String[] parts = text.split(\":::\");\r\n        return parts[0];\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/DaikonParser_5Test.java",
		"test_prompt": "// DaikonParser_5Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport fi.vtt.noen.testgen.model.daikon.*;\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonParser}.\n* It contains ten unit test cases for the {@link DaikonParser#parseStringList(String)} method.\n*/\nclass DaikonParser_5Test {"
	},
	{
		"original_code": "// DaikonParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.*;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * A parser for Daikon log files. Reads the Daikon log file and parses it into blocks, where each\r\n * block represents a monitored point of execution. Each block is taken to describe a state in the\r\n * generated state-machine. The invariants for this block are then turned into\r\n * invariant constraint objects describing when these states can be entered. Block sequences are also\r\n * considered, and considered to describe transition constraints between two blocks where one\r\n * follows another. These are then turned into transition invariant constraints for when this\r\n * transition can occur.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonParser {\r\n\r\n    private static final String EOF = \"Exiting Daikon.\";\r\n\r\n    //  private static final String ln = System.getProperty(\"line.separator\");\r\n    private String itemSeparator;\r\n\r\n    private final String text;\r\n\r\n    private int index = 0;\r\n\r\n    public DaikonParser(String text) {\r\n        this.text = text;\r\n        trySeparator(\"\\r\\n\");\r\n        trySeparator(\"\\n\");\r\n        trySeparator(\"\\r\");\r\n        index = text.indexOf(itemSeparator) + itemSeparator.length();\r\n    }\r\n\r\n    private void trySeparator(String lineChange) {\r\n        if (itemSeparator != null) {\r\n            //already found and set\r\n            return;\r\n        }\r\n        String test = \"===========================================================================\" + lineChange;\r\n        if (text.indexOf(test) > 0) {\r\n            itemSeparator = test;\r\n        }\r\n    }\r\n\r\n    public DaikonModel parseAll() {\r\n        String block = nextBlock();\r\n        DaikonModel model = new DaikonModel();\r\n        while (block != null) {\r\n            //      System.out.println(\"block:\"+block);\r\n            Collection<String> items = items(block);\r\n            Iterator<String> i = items.iterator();\r\n            String name = parseEventName(i.next());\r\n            DaikonModelElement me = DaikonModelElement.create(name);\r\n            model.add(me);\r\n            while (i.hasNext()) {\r\n                DaikonConstraint daikonConstraint = constraint(i.next());\r\n                if (daikonConstraint != null && daikonConstraint.isEnabled()) {\r\n                    //some logs had empty lines which now give null, so add this paranoia..\r\n                    me.addConstraint(daikonConstraint);\r\n                }\r\n            }\r\n            block = nextBlock();\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public String nextBlock() {\r\n        int endIndex = text.indexOf(itemSeparator, index);\r\n        if (endIndex < 0) {\r\n            endIndex = text.indexOf(EOF, index);\r\n        }\r\n        if (endIndex < 0) {\r\n            return null;\r\n        }\r\n        String result = text.substring(index, endIndex);\r\n        index = endIndex + itemSeparator.length();\r\n        return result;\r\n    }\r\n\r\n    public static Collection<String> items(String block) {\r\n        Collection<String> items = new ArrayList<String>();\r\n        int index = 0;\r\n        int endIndex = block.indexOf(\"\\n\");\r\n        while (endIndex > 0) {\r\n            String item = block.substring(index, endIndex);\r\n            items.add(item);\r\n            index = endIndex + 1;\r\n            endIndex = block.indexOf(\"\\n\", index);\r\n        }\r\n        return items;\r\n    }\r\n\r\n    public static DaikonConstraint constraint(String item) {\r\n        //    System.out.println(\"item:\"+item);\r\n        if (item.trim().length() == 0) {\r\n            //some daikon logs had empty lines so we do this now..\r\n            return null;\r\n        }\r\n        if (item.split(\"%\").length > 1) {\r\n            //some things just are not to be supported..\r\n            return null;\r\n        }\r\n        String[] parts = item.split(\" >= \");\r\n        if (parts.length == 2) {\r\n            return new GreaterOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" > \");\r\n        if (parts.length == 2) {\r\n            return new GreaterConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" <= \");\r\n        if (parts.length == 2) {\r\n            return new LesserOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" < \");\r\n        if (parts.length == 2) {\r\n            return new LesserConstraint(parts[0], parts[1]);\r\n        }\r\n        if (item.startsWith(\"size(\")) {\r\n            parts = item.split(\" == \");\r\n            if (parts.length == 2) {\r\n                return new ConstantSizeConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" != \");\r\n            if (parts.length == 2) {\r\n                return new NonEqualConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" one of \\\\{\");\r\n            return new ConstantSizeConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] == \\\\[\");\r\n        if (parts.length == 2) {\r\n            return new ArrayContentsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] elements == \");\r\n        if (parts.length == 2) {\r\n            return new ArrayElementsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\" == size\\\\(\");\r\n        if (parts.length == 2) {\r\n            return new SizeOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" == \");\r\n        if (parts.length == 2) {\r\n            return new EqualsConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" != \");\r\n        if (parts.length == 2) {\r\n            return new NonEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        // { is a special char in java regep so we must escape it \\\\{ or we get regexp error\r\n        parts = item.split(\" one of \\\\{\");\r\n        if (parts.length == 2) {\r\n            return new OneOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" in \");\r\n        if (parts.length == 2) {\r\n            return new AlwaysInArrayConstraint(parts[0], parts[1]);\r\n        }\r\n        throw new IllegalArgumentException(\"Unsupported contraint:\" + item);\r\n    }\r\n\r\n    public static Object parseValueObject(String obj) {\r\n        //remove any whitespace, line endings etc that will cause failure of startwith and endswith\r\n        obj = obj.trim();\r\n        if (obj.startsWith(\"[\") && obj.endsWith(\"]\")) {\r\n            return parseStringList(obj);\r\n        }\r\n        boolean array = false;\r\n        if (obj.endsWith(\"[]\")) {\r\n            array = true;\r\n            obj = obj.substring(0, obj.length() - 2);\r\n        }\r\n        if (obj.length() == 0) {\r\n            throw new IllegalArgumentException(\"Cannot parseLexical value from empty string\");\r\n        }\r\n        if (obj.startsWith(\"\\\"\") && obj.endsWith(\"\\\"\")) {\r\n            //in this case it is of form \"value\" and is a STRING so we remove the surrounding \"\"\r\n            String value = obj.substring(1, obj.length() - 1);\r\n            return value;\r\n        }\r\n        if (obj.equals(\"true\") || obj.equals(\"false\")) {\r\n            //in this case we have a BOOLEAN variable\r\n            boolean value = Boolean.parseBoolean(obj);\r\n            return value;\r\n        }\r\n        try {\r\n            //we try to parseLexical it as a NUMBER, if we succeed we are happy\r\n            double value = Double.parseDouble(obj);\r\n            return value;\r\n        } catch (NumberFormatException e) {\r\n            //if we come here, it was not a number and we ignore this exception\r\n        }\r\n        if (obj.indexOf(\"?\") == -1) {\r\n            //parameter index with ? separator is needed for reference objects, otherwise we consider it a string\r\n            //this can happen for array content values\r\n            return obj;\r\n        }\r\n        //    System.out.println(\"creating reference object for:\"+obj);\r\n        //the only possibility left is that it is a REFERENCE TO ANOTHER VARIABLE\r\n        //meaning it has a certain relation with the other variable, such as they are always equal\r\n        return new ReferenceValue(obj, array);\r\n    }\r\n\r\n    public static Collection<String> parseStringList(String obj) {\r\n        Collection<String> result = new ArrayList<String>();\r\n        //trim [ from start and ] from end\r\n        obj = obj.substring(1, obj.length() - 1);\r\n        String[] values = obj.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        result.addAll(Arrays.asList(values));\r\n        return result;\r\n    }\r\n\r\n    public static Collection parseObjectList(String value) {\r\n        if (value.length() == 0) {\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        Collection contents = new ArrayList();\r\n        String[] valueArray = value.split(\",\");\r\n        for (String s : valueArray) {\r\n            Object obj = DaikonParser.parseValueObject(s);\r\n            contents.add(obj);\r\n        }\r\n        return contents;\r\n    }\r\n\r\n    public static String parseEventName(String text) {\r\n        String[] parts = text.split(\":::\");\r\n        return parts[0];\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/DaikonParser_6Test.java",
		"test_prompt": "// DaikonParser_6Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport fi.vtt.noen.testgen.model.daikon.*;\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonParser}.\n* It contains ten unit test cases for the {@link DaikonParser#parseObjectList(String)} method.\n*/\nclass DaikonParser_6Test {"
	},
	{
		"original_code": "// DaikonParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.*;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\r\nimport java.util.*;\r\n\r\n/**\r\n * A parser for Daikon log files. Reads the Daikon log file and parses it into blocks, where each\r\n * block represents a monitored point of execution. Each block is taken to describe a state in the\r\n * generated state-machine. The invariants for this block are then turned into\r\n * invariant constraint objects describing when these states can be entered. Block sequences are also\r\n * considered, and considered to describe transition constraints between two blocks where one\r\n * follows another. These are then turned into transition invariant constraints for when this\r\n * transition can occur.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonParser {\r\n\r\n    private static final String EOF = \"Exiting Daikon.\";\r\n\r\n    //  private static final String ln = System.getProperty(\"line.separator\");\r\n    private String itemSeparator;\r\n\r\n    private final String text;\r\n\r\n    private int index = 0;\r\n\r\n    public DaikonParser(String text) {\r\n        this.text = text;\r\n        trySeparator(\"\\r\\n\");\r\n        trySeparator(\"\\n\");\r\n        trySeparator(\"\\r\");\r\n        index = text.indexOf(itemSeparator) + itemSeparator.length();\r\n    }\r\n\r\n    private void trySeparator(String lineChange) {\r\n        if (itemSeparator != null) {\r\n            //already found and set\r\n            return;\r\n        }\r\n        String test = \"===========================================================================\" + lineChange;\r\n        if (text.indexOf(test) > 0) {\r\n            itemSeparator = test;\r\n        }\r\n    }\r\n\r\n    public DaikonModel parseAll() {\r\n        String block = nextBlock();\r\n        DaikonModel model = new DaikonModel();\r\n        while (block != null) {\r\n            //      System.out.println(\"block:\"+block);\r\n            Collection<String> items = items(block);\r\n            Iterator<String> i = items.iterator();\r\n            String name = parseEventName(i.next());\r\n            DaikonModelElement me = DaikonModelElement.create(name);\r\n            model.add(me);\r\n            while (i.hasNext()) {\r\n                DaikonConstraint daikonConstraint = constraint(i.next());\r\n                if (daikonConstraint != null && daikonConstraint.isEnabled()) {\r\n                    //some logs had empty lines which now give null, so add this paranoia..\r\n                    me.addConstraint(daikonConstraint);\r\n                }\r\n            }\r\n            block = nextBlock();\r\n        }\r\n        return model;\r\n    }\r\n\r\n    public String nextBlock() {\r\n        int endIndex = text.indexOf(itemSeparator, index);\r\n        if (endIndex < 0) {\r\n            endIndex = text.indexOf(EOF, index);\r\n        }\r\n        if (endIndex < 0) {\r\n            return null;\r\n        }\r\n        String result = text.substring(index, endIndex);\r\n        index = endIndex + itemSeparator.length();\r\n        return result;\r\n    }\r\n\r\n    public static Collection<String> items(String block) {\r\n        Collection<String> items = new ArrayList<String>();\r\n        int index = 0;\r\n        int endIndex = block.indexOf(\"\\n\");\r\n        while (endIndex > 0) {\r\n            String item = block.substring(index, endIndex);\r\n            items.add(item);\r\n            index = endIndex + 1;\r\n            endIndex = block.indexOf(\"\\n\", index);\r\n        }\r\n        return items;\r\n    }\r\n\r\n    public static DaikonConstraint constraint(String item) {\r\n        //    System.out.println(\"item:\"+item);\r\n        if (item.trim().length() == 0) {\r\n            //some daikon logs had empty lines so we do this now..\r\n            return null;\r\n        }\r\n        if (item.split(\"%\").length > 1) {\r\n            //some things just are not to be supported..\r\n            return null;\r\n        }\r\n        String[] parts = item.split(\" >= \");\r\n        if (parts.length == 2) {\r\n            return new GreaterOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" > \");\r\n        if (parts.length == 2) {\r\n            return new GreaterConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" <= \");\r\n        if (parts.length == 2) {\r\n            return new LesserOrEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" < \");\r\n        if (parts.length == 2) {\r\n            return new LesserConstraint(parts[0], parts[1]);\r\n        }\r\n        if (item.startsWith(\"size(\")) {\r\n            parts = item.split(\" == \");\r\n            if (parts.length == 2) {\r\n                return new ConstantSizeConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" != \");\r\n            if (parts.length == 2) {\r\n                return new NonEqualConstraint(parts[0], parts[1]);\r\n            }\r\n            parts = item.split(\" one of \\\\{\");\r\n            return new ConstantSizeConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] == \\\\[\");\r\n        if (parts.length == 2) {\r\n            return new ArrayContentsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\"\\\\[\\\\] elements == \");\r\n        if (parts.length == 2) {\r\n            return new ArrayElementsConstraint(parts[0] + \"[]\", parts[1]);\r\n        }\r\n        parts = item.split(\" == size\\\\(\");\r\n        if (parts.length == 2) {\r\n            return new SizeOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" == \");\r\n        if (parts.length == 2) {\r\n            return new EqualsConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" != \");\r\n        if (parts.length == 2) {\r\n            return new NonEqualConstraint(parts[0], parts[1]);\r\n        }\r\n        // { is a special char in java regep so we must escape it \\\\{ or we get regexp error\r\n        parts = item.split(\" one of \\\\{\");\r\n        if (parts.length == 2) {\r\n            return new OneOfConstraint(parts[0], parts[1]);\r\n        }\r\n        parts = item.split(\" in \");\r\n        if (parts.length == 2) {\r\n            return new AlwaysInArrayConstraint(parts[0], parts[1]);\r\n        }\r\n        throw new IllegalArgumentException(\"Unsupported contraint:\" + item);\r\n    }\r\n\r\n    public static Object parseValueObject(String obj) {\r\n        //remove any whitespace, line endings etc that will cause failure of startwith and endswith\r\n        obj = obj.trim();\r\n        if (obj.startsWith(\"[\") && obj.endsWith(\"]\")) {\r\n            return parseStringList(obj);\r\n        }\r\n        boolean array = false;\r\n        if (obj.endsWith(\"[]\")) {\r\n            array = true;\r\n            obj = obj.substring(0, obj.length() - 2);\r\n        }\r\n        if (obj.length() == 0) {\r\n            throw new IllegalArgumentException(\"Cannot parseLexical value from empty string\");\r\n        }\r\n        if (obj.startsWith(\"\\\"\") && obj.endsWith(\"\\\"\")) {\r\n            //in this case it is of form \"value\" and is a STRING so we remove the surrounding \"\"\r\n            String value = obj.substring(1, obj.length() - 1);\r\n            return value;\r\n        }\r\n        if (obj.equals(\"true\") || obj.equals(\"false\")) {\r\n            //in this case we have a BOOLEAN variable\r\n            boolean value = Boolean.parseBoolean(obj);\r\n            return value;\r\n        }\r\n        try {\r\n            //we try to parseLexical it as a NUMBER, if we succeed we are happy\r\n            double value = Double.parseDouble(obj);\r\n            return value;\r\n        } catch (NumberFormatException e) {\r\n            //if we come here, it was not a number and we ignore this exception\r\n        }\r\n        if (obj.indexOf(\"?\") == -1) {\r\n            //parameter index with ? separator is needed for reference objects, otherwise we consider it a string\r\n            //this can happen for array content values\r\n            return obj;\r\n        }\r\n        //    System.out.println(\"creating reference object for:\"+obj);\r\n        //the only possibility left is that it is a REFERENCE TO ANOTHER VARIABLE\r\n        //meaning it has a certain relation with the other variable, such as they are always equal\r\n        return new ReferenceValue(obj, array);\r\n    }\r\n\r\n    public static Collection<String> parseStringList(String obj) {\r\n        Collection<String> result = new ArrayList<String>();\r\n        //trim [ from start and ] from end\r\n        obj = obj.substring(1, obj.length() - 1);\r\n        String[] values = obj.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        result.addAll(Arrays.asList(values));\r\n        return result;\r\n    }\r\n\r\n    public static Collection parseObjectList(String value) {\r\n        if (value.length() == 0) {\r\n            return Collections.EMPTY_LIST;\r\n        }\r\n        Collection contents = new ArrayList();\r\n        String[] valueArray = value.split(\",\");\r\n        for (String s : valueArray) {\r\n            Object obj = DaikonParser.parseValueObject(s);\r\n            contents.add(obj);\r\n        }\r\n        return contents;\r\n    }\r\n\r\n    public static String parseEventName(String text) {\r\n        String[] parts = text.split(\":::\");\r\n        return parts[0];\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/DaikonParser_7Test.java",
		"test_prompt": "// DaikonParser_7Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport fi.vtt.noen.testgen.model.daikon.*;\nimport fi.vtt.noen.testgen.model.daikon.constraints.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonParser}.\n* It contains ten unit test cases for the {@link DaikonParser#parseEventName(String)} method.\n*/\nclass DaikonParser_7Test {"
	},
	{
		"original_code": "// PromParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport org.deckfour.xes.in.XMxmlParser;\r\nimport org.deckfour.xes.model.XLog;\r\nimport org.deckfour.xes.model.XEvent;\r\nimport org.deckfour.xes.model.XAttribute;\r\nimport org.deckfour.xes.info.XLogInfo;\r\nimport org.deckfour.xes.info.XLogInfoFactory;\r\nimport org.deckfour.xes.classification.XEventClassifier;\r\nimport org.deckfour.xes.classification.XEventNameClassifier;\r\nimport org.deckfour.xes.classification.XEventClass;\r\nimport org.processmining.framework.plugin.*;\r\nimport org.processmining.framework.plugin.events.ProgressEventListener;\r\nimport org.processmining.framework.plugin.events.PluginLifeCycleEventListener;\r\nimport org.processmining.framework.plugin.events.Logger;\r\nimport org.processmining.framework.plugin.impl.AbstractPluginContext;\r\nimport org.processmining.framework.plugin.impl.FieldSetException;\r\nimport org.processmining.framework.connections.Connection;\r\nimport org.processmining.framework.connections.ConnectionManager;\r\nimport org.processmining.framework.providedobjects.ProvidedObjectManager;\r\nimport org.processmining.contexts.cli.CLIPluginContext;\r\nimport org.processmining.contexts.cli.CLIContext;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMinerInput;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMiner;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMinerOutput;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSAbstractions;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSDirections;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSModes;\r\nimport org.processmining.plugins.transitionsystem.miner.modir.TSMinerModirInput;\r\nimport org.processmining.plugins.transitionsystem.converter.util.TSConversions;\r\nimport org.xml.sax.SAXException;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\nimport java.io.IOException;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.util.*;\r\nimport java.util.concurrent.Executor;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\n\r\n/**\r\n * Uses ProM code to build an FSM from a suitable log file and takes the resulting data\r\n * structures describing the FSM, turning these into custom formats used for EFSM generation.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class PromParser {\r\n\r\n    public XLog parseLog(InputStream in) {\r\n        try {\r\n            Set<XLog> logs = new XMxmlParser().parse(in);\r\n            Iterator<XLog> i = logs.iterator();\r\n            XLog log = i.next();\r\n            return log;\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Problem with PROM MXML parser.\", e);\r\n        }\r\n    }\r\n\r\n    public Collection<String> createFilters(XLogInfo summary) {\r\n        Collection<String> filters = new ArrayList<String>();\r\n        for (XEventClass xe : summary.getIdClasses().getClasses()) {\r\n            filters.add(xe.toString());\r\n        }\r\n        return filters;\r\n    }\r\n\r\n    public FSMModel parse(InputStream in) {\r\n        XLog log = parseLog(in);\r\n        XLogInfo summary = XLogInfoFactory.createLogInfo(log);\r\n        CLIPluginContext context = new CLIPluginContext(new CLIContext(), \"PROMTest\");\r\n        TSMinerInput input = new TSMinerInput(context, log, summary);\r\n        //    System.out.println(\"converter:\"+input.getConverterSettings().getUse(TSConversions.KILLSELFLOOPS));\r\n        //    input.getConverterSettings().setUse(TSConversions.KILLSELFLOOPS, false);\r\n        TSMinerModirInput modirInput = new TSMinerModirInput();\r\n        modirInput.setUse(true);\r\n        Collection<String> filters = createFilters(summary);\r\n        modirInput.getFilter().addAll(filters);\r\n        modirInput.setAbstraction(TSAbstractions.SEQUENCE);\r\n        modirInput.setHorizon(1);\r\n        modirInput.setFilteredHorizon(1);\r\n        input.setModirSettings(TSDirections.BACKWARD, TSModes.MODELELEMENT, modirInput);\r\n        TSMiner miner = new TSMiner(context);\r\n        TSMinerOutput output = miner.mine(input);\r\n        FSMModel fsm = new FSMModel(output.getTransitionSystem());\r\n        return fsm;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/PromParser_0Test.java",
		"test_prompt": "// PromParser_0Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport org.deckfour.xes.in.XMxmlParser;\nimport org.deckfour.xes.model.XLog;\nimport org.deckfour.xes.model.XEvent;\nimport org.deckfour.xes.model.XAttribute;\nimport org.deckfour.xes.info.XLogInfo;\nimport org.deckfour.xes.info.XLogInfoFactory;\nimport org.deckfour.xes.classification.XEventClassifier;\nimport org.deckfour.xes.classification.XEventNameClassifier;\nimport org.deckfour.xes.classification.XEventClass;\nimport org.processmining.framework.plugin.*;\nimport org.processmining.framework.plugin.events.ProgressEventListener;\nimport org.processmining.framework.plugin.events.PluginLifeCycleEventListener;\nimport org.processmining.framework.plugin.events.Logger;\nimport org.processmining.framework.plugin.impl.AbstractPluginContext;\nimport org.processmining.framework.plugin.impl.FieldSetException;\nimport org.processmining.framework.connections.Connection;\nimport org.processmining.framework.connections.ConnectionManager;\nimport org.processmining.framework.providedobjects.ProvidedObjectManager;\nimport org.processmining.contexts.cli.CLIPluginContext;\nimport org.processmining.contexts.cli.CLIContext;\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\nimport org.processmining.plugins.transitionsystem.miner.TSMinerInput;\nimport org.processmining.plugins.transitionsystem.miner.TSMiner;\nimport org.processmining.plugins.transitionsystem.miner.TSMinerOutput;\nimport org.processmining.plugins.transitionsystem.miner.util.TSAbstractions;\nimport org.processmining.plugins.transitionsystem.miner.util.TSDirections;\nimport org.processmining.plugins.transitionsystem.miner.util.TSModes;\nimport org.processmining.plugins.transitionsystem.miner.modir.TSMinerModirInput;\nimport org.processmining.plugins.transitionsystem.converter.util.TSConversions;\nimport org.xml.sax.SAXException;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.ByteArrayOutputStream;\nimport java.util.*;\nimport java.util.concurrent.Executor;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PromParser}.\n* It contains ten unit test cases for the {@link PromParser#parseLog(InputStream)} method.\n*/\nclass PromParser_0Test {"
	},
	{
		"original_code": "// PromParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport org.deckfour.xes.in.XMxmlParser;\r\nimport org.deckfour.xes.model.XLog;\r\nimport org.deckfour.xes.model.XEvent;\r\nimport org.deckfour.xes.model.XAttribute;\r\nimport org.deckfour.xes.info.XLogInfo;\r\nimport org.deckfour.xes.info.XLogInfoFactory;\r\nimport org.deckfour.xes.classification.XEventClassifier;\r\nimport org.deckfour.xes.classification.XEventNameClassifier;\r\nimport org.deckfour.xes.classification.XEventClass;\r\nimport org.processmining.framework.plugin.*;\r\nimport org.processmining.framework.plugin.events.ProgressEventListener;\r\nimport org.processmining.framework.plugin.events.PluginLifeCycleEventListener;\r\nimport org.processmining.framework.plugin.events.Logger;\r\nimport org.processmining.framework.plugin.impl.AbstractPluginContext;\r\nimport org.processmining.framework.plugin.impl.FieldSetException;\r\nimport org.processmining.framework.connections.Connection;\r\nimport org.processmining.framework.connections.ConnectionManager;\r\nimport org.processmining.framework.providedobjects.ProvidedObjectManager;\r\nimport org.processmining.contexts.cli.CLIPluginContext;\r\nimport org.processmining.contexts.cli.CLIContext;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMinerInput;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMiner;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMinerOutput;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSAbstractions;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSDirections;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSModes;\r\nimport org.processmining.plugins.transitionsystem.miner.modir.TSMinerModirInput;\r\nimport org.processmining.plugins.transitionsystem.converter.util.TSConversions;\r\nimport org.xml.sax.SAXException;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\nimport java.io.IOException;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.util.*;\r\nimport java.util.concurrent.Executor;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\n\r\n/**\r\n * Uses ProM code to build an FSM from a suitable log file and takes the resulting data\r\n * structures describing the FSM, turning these into custom formats used for EFSM generation.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class PromParser {\r\n\r\n    public XLog parseLog(InputStream in) {\r\n        try {\r\n            Set<XLog> logs = new XMxmlParser().parse(in);\r\n            Iterator<XLog> i = logs.iterator();\r\n            XLog log = i.next();\r\n            return log;\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Problem with PROM MXML parser.\", e);\r\n        }\r\n    }\r\n\r\n    public Collection<String> createFilters(XLogInfo summary) {\r\n        Collection<String> filters = new ArrayList<String>();\r\n        for (XEventClass xe : summary.getIdClasses().getClasses()) {\r\n            filters.add(xe.toString());\r\n        }\r\n        return filters;\r\n    }\r\n\r\n    public FSMModel parse(InputStream in) {\r\n        XLog log = parseLog(in);\r\n        XLogInfo summary = XLogInfoFactory.createLogInfo(log);\r\n        CLIPluginContext context = new CLIPluginContext(new CLIContext(), \"PROMTest\");\r\n        TSMinerInput input = new TSMinerInput(context, log, summary);\r\n        //    System.out.println(\"converter:\"+input.getConverterSettings().getUse(TSConversions.KILLSELFLOOPS));\r\n        //    input.getConverterSettings().setUse(TSConversions.KILLSELFLOOPS, false);\r\n        TSMinerModirInput modirInput = new TSMinerModirInput();\r\n        modirInput.setUse(true);\r\n        Collection<String> filters = createFilters(summary);\r\n        modirInput.getFilter().addAll(filters);\r\n        modirInput.setAbstraction(TSAbstractions.SEQUENCE);\r\n        modirInput.setHorizon(1);\r\n        modirInput.setFilteredHorizon(1);\r\n        input.setModirSettings(TSDirections.BACKWARD, TSModes.MODELELEMENT, modirInput);\r\n        TSMiner miner = new TSMiner(context);\r\n        TSMinerOutput output = miner.mine(input);\r\n        FSMModel fsm = new FSMModel(output.getTransitionSystem());\r\n        return fsm;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/PromParser_1Test.java",
		"test_prompt": "// PromParser_1Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport org.deckfour.xes.in.XMxmlParser;\nimport org.deckfour.xes.model.XLog;\nimport org.deckfour.xes.model.XEvent;\nimport org.deckfour.xes.model.XAttribute;\nimport org.deckfour.xes.info.XLogInfo;\nimport org.deckfour.xes.info.XLogInfoFactory;\nimport org.deckfour.xes.classification.XEventClassifier;\nimport org.deckfour.xes.classification.XEventNameClassifier;\nimport org.deckfour.xes.classification.XEventClass;\nimport org.processmining.framework.plugin.*;\nimport org.processmining.framework.plugin.events.ProgressEventListener;\nimport org.processmining.framework.plugin.events.PluginLifeCycleEventListener;\nimport org.processmining.framework.plugin.events.Logger;\nimport org.processmining.framework.plugin.impl.AbstractPluginContext;\nimport org.processmining.framework.plugin.impl.FieldSetException;\nimport org.processmining.framework.connections.Connection;\nimport org.processmining.framework.connections.ConnectionManager;\nimport org.processmining.framework.providedobjects.ProvidedObjectManager;\nimport org.processmining.contexts.cli.CLIPluginContext;\nimport org.processmining.contexts.cli.CLIContext;\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\nimport org.processmining.plugins.transitionsystem.miner.TSMinerInput;\nimport org.processmining.plugins.transitionsystem.miner.TSMiner;\nimport org.processmining.plugins.transitionsystem.miner.TSMinerOutput;\nimport org.processmining.plugins.transitionsystem.miner.util.TSAbstractions;\nimport org.processmining.plugins.transitionsystem.miner.util.TSDirections;\nimport org.processmining.plugins.transitionsystem.miner.util.TSModes;\nimport org.processmining.plugins.transitionsystem.miner.modir.TSMinerModirInput;\nimport org.processmining.plugins.transitionsystem.converter.util.TSConversions;\nimport org.xml.sax.SAXException;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.ByteArrayOutputStream;\nimport java.util.*;\nimport java.util.concurrent.Executor;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PromParser}.\n* It contains ten unit test cases for the {@link PromParser#createFilters(XLogInfo)} method.\n*/\nclass PromParser_1Test {"
	},
	{
		"original_code": "// PromParser.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.parser;\r\n\r\nimport org.deckfour.xes.in.XMxmlParser;\r\nimport org.deckfour.xes.model.XLog;\r\nimport org.deckfour.xes.model.XEvent;\r\nimport org.deckfour.xes.model.XAttribute;\r\nimport org.deckfour.xes.info.XLogInfo;\r\nimport org.deckfour.xes.info.XLogInfoFactory;\r\nimport org.deckfour.xes.classification.XEventClassifier;\r\nimport org.deckfour.xes.classification.XEventNameClassifier;\r\nimport org.deckfour.xes.classification.XEventClass;\r\nimport org.processmining.framework.plugin.*;\r\nimport org.processmining.framework.plugin.events.ProgressEventListener;\r\nimport org.processmining.framework.plugin.events.PluginLifeCycleEventListener;\r\nimport org.processmining.framework.plugin.events.Logger;\r\nimport org.processmining.framework.plugin.impl.AbstractPluginContext;\r\nimport org.processmining.framework.plugin.impl.FieldSetException;\r\nimport org.processmining.framework.connections.Connection;\r\nimport org.processmining.framework.connections.ConnectionManager;\r\nimport org.processmining.framework.providedobjects.ProvidedObjectManager;\r\nimport org.processmining.contexts.cli.CLIPluginContext;\r\nimport org.processmining.contexts.cli.CLIContext;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMinerInput;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMiner;\r\nimport org.processmining.plugins.transitionsystem.miner.TSMinerOutput;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSAbstractions;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSDirections;\r\nimport org.processmining.plugins.transitionsystem.miner.util.TSModes;\r\nimport org.processmining.plugins.transitionsystem.miner.modir.TSMinerModirInput;\r\nimport org.processmining.plugins.transitionsystem.converter.util.TSConversions;\r\nimport org.xml.sax.SAXException;\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\nimport java.io.IOException;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.util.*;\r\nimport java.util.concurrent.Executor;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\n\r\n/**\r\n * Uses ProM code to build an FSM from a suitable log file and takes the resulting data\r\n * structures describing the FSM, turning these into custom formats used for EFSM generation.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class PromParser {\r\n\r\n    public XLog parseLog(InputStream in) {\r\n        try {\r\n            Set<XLog> logs = new XMxmlParser().parse(in);\r\n            Iterator<XLog> i = logs.iterator();\r\n            XLog log = i.next();\r\n            return log;\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Problem with PROM MXML parser.\", e);\r\n        }\r\n    }\r\n\r\n    public Collection<String> createFilters(XLogInfo summary) {\r\n        Collection<String> filters = new ArrayList<String>();\r\n        for (XEventClass xe : summary.getIdClasses().getClasses()) {\r\n            filters.add(xe.toString());\r\n        }\r\n        return filters;\r\n    }\r\n\r\n    public FSMModel parse(InputStream in) {\r\n        XLog log = parseLog(in);\r\n        XLogInfo summary = XLogInfoFactory.createLogInfo(log);\r\n        CLIPluginContext context = new CLIPluginContext(new CLIContext(), \"PROMTest\");\r\n        TSMinerInput input = new TSMinerInput(context, log, summary);\r\n        //    System.out.println(\"converter:\"+input.getConverterSettings().getUse(TSConversions.KILLSELFLOOPS));\r\n        //    input.getConverterSettings().setUse(TSConversions.KILLSELFLOOPS, false);\r\n        TSMinerModirInput modirInput = new TSMinerModirInput();\r\n        modirInput.setUse(true);\r\n        Collection<String> filters = createFilters(summary);\r\n        modirInput.getFilter().addAll(filters);\r\n        modirInput.setAbstraction(TSAbstractions.SEQUENCE);\r\n        modirInput.setHorizon(1);\r\n        modirInput.setFilteredHorizon(1);\r\n        input.setModirSettings(TSDirections.BACKWARD, TSModes.MODELELEMENT, modirInput);\r\n        TSMiner miner = new TSMiner(context);\r\n        TSMinerOutput output = miner.mine(input);\r\n        FSMModel fsm = new FSMModel(output.getTransitionSystem());\r\n        return fsm;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/parser/PromParser_2Test.java",
		"test_prompt": "// PromParser_2Test.java\npackage fi.vtt.noen.testgen.parser;\n\nimport org.deckfour.xes.in.XMxmlParser;\nimport org.deckfour.xes.model.XLog;\nimport org.deckfour.xes.model.XEvent;\nimport org.deckfour.xes.model.XAttribute;\nimport org.deckfour.xes.info.XLogInfo;\nimport org.deckfour.xes.info.XLogInfoFactory;\nimport org.deckfour.xes.classification.XEventClassifier;\nimport org.deckfour.xes.classification.XEventNameClassifier;\nimport org.deckfour.xes.classification.XEventClass;\nimport org.processmining.framework.plugin.*;\nimport org.processmining.framework.plugin.events.ProgressEventListener;\nimport org.processmining.framework.plugin.events.PluginLifeCycleEventListener;\nimport org.processmining.framework.plugin.events.Logger;\nimport org.processmining.framework.plugin.impl.AbstractPluginContext;\nimport org.processmining.framework.plugin.impl.FieldSetException;\nimport org.processmining.framework.connections.Connection;\nimport org.processmining.framework.connections.ConnectionManager;\nimport org.processmining.framework.providedobjects.ProvidedObjectManager;\nimport org.processmining.contexts.cli.CLIPluginContext;\nimport org.processmining.contexts.cli.CLIContext;\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\nimport org.processmining.plugins.transitionsystem.miner.TSMinerInput;\nimport org.processmining.plugins.transitionsystem.miner.TSMiner;\nimport org.processmining.plugins.transitionsystem.miner.TSMinerOutput;\nimport org.processmining.plugins.transitionsystem.miner.util.TSAbstractions;\nimport org.processmining.plugins.transitionsystem.miner.util.TSDirections;\nimport org.processmining.plugins.transitionsystem.miner.util.TSModes;\nimport org.processmining.plugins.transitionsystem.miner.modir.TSMinerModirInput;\nimport org.processmining.plugins.transitionsystem.converter.util.TSConversions;\nimport org.xml.sax.SAXException;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.io.ByteArrayOutputStream;\nimport java.util.*;\nimport java.util.concurrent.Executor;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PromParser}.\n* It contains ten unit test cases for the {@link PromParser#parse(InputStream)} method.\n*/\nclass PromParser_2Test {"
	},
	{
		"original_code": "// Main.java\n/*\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\n *\n * This file is part of NOEN framework.\n *\n * NOEN framework is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2.\n *\n * NOEN framework is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\n\n/**\n * The starting point of the model generation. Run both Daikon and ProM in the background,\n * processes the results and generates the EFSM code as a result.\n *\n * @author Teemu Kanstr�n\n */\npublic class Main {\n\n    private static String logName = null;\n\n    private static String efsmPackageName = null;\n\n    private static String efsmClassName = null;\n\n    private static PromParser promParser = new PromParser();\n\n    private static Properties configuration = null;\n\n    public static void main(String[] args) throws Exception {\n        logName = args[0];\n        efsmPackageName = args[1];\n        efsmClassName = args[2];\n        DaikonModel dm = createDaikonModel();\n        System.out.println(\"Daikon model created.\");\n        FSMModel fsm = createFSM();\n        System.out.println(\"FSM (PROM) model created.\");\n        generateEFSM(dm, fsm);\n        System.out.println(\"EFSM created and saved to \" + efsmClassName);\n        //    DaikonModel dmOk = createDaikonModel(\"ok\");\n        //    FSMModel fsmOk = createFSM(\"ok\");\n        //    generateEFSM(\"ok\", dmOk, fsmOk);\n        //    DaikonModel dmError = createDaikonModel(\"error\");\n        //    FSMModel fsmError = createFSM(\"error\");\n        //    generateEFSM(\"error\", dmError, fsmError);\n    }\n\n    private static void saveToFile(String fileName, String content) throws Exception {\n        fileName += \".java\";\n        File outFile = new File(fileName);\n        FileWriter out = new FileWriter(outFile);\n        out.write(content);\n        out.close();\n    }\n\n    public static DaikonModel createDaikonModel() throws Exception {\n        String fileName = logName + \".dtrace\";\n        System.out.println(\"Running daikon for file:\" + fileName);\n        //comment this line out and the next in to run with pre-processed daikon output\n        String daikonOutput = executeDaikon(fileName);\n        //    String daikonOutput = fakeDaikon(\"daikon-test-output.txt\");\n        System.out.println(\"Daikon run ended, parsin Daikon model\");\n        //    System.out.println(\"daikon output:\"+daikonOutput);\n        DaikonParser parser = new DaikonParser(daikonOutput);\n        return parser.parseAll();\n    }\n\n    public static FSMModel createFSM() throws Exception {\n        String fileName = logName + \".mxml\";\n        System.out.println(\"Running PROM parser for file:\" + fileName);\n        InputStream in = new FileInputStream(fileName);\n        return promParser.parse(in);\n    }\n\n    public static String fakeDaikon(String fileName) throws Exception {\n        FileInputStream fin = new FileInputStream(fileName);\n        return StringUtils.stringForStream(fin);\n    }\n\n    public static String executeDaikon(String fileName) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n        Process p = rt.exec(\"java -Xmx512m daikon.Daikon --nohierarchy \" + fileName);\n        InputStream output = p.getInputStream();\n        return stringForStream(output);\n    }\n\n    private static void generateEFSM(DaikonModel dm, FSMModel fsm) throws Exception {\n        EFSMGenerator generator = new EFSMGenerator(classUnderTest(), fsm, dm, inputs(), outputs());\n        System.out.println(\"Generating EFSM\");\n        String efsm = generator.generateEFSM(efsmPackageName, efsmClassName);\n        saveToFile(efsmClassName, efsm);\n    }\n\n    private static Class classUnderTest() throws Exception {\n        return classForProperty(\"ClassUnderTest\");\n    }\n\n    private static Class classForProperty(String property) throws Exception {\n        if (configuration == null) {\n            configuration = new Properties();\n            configuration.load(new FileInputStream(\"testgen.properties\"));\n        }\n        String className = configuration.getProperty(property);\n        if (className == null) {\n            return null;\n        }\n        System.out.println(\"creating class for:\" + className);\n        return Class.forName(className);\n    }\n\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\n        Collection<Class> classes = new ArrayList<Class>();\n        int index = 1;\n        while (true) {\n            Class clazz = classForProperty(prefix + index);\n            index++;\n            if (clazz == null) {\n                break;\n            }\n            classes.add(clazz);\n        }\n        return classes;\n    }\n\n    public static Collection<Class> inputs() throws Exception {\n        return classesForMultipleProperties(\"InputInterface\");\n    }\n\n    public static Collection<Class> outputs() throws Exception {\n        return classesForMultipleProperties(\"OutputInterface\");\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/Main_0Test.java",
		"test_prompt": "// Main_0Test.java\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#createDaikonModel()} method.\n*/\nclass Main_0Test {"
	},
	{
		"original_code": "// Main.java\n/*\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\n *\n * This file is part of NOEN framework.\n *\n * NOEN framework is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2.\n *\n * NOEN framework is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\n\n/**\n * The starting point of the model generation. Run both Daikon and ProM in the background,\n * processes the results and generates the EFSM code as a result.\n *\n * @author Teemu Kanstr�n\n */\npublic class Main {\n\n    private static String logName = null;\n\n    private static String efsmPackageName = null;\n\n    private static String efsmClassName = null;\n\n    private static PromParser promParser = new PromParser();\n\n    private static Properties configuration = null;\n\n    public static void main(String[] args) throws Exception {\n        logName = args[0];\n        efsmPackageName = args[1];\n        efsmClassName = args[2];\n        DaikonModel dm = createDaikonModel();\n        System.out.println(\"Daikon model created.\");\n        FSMModel fsm = createFSM();\n        System.out.println(\"FSM (PROM) model created.\");\n        generateEFSM(dm, fsm);\n        System.out.println(\"EFSM created and saved to \" + efsmClassName);\n        //    DaikonModel dmOk = createDaikonModel(\"ok\");\n        //    FSMModel fsmOk = createFSM(\"ok\");\n        //    generateEFSM(\"ok\", dmOk, fsmOk);\n        //    DaikonModel dmError = createDaikonModel(\"error\");\n        //    FSMModel fsmError = createFSM(\"error\");\n        //    generateEFSM(\"error\", dmError, fsmError);\n    }\n\n    private static void saveToFile(String fileName, String content) throws Exception {\n        fileName += \".java\";\n        File outFile = new File(fileName);\n        FileWriter out = new FileWriter(outFile);\n        out.write(content);\n        out.close();\n    }\n\n    public static DaikonModel createDaikonModel() throws Exception {\n        String fileName = logName + \".dtrace\";\n        System.out.println(\"Running daikon for file:\" + fileName);\n        //comment this line out and the next in to run with pre-processed daikon output\n        String daikonOutput = executeDaikon(fileName);\n        //    String daikonOutput = fakeDaikon(\"daikon-test-output.txt\");\n        System.out.println(\"Daikon run ended, parsin Daikon model\");\n        //    System.out.println(\"daikon output:\"+daikonOutput);\n        DaikonParser parser = new DaikonParser(daikonOutput);\n        return parser.parseAll();\n    }\n\n    public static FSMModel createFSM() throws Exception {\n        String fileName = logName + \".mxml\";\n        System.out.println(\"Running PROM parser for file:\" + fileName);\n        InputStream in = new FileInputStream(fileName);\n        return promParser.parse(in);\n    }\n\n    public static String fakeDaikon(String fileName) throws Exception {\n        FileInputStream fin = new FileInputStream(fileName);\n        return StringUtils.stringForStream(fin);\n    }\n\n    public static String executeDaikon(String fileName) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n        Process p = rt.exec(\"java -Xmx512m daikon.Daikon --nohierarchy \" + fileName);\n        InputStream output = p.getInputStream();\n        return stringForStream(output);\n    }\n\n    private static void generateEFSM(DaikonModel dm, FSMModel fsm) throws Exception {\n        EFSMGenerator generator = new EFSMGenerator(classUnderTest(), fsm, dm, inputs(), outputs());\n        System.out.println(\"Generating EFSM\");\n        String efsm = generator.generateEFSM(efsmPackageName, efsmClassName);\n        saveToFile(efsmClassName, efsm);\n    }\n\n    private static Class classUnderTest() throws Exception {\n        return classForProperty(\"ClassUnderTest\");\n    }\n\n    private static Class classForProperty(String property) throws Exception {\n        if (configuration == null) {\n            configuration = new Properties();\n            configuration.load(new FileInputStream(\"testgen.properties\"));\n        }\n        String className = configuration.getProperty(property);\n        if (className == null) {\n            return null;\n        }\n        System.out.println(\"creating class for:\" + className);\n        return Class.forName(className);\n    }\n\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\n        Collection<Class> classes = new ArrayList<Class>();\n        int index = 1;\n        while (true) {\n            Class clazz = classForProperty(prefix + index);\n            index++;\n            if (clazz == null) {\n                break;\n            }\n            classes.add(clazz);\n        }\n        return classes;\n    }\n\n    public static Collection<Class> inputs() throws Exception {\n        return classesForMultipleProperties(\"InputInterface\");\n    }\n\n    public static Collection<Class> outputs() throws Exception {\n        return classesForMultipleProperties(\"OutputInterface\");\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/Main_1Test.java",
		"test_prompt": "// Main_1Test.java\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#createFSM()} method.\n*/\nclass Main_1Test {"
	},
	{
		"original_code": "// Main.java\n/*\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\n *\n * This file is part of NOEN framework.\n *\n * NOEN framework is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2.\n *\n * NOEN framework is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\n\n/**\n * The starting point of the model generation. Run both Daikon and ProM in the background,\n * processes the results and generates the EFSM code as a result.\n *\n * @author Teemu Kanstr�n\n */\npublic class Main {\n\n    private static String logName = null;\n\n    private static String efsmPackageName = null;\n\n    private static String efsmClassName = null;\n\n    private static PromParser promParser = new PromParser();\n\n    private static Properties configuration = null;\n\n    public static void main(String[] args) throws Exception {\n        logName = args[0];\n        efsmPackageName = args[1];\n        efsmClassName = args[2];\n        DaikonModel dm = createDaikonModel();\n        System.out.println(\"Daikon model created.\");\n        FSMModel fsm = createFSM();\n        System.out.println(\"FSM (PROM) model created.\");\n        generateEFSM(dm, fsm);\n        System.out.println(\"EFSM created and saved to \" + efsmClassName);\n        //    DaikonModel dmOk = createDaikonModel(\"ok\");\n        //    FSMModel fsmOk = createFSM(\"ok\");\n        //    generateEFSM(\"ok\", dmOk, fsmOk);\n        //    DaikonModel dmError = createDaikonModel(\"error\");\n        //    FSMModel fsmError = createFSM(\"error\");\n        //    generateEFSM(\"error\", dmError, fsmError);\n    }\n\n    private static void saveToFile(String fileName, String content) throws Exception {\n        fileName += \".java\";\n        File outFile = new File(fileName);\n        FileWriter out = new FileWriter(outFile);\n        out.write(content);\n        out.close();\n    }\n\n    public static DaikonModel createDaikonModel() throws Exception {\n        String fileName = logName + \".dtrace\";\n        System.out.println(\"Running daikon for file:\" + fileName);\n        //comment this line out and the next in to run with pre-processed daikon output\n        String daikonOutput = executeDaikon(fileName);\n        //    String daikonOutput = fakeDaikon(\"daikon-test-output.txt\");\n        System.out.println(\"Daikon run ended, parsin Daikon model\");\n        //    System.out.println(\"daikon output:\"+daikonOutput);\n        DaikonParser parser = new DaikonParser(daikonOutput);\n        return parser.parseAll();\n    }\n\n    public static FSMModel createFSM() throws Exception {\n        String fileName = logName + \".mxml\";\n        System.out.println(\"Running PROM parser for file:\" + fileName);\n        InputStream in = new FileInputStream(fileName);\n        return promParser.parse(in);\n    }\n\n    public static String fakeDaikon(String fileName) throws Exception {\n        FileInputStream fin = new FileInputStream(fileName);\n        return StringUtils.stringForStream(fin);\n    }\n\n    public static String executeDaikon(String fileName) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n        Process p = rt.exec(\"java -Xmx512m daikon.Daikon --nohierarchy \" + fileName);\n        InputStream output = p.getInputStream();\n        return stringForStream(output);\n    }\n\n    private static void generateEFSM(DaikonModel dm, FSMModel fsm) throws Exception {\n        EFSMGenerator generator = new EFSMGenerator(classUnderTest(), fsm, dm, inputs(), outputs());\n        System.out.println(\"Generating EFSM\");\n        String efsm = generator.generateEFSM(efsmPackageName, efsmClassName);\n        saveToFile(efsmClassName, efsm);\n    }\n\n    private static Class classUnderTest() throws Exception {\n        return classForProperty(\"ClassUnderTest\");\n    }\n\n    private static Class classForProperty(String property) throws Exception {\n        if (configuration == null) {\n            configuration = new Properties();\n            configuration.load(new FileInputStream(\"testgen.properties\"));\n        }\n        String className = configuration.getProperty(property);\n        if (className == null) {\n            return null;\n        }\n        System.out.println(\"creating class for:\" + className);\n        return Class.forName(className);\n    }\n\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\n        Collection<Class> classes = new ArrayList<Class>();\n        int index = 1;\n        while (true) {\n            Class clazz = classForProperty(prefix + index);\n            index++;\n            if (clazz == null) {\n                break;\n            }\n            classes.add(clazz);\n        }\n        return classes;\n    }\n\n    public static Collection<Class> inputs() throws Exception {\n        return classesForMultipleProperties(\"InputInterface\");\n    }\n\n    public static Collection<Class> outputs() throws Exception {\n        return classesForMultipleProperties(\"OutputInterface\");\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/Main_2Test.java",
		"test_prompt": "// Main_2Test.java\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#fakeDaikon(String)} method.\n*/\nclass Main_2Test {"
	},
	{
		"original_code": "// Main.java\n/*\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\n *\n * This file is part of NOEN framework.\n *\n * NOEN framework is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2.\n *\n * NOEN framework is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\n\n/**\n * The starting point of the model generation. Run both Daikon and ProM in the background,\n * processes the results and generates the EFSM code as a result.\n *\n * @author Teemu Kanstr�n\n */\npublic class Main {\n\n    private static String logName = null;\n\n    private static String efsmPackageName = null;\n\n    private static String efsmClassName = null;\n\n    private static PromParser promParser = new PromParser();\n\n    private static Properties configuration = null;\n\n    public static void main(String[] args) throws Exception {\n        logName = args[0];\n        efsmPackageName = args[1];\n        efsmClassName = args[2];\n        DaikonModel dm = createDaikonModel();\n        System.out.println(\"Daikon model created.\");\n        FSMModel fsm = createFSM();\n        System.out.println(\"FSM (PROM) model created.\");\n        generateEFSM(dm, fsm);\n        System.out.println(\"EFSM created and saved to \" + efsmClassName);\n        //    DaikonModel dmOk = createDaikonModel(\"ok\");\n        //    FSMModel fsmOk = createFSM(\"ok\");\n        //    generateEFSM(\"ok\", dmOk, fsmOk);\n        //    DaikonModel dmError = createDaikonModel(\"error\");\n        //    FSMModel fsmError = createFSM(\"error\");\n        //    generateEFSM(\"error\", dmError, fsmError);\n    }\n\n    private static void saveToFile(String fileName, String content) throws Exception {\n        fileName += \".java\";\n        File outFile = new File(fileName);\n        FileWriter out = new FileWriter(outFile);\n        out.write(content);\n        out.close();\n    }\n\n    public static DaikonModel createDaikonModel() throws Exception {\n        String fileName = logName + \".dtrace\";\n        System.out.println(\"Running daikon for file:\" + fileName);\n        //comment this line out and the next in to run with pre-processed daikon output\n        String daikonOutput = executeDaikon(fileName);\n        //    String daikonOutput = fakeDaikon(\"daikon-test-output.txt\");\n        System.out.println(\"Daikon run ended, parsin Daikon model\");\n        //    System.out.println(\"daikon output:\"+daikonOutput);\n        DaikonParser parser = new DaikonParser(daikonOutput);\n        return parser.parseAll();\n    }\n\n    public static FSMModel createFSM() throws Exception {\n        String fileName = logName + \".mxml\";\n        System.out.println(\"Running PROM parser for file:\" + fileName);\n        InputStream in = new FileInputStream(fileName);\n        return promParser.parse(in);\n    }\n\n    public static String fakeDaikon(String fileName) throws Exception {\n        FileInputStream fin = new FileInputStream(fileName);\n        return StringUtils.stringForStream(fin);\n    }\n\n    public static String executeDaikon(String fileName) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n        Process p = rt.exec(\"java -Xmx512m daikon.Daikon --nohierarchy \" + fileName);\n        InputStream output = p.getInputStream();\n        return stringForStream(output);\n    }\n\n    private static void generateEFSM(DaikonModel dm, FSMModel fsm) throws Exception {\n        EFSMGenerator generator = new EFSMGenerator(classUnderTest(), fsm, dm, inputs(), outputs());\n        System.out.println(\"Generating EFSM\");\n        String efsm = generator.generateEFSM(efsmPackageName, efsmClassName);\n        saveToFile(efsmClassName, efsm);\n    }\n\n    private static Class classUnderTest() throws Exception {\n        return classForProperty(\"ClassUnderTest\");\n    }\n\n    private static Class classForProperty(String property) throws Exception {\n        if (configuration == null) {\n            configuration = new Properties();\n            configuration.load(new FileInputStream(\"testgen.properties\"));\n        }\n        String className = configuration.getProperty(property);\n        if (className == null) {\n            return null;\n        }\n        System.out.println(\"creating class for:\" + className);\n        return Class.forName(className);\n    }\n\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\n        Collection<Class> classes = new ArrayList<Class>();\n        int index = 1;\n        while (true) {\n            Class clazz = classForProperty(prefix + index);\n            index++;\n            if (clazz == null) {\n                break;\n            }\n            classes.add(clazz);\n        }\n        return classes;\n    }\n\n    public static Collection<Class> inputs() throws Exception {\n        return classesForMultipleProperties(\"InputInterface\");\n    }\n\n    public static Collection<Class> outputs() throws Exception {\n        return classesForMultipleProperties(\"OutputInterface\");\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/Main_3Test.java",
		"test_prompt": "// Main_3Test.java\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#executeDaikon(String)} method.\n*/\nclass Main_3Test {"
	},
	{
		"original_code": "// Main.java\n/*\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\n *\n * This file is part of NOEN framework.\n *\n * NOEN framework is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2.\n *\n * NOEN framework is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\n\n/**\n * The starting point of the model generation. Run both Daikon and ProM in the background,\n * processes the results and generates the EFSM code as a result.\n *\n * @author Teemu Kanstr�n\n */\npublic class Main {\n\n    private static String logName = null;\n\n    private static String efsmPackageName = null;\n\n    private static String efsmClassName = null;\n\n    private static PromParser promParser = new PromParser();\n\n    private static Properties configuration = null;\n\n    public static void main(String[] args) throws Exception {\n        logName = args[0];\n        efsmPackageName = args[1];\n        efsmClassName = args[2];\n        DaikonModel dm = createDaikonModel();\n        System.out.println(\"Daikon model created.\");\n        FSMModel fsm = createFSM();\n        System.out.println(\"FSM (PROM) model created.\");\n        generateEFSM(dm, fsm);\n        System.out.println(\"EFSM created and saved to \" + efsmClassName);\n        //    DaikonModel dmOk = createDaikonModel(\"ok\");\n        //    FSMModel fsmOk = createFSM(\"ok\");\n        //    generateEFSM(\"ok\", dmOk, fsmOk);\n        //    DaikonModel dmError = createDaikonModel(\"error\");\n        //    FSMModel fsmError = createFSM(\"error\");\n        //    generateEFSM(\"error\", dmError, fsmError);\n    }\n\n    private static void saveToFile(String fileName, String content) throws Exception {\n        fileName += \".java\";\n        File outFile = new File(fileName);\n        FileWriter out = new FileWriter(outFile);\n        out.write(content);\n        out.close();\n    }\n\n    public static DaikonModel createDaikonModel() throws Exception {\n        String fileName = logName + \".dtrace\";\n        System.out.println(\"Running daikon for file:\" + fileName);\n        //comment this line out and the next in to run with pre-processed daikon output\n        String daikonOutput = executeDaikon(fileName);\n        //    String daikonOutput = fakeDaikon(\"daikon-test-output.txt\");\n        System.out.println(\"Daikon run ended, parsin Daikon model\");\n        //    System.out.println(\"daikon output:\"+daikonOutput);\n        DaikonParser parser = new DaikonParser(daikonOutput);\n        return parser.parseAll();\n    }\n\n    public static FSMModel createFSM() throws Exception {\n        String fileName = logName + \".mxml\";\n        System.out.println(\"Running PROM parser for file:\" + fileName);\n        InputStream in = new FileInputStream(fileName);\n        return promParser.parse(in);\n    }\n\n    public static String fakeDaikon(String fileName) throws Exception {\n        FileInputStream fin = new FileInputStream(fileName);\n        return StringUtils.stringForStream(fin);\n    }\n\n    public static String executeDaikon(String fileName) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n        Process p = rt.exec(\"java -Xmx512m daikon.Daikon --nohierarchy \" + fileName);\n        InputStream output = p.getInputStream();\n        return stringForStream(output);\n    }\n\n    private static void generateEFSM(DaikonModel dm, FSMModel fsm) throws Exception {\n        EFSMGenerator generator = new EFSMGenerator(classUnderTest(), fsm, dm, inputs(), outputs());\n        System.out.println(\"Generating EFSM\");\n        String efsm = generator.generateEFSM(efsmPackageName, efsmClassName);\n        saveToFile(efsmClassName, efsm);\n    }\n\n    private static Class classUnderTest() throws Exception {\n        return classForProperty(\"ClassUnderTest\");\n    }\n\n    private static Class classForProperty(String property) throws Exception {\n        if (configuration == null) {\n            configuration = new Properties();\n            configuration.load(new FileInputStream(\"testgen.properties\"));\n        }\n        String className = configuration.getProperty(property);\n        if (className == null) {\n            return null;\n        }\n        System.out.println(\"creating class for:\" + className);\n        return Class.forName(className);\n    }\n\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\n        Collection<Class> classes = new ArrayList<Class>();\n        int index = 1;\n        while (true) {\n            Class clazz = classForProperty(prefix + index);\n            index++;\n            if (clazz == null) {\n                break;\n            }\n            classes.add(clazz);\n        }\n        return classes;\n    }\n\n    public static Collection<Class> inputs() throws Exception {\n        return classesForMultipleProperties(\"InputInterface\");\n    }\n\n    public static Collection<Class> outputs() throws Exception {\n        return classesForMultipleProperties(\"OutputInterface\");\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/Main_4Test.java",
		"test_prompt": "// Main_4Test.java\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#inputs()} method.\n*/\nclass Main_4Test {"
	},
	{
		"original_code": "// Main.java\n/*\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\n *\n * This file is part of NOEN framework.\n *\n * NOEN framework is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2.\n *\n * NOEN framework is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\n\n/**\n * The starting point of the model generation. Run both Daikon and ProM in the background,\n * processes the results and generates the EFSM code as a result.\n *\n * @author Teemu Kanstr�n\n */\npublic class Main {\n\n    private static String logName = null;\n\n    private static String efsmPackageName = null;\n\n    private static String efsmClassName = null;\n\n    private static PromParser promParser = new PromParser();\n\n    private static Properties configuration = null;\n\n    public static void main(String[] args) throws Exception {\n        logName = args[0];\n        efsmPackageName = args[1];\n        efsmClassName = args[2];\n        DaikonModel dm = createDaikonModel();\n        System.out.println(\"Daikon model created.\");\n        FSMModel fsm = createFSM();\n        System.out.println(\"FSM (PROM) model created.\");\n        generateEFSM(dm, fsm);\n        System.out.println(\"EFSM created and saved to \" + efsmClassName);\n        //    DaikonModel dmOk = createDaikonModel(\"ok\");\n        //    FSMModel fsmOk = createFSM(\"ok\");\n        //    generateEFSM(\"ok\", dmOk, fsmOk);\n        //    DaikonModel dmError = createDaikonModel(\"error\");\n        //    FSMModel fsmError = createFSM(\"error\");\n        //    generateEFSM(\"error\", dmError, fsmError);\n    }\n\n    private static void saveToFile(String fileName, String content) throws Exception {\n        fileName += \".java\";\n        File outFile = new File(fileName);\n        FileWriter out = new FileWriter(outFile);\n        out.write(content);\n        out.close();\n    }\n\n    public static DaikonModel createDaikonModel() throws Exception {\n        String fileName = logName + \".dtrace\";\n        System.out.println(\"Running daikon for file:\" + fileName);\n        //comment this line out and the next in to run with pre-processed daikon output\n        String daikonOutput = executeDaikon(fileName);\n        //    String daikonOutput = fakeDaikon(\"daikon-test-output.txt\");\n        System.out.println(\"Daikon run ended, parsin Daikon model\");\n        //    System.out.println(\"daikon output:\"+daikonOutput);\n        DaikonParser parser = new DaikonParser(daikonOutput);\n        return parser.parseAll();\n    }\n\n    public static FSMModel createFSM() throws Exception {\n        String fileName = logName + \".mxml\";\n        System.out.println(\"Running PROM parser for file:\" + fileName);\n        InputStream in = new FileInputStream(fileName);\n        return promParser.parse(in);\n    }\n\n    public static String fakeDaikon(String fileName) throws Exception {\n        FileInputStream fin = new FileInputStream(fileName);\n        return StringUtils.stringForStream(fin);\n    }\n\n    public static String executeDaikon(String fileName) throws Exception {\n        Runtime rt = Runtime.getRuntime();\n        Process p = rt.exec(\"java -Xmx512m daikon.Daikon --nohierarchy \" + fileName);\n        InputStream output = p.getInputStream();\n        return stringForStream(output);\n    }\n\n    private static void generateEFSM(DaikonModel dm, FSMModel fsm) throws Exception {\n        EFSMGenerator generator = new EFSMGenerator(classUnderTest(), fsm, dm, inputs(), outputs());\n        System.out.println(\"Generating EFSM\");\n        String efsm = generator.generateEFSM(efsmPackageName, efsmClassName);\n        saveToFile(efsmClassName, efsm);\n    }\n\n    private static Class classUnderTest() throws Exception {\n        return classForProperty(\"ClassUnderTest\");\n    }\n\n    private static Class classForProperty(String property) throws Exception {\n        if (configuration == null) {\n            configuration = new Properties();\n            configuration.load(new FileInputStream(\"testgen.properties\"));\n        }\n        String className = configuration.getProperty(property);\n        if (className == null) {\n            return null;\n        }\n        System.out.println(\"creating class for:\" + className);\n        return Class.forName(className);\n    }\n\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\n        Collection<Class> classes = new ArrayList<Class>();\n        int index = 1;\n        while (true) {\n            Class clazz = classForProperty(prefix + index);\n            index++;\n            if (clazz == null) {\n                break;\n            }\n            classes.add(clazz);\n        }\n        return classes;\n    }\n\n    public static Collection<Class> inputs() throws Exception {\n        return classesForMultipleProperties(\"InputInterface\");\n    }\n\n    public static Collection<Class> outputs() throws Exception {\n        return classesForMultipleProperties(\"OutputInterface\");\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/Main_5Test.java",
		"test_prompt": "// Main_5Test.java\npackage fi.vtt.noen.testgen;\n\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.efsm.EFSMGenerator;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.util.Properties;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#outputs()} method.\n*/\nclass Main_5Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_0Test.java",
		"test_prompt": "// EFSMGenerator_0Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#generateEFSM(String, String)} method.\n*/\nclass EFSMGenerator_0Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_1Test.java",
		"test_prompt": "// EFSMGenerator_1Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#variables()} method.\n*/\nclass EFSMGenerator_1Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_2Test.java",
		"test_prompt": "// EFSMGenerator_2Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#constructor(String)} method.\n*/\nclass EFSMGenerator_2Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_3Test.java",
		"test_prompt": "// EFSMGenerator_3Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#arrays()} method.\n*/\nclass EFSMGenerator_3Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_4Test.java",
		"test_prompt": "// EFSMGenerator_4Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#stateEnumFor(Collection)} method.\n*/\nclass EFSMGenerator_4Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_5Test.java",
		"test_prompt": "// EFSMGenerator_5Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#stateMethod()} method.\n*/\nclass EFSMGenerator_5Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_6Test.java",
		"test_prompt": "// EFSMGenerator_6Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#actionFor(String)} method.\n*/\nclass EFSMGenerator_6Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_7Test.java",
		"test_prompt": "// EFSMGenerator_7Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#transitionActionsFor(String)} method.\n*/\nclass EFSMGenerator_7Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_8Test.java",
		"test_prompt": "// EFSMGenerator_8Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#assertFor(Method, String)} method.\n*/\nclass EFSMGenerator_8Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_9Test.java",
		"test_prompt": "// EFSMGenerator_9Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#sutCall(String)} method.\n*/\nclass EFSMGenerator_9Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_10Test.java",
		"test_prompt": "// EFSMGenerator_10Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#valueMethods()} method.\n*/\nclass EFSMGenerator_10Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_11Test.java",
		"test_prompt": "// EFSMGenerator_11Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#booleanJavaReturn(DaikonState, int)} method.\n*/\nclass EFSMGenerator_11Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_12Test.java",
		"test_prompt": "// EFSMGenerator_12Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#minMaxJavaReturn(DaikonState, int, Class)} method.\n*/\nclass EFSMGenerator_12Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_13Test.java",
		"test_prompt": "// EFSMGenerator_13Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#guardFor(String)} method.\n*/\nclass EFSMGenerator_13Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_14Test.java",
		"test_prompt": "// EFSMGenerator_14Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#guardCheckMethods()} method.\n*/\nclass EFSMGenerator_14Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_15Test.java",
		"test_prompt": "// EFSMGenerator_15Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#header(String, String)} method.\n*/\nclass EFSMGenerator_15Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_16Test.java",
		"test_prompt": "// EFSMGenerator_16Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#footer()} method.\n*/\nclass EFSMGenerator_16Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_17Test.java",
		"test_prompt": "// EFSMGenerator_17Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#resetMethod(Collection, Collection)} method.\n*/\nclass EFSMGenerator_17Test {"
	},
	{
		"original_code": "// EFSMGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\r\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\r\nimport static fi.vtt.noen.testgen.StringUtils.*;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\r\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\r\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.parser.PromParser;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.io.InputStream;\r\nimport java.io.ByteArrayInputStream;\r\nimport java.util.*;\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Parses together the PROM model as well as the Daikon model to create EFSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EFSMGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private final String ln = \"\\n\";\r\n\r\n    //this is the PROM model, describing states and transitions\r\n    private final FSMModel fsm;\r\n\r\n    //describes the invariants over the transitions.\r\n    private final DaikonModel dm;\r\n\r\n    //names of array variables in the model, used in code generation\r\n    private final Collection<String> arrayNames = new HashSet<String>();\r\n\r\n    //names of all input interface(s) methods\r\n    private final Collection<String> inputs = new ArrayList<String>();\r\n\r\n    //  private final Collection<String> outputs = new ArrayList<String>();\r\n    //classes to import for the model, used for code generation\r\n    private final Collection<Class> imports = new TreeSet<Class>(new ImportClassComparator());\r\n\r\n    //classes for which mock objects have been made\r\n    private final Collection<Class> mocks = new HashSet<Class>();\r\n\r\n    //map of methods and return values to create parameters for method calls into SUT. key = method name, value = return type\r\n    private final Map<String, Class> valueMethods = new TreeMap<String, Class>();\r\n\r\n    //list of output interfaces\r\n    private Collection<Class> outputInterfaces = null;\r\n\r\n    //the object that is the target of testing (SUT)\r\n    private final Class objectUnderTest;\r\n\r\n    //index for generated return value object names (rv1, rv2, rv3, ...)\r\n    private int rvIndex = 1;\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n    }\r\n\r\n    /**\r\n     * Only for testing.\r\n     *\r\n     * @param objectUnderTest\r\n     * @param fsm\r\n     * @param dm\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, FSMModel fsm, DaikonModel dm, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * @param objectUnderTest\r\n     * @param daikonOutput\r\n     * @param promOutput\r\n     * @param inputInterfaces\r\n     * @param outputInterfaces\r\n     */\r\n    public EFSMGenerator(Class objectUnderTest, String daikonOutput, String promOutput, Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        DaikonParser daikon = new DaikonParser(daikonOutput);\r\n        InputStream in = new ByteArrayInputStream(promOutput.getBytes());\r\n        PromParser prom = new PromParser();\r\n        FSMModel fsm = prom.parse(in);\r\n        DaikonModel dm = daikon.parseAll();\r\n        //since we only deal with the method names, we parseLexical those from input/output interfaces to match against fsm states.\r\n        //method name should equal stateid in fsm/daikon. later these are used differentiate states as output or input\r\n        this.fsm = fsm;\r\n        this.dm = dm;\r\n        this.objectUnderTest = objectUnderTest;\r\n        imports.add(objectUnderTest);\r\n        parseInterfaces(inputInterfaces, outputInterfaces);\r\n    }\r\n\r\n    //\r\n    private void parseInterfaces(Collection<Class> inputInterfaces, Collection<Class> outputInterfaces) {\r\n        this.outputInterfaces = outputInterfaces;\r\n        Collection<String> inputs = InterfaceParser.methodNames(inputInterfaces);\r\n        this.inputs.addAll(inputs);\r\n        mocks.addAll(outputInterfaces);\r\n        //    Collection<String> outputs = InterfaceParser.methodNames(outputInterfaces);\r\n        //    this.outputs.addAll(outputs);\r\n        imports.addAll(inputInterfaces);\r\n        imports.addAll(outputInterfaces);\r\n    }\r\n\r\n    /**\r\n     * Generates the actual EFSM\r\n     *\r\n     * @return EFSM as Java code for ModelJUnit.\r\n     */\r\n    public String generateEFSM(String packageName, String className) {\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        StringBuffer body = new StringBuffer();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            if (inputs.contains(stateId)) {\r\n                body.append(ln);\r\n                body.append(actionFor(stateId));\r\n                body.append(ln);\r\n                body.append(guardFor(stateId));\r\n            }\r\n            //      body.append(ln);\r\n            body.append(transitionActionsFor(stateId));\r\n        }\r\n        body.append(ln);\r\n        body.append(valueMethods());\r\n        StringBuffer efsm = new StringBuffer();\r\n        efsm.append(header(packageName, className));\r\n        efsm.append(variables());\r\n        efsm.append(testMethod(className));\r\n        efsm.append(resetMethod(arrayNames, mocks));\r\n        //efsm.append(constructor(className));\r\n        efsm.append(stateMethod());\r\n        efsm.append(body);\r\n        efsm.append(helperMethods());\r\n        efsm.append(guardCheckMethods());\r\n        efsm.append(footer());\r\n        return efsm.toString();\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String variables() {\r\n        String variables = arrays();\r\n        variables += \"  private String state = \\\"\\\";\" + ln;\r\n        String sutClass = objectUnderTest.getSimpleName();\r\n        String sutObject = lowerCaseFirstLetter(sutClass);\r\n        variables += \"  private \" + sutClass + \" \" + sutObject + \";\" + ln;\r\n        for (Class clazz : mocks) {\r\n            String className = clazz.getSimpleName();\r\n            variables += \"  private \" + className + \" \" + mockNameFor(className) + \";\" + ln + ln;\r\n        }\r\n        return variables;\r\n    }\r\n\r\n    /**\r\n     * @param className\r\n     * @return\r\n     */\r\n    public String constructor(String className) {\r\n        String parameter = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(parameter);\r\n        parameter += \" \" + objectName;\r\n        String constructor = \"  public \" + className + \"(\" + parameter + \") {\" + ln + \"    this.\" + objectName + \" = \" + objectName + \";\" + ln + \"  }\" + ln + ln;\r\n        return constructor;\r\n    }\r\n\r\n    /**\r\n     * Generates the Java code to define a Collection/ArrayList for all the arrays present in the traces.\r\n     *\r\n     * @return Java code to define all used arrays in EFSM model.\r\n     */\r\n    public String arrays() {\r\n        String arrays = \"\";\r\n        for (Iterator<String> i = arrayNames.iterator(); i.hasNext(); ) {\r\n            String name = i.next();\r\n            arrays += \"  private List \" + name + \" = new ArrayList();\" + ln;\r\n        }\r\n        return arrays;\r\n    }\r\n\r\n    /**\r\n     * Old code to create state enumeration. Not used anymore, just kept around for experimentation.\r\n     *\r\n     * @param states  The states of the model.\r\n     * @return  Java code to define the state variable and related enumeration.\r\n     */\r\n    public String stateEnumFor(Collection<FSMState> states) {\r\n        String stateEnum = \"  private enum States {\" + ln;\r\n        stateEnum += \"    Init\";\r\n        for (FSMState state : states) {\r\n            String id = capitalizeFirstLetter(state.id());\r\n            stateEnum += \",\" + ln + \"    \" + id;\r\n        }\r\n        stateEnum += ln + \"  }\" + ln + ln;\r\n        stateEnum += \"  public Object getState() {\" + ln;\r\n        stateEnum += \"    return state;\" + ln;\r\n        stateEnum += \"  }\" + ln;\r\n        return stateEnum;\r\n    }\r\n\r\n    /**\r\n     * Generates the state definition method for EFSM.\r\n     *\r\n     * @return  Java code to define the state access method.\r\n     */\r\n    public String stateMethod() {\r\n        String state = \"  public Object getState() {\" + ln;\r\n        state += \"    return state;\" + ln;\r\n        state += \"  }\" + ln;\r\n        return state;\r\n    }\r\n\r\n    private String asState(String id) {\r\n        return capitalizeFirstLetter(id);\r\n    }\r\n\r\n    /**\r\n     * Generates the @Action part of the EFSM model for modeljunit.\r\n     *\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public String actionFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        String action = \"  @Action\" + ln;\r\n        action += \"  public void \" + stateId + \"() throws Exception {\" + ln;\r\n        action += \"    this.state = \\\"\" + asState(stateId) + \"\\\";\" + ln;\r\n        action += \"    System.out.println(\\\"\" + stateId.toUpperCase() + \"\\\");\" + ln;\r\n        action += sutCallWithNoOutputMethods(stateId);\r\n        //    action += prefixWith(sutCall(stateId), \"    \");\r\n        action += \"  }\" + ln;\r\n        //    action += transitionMethods;\r\n        return action;\r\n    }\r\n\r\n    private String sutCallWithNoOutputMethods(String stateId) {\r\n        String call = \"\";\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.replay();\r\n        }\r\n        call += sutCall(stateId);\r\n        for (Class clazz : mocks) {\r\n            MockGenerator mocker = new MockGenerator(clazz);\r\n            call += mocker.verify();\r\n        }\r\n        return prefixWith(call, \"    \");\r\n    }\r\n\r\n    public String transitionActionsFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            return \"\";\r\n        }\r\n        System.out.println(\"state:\" + stateId);\r\n        Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n        String actions = \"\";\r\n        for (DaikonTransition transition : transitions) {\r\n            String target = transition.getTarget();\r\n            System.out.println(\"target:\" + target);\r\n            if (inputs.contains(target)) {\r\n                //skip inputs here, they are to be their own action methods with guards\r\n                continue;\r\n            }\r\n            arrayNames.addAll(transition.arrayNamesForConstraints());\r\n            Method outputMethod = getOutputInterfaceMethodByName(target);\r\n            Class outputInterface = getMockClassFor(target);\r\n            MockGenerator mocker = new MockGenerator(outputInterface);\r\n            actions += ln;\r\n            actions += \"  @Action\" + ln;\r\n            actions += \"  public void \" + stateId + \"_\" + target + \"() throws Exception {\" + ln;\r\n            String contents = \"\";\r\n            contents += \"this.state = \\\"\" + asState(stateId) + \"->\" + asState(target) + \"\\\";\" + ln;\r\n            contents += \"System.out.println(\\\"\" + stateId.toUpperCase() + \"->\" + target.toUpperCase() + \"\\\");\" + ln;\r\n            DaikonState state = dm.getState(target + \"_EXIT\");\r\n            //      System.out.println(\"states:\");\r\n            //      dm.printStates();\r\n            //     System.out.println(\"state:\"+target+\"_EXIT\");\r\n            String returnValue = \"\";\r\n            if (state != null) {\r\n                for (DaikonConstraint constraint : state.getConstraints()) {\r\n                    returnValue += constraint.returnValue();\r\n                }\r\n            }\r\n            contents += mocker.callFor(outputMethod, returnValue);\r\n            contents += mocker.replay();\r\n            contents += sutCall(stateId);\r\n            contents += mocker.verify();\r\n            contents = StringUtils.prefixWith(contents, \"    \");\r\n            actions += contents;\r\n            actions += \"  }\" + ln + ln;\r\n            actions += \"  public boolean \" + stateId + \"_\" + target + \"Guard() {\" + ln;\r\n            actions += transition.createTransitionGuards();\r\n            actions += \"    return true;\" + ln;\r\n            actions += \"  }\" + ln;\r\n        }\r\n        return actions;\r\n    }\r\n\r\n    /**\r\n     * @param stateId\r\n     * @return\r\n     */\r\n    public Collection<DaikonTransition> getTransitionsFrom(String stateId) {\r\n        Collection<DaikonTransition> transitions = dm.getTransitions(stateId);\r\n        if (transitions == null) {\r\n            return Collections.emptyList();\r\n        }\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     *  public String transitionMethodCallsFor(String stateId) {\r\n     *    transitionMethods = \"\";\r\n     *    String result = \"\";\r\n     *    Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n     *    for (DaikonTransition transition : transitions) {\r\n     *      String target = transition.getTarget();\r\n     *      if (inputs.contains(target)) {\r\n     *        //skip inputs here, they are to be their own action methods with guards\r\n     *        continue;\r\n     *      }\r\n     *      arrayNames.addAll(transition.arrayNamesForConstraints());\r\n     *      Method outputMethod = getOutputInterfaceMethodByName(target);\r\n     *      Class outputInterface = outputMethod.getDeclaringClass();\r\n     *      MockGenerator mocker = new MockGenerator(outputInterface);\r\n     *      String contents = \"this.state += \\\"->\"+asState(outputMethod.getName())+\"\\\";\"+ln;\r\n     *      contents += mocker.callFor(outputMethod);\r\n     *      contents += mocker.replay();\r\n     *      mocks.add(outputInterface);\r\n     *      contents += sutCall(stateId);\r\n     *      contents += mocker.verify();\r\n     *      contents += \"return true;\"+ln;\r\n     *      contents = StringUtils.prefixWith(contents, \"    \");\r\n     *      String transitionMethodName = stateId + \"_\" + target + \"_Transition\";\r\n     *      String methodContent = \"  public boolean \"+transitionMethodName+\"() {\"+ln;\r\n     *      methodContent += transition.createTransitionGuards();\r\n     *      methodContent += ln+contents;\r\n     *      methodContent += \"  }\"+ln;\r\n     *      transitionMethods += ln+methodContent;\r\n     *      result += \"    if(\"+transitionMethodName+\"()) return;\"+ln;\r\n     *    }\r\n     *    return result;\r\n     *  }\r\n     */\r\n    public String assertFor(Method method, String returnVar) {\r\n        //    System.out.println(\"getting exit state:\"+method.getName()+\"_EXIT\");\r\n        DaikonState state = dm.getState(method.getName() + \"_EXIT\");\r\n        String assertion = \"\";\r\n        for (DaikonConstraint constraint : state.getConstraints()) {\r\n            assertion += constraint.asAssert(returnVar);\r\n            //TODO to make this work, parseLexical object type from left and if not string/primitive then make the call\r\n            /*      Collection<String> valuesToAdd = constraint.getAssertObjectValues();\r\n      if (valuesToAdd.size() == 0) {\r\n        //avoid generating unnecessary methods\r\n        continue;\r\n      }\r\n      String name = constraint.getAssertObjectName();\r\n      Collection<String> values = assertObjects.get(name);\r\n      if (values == null) {\r\n        values = new HashSet<String>();\r\n        assertObjects.put(name, values);\r\n      }\r\n      values.addAll(valuesToAdd);*/\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    /*\r\n  public String returnValueBuilders() {\r\n    String result = \"\";\r\n    for (String name : assertObjects.keySet()) {\r\n      Collection<String> values = assertObjects.get(name);\r\n      result += \"public \"+name+\" create\"+name+\"For(String str) {\"+ln;\r\n      for (String str : values) {\r\n        result += \"  if(str.equals(\"+str+\")) {\"+ln;\r\n        result += \"    return null;\"+ln;\r\n        result += \"  }\"+ln;\r\n      }\r\n      result += \"}\"+ln;\r\n    }\r\n    return result;\r\n  }*/\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    public String sutCall(String methodName) {\r\n        Method method = getSUTMethod(methodName);\r\n        String className = objectUnderTest.getSimpleName();\r\n        String objectName = lowerCaseFirstLetter(className);\r\n        Class[] parameterTypes = method.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            imports.add(type);\r\n            String parameterMethodName = methodName + \"_p\" + i + \"()\";\r\n            parameters += parameterMethodName;\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n            valueMethods.put(parameterMethodName, type);\r\n        }\r\n        Class returnType = method.getReturnType();\r\n        String sutCall = objectName + \".\" + methodName + \"(\" + parameters + \");\" + ln;\r\n        if (returnType.equals(void.class)) {\r\n            return sutCall;\r\n        }\r\n        String assertion = assertFor(method, \"rv\" + rvIndex);\r\n        imports.add(returnType);\r\n        String returnTypeName = returnType.getSimpleName();\r\n        String prefix = returnTypeName + \" rv\" + rvIndex + \" = \";\r\n        rvIndex++;\r\n        return prefix + sutCall + assertion;\r\n    }\r\n\r\n    /**\r\n     * @param methodName\r\n     * @return\r\n     */\r\n    private Method getSUTMethod(String methodName) {\r\n        Method[] methods = objectUnderTest.getMethods();\r\n        for (Method method : methods) {\r\n            if (method.getName().equals(methodName)) {\r\n                return method;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in \" + objectUnderTest + \".\");\r\n    }\r\n\r\n    /**\r\n     * @return\r\n     */\r\n    public String valueMethods() {\r\n        String result = \"  //---------- TODO IMPLEMENT METHODS IN THIS SECTION TO GENERATE OBJECTS ------------\" + ln;\r\n        String sutName = objectUnderTest.getSimpleName();\r\n        result += \"  private \" + sutName + \" create\" + sutName + \"(\";\r\n        for (Class mockType : mocks) {\r\n            imports.add(mockType);\r\n            String typeName = mockType.getSimpleName();\r\n            result += typeName;\r\n            result += \" mock\" + typeName;\r\n        }\r\n        result += \") throws Exception {\" + ln;\r\n        result += \"    return null;\" + ln;\r\n        result += \"  }\" + ln + ln;\r\n        for (Iterator<String> i = valueMethods.keySet().iterator(); i.hasNext(); ) {\r\n            String parameterMethodName = i.next();\r\n            Class type = valueMethods.get(parameterMethodName);\r\n            //the states are stored with actual method names, we must get the original from the valuemethod name to access it\r\n            String[] parts = parameterMethodName.split(\"_p\");\r\n            String methodName = parts[0];\r\n            String indexStr = parts[1].split(\"\\\\(\")[0];\r\n            int index = Integer.parseInt(indexStr);\r\n            DaikonState state = dm.getState(methodName);\r\n            //TODO remove debug\r\n            //      System.out.println(\"state for:\"+methodName+\" = \"+state);\r\n            /*      if (state.getFullName().equals(\"Cunsubscribe\")) {\r\n        System.out.println(\"pindex:\"+index);\r\n        if (index == 2) {\r\n          System.out.println(\"type:\"+type.isPrimitive());\r\n        }\r\n      }*/\r\n            result += \"  private \" + type.getSimpleName() + \" \" + parameterMethodName + \" {\" + ln;\r\n            if (type.equals(boolean.class)) {\r\n                result += booleanJavaReturn(state, index);\r\n            } else if (type.isPrimitive()) {\r\n                result += minMaxJavaReturn(state, index, type);\r\n            } else {\r\n                String param = state.parameterValues(type.getSimpleName());\r\n                if (param != null) {\r\n                    result += param;\r\n                } else {\r\n                    result += \"    return null;\" + ln;\r\n                }\r\n            }\r\n            result += \"  }\" + ln;\r\n            if (i.hasNext()) {\r\n                result += ln;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public String booleanJavaReturn(DaikonState state, int parameterIndex) {\r\n        boolean returnTrue = state.booleanTrue(parameterIndex);\r\n        boolean returnFalse = state.booleanFalse(parameterIndex);\r\n        if (returnTrue) {\r\n            if (returnFalse) {\r\n                String java = \"    double rnd = Math.random();\" + ln;\r\n                java += \"    if (rnd >= 0.5) {\" + ln;\r\n                java += \"      return false;\" + ln;\r\n                java += \"    }\" + ln;\r\n                java += \"    return true;\" + ln;\r\n                return java;\r\n            }\r\n            return \"    return true;\" + ln;\r\n        }\r\n        return \"    return false;\" + ln;\r\n    }\r\n\r\n    public String minMaxJavaReturn(DaikonState state, int parameterIndex, Class type) {\r\n        //TODO:state is is the method in general, not tied to transition in which it is\r\n        //executed. this could be narrowed.. or in spirit of some publications\r\n        //it could also be extended to test with new values.. so its an open option\r\n        //may be useful to try with different styles\r\n        double min = state.min(parameterIndex);\r\n        double max = state.max(parameterIndex);\r\n        double diff = max - min;\r\n        if (diff == 0) {\r\n            String typecast = \"\";\r\n            if (type.equals(int.class)) {\r\n                typecast = \"(int)\";\r\n            } else if (type.equals(char.class)) {\r\n                typecast = \"(char)\";\r\n            } else if (type.equals(byte.class)) {\r\n                typecast = \"(byte)\";\r\n            } else if (type.equals(long.class)) {\r\n                typecast = \"(long)\";\r\n            } else if (type.equals(float.class)) {\r\n                typecast = \"(float)\";\r\n            } else if (type.equals(double.class)) {\r\n                typecast = \"(double)\";\r\n            }\r\n            //it has a constant value\r\n            return \"    return \" + typecast + min + \";\" + ln;\r\n        }\r\n        if (diff < 0) {\r\n            throw new IllegalStateException(\"Invariant max is smaller than min for:\" + state.getFullName());\r\n        }\r\n        String value = \"    return 0\";\r\n        if (type.equals(int.class)) {\r\n            value = \"    return cInt((int)\" + min + \", (int)\" + max + \");\";\r\n        } else if (type.equals(char.class)) {\r\n            value = \"    return cChar((char)\" + min + \", (char)\" + max + \");\";\r\n        } else if (type.equals(byte.class)) {\r\n            value = \"    return cByte((byte)\" + min + \", (byte)\" + max + \");\";\r\n        } else if (type.equals(long.class)) {\r\n            value = \"    return cLong((long)\" + min + \", (long)\" + max + \");\";\r\n        } else if (type.equals(float.class)) {\r\n            value = \"    return cFloat((float)\" + min + \", (float)\" + max + \");\";\r\n        } else if (type.equals(double.class)) {\r\n            value = \"    return cDouble((double)\" + min + \", (double)\" + max + \");\";\r\n        }\r\n        return value + ln;\r\n    }\r\n\r\n    public Method getOutputInterfaceMethodByName(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return method;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public Class getMockClassFor(String methodName) {\r\n        for (Class clazz : outputInterfaces) {\r\n            Method[] methods = clazz.getMethods();\r\n            for (Method method : methods) {\r\n                if (method.getName().equals(methodName)) {\r\n                    return clazz;\r\n                }\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"No method '\" + methodName + \"' found in any available output interface:\" + outputInterfaces);\r\n    }\r\n\r\n    public String guardFor(String stateId) {\r\n        if (!inputs.contains(stateId)) {\r\n            //only generate for input states (or methods as they are)\r\n            return \"\";\r\n        }\r\n        DaikonState state = dm.getState(stateId);\r\n        String guard = \"  public boolean \" + stateId + \"Guard() {\" + ln;\r\n        if (state != null) {\r\n            guard += state.createGuardInvocations();\r\n            arrayNames.addAll(state.arrayNamesForConstraints());\r\n        }\r\n        guard += \"    return true;\" + ln;\r\n        guard += \"  }\" + ln;\r\n        return guard;\r\n    }\r\n\r\n    public String guardCheckMethods() {\r\n        //these are disabled now since no longer needed\r\n        if (true)\r\n            return \"\";\r\n        String methods = \"//----------------------- GENERATED GUARD CHECK METHODS -----------------------------\" + ln;\r\n        Map<String, FSMState> fsmStates = fsm.getStates();\r\n        Set<String> generatedMethods = new HashSet<String>();\r\n        for (String stateId : fsmStates.keySet()) {\r\n            DaikonState state = dm.getState(stateId);\r\n            methods += state.guardContentMethods(generatedMethods);\r\n            Collection<DaikonTransition> transitions = getTransitionsFrom(stateId);\r\n            for (DaikonTransition transition : transitions) {\r\n                methods += transition.guardContentMethods(generatedMethods);\r\n            }\r\n        }\r\n        return methods;\r\n    }\r\n\r\n    /**\r\n     * Creates the basic Java code for the header part of the modeljunit EFSM code. This includes\r\n     * imports, class definitions, etc. All possibly used classes are always imported regardles,\r\n     * such as collection, arraylist, ...\r\n     *\r\n     * @return The java code for imports and other header stuff.\r\n     */\r\n    public String header(String packageName, String className) {\r\n        String header = \"package \" + packageName + \";\" + ln + ln;\r\n        header += \"import static org.junit.Assert.*;\" + ln;\r\n        header += \"import static org.easymock.EasyMock.*;\" + ln + ln;\r\n        header += \"import org.easymock.EasyMock;\" + ln;\r\n        header += \"import org.junit.Before;\" + ln;\r\n        header += \"import org.junit.Test;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.FsmModel;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Tester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.RandomTester;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.GraphListener;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.CoverageMetric;\" + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.coverage.TransitionCoverage;\" + ln + ln;\r\n        header += \"import net.sourceforge.czt.modeljunit.Action;\" + ln;\r\n        header += \"import java.util.Iterator;\" + ln;\r\n        header += \"import java.util.HashSet;\" + ln;\r\n        header += \"import java.util.List;\" + ln;\r\n        header += \"import java.util.Random;\" + ln;\r\n        //add imports like this so the sets take care of duplicates\r\n        imports.add(java.util.Collection.class);\r\n        imports.add(java.util.ArrayList.class);\r\n        for (Iterator<Class> i = imports.iterator(); i.hasNext(); ) {\r\n            Class clazz = i.next();\r\n            if (clazz.isPrimitive() || clazz.getPackage().getName().equals(\"java.lang\")) {\r\n                continue;\r\n            }\r\n            header += \"import \" + clazz.getName() + \";\" + ln;\r\n            if (!i.hasNext()) {\r\n                header += ln;\r\n            }\r\n        }\r\n        header += \"public class \" + className + \" implements FsmModel {\" + ln;\r\n        header += \"  private int testIndex = 1;\" + ln;\r\n        return header;\r\n    }\r\n\r\n    /**\r\n     * Last part of the EFSM Java code for modeljunit, closes the model class.\r\n     *\r\n     * @return The Java code to close up the model.\r\n     */\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n\r\n    public String resetMethod(Collection<String> arrayNames, Collection<Class> mocks) {\r\n        String reset = \"  public void reset(boolean b) {\" + ln;\r\n        reset += \"    state = \\\"\\\";\" + ln;\r\n        reset += \"    System.out.println(\\\"------------------- STARTING TEST \\\"+testIndex+\\\"--------------------------\\\");\" + ln;\r\n        reset += \"    testIndex++;\" + ln;\r\n        for (String name : arrayNames) {\r\n            reset += \"    \" + name + \".clear();\" + ln;\r\n        }\r\n        for (Class clazz : mocks) {\r\n            reset += \"    EasyMock.reset(\" + mockNameFor(clazz.getSimpleName()) + \");\" + ln;\r\n        }\r\n        reset += sutSetup();\r\n        reset += \"  }\" + ln + ln;\r\n        return reset;\r\n    }\r\n\r\n    private String sutSetup() {\r\n        String setup = \"    try {\" + ln;\r\n        String objectName = objectUnderTest.getSimpleName();\r\n        String lcObjectName = lowerCaseFirstLetter(objectName);\r\n        setup += \"      \" + lcObjectName + \" = create\" + objectName + \"(\";\r\n        for (Class clazz : mocks) {\r\n            if (!setup.endsWith(\"(\")) {\r\n                setup += \",\";\r\n            }\r\n            setup += mockNameFor(clazz.getSimpleName());\r\n        }\r\n        setup += \");\" + ln;\r\n        setup += \"    } catch (Exception e) {\" + ln;\r\n        setup += \"      throw new RuntimeException(e);\" + ln;\r\n        setup += \"    }\" + ln;\r\n        return setup;\r\n    }\r\n\r\n    private String mockSetup() {\r\n        String setup = \"\";\r\n        for (Class clazz : mocks) {\r\n            setup += \"    \" + mockInit(clazz.getSimpleName());\r\n        }\r\n        return setup;\r\n    }\r\n\r\n    public String testMethod(String className) {\r\n        String testMethod = \"  @Test\" + ln + \"  public void modelJUnitTest() throws Exception {\" + ln + mockSetup() + \"    Tester tester = new RandomTester(this);\" + ln + \"    GraphListener listener = tester.buildGraph();\" + ln + \"    listener.printGraphDot(\\\"\" + className + \".dot\\\");\" + ln + \"    CoverageMetric trCoverage = new TransitionCoverage();\" + ln + \"    tester.addListener(trCoverage);\" + ln + \"    tester.addListener(\\\"verbose\\\");\" + ln + \"    tester.generate(20);\" + ln + \"    tester.getModel().printMessage(trCoverage.getName() + \\\" was \\\" + trCoverage.toString());\" + ln + \"  }\" + ln + ln;\r\n        return testMethod;\r\n    }\r\n\r\n    private String helperMethods() {\r\n        return ln + \"  //---------- HELPER METHODS TO GENERATE PRIMITIVE VALUES -----------------------------------------\" + ln + numberHelper(\"int\") + ln + numberHelper(\"float\") + ln + numberHelper(\"long\") + ln + numberHelper(\"byte\") + ln + numberHelper(\"char\") + ln + mainNumberHelpers() + ln + randomCollectionItemHelper();\r\n    }\r\n\r\n    private String numberHelper(String type) {\r\n        String methodName = capitalizeFirstLetter(type);\r\n        return \"  public \" + type + \" c\" + methodName + \"() {\" + ln + \"    return (\" + type + \") Math.round(cDouble());\" + ln + \"  }\" + ln + ln + \"  public \" + type + \" c\" + methodName + \"(\" + type + \" min, \" + type + \" max) {\" + ln + \"    return (\" + type + \") Math.round(cDouble(min, max));\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    private String mainNumberHelpers() {\r\n        imports.add(Random.class);\r\n        return \"  public double cDouble() {\" + ln + \"    double min = Integer.MIN_VALUE;\" + ln + \"    double max = Integer.MAX_VALUE;\" + ln + \"    return cDouble(min, max);\" + ln + \"  }\" + ln + ln + \"  Random random = new Random(100);\" + ln + ln + \"  public double cDouble(double min, double max) {\" + ln + \"    double diff = max-min;\" + ln + \"    double rnd = random.nextDouble();\" + ln + \"    rnd *= diff;\" + ln + \"    rnd += min;\" + ln + \"    return rnd;\" + ln + \"  }\" + ln;\r\n    }\r\n\r\n    //TODO miksi on turhia arrayta siell� generoidussa mallissa?\r\n    private String randomCollectionItemHelper() {\r\n        return \"  public Object randomItemFrom(Collection array) {\" + ln + \"    List list = new ArrayList(array);\" + ln + \"    return list.get(cInt(0, array.size()-1));\" + ln + \"  }\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/EFSMGenerator_18Test.java",
		"test_prompt": "// EFSMGenerator_18Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockNameFor;\nimport static fi.vtt.noen.testgen.model.efsm.MockGenerator.mockInit;\nimport static fi.vtt.noen.testgen.StringUtils.*;\nimport fi.vtt.noen.testgen.model.fsm.FSMModel;\nimport fi.vtt.noen.testgen.model.fsm.FSMState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonState;\nimport fi.vtt.noen.testgen.model.daikon.DaikonModel;\nimport fi.vtt.noen.testgen.model.daikon.DaikonTransition;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.parser.PromParser;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.io.InputStream;\nimport java.io.ByteArrayInputStream;\nimport java.util.*;\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EFSMGenerator}.\n* It contains ten unit test cases for the {@link EFSMGenerator#testMethod(String)} method.\n*/\nclass EFSMGenerator_18Test {"
	},
	{
		"original_code": "// StubGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * DEPRECATED: Uses MockGenerator now. Generates stub classes for given interface definitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StubGenerator {\r\n\r\n    private String ln = \"\\n\";\r\n\r\n    public String stubFor(Class myInterface, String packageName, String className) {\r\n        return header(packageName, className) + variables() + methods(myInterface) + footer();\r\n    }\r\n\r\n    public String header(String packageName, String className) {\r\n        return \"package \" + packageName + \";\" + ln + ln + \"import java.util.Map;\" + ln + \"import java.util.HashMap;\" + ln + ln + \"public class \" + className + \" {\" + ln;\r\n    }\r\n\r\n    public String variables() {\r\n        String result = \"  private Map<String, Integer> messages = new HashMap<String, Integer>();\" + ln + ln + \"  public void reset() {\" + ln + \"    messages.clear();\" + ln + \"  }\" + ln + ln + \"  private void msgReceived(String msg) {\" + ln + \"    Integer count = messages.get(msg);\" + ln + \"    if (count == null) {\" + ln + \"      count = 0;\" + ln + \"    }\" + ln + \"    count++;\" + ln + \"    messages.put(msg, count);\" + ln + \"  }\" + ln + ln + \"  public int countFor(String msg) {\" + ln + \"    return messages.get(msg);\" + ln + \"  }\" + ln;\r\n        return result;\r\n    }\r\n\r\n    public String methods(Class myInterface) {\r\n        Method[] methods = myInterface.getMethods();\r\n        String stub = \"\";\r\n        for (int i = 0; i < methods.length; i++) {\r\n            Method method = methods[i];\r\n            stub += stubFor(method);\r\n        }\r\n        return stub;\r\n    }\r\n\r\n    public String stubFor(Method method) {\r\n        String stub = methodNameFor(method);\r\n        stub = methodContentsFor(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String methodContentsFor(Method method, String stub) {\r\n        stub += \" {\" + ln;\r\n        Class returnType = method.getReturnType();\r\n        String name = method.getName();\r\n        stub += \"    msgReceived(\\\"\" + name + \"\\\");\" + ln;\r\n        if (!returnType.equals(void.class)) {\r\n            stub += \"    return null;\" + ln;\r\n        }\r\n        stub += \"  }\" + ln;\r\n        return stub;\r\n    }\r\n\r\n    private String methodNameFor(Method method) {\r\n        String fullName = method.toString();\r\n        String[] parts = fullName.split(\" \");\r\n        //interface methods are always shown as \"abstract\" so remove that (parts[1])\r\n        String methodName = \"  \" + parts[0] + \" \" + parts[2] + \" \" + method.getName();\r\n        //Method.toString also returns fully qualified class names etc so remove those\r\n        parts = fullName.split(method.getName() + \"\\\\(\");\r\n        //parts[1] will now contain the parameters and throws statements\r\n        String params = \"(\" + parts[1];\r\n        String stub = methodName + params;\r\n        stub = addParameterNames(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String addParameterNames(Method method, String stub) {\r\n        if (method.getParameterTypes().length == 0) {\r\n            //it has no parameters\r\n            return stub;\r\n        }\r\n        String[] parts = stub.split(\" throws \");\r\n        String exceptions = \"\";\r\n        if (parts.length > 1) {\r\n            exceptions = \" throws \" + parts[1];\r\n            stub = parts[0];\r\n        }\r\n        //remove trailing \")\" for parameter parsing\r\n        stub = stub.substring(0, stub.length() - 1);\r\n        parts = stub.split(\",\");\r\n        stub = parts[0] + \" p1\";\r\n        for (int i = 1; i < parts.length; i++) {\r\n            String type = parts[i];\r\n            String name = \" p\" + (i + 1);\r\n            stub += \", \" + type + name;\r\n        }\r\n        //put the \")\" back there\r\n        return stub + \")\" + exceptions;\r\n    }\r\n\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/StubGenerator_0Test.java",
		"test_prompt": "// StubGenerator_0Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StubGenerator}.\n* It contains ten unit test cases for the {@link StubGenerator#stubFor(Class, String, String)} method.\n*/\nclass StubGenerator_0Test {"
	},
	{
		"original_code": "// StubGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * DEPRECATED: Uses MockGenerator now. Generates stub classes for given interface definitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StubGenerator {\r\n\r\n    private String ln = \"\\n\";\r\n\r\n    public String stubFor(Class myInterface, String packageName, String className) {\r\n        return header(packageName, className) + variables() + methods(myInterface) + footer();\r\n    }\r\n\r\n    public String header(String packageName, String className) {\r\n        return \"package \" + packageName + \";\" + ln + ln + \"import java.util.Map;\" + ln + \"import java.util.HashMap;\" + ln + ln + \"public class \" + className + \" {\" + ln;\r\n    }\r\n\r\n    public String variables() {\r\n        String result = \"  private Map<String, Integer> messages = new HashMap<String, Integer>();\" + ln + ln + \"  public void reset() {\" + ln + \"    messages.clear();\" + ln + \"  }\" + ln + ln + \"  private void msgReceived(String msg) {\" + ln + \"    Integer count = messages.get(msg);\" + ln + \"    if (count == null) {\" + ln + \"      count = 0;\" + ln + \"    }\" + ln + \"    count++;\" + ln + \"    messages.put(msg, count);\" + ln + \"  }\" + ln + ln + \"  public int countFor(String msg) {\" + ln + \"    return messages.get(msg);\" + ln + \"  }\" + ln;\r\n        return result;\r\n    }\r\n\r\n    public String methods(Class myInterface) {\r\n        Method[] methods = myInterface.getMethods();\r\n        String stub = \"\";\r\n        for (int i = 0; i < methods.length; i++) {\r\n            Method method = methods[i];\r\n            stub += stubFor(method);\r\n        }\r\n        return stub;\r\n    }\r\n\r\n    public String stubFor(Method method) {\r\n        String stub = methodNameFor(method);\r\n        stub = methodContentsFor(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String methodContentsFor(Method method, String stub) {\r\n        stub += \" {\" + ln;\r\n        Class returnType = method.getReturnType();\r\n        String name = method.getName();\r\n        stub += \"    msgReceived(\\\"\" + name + \"\\\");\" + ln;\r\n        if (!returnType.equals(void.class)) {\r\n            stub += \"    return null;\" + ln;\r\n        }\r\n        stub += \"  }\" + ln;\r\n        return stub;\r\n    }\r\n\r\n    private String methodNameFor(Method method) {\r\n        String fullName = method.toString();\r\n        String[] parts = fullName.split(\" \");\r\n        //interface methods are always shown as \"abstract\" so remove that (parts[1])\r\n        String methodName = \"  \" + parts[0] + \" \" + parts[2] + \" \" + method.getName();\r\n        //Method.toString also returns fully qualified class names etc so remove those\r\n        parts = fullName.split(method.getName() + \"\\\\(\");\r\n        //parts[1] will now contain the parameters and throws statements\r\n        String params = \"(\" + parts[1];\r\n        String stub = methodName + params;\r\n        stub = addParameterNames(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String addParameterNames(Method method, String stub) {\r\n        if (method.getParameterTypes().length == 0) {\r\n            //it has no parameters\r\n            return stub;\r\n        }\r\n        String[] parts = stub.split(\" throws \");\r\n        String exceptions = \"\";\r\n        if (parts.length > 1) {\r\n            exceptions = \" throws \" + parts[1];\r\n            stub = parts[0];\r\n        }\r\n        //remove trailing \")\" for parameter parsing\r\n        stub = stub.substring(0, stub.length() - 1);\r\n        parts = stub.split(\",\");\r\n        stub = parts[0] + \" p1\";\r\n        for (int i = 1; i < parts.length; i++) {\r\n            String type = parts[i];\r\n            String name = \" p\" + (i + 1);\r\n            stub += \", \" + type + name;\r\n        }\r\n        //put the \")\" back there\r\n        return stub + \")\" + exceptions;\r\n    }\r\n\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/StubGenerator_1Test.java",
		"test_prompt": "// StubGenerator_1Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StubGenerator}.\n* It contains ten unit test cases for the {@link StubGenerator#header(String, String)} method.\n*/\nclass StubGenerator_1Test {"
	},
	{
		"original_code": "// StubGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * DEPRECATED: Uses MockGenerator now. Generates stub classes for given interface definitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StubGenerator {\r\n\r\n    private String ln = \"\\n\";\r\n\r\n    public String stubFor(Class myInterface, String packageName, String className) {\r\n        return header(packageName, className) + variables() + methods(myInterface) + footer();\r\n    }\r\n\r\n    public String header(String packageName, String className) {\r\n        return \"package \" + packageName + \";\" + ln + ln + \"import java.util.Map;\" + ln + \"import java.util.HashMap;\" + ln + ln + \"public class \" + className + \" {\" + ln;\r\n    }\r\n\r\n    public String variables() {\r\n        String result = \"  private Map<String, Integer> messages = new HashMap<String, Integer>();\" + ln + ln + \"  public void reset() {\" + ln + \"    messages.clear();\" + ln + \"  }\" + ln + ln + \"  private void msgReceived(String msg) {\" + ln + \"    Integer count = messages.get(msg);\" + ln + \"    if (count == null) {\" + ln + \"      count = 0;\" + ln + \"    }\" + ln + \"    count++;\" + ln + \"    messages.put(msg, count);\" + ln + \"  }\" + ln + ln + \"  public int countFor(String msg) {\" + ln + \"    return messages.get(msg);\" + ln + \"  }\" + ln;\r\n        return result;\r\n    }\r\n\r\n    public String methods(Class myInterface) {\r\n        Method[] methods = myInterface.getMethods();\r\n        String stub = \"\";\r\n        for (int i = 0; i < methods.length; i++) {\r\n            Method method = methods[i];\r\n            stub += stubFor(method);\r\n        }\r\n        return stub;\r\n    }\r\n\r\n    public String stubFor(Method method) {\r\n        String stub = methodNameFor(method);\r\n        stub = methodContentsFor(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String methodContentsFor(Method method, String stub) {\r\n        stub += \" {\" + ln;\r\n        Class returnType = method.getReturnType();\r\n        String name = method.getName();\r\n        stub += \"    msgReceived(\\\"\" + name + \"\\\");\" + ln;\r\n        if (!returnType.equals(void.class)) {\r\n            stub += \"    return null;\" + ln;\r\n        }\r\n        stub += \"  }\" + ln;\r\n        return stub;\r\n    }\r\n\r\n    private String methodNameFor(Method method) {\r\n        String fullName = method.toString();\r\n        String[] parts = fullName.split(\" \");\r\n        //interface methods are always shown as \"abstract\" so remove that (parts[1])\r\n        String methodName = \"  \" + parts[0] + \" \" + parts[2] + \" \" + method.getName();\r\n        //Method.toString also returns fully qualified class names etc so remove those\r\n        parts = fullName.split(method.getName() + \"\\\\(\");\r\n        //parts[1] will now contain the parameters and throws statements\r\n        String params = \"(\" + parts[1];\r\n        String stub = methodName + params;\r\n        stub = addParameterNames(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String addParameterNames(Method method, String stub) {\r\n        if (method.getParameterTypes().length == 0) {\r\n            //it has no parameters\r\n            return stub;\r\n        }\r\n        String[] parts = stub.split(\" throws \");\r\n        String exceptions = \"\";\r\n        if (parts.length > 1) {\r\n            exceptions = \" throws \" + parts[1];\r\n            stub = parts[0];\r\n        }\r\n        //remove trailing \")\" for parameter parsing\r\n        stub = stub.substring(0, stub.length() - 1);\r\n        parts = stub.split(\",\");\r\n        stub = parts[0] + \" p1\";\r\n        for (int i = 1; i < parts.length; i++) {\r\n            String type = parts[i];\r\n            String name = \" p\" + (i + 1);\r\n            stub += \", \" + type + name;\r\n        }\r\n        //put the \")\" back there\r\n        return stub + \")\" + exceptions;\r\n    }\r\n\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/StubGenerator_2Test.java",
		"test_prompt": "// StubGenerator_2Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StubGenerator}.\n* It contains ten unit test cases for the {@link StubGenerator#variables()} method.\n*/\nclass StubGenerator_2Test {"
	},
	{
		"original_code": "// StubGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * DEPRECATED: Uses MockGenerator now. Generates stub classes for given interface definitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StubGenerator {\r\n\r\n    private String ln = \"\\n\";\r\n\r\n    public String stubFor(Class myInterface, String packageName, String className) {\r\n        return header(packageName, className) + variables() + methods(myInterface) + footer();\r\n    }\r\n\r\n    public String header(String packageName, String className) {\r\n        return \"package \" + packageName + \";\" + ln + ln + \"import java.util.Map;\" + ln + \"import java.util.HashMap;\" + ln + ln + \"public class \" + className + \" {\" + ln;\r\n    }\r\n\r\n    public String variables() {\r\n        String result = \"  private Map<String, Integer> messages = new HashMap<String, Integer>();\" + ln + ln + \"  public void reset() {\" + ln + \"    messages.clear();\" + ln + \"  }\" + ln + ln + \"  private void msgReceived(String msg) {\" + ln + \"    Integer count = messages.get(msg);\" + ln + \"    if (count == null) {\" + ln + \"      count = 0;\" + ln + \"    }\" + ln + \"    count++;\" + ln + \"    messages.put(msg, count);\" + ln + \"  }\" + ln + ln + \"  public int countFor(String msg) {\" + ln + \"    return messages.get(msg);\" + ln + \"  }\" + ln;\r\n        return result;\r\n    }\r\n\r\n    public String methods(Class myInterface) {\r\n        Method[] methods = myInterface.getMethods();\r\n        String stub = \"\";\r\n        for (int i = 0; i < methods.length; i++) {\r\n            Method method = methods[i];\r\n            stub += stubFor(method);\r\n        }\r\n        return stub;\r\n    }\r\n\r\n    public String stubFor(Method method) {\r\n        String stub = methodNameFor(method);\r\n        stub = methodContentsFor(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String methodContentsFor(Method method, String stub) {\r\n        stub += \" {\" + ln;\r\n        Class returnType = method.getReturnType();\r\n        String name = method.getName();\r\n        stub += \"    msgReceived(\\\"\" + name + \"\\\");\" + ln;\r\n        if (!returnType.equals(void.class)) {\r\n            stub += \"    return null;\" + ln;\r\n        }\r\n        stub += \"  }\" + ln;\r\n        return stub;\r\n    }\r\n\r\n    private String methodNameFor(Method method) {\r\n        String fullName = method.toString();\r\n        String[] parts = fullName.split(\" \");\r\n        //interface methods are always shown as \"abstract\" so remove that (parts[1])\r\n        String methodName = \"  \" + parts[0] + \" \" + parts[2] + \" \" + method.getName();\r\n        //Method.toString also returns fully qualified class names etc so remove those\r\n        parts = fullName.split(method.getName() + \"\\\\(\");\r\n        //parts[1] will now contain the parameters and throws statements\r\n        String params = \"(\" + parts[1];\r\n        String stub = methodName + params;\r\n        stub = addParameterNames(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String addParameterNames(Method method, String stub) {\r\n        if (method.getParameterTypes().length == 0) {\r\n            //it has no parameters\r\n            return stub;\r\n        }\r\n        String[] parts = stub.split(\" throws \");\r\n        String exceptions = \"\";\r\n        if (parts.length > 1) {\r\n            exceptions = \" throws \" + parts[1];\r\n            stub = parts[0];\r\n        }\r\n        //remove trailing \")\" for parameter parsing\r\n        stub = stub.substring(0, stub.length() - 1);\r\n        parts = stub.split(\",\");\r\n        stub = parts[0] + \" p1\";\r\n        for (int i = 1; i < parts.length; i++) {\r\n            String type = parts[i];\r\n            String name = \" p\" + (i + 1);\r\n            stub += \", \" + type + name;\r\n        }\r\n        //put the \")\" back there\r\n        return stub + \")\" + exceptions;\r\n    }\r\n\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/StubGenerator_3Test.java",
		"test_prompt": "// StubGenerator_3Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StubGenerator}.\n* It contains ten unit test cases for the {@link StubGenerator#methods(Class)} method.\n*/\nclass StubGenerator_3Test {"
	},
	{
		"original_code": "// StubGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * DEPRECATED: Uses MockGenerator now. Generates stub classes for given interface definitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StubGenerator {\r\n\r\n    private String ln = \"\\n\";\r\n\r\n    public String stubFor(Class myInterface, String packageName, String className) {\r\n        return header(packageName, className) + variables() + methods(myInterface) + footer();\r\n    }\r\n\r\n    public String header(String packageName, String className) {\r\n        return \"package \" + packageName + \";\" + ln + ln + \"import java.util.Map;\" + ln + \"import java.util.HashMap;\" + ln + ln + \"public class \" + className + \" {\" + ln;\r\n    }\r\n\r\n    public String variables() {\r\n        String result = \"  private Map<String, Integer> messages = new HashMap<String, Integer>();\" + ln + ln + \"  public void reset() {\" + ln + \"    messages.clear();\" + ln + \"  }\" + ln + ln + \"  private void msgReceived(String msg) {\" + ln + \"    Integer count = messages.get(msg);\" + ln + \"    if (count == null) {\" + ln + \"      count = 0;\" + ln + \"    }\" + ln + \"    count++;\" + ln + \"    messages.put(msg, count);\" + ln + \"  }\" + ln + ln + \"  public int countFor(String msg) {\" + ln + \"    return messages.get(msg);\" + ln + \"  }\" + ln;\r\n        return result;\r\n    }\r\n\r\n    public String methods(Class myInterface) {\r\n        Method[] methods = myInterface.getMethods();\r\n        String stub = \"\";\r\n        for (int i = 0; i < methods.length; i++) {\r\n            Method method = methods[i];\r\n            stub += stubFor(method);\r\n        }\r\n        return stub;\r\n    }\r\n\r\n    public String stubFor(Method method) {\r\n        String stub = methodNameFor(method);\r\n        stub = methodContentsFor(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String methodContentsFor(Method method, String stub) {\r\n        stub += \" {\" + ln;\r\n        Class returnType = method.getReturnType();\r\n        String name = method.getName();\r\n        stub += \"    msgReceived(\\\"\" + name + \"\\\");\" + ln;\r\n        if (!returnType.equals(void.class)) {\r\n            stub += \"    return null;\" + ln;\r\n        }\r\n        stub += \"  }\" + ln;\r\n        return stub;\r\n    }\r\n\r\n    private String methodNameFor(Method method) {\r\n        String fullName = method.toString();\r\n        String[] parts = fullName.split(\" \");\r\n        //interface methods are always shown as \"abstract\" so remove that (parts[1])\r\n        String methodName = \"  \" + parts[0] + \" \" + parts[2] + \" \" + method.getName();\r\n        //Method.toString also returns fully qualified class names etc so remove those\r\n        parts = fullName.split(method.getName() + \"\\\\(\");\r\n        //parts[1] will now contain the parameters and throws statements\r\n        String params = \"(\" + parts[1];\r\n        String stub = methodName + params;\r\n        stub = addParameterNames(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String addParameterNames(Method method, String stub) {\r\n        if (method.getParameterTypes().length == 0) {\r\n            //it has no parameters\r\n            return stub;\r\n        }\r\n        String[] parts = stub.split(\" throws \");\r\n        String exceptions = \"\";\r\n        if (parts.length > 1) {\r\n            exceptions = \" throws \" + parts[1];\r\n            stub = parts[0];\r\n        }\r\n        //remove trailing \")\" for parameter parsing\r\n        stub = stub.substring(0, stub.length() - 1);\r\n        parts = stub.split(\",\");\r\n        stub = parts[0] + \" p1\";\r\n        for (int i = 1; i < parts.length; i++) {\r\n            String type = parts[i];\r\n            String name = \" p\" + (i + 1);\r\n            stub += \", \" + type + name;\r\n        }\r\n        //put the \")\" back there\r\n        return stub + \")\" + exceptions;\r\n    }\r\n\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/StubGenerator_4Test.java",
		"test_prompt": "// StubGenerator_4Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StubGenerator}.\n* It contains ten unit test cases for the {@link StubGenerator#stubFor(Method)} method.\n*/\nclass StubGenerator_4Test {"
	},
	{
		"original_code": "// StubGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * DEPRECATED: Uses MockGenerator now. Generates stub classes for given interface definitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class StubGenerator {\r\n\r\n    private String ln = \"\\n\";\r\n\r\n    public String stubFor(Class myInterface, String packageName, String className) {\r\n        return header(packageName, className) + variables() + methods(myInterface) + footer();\r\n    }\r\n\r\n    public String header(String packageName, String className) {\r\n        return \"package \" + packageName + \";\" + ln + ln + \"import java.util.Map;\" + ln + \"import java.util.HashMap;\" + ln + ln + \"public class \" + className + \" {\" + ln;\r\n    }\r\n\r\n    public String variables() {\r\n        String result = \"  private Map<String, Integer> messages = new HashMap<String, Integer>();\" + ln + ln + \"  public void reset() {\" + ln + \"    messages.clear();\" + ln + \"  }\" + ln + ln + \"  private void msgReceived(String msg) {\" + ln + \"    Integer count = messages.get(msg);\" + ln + \"    if (count == null) {\" + ln + \"      count = 0;\" + ln + \"    }\" + ln + \"    count++;\" + ln + \"    messages.put(msg, count);\" + ln + \"  }\" + ln + ln + \"  public int countFor(String msg) {\" + ln + \"    return messages.get(msg);\" + ln + \"  }\" + ln;\r\n        return result;\r\n    }\r\n\r\n    public String methods(Class myInterface) {\r\n        Method[] methods = myInterface.getMethods();\r\n        String stub = \"\";\r\n        for (int i = 0; i < methods.length; i++) {\r\n            Method method = methods[i];\r\n            stub += stubFor(method);\r\n        }\r\n        return stub;\r\n    }\r\n\r\n    public String stubFor(Method method) {\r\n        String stub = methodNameFor(method);\r\n        stub = methodContentsFor(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String methodContentsFor(Method method, String stub) {\r\n        stub += \" {\" + ln;\r\n        Class returnType = method.getReturnType();\r\n        String name = method.getName();\r\n        stub += \"    msgReceived(\\\"\" + name + \"\\\");\" + ln;\r\n        if (!returnType.equals(void.class)) {\r\n            stub += \"    return null;\" + ln;\r\n        }\r\n        stub += \"  }\" + ln;\r\n        return stub;\r\n    }\r\n\r\n    private String methodNameFor(Method method) {\r\n        String fullName = method.toString();\r\n        String[] parts = fullName.split(\" \");\r\n        //interface methods are always shown as \"abstract\" so remove that (parts[1])\r\n        String methodName = \"  \" + parts[0] + \" \" + parts[2] + \" \" + method.getName();\r\n        //Method.toString also returns fully qualified class names etc so remove those\r\n        parts = fullName.split(method.getName() + \"\\\\(\");\r\n        //parts[1] will now contain the parameters and throws statements\r\n        String params = \"(\" + parts[1];\r\n        String stub = methodName + params;\r\n        stub = addParameterNames(method, stub);\r\n        return stub;\r\n    }\r\n\r\n    private String addParameterNames(Method method, String stub) {\r\n        if (method.getParameterTypes().length == 0) {\r\n            //it has no parameters\r\n            return stub;\r\n        }\r\n        String[] parts = stub.split(\" throws \");\r\n        String exceptions = \"\";\r\n        if (parts.length > 1) {\r\n            exceptions = \" throws \" + parts[1];\r\n            stub = parts[0];\r\n        }\r\n        //remove trailing \")\" for parameter parsing\r\n        stub = stub.substring(0, stub.length() - 1);\r\n        parts = stub.split(\",\");\r\n        stub = parts[0] + \" p1\";\r\n        for (int i = 1; i < parts.length; i++) {\r\n            String type = parts[i];\r\n            String name = \" p\" + (i + 1);\r\n            stub += \", \" + type + name;\r\n        }\r\n        //put the \")\" back there\r\n        return stub + \")\" + exceptions;\r\n    }\r\n\r\n    public String footer() {\r\n        return \"}\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/StubGenerator_5Test.java",
		"test_prompt": "// StubGenerator_5Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Field;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StubGenerator}.\n* It contains ten unit test cases for the {@link StubGenerator#footer()} method.\n*/\nclass StubGenerator_5Test {"
	},
	{
		"original_code": "// ImportClassComparator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * This is used in code generation to order the generated import statements in the resulting source code.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ImportClassComparator implements Comparator<Class> {\r\n\r\n    public int compare(Class c1, Class c2) {\r\n        return c1.getName().compareTo(c2.getName());\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/ImportClassComparator.java",
		"test_prompt": "// ImportClassComparatorTest.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ImportClassComparator}.\n* It contains ten unit test cases for the {@link ImportClassComparator#compare(Class, Class)} method.\n*/\nclass ImportClassComparatorTest {"
	},
	{
		"original_code": "// MockGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Generates source code related to creating mock objects, setting their expectations, and verifying\r\n * their correctness, etc.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class MockGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private static final String ln = \"\\n\";\r\n\r\n    private final String className;\r\n\r\n    public MockGenerator(Class clazz) {\r\n        this.className = clazz.getSimpleName();\r\n    }\r\n\r\n    public static String mockNameFor(String className) {\r\n        return \"mock\" + className;\r\n    }\r\n\r\n    public static String mockInit(String className) {\r\n        return mockNameFor(className) + \" = createMock(\" + className + \".class);\" + ln;\r\n    }\r\n\r\n    public String replay() {\r\n        return \"replay(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    public String verify() {\r\n        return \"verify(mock\" + className + \");\" + ln + \"EasyMock.reset(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    /**\r\n     * @param methodToCall\r\n     * @return\r\n     */\r\n    public String callFor(Method methodToCall, String returnValue) {\r\n        String methodName = methodToCall.getName();\r\n        Class[] parameterTypes = methodToCall.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            if (type.equals(boolean.class)) {\r\n                parameters += \"false\";\r\n            } else if (type.isPrimitive()) {\r\n                parameters += 0;\r\n            } else {\r\n                parameters += \"(\" + type.getSimpleName() + \")anyObject()\";\r\n            }\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n        }\r\n        String mockCall = \"mock\" + className + \".\" + methodName + \"(\" + parameters + \")\";\r\n        if (returnValue != null) {\r\n            mockCall = \"expect(\" + mockCall + \").andReturn(\" + returnValue + \")\";\r\n        }\r\n        mockCall += \";\" + ln;\r\n        return mockCall;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/MockGenerator_0Test.java",
		"test_prompt": "// MockGenerator_0Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MockGenerator}.\n* It contains ten unit test cases for the {@link MockGenerator#mockNameFor(String)} method.\n*/\nclass MockGenerator_0Test {"
	},
	{
		"original_code": "// MockGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Generates source code related to creating mock objects, setting their expectations, and verifying\r\n * their correctness, etc.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class MockGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private static final String ln = \"\\n\";\r\n\r\n    private final String className;\r\n\r\n    public MockGenerator(Class clazz) {\r\n        this.className = clazz.getSimpleName();\r\n    }\r\n\r\n    public static String mockNameFor(String className) {\r\n        return \"mock\" + className;\r\n    }\r\n\r\n    public static String mockInit(String className) {\r\n        return mockNameFor(className) + \" = createMock(\" + className + \".class);\" + ln;\r\n    }\r\n\r\n    public String replay() {\r\n        return \"replay(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    public String verify() {\r\n        return \"verify(mock\" + className + \");\" + ln + \"EasyMock.reset(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    /**\r\n     * @param methodToCall\r\n     * @return\r\n     */\r\n    public String callFor(Method methodToCall, String returnValue) {\r\n        String methodName = methodToCall.getName();\r\n        Class[] parameterTypes = methodToCall.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            if (type.equals(boolean.class)) {\r\n                parameters += \"false\";\r\n            } else if (type.isPrimitive()) {\r\n                parameters += 0;\r\n            } else {\r\n                parameters += \"(\" + type.getSimpleName() + \")anyObject()\";\r\n            }\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n        }\r\n        String mockCall = \"mock\" + className + \".\" + methodName + \"(\" + parameters + \")\";\r\n        if (returnValue != null) {\r\n            mockCall = \"expect(\" + mockCall + \").andReturn(\" + returnValue + \")\";\r\n        }\r\n        mockCall += \";\" + ln;\r\n        return mockCall;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/MockGenerator_1Test.java",
		"test_prompt": "// MockGenerator_1Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MockGenerator}.\n* It contains ten unit test cases for the {@link MockGenerator#mockInit(String)} method.\n*/\nclass MockGenerator_1Test {"
	},
	{
		"original_code": "// MockGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Generates source code related to creating mock objects, setting their expectations, and verifying\r\n * their correctness, etc.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class MockGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private static final String ln = \"\\n\";\r\n\r\n    private final String className;\r\n\r\n    public MockGenerator(Class clazz) {\r\n        this.className = clazz.getSimpleName();\r\n    }\r\n\r\n    public static String mockNameFor(String className) {\r\n        return \"mock\" + className;\r\n    }\r\n\r\n    public static String mockInit(String className) {\r\n        return mockNameFor(className) + \" = createMock(\" + className + \".class);\" + ln;\r\n    }\r\n\r\n    public String replay() {\r\n        return \"replay(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    public String verify() {\r\n        return \"verify(mock\" + className + \");\" + ln + \"EasyMock.reset(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    /**\r\n     * @param methodToCall\r\n     * @return\r\n     */\r\n    public String callFor(Method methodToCall, String returnValue) {\r\n        String methodName = methodToCall.getName();\r\n        Class[] parameterTypes = methodToCall.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            if (type.equals(boolean.class)) {\r\n                parameters += \"false\";\r\n            } else if (type.isPrimitive()) {\r\n                parameters += 0;\r\n            } else {\r\n                parameters += \"(\" + type.getSimpleName() + \")anyObject()\";\r\n            }\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n        }\r\n        String mockCall = \"mock\" + className + \".\" + methodName + \"(\" + parameters + \")\";\r\n        if (returnValue != null) {\r\n            mockCall = \"expect(\" + mockCall + \").andReturn(\" + returnValue + \")\";\r\n        }\r\n        mockCall += \";\" + ln;\r\n        return mockCall;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/MockGenerator_2Test.java",
		"test_prompt": "// MockGenerator_2Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MockGenerator}.\n* It contains ten unit test cases for the {@link MockGenerator#replay()} method.\n*/\nclass MockGenerator_2Test {"
	},
	{
		"original_code": "// MockGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Generates source code related to creating mock objects, setting their expectations, and verifying\r\n * their correctness, etc.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class MockGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private static final String ln = \"\\n\";\r\n\r\n    private final String className;\r\n\r\n    public MockGenerator(Class clazz) {\r\n        this.className = clazz.getSimpleName();\r\n    }\r\n\r\n    public static String mockNameFor(String className) {\r\n        return \"mock\" + className;\r\n    }\r\n\r\n    public static String mockInit(String className) {\r\n        return mockNameFor(className) + \" = createMock(\" + className + \".class);\" + ln;\r\n    }\r\n\r\n    public String replay() {\r\n        return \"replay(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    public String verify() {\r\n        return \"verify(mock\" + className + \");\" + ln + \"EasyMock.reset(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    /**\r\n     * @param methodToCall\r\n     * @return\r\n     */\r\n    public String callFor(Method methodToCall, String returnValue) {\r\n        String methodName = methodToCall.getName();\r\n        Class[] parameterTypes = methodToCall.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            if (type.equals(boolean.class)) {\r\n                parameters += \"false\";\r\n            } else if (type.isPrimitive()) {\r\n                parameters += 0;\r\n            } else {\r\n                parameters += \"(\" + type.getSimpleName() + \")anyObject()\";\r\n            }\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n        }\r\n        String mockCall = \"mock\" + className + \".\" + methodName + \"(\" + parameters + \")\";\r\n        if (returnValue != null) {\r\n            mockCall = \"expect(\" + mockCall + \").andReturn(\" + returnValue + \")\";\r\n        }\r\n        mockCall += \";\" + ln;\r\n        return mockCall;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/MockGenerator_3Test.java",
		"test_prompt": "// MockGenerator_3Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MockGenerator}.\n* It contains ten unit test cases for the {@link MockGenerator#verify()} method.\n*/\nclass MockGenerator_3Test {"
	},
	{
		"original_code": "// MockGenerator.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.efsm;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\n/**\r\n * Generates source code related to creating mock objects, setting their expectations, and verifying\r\n * their correctness, etc.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class MockGenerator {\r\n\r\n    //used as line separator all around, should be moved to common class\r\n    private static final String ln = \"\\n\";\r\n\r\n    private final String className;\r\n\r\n    public MockGenerator(Class clazz) {\r\n        this.className = clazz.getSimpleName();\r\n    }\r\n\r\n    public static String mockNameFor(String className) {\r\n        return \"mock\" + className;\r\n    }\r\n\r\n    public static String mockInit(String className) {\r\n        return mockNameFor(className) + \" = createMock(\" + className + \".class);\" + ln;\r\n    }\r\n\r\n    public String replay() {\r\n        return \"replay(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    public String verify() {\r\n        return \"verify(mock\" + className + \");\" + ln + \"EasyMock.reset(mock\" + className + \");\" + ln;\r\n    }\r\n\r\n    /**\r\n     * @param methodToCall\r\n     * @return\r\n     */\r\n    public String callFor(Method methodToCall, String returnValue) {\r\n        String methodName = methodToCall.getName();\r\n        Class[] parameterTypes = methodToCall.getParameterTypes();\r\n        String parameters = \"\";\r\n        for (int i = 0; i < parameterTypes.length; i++) {\r\n            Class type = parameterTypes[i];\r\n            if (type.equals(boolean.class)) {\r\n                parameters += \"false\";\r\n            } else if (type.isPrimitive()) {\r\n                parameters += 0;\r\n            } else {\r\n                parameters += \"(\" + type.getSimpleName() + \")anyObject()\";\r\n            }\r\n            if (i < parameterTypes.length - 1) {\r\n                parameters += \", \";\r\n            }\r\n        }\r\n        String mockCall = \"mock\" + className + \".\" + methodName + \"(\" + parameters + \")\";\r\n        if (returnValue != null) {\r\n            mockCall = \"expect(\" + mockCall + \").andReturn(\" + returnValue + \")\";\r\n        }\r\n        mockCall += \";\" + ln;\r\n        return mockCall;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/efsm/MockGenerator_4Test.java",
		"test_prompt": "// MockGenerator_4Test.java\npackage fi.vtt.noen.testgen.model.efsm;\n\nimport java.lang.reflect.Method;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MockGenerator}.\n* It contains ten unit test cases for the {@link MockGenerator#callFor(Method, String)} method.\n*/\nclass MockGenerator_4Test {"
	},
	{
		"original_code": "// Event.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.invariants;\r\n\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class Event {\r\n\r\n    private final String name;\r\n\r\n    private boolean exit = false;\r\n\r\n    private final Collection<CollectionAttribute> collectionAttributes = new ArrayList<CollectionAttribute>();\r\n\r\n    private final Collection<StringAttribute> stringAttributes = new ArrayList<StringAttribute>();\r\n\r\n    public Event(String name) {\r\n        this(name, false);\r\n    }\r\n\r\n    public Event(String name, boolean exit) {\r\n        this.name = name;\r\n        this.exit = exit;\r\n    }\r\n\r\n    public void add(StringAttribute attribute) {\r\n        stringAttributes.add(attribute);\r\n    }\r\n\r\n    public void add(CollectionAttribute attribute) {\r\n        collectionAttributes.add(attribute);\r\n    }\r\n\r\n    public boolean isExit() {\r\n        return exit;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public Collection<CollectionAttribute> getCollectionAttributes() {\r\n        return collectionAttributes;\r\n    }\r\n\r\n    public CollectionAttribute getCollectionAttribute(String name) {\r\n        for (CollectionAttribute ca : collectionAttributes) {\r\n            if (ca.getName().equals(name)) {\r\n                return ca;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public Collection<StringAttribute> getStringAttributes() {\r\n        return stringAttributes;\r\n    }\r\n\r\n    public StringAttribute getStringAttribute(String name) {\r\n        for (StringAttribute sa : stringAttributes) {\r\n            if (sa.getName().equals(name)) {\r\n                return sa;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/invariants/Event.java",
		"test_prompt": "// EventTest.java\npackage fi.vtt.noen.testgen.model.invariants;\n\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Event}.\n* It contains ten unit test cases for the {@link Event#isExit()} method.\n*/\nclass EventTest {"
	},
	{
		"original_code": "// InvariantAlwaysIn.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.invariants;\r\n\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class InvariantAlwaysIn extends Invariant {\r\n\r\n    private final Collection<String> variables = new ArrayList<String>();\r\n\r\n    public InvariantAlwaysIn(String name) {\r\n        super(InvariantType.ALWAYS_IN, name);\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return variables.isEmpty();\r\n    }\r\n\r\n    public void add(String variable) {\r\n        variables.add(variable);\r\n    }\r\n\r\n    public Collection<String> getVariables() {\r\n        return variables;\r\n    }\r\n\r\n    public boolean equals(Object o) {\r\n        return name.equals(o);\r\n    }\r\n\r\n    public int hashCode() {\r\n        return name.hashCode();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/invariants/InvariantAlwaysIn_0Test.java",
		"test_prompt": "// InvariantAlwaysIn_0Test.java\npackage fi.vtt.noen.testgen.model.invariants;\n\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InvariantAlwaysIn}.\n* It contains ten unit test cases for the {@link InvariantAlwaysIn#isEmpty()} method.\n*/\nclass InvariantAlwaysIn_0Test {"
	},
	{
		"original_code": "// InvariantAlwaysIn.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.invariants;\r\n\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class InvariantAlwaysIn extends Invariant {\r\n\r\n    private final Collection<String> variables = new ArrayList<String>();\r\n\r\n    public InvariantAlwaysIn(String name) {\r\n        super(InvariantType.ALWAYS_IN, name);\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return variables.isEmpty();\r\n    }\r\n\r\n    public void add(String variable) {\r\n        variables.add(variable);\r\n    }\r\n\r\n    public Collection<String> getVariables() {\r\n        return variables;\r\n    }\r\n\r\n    public boolean equals(Object o) {\r\n        return name.equals(o);\r\n    }\r\n\r\n    public int hashCode() {\r\n        return name.hashCode();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/invariants/InvariantAlwaysIn_1Test.java",
		"test_prompt": "// InvariantAlwaysIn_1Test.java\npackage fi.vtt.noen.testgen.model.invariants;\n\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InvariantAlwaysIn}.\n* It contains ten unit test cases for the {@link InvariantAlwaysIn#equals(Object)} method.\n*/\nclass InvariantAlwaysIn_1Test {"
	},
	{
		"original_code": "// InvariantAlwaysIn.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.invariants;\r\n\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class InvariantAlwaysIn extends Invariant {\r\n\r\n    private final Collection<String> variables = new ArrayList<String>();\r\n\r\n    public InvariantAlwaysIn(String name) {\r\n        super(InvariantType.ALWAYS_IN, name);\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return variables.isEmpty();\r\n    }\r\n\r\n    public void add(String variable) {\r\n        variables.add(variable);\r\n    }\r\n\r\n    public Collection<String> getVariables() {\r\n        return variables;\r\n    }\r\n\r\n    public boolean equals(Object o) {\r\n        return name.equals(o);\r\n    }\r\n\r\n    public int hashCode() {\r\n        return name.hashCode();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/invariants/InvariantAlwaysIn_2Test.java",
		"test_prompt": "// InvariantAlwaysIn_2Test.java\npackage fi.vtt.noen.testgen.model.invariants;\n\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InvariantAlwaysIn}.\n* It contains ten unit test cases for the {@link InvariantAlwaysIn#hashCode()} method.\n*/\nclass InvariantAlwaysIn_2Test {"
	},
	{
		"original_code": "// FSMState.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.fsm;\r\n\r\nimport java.util.Set;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * A state in the FSM.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class FSMState {\r\n\r\n    private final String id;\r\n\r\n    public FSMState(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String id() {\r\n        return id;\r\n    }\r\n\r\n    public String toString() {\r\n        return id;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/fsm/FSMState.java",
		"test_prompt": "// FSMStateTest.java\npackage fi.vtt.noen.testgen.model.fsm;\n\nimport java.util.Set;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSMState}.\n* It contains ten unit test cases for the {@link FSMState#id()} method.\n*/\nclass FSMStateTest {"
	},
	{
		"original_code": "// FSMModel.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.fsm;\r\n\r\nimport org.processmining.models.graphbased.directed.transitionsystem.TransitionSystem;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes the FSM model as received from ProM. FSM states and transitions between these states.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class FSMModel {\r\n\r\n    private Map<String, FSMState> states = new TreeMap<String, FSMState>();\r\n\r\n    private Map<FSMState, Collection<FSMTransition>> transitions = new HashMap<FSMState, Collection<FSMTransition>>();\r\n\r\n    private Set<FSMTransition> allTransitions = new HashSet<FSMTransition>();\r\n\r\n    //this is for testing\r\n    public FSMModel(TreeMap<String, FSMState> states, Collection<FSMTransition> transitions) {\r\n        this.states = states;\r\n        for (Iterator<FSMTransition> i = transitions.iterator(); i.hasNext(); ) {\r\n            FSMTransition transition = i.next();\r\n            FSMState source = transition.getSource();\r\n            addTransition(source, transition);\r\n        }\r\n    }\r\n\r\n    private void addTransition(FSMState source, FSMTransition transition) {\r\n        Collection<FSMTransition> transitions = this.transitions.get(source);\r\n        if (transitions == null) {\r\n            transitions = new ArrayList<FSMTransition>();\r\n            this.transitions.put(source, transitions);\r\n        }\r\n        transitions.add(transition);\r\n        allTransitions.add(transition);\r\n    }\r\n\r\n    public FSMModel(TransitionSystem ts) {\r\n        Set<State> tsStates = ts.getNodes();\r\n        for (State state : tsStates) {\r\n            String id = removePromPrefixAndPostFix(state.toString());\r\n            if (id.length() == 0) {\r\n                //skip the \"INIT\" empty state that is added by PROM\r\n                continue;\r\n            }\r\n            FSMState fsmState = new FSMState(id);\r\n            states.put(id, fsmState);\r\n        }\r\n        Set<Transition> tsTransitions = ts.getEdges();\r\n        for (Transition transition : tsTransitions) {\r\n            String sourceId = transition.getSource().toString();\r\n            if (sourceId.length() == 0) {\r\n                //skip the \"INIT\" empty state that is added by PROM\r\n                continue;\r\n            }\r\n            sourceId = removePromPrefixAndPostFix(sourceId);\r\n            FSMState source = states.get(sourceId);\r\n            String targetId = transition.getTarget().toString();\r\n            targetId = removePromPrefixAndPostFix(targetId);\r\n            FSMState target = states.get(targetId);\r\n            FSMTransition st = new FSMTransition(source, target);\r\n            addTransition(source, st);\r\n        }\r\n    }\r\n\r\n    //removes [[ and ]] surroundings from prom state names to match then to daikon states\r\n    private String removePromPrefixAndPostFix(String stateId) {\r\n        if (stateId.equals(\"[[]]\")) {\r\n            return \"\";\r\n        }\r\n        String[] parts = stateId.split(\"\\\\[\\\\[\");\r\n        stateId = parts[1];\r\n        parts = stateId.split(\"\\\\]\\\\]\");\r\n        stateId = parts[0];\r\n        return stateId;\r\n    }\r\n\r\n    public Map<String, FSMState> getStates() {\r\n        return states;\r\n    }\r\n\r\n    public int numberOfStates() {\r\n        return states.size();\r\n    }\r\n\r\n    public int numberOfTransitions() {\r\n        return allTransitions.size();\r\n    }\r\n\r\n    public Collection<FSMTransition> getTransitionsFor(FSMState state) {\r\n        return transitions.get(state);\r\n    }\r\n\r\n    public FSMState getState(String id) {\r\n        return states.get(id);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"states:\" + states.toString() + \"\\ntransitions:\" + transitions.toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/fsm/FSMModel_0Test.java",
		"test_prompt": "// FSMModel_0Test.java\npackage fi.vtt.noen.testgen.model.fsm;\n\nimport org.processmining.models.graphbased.directed.transitionsystem.TransitionSystem;\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSMModel}.\n* It contains ten unit test cases for the {@link FSMModel#numberOfStates()} method.\n*/\nclass FSMModel_0Test {"
	},
	{
		"original_code": "// FSMModel.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.fsm;\r\n\r\nimport org.processmining.models.graphbased.directed.transitionsystem.TransitionSystem;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\r\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes the FSM model as received from ProM. FSM states and transitions between these states.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class FSMModel {\r\n\r\n    private Map<String, FSMState> states = new TreeMap<String, FSMState>();\r\n\r\n    private Map<FSMState, Collection<FSMTransition>> transitions = new HashMap<FSMState, Collection<FSMTransition>>();\r\n\r\n    private Set<FSMTransition> allTransitions = new HashSet<FSMTransition>();\r\n\r\n    //this is for testing\r\n    public FSMModel(TreeMap<String, FSMState> states, Collection<FSMTransition> transitions) {\r\n        this.states = states;\r\n        for (Iterator<FSMTransition> i = transitions.iterator(); i.hasNext(); ) {\r\n            FSMTransition transition = i.next();\r\n            FSMState source = transition.getSource();\r\n            addTransition(source, transition);\r\n        }\r\n    }\r\n\r\n    private void addTransition(FSMState source, FSMTransition transition) {\r\n        Collection<FSMTransition> transitions = this.transitions.get(source);\r\n        if (transitions == null) {\r\n            transitions = new ArrayList<FSMTransition>();\r\n            this.transitions.put(source, transitions);\r\n        }\r\n        transitions.add(transition);\r\n        allTransitions.add(transition);\r\n    }\r\n\r\n    public FSMModel(TransitionSystem ts) {\r\n        Set<State> tsStates = ts.getNodes();\r\n        for (State state : tsStates) {\r\n            String id = removePromPrefixAndPostFix(state.toString());\r\n            if (id.length() == 0) {\r\n                //skip the \"INIT\" empty state that is added by PROM\r\n                continue;\r\n            }\r\n            FSMState fsmState = new FSMState(id);\r\n            states.put(id, fsmState);\r\n        }\r\n        Set<Transition> tsTransitions = ts.getEdges();\r\n        for (Transition transition : tsTransitions) {\r\n            String sourceId = transition.getSource().toString();\r\n            if (sourceId.length() == 0) {\r\n                //skip the \"INIT\" empty state that is added by PROM\r\n                continue;\r\n            }\r\n            sourceId = removePromPrefixAndPostFix(sourceId);\r\n            FSMState source = states.get(sourceId);\r\n            String targetId = transition.getTarget().toString();\r\n            targetId = removePromPrefixAndPostFix(targetId);\r\n            FSMState target = states.get(targetId);\r\n            FSMTransition st = new FSMTransition(source, target);\r\n            addTransition(source, st);\r\n        }\r\n    }\r\n\r\n    //removes [[ and ]] surroundings from prom state names to match then to daikon states\r\n    private String removePromPrefixAndPostFix(String stateId) {\r\n        if (stateId.equals(\"[[]]\")) {\r\n            return \"\";\r\n        }\r\n        String[] parts = stateId.split(\"\\\\[\\\\[\");\r\n        stateId = parts[1];\r\n        parts = stateId.split(\"\\\\]\\\\]\");\r\n        stateId = parts[0];\r\n        return stateId;\r\n    }\r\n\r\n    public Map<String, FSMState> getStates() {\r\n        return states;\r\n    }\r\n\r\n    public int numberOfStates() {\r\n        return states.size();\r\n    }\r\n\r\n    public int numberOfTransitions() {\r\n        return allTransitions.size();\r\n    }\r\n\r\n    public Collection<FSMTransition> getTransitionsFor(FSMState state) {\r\n        return transitions.get(state);\r\n    }\r\n\r\n    public FSMState getState(String id) {\r\n        return states.get(id);\r\n    }\r\n\r\n    public String toString() {\r\n        return \"states:\" + states.toString() + \"\\ntransitions:\" + transitions.toString();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/fsm/FSMModel_1Test.java",
		"test_prompt": "// FSMModel_1Test.java\npackage fi.vtt.noen.testgen.model.fsm;\n\nimport org.processmining.models.graphbased.directed.transitionsystem.TransitionSystem;\nimport org.processmining.models.graphbased.directed.transitionsystem.State;\nimport org.processmining.models.graphbased.directed.transitionsystem.Transition;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FSMModel}.\n* It contains ten unit test cases for the {@link FSMModel#numberOfTransitions()} method.\n*/\nclass FSMModel_1Test {"
	},
	{
		"original_code": "// DaikonState.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes invariants related to a single state (method call). These are manifested in the\r\n * generated model code as input method states without transitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonState extends DaikonModelElement {\r\n\r\n    private double min = Integer.MAX_VALUE;\r\n\r\n    private double max = Integer.MIN_VALUE;\r\n\r\n    public DaikonState(String fullName) {\r\n        super(fullName);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.parameterValues(type) != null) {\r\n                return dc.parameterValues(type);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String createGuardInvocations() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        //NOTE: this is to test better guards with only size checks\r\n        if (true)\r\n            return \"\";\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    //TODO here is a BUG, we need to map min-max to parameters now all parameter for a state share the same min-max\r\n    private void calculateMinMax(int parameterIndex) {\r\n        if (min < Integer.MAX_VALUE || max > Integer.MIN_VALUE) {\r\n            return;\r\n        }\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            double dcmin = dc.min();\r\n            if (dcmin < min) {\r\n                min = dcmin;\r\n            }\r\n            double dcmax = dc.max();\r\n            if (dcmax > max) {\r\n                max = dcmax;\r\n            }\r\n        }\r\n        if (min == Integer.MAX_VALUE) {\r\n            min = Integer.MIN_VALUE;\r\n        }\r\n        if (max == Integer.MIN_VALUE) {\r\n            max = Integer.MAX_VALUE;\r\n        }\r\n    }\r\n\r\n    public double min(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return min;\r\n    }\r\n\r\n    public double max(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return max;\r\n    }\r\n\r\n    public boolean booleanTrue(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isTrue()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean booleanFalse(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isFalse()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonState_0Test.java",
		"test_prompt": "// DaikonState_0Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonState}.\n* It contains ten unit test cases for the {@link DaikonState#parameterValues(String)} method.\n*/\nclass DaikonState_0Test {"
	},
	{
		"original_code": "// DaikonState.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes invariants related to a single state (method call). These are manifested in the\r\n * generated model code as input method states without transitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonState extends DaikonModelElement {\r\n\r\n    private double min = Integer.MAX_VALUE;\r\n\r\n    private double max = Integer.MIN_VALUE;\r\n\r\n    public DaikonState(String fullName) {\r\n        super(fullName);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.parameterValues(type) != null) {\r\n                return dc.parameterValues(type);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String createGuardInvocations() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        //NOTE: this is to test better guards with only size checks\r\n        if (true)\r\n            return \"\";\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    //TODO here is a BUG, we need to map min-max to parameters now all parameter for a state share the same min-max\r\n    private void calculateMinMax(int parameterIndex) {\r\n        if (min < Integer.MAX_VALUE || max > Integer.MIN_VALUE) {\r\n            return;\r\n        }\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            double dcmin = dc.min();\r\n            if (dcmin < min) {\r\n                min = dcmin;\r\n            }\r\n            double dcmax = dc.max();\r\n            if (dcmax > max) {\r\n                max = dcmax;\r\n            }\r\n        }\r\n        if (min == Integer.MAX_VALUE) {\r\n            min = Integer.MIN_VALUE;\r\n        }\r\n        if (max == Integer.MIN_VALUE) {\r\n            max = Integer.MAX_VALUE;\r\n        }\r\n    }\r\n\r\n    public double min(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return min;\r\n    }\r\n\r\n    public double max(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return max;\r\n    }\r\n\r\n    public boolean booleanTrue(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isTrue()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean booleanFalse(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isFalse()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonState_1Test.java",
		"test_prompt": "// DaikonState_1Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonState}.\n* It contains ten unit test cases for the {@link DaikonState#createGuardInvocations()} method.\n*/\nclass DaikonState_1Test {"
	},
	{
		"original_code": "// DaikonState.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes invariants related to a single state (method call). These are manifested in the\r\n * generated model code as input method states without transitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonState extends DaikonModelElement {\r\n\r\n    private double min = Integer.MAX_VALUE;\r\n\r\n    private double max = Integer.MIN_VALUE;\r\n\r\n    public DaikonState(String fullName) {\r\n        super(fullName);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.parameterValues(type) != null) {\r\n                return dc.parameterValues(type);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String createGuardInvocations() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        //NOTE: this is to test better guards with only size checks\r\n        if (true)\r\n            return \"\";\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    //TODO here is a BUG, we need to map min-max to parameters now all parameter for a state share the same min-max\r\n    private void calculateMinMax(int parameterIndex) {\r\n        if (min < Integer.MAX_VALUE || max > Integer.MIN_VALUE) {\r\n            return;\r\n        }\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            double dcmin = dc.min();\r\n            if (dcmin < min) {\r\n                min = dcmin;\r\n            }\r\n            double dcmax = dc.max();\r\n            if (dcmax > max) {\r\n                max = dcmax;\r\n            }\r\n        }\r\n        if (min == Integer.MAX_VALUE) {\r\n            min = Integer.MIN_VALUE;\r\n        }\r\n        if (max == Integer.MIN_VALUE) {\r\n            max = Integer.MAX_VALUE;\r\n        }\r\n    }\r\n\r\n    public double min(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return min;\r\n    }\r\n\r\n    public double max(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return max;\r\n    }\r\n\r\n    public boolean booleanTrue(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isTrue()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean booleanFalse(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isFalse()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonState_2Test.java",
		"test_prompt": "// DaikonState_2Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonState}.\n* It contains ten unit test cases for the {@link DaikonState#guardContentMethods(Set)} method.\n*/\nclass DaikonState_2Test {"
	},
	{
		"original_code": "// DaikonState.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes invariants related to a single state (method call). These are manifested in the\r\n * generated model code as input method states without transitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonState extends DaikonModelElement {\r\n\r\n    private double min = Integer.MAX_VALUE;\r\n\r\n    private double max = Integer.MIN_VALUE;\r\n\r\n    public DaikonState(String fullName) {\r\n        super(fullName);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.parameterValues(type) != null) {\r\n                return dc.parameterValues(type);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String createGuardInvocations() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        //NOTE: this is to test better guards with only size checks\r\n        if (true)\r\n            return \"\";\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    //TODO here is a BUG, we need to map min-max to parameters now all parameter for a state share the same min-max\r\n    private void calculateMinMax(int parameterIndex) {\r\n        if (min < Integer.MAX_VALUE || max > Integer.MIN_VALUE) {\r\n            return;\r\n        }\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            double dcmin = dc.min();\r\n            if (dcmin < min) {\r\n                min = dcmin;\r\n            }\r\n            double dcmax = dc.max();\r\n            if (dcmax > max) {\r\n                max = dcmax;\r\n            }\r\n        }\r\n        if (min == Integer.MAX_VALUE) {\r\n            min = Integer.MIN_VALUE;\r\n        }\r\n        if (max == Integer.MIN_VALUE) {\r\n            max = Integer.MAX_VALUE;\r\n        }\r\n    }\r\n\r\n    public double min(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return min;\r\n    }\r\n\r\n    public double max(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return max;\r\n    }\r\n\r\n    public boolean booleanTrue(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isTrue()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean booleanFalse(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isFalse()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonState_3Test.java",
		"test_prompt": "// DaikonState_3Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonState}.\n* It contains ten unit test cases for the {@link DaikonState#min(int)} method.\n*/\nclass DaikonState_3Test {"
	},
	{
		"original_code": "// DaikonState.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes invariants related to a single state (method call). These are manifested in the\r\n * generated model code as input method states without transitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonState extends DaikonModelElement {\r\n\r\n    private double min = Integer.MAX_VALUE;\r\n\r\n    private double max = Integer.MIN_VALUE;\r\n\r\n    public DaikonState(String fullName) {\r\n        super(fullName);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.parameterValues(type) != null) {\r\n                return dc.parameterValues(type);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String createGuardInvocations() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        //NOTE: this is to test better guards with only size checks\r\n        if (true)\r\n            return \"\";\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    //TODO here is a BUG, we need to map min-max to parameters now all parameter for a state share the same min-max\r\n    private void calculateMinMax(int parameterIndex) {\r\n        if (min < Integer.MAX_VALUE || max > Integer.MIN_VALUE) {\r\n            return;\r\n        }\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            double dcmin = dc.min();\r\n            if (dcmin < min) {\r\n                min = dcmin;\r\n            }\r\n            double dcmax = dc.max();\r\n            if (dcmax > max) {\r\n                max = dcmax;\r\n            }\r\n        }\r\n        if (min == Integer.MAX_VALUE) {\r\n            min = Integer.MIN_VALUE;\r\n        }\r\n        if (max == Integer.MIN_VALUE) {\r\n            max = Integer.MAX_VALUE;\r\n        }\r\n    }\r\n\r\n    public double min(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return min;\r\n    }\r\n\r\n    public double max(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return max;\r\n    }\r\n\r\n    public boolean booleanTrue(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isTrue()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean booleanFalse(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isFalse()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonState_4Test.java",
		"test_prompt": "// DaikonState_4Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonState}.\n* It contains ten unit test cases for the {@link DaikonState#max(int)} method.\n*/\nclass DaikonState_4Test {"
	},
	{
		"original_code": "// DaikonState.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes invariants related to a single state (method call). These are manifested in the\r\n * generated model code as input method states without transitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonState extends DaikonModelElement {\r\n\r\n    private double min = Integer.MAX_VALUE;\r\n\r\n    private double max = Integer.MIN_VALUE;\r\n\r\n    public DaikonState(String fullName) {\r\n        super(fullName);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.parameterValues(type) != null) {\r\n                return dc.parameterValues(type);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String createGuardInvocations() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        //NOTE: this is to test better guards with only size checks\r\n        if (true)\r\n            return \"\";\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    //TODO here is a BUG, we need to map min-max to parameters now all parameter for a state share the same min-max\r\n    private void calculateMinMax(int parameterIndex) {\r\n        if (min < Integer.MAX_VALUE || max > Integer.MIN_VALUE) {\r\n            return;\r\n        }\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            double dcmin = dc.min();\r\n            if (dcmin < min) {\r\n                min = dcmin;\r\n            }\r\n            double dcmax = dc.max();\r\n            if (dcmax > max) {\r\n                max = dcmax;\r\n            }\r\n        }\r\n        if (min == Integer.MAX_VALUE) {\r\n            min = Integer.MIN_VALUE;\r\n        }\r\n        if (max == Integer.MIN_VALUE) {\r\n            max = Integer.MAX_VALUE;\r\n        }\r\n    }\r\n\r\n    public double min(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return min;\r\n    }\r\n\r\n    public double max(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return max;\r\n    }\r\n\r\n    public boolean booleanTrue(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isTrue()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean booleanFalse(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isFalse()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonState_5Test.java",
		"test_prompt": "// DaikonState_5Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonState}.\n* It contains ten unit test cases for the {@link DaikonState#booleanTrue(int)} method.\n*/\nclass DaikonState_5Test {"
	},
	{
		"original_code": "// DaikonState.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes invariants related to a single state (method call). These are manifested in the\r\n * generated model code as input method states without transitions.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonState extends DaikonModelElement {\r\n\r\n    private double min = Integer.MAX_VALUE;\r\n\r\n    private double max = Integer.MIN_VALUE;\r\n\r\n    public DaikonState(String fullName) {\r\n        super(fullName);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.parameterValues(type) != null) {\r\n                return dc.parameterValues(type);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public String createGuardInvocations() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        //NOTE: this is to test better guards with only size checks\r\n        if (true)\r\n            return \"\";\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    //TODO here is a BUG, we need to map min-max to parameters now all parameter for a state share the same min-max\r\n    private void calculateMinMax(int parameterIndex) {\r\n        if (min < Integer.MAX_VALUE || max > Integer.MIN_VALUE) {\r\n            return;\r\n        }\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            double dcmin = dc.min();\r\n            if (dcmin < min) {\r\n                min = dcmin;\r\n            }\r\n            double dcmax = dc.max();\r\n            if (dcmax > max) {\r\n                max = dcmax;\r\n            }\r\n        }\r\n        if (min == Integer.MAX_VALUE) {\r\n            min = Integer.MIN_VALUE;\r\n        }\r\n        if (max == Integer.MIN_VALUE) {\r\n            max = Integer.MAX_VALUE;\r\n        }\r\n    }\r\n\r\n    public double min(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return min;\r\n    }\r\n\r\n    public double max(int parameterIndex) {\r\n        calculateMinMax(parameterIndex);\r\n        return max;\r\n    }\r\n\r\n    public boolean booleanTrue(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isTrue()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public boolean booleanFalse(int parameterIndex) {\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.getIndex() != parameterIndex) {\r\n                continue;\r\n            }\r\n            if (dc.isFalse()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonState_6Test.java",
		"test_prompt": "// DaikonState_6Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonState}.\n* It contains ten unit test cases for the {@link DaikonState#booleanFalse(int)} method.\n*/\nclass DaikonState_6Test {"
	},
	{
		"original_code": "// DaikonModel.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes constraints related to the states and transitions of the EFSM.\r\n * Each transition from a state is related to a set of invariants to describe when\r\n * a transition from a state is allowed to happen. Transitions also describe the\r\n * invariants related to when a transition is made from one state to another. This\r\n * is used in the geneted model to generate guards for input_output states.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonModel {\r\n\r\n    private Map<String, DaikonState> states = new HashMap<String, DaikonState>();\r\n\r\n    private Map<String, Collection<DaikonTransition>> transitions = new HashMap<String, Collection<DaikonTransition>>();\r\n\r\n    public void add(DaikonModelElement element) {\r\n        if (element instanceof DaikonState) {\r\n            add((DaikonState) element);\r\n            return;\r\n        }\r\n        add((DaikonTransition) element);\r\n    }\r\n\r\n    public void add(DaikonState state) {\r\n        String name = state.getFullName();\r\n        states.put(name, state);\r\n    }\r\n\r\n    public void add(DaikonTransition transition) {\r\n        String source = transition.getSource();\r\n        Collection<DaikonTransition> transitions = this.transitions.get(source);\r\n        if (transitions == null) {\r\n            transitions = new ArrayList<DaikonTransition>();\r\n            this.transitions.put(source, transitions);\r\n        }\r\n        transitions.add(transition);\r\n    }\r\n\r\n    public DaikonState getState(String id) {\r\n        return states.get(id);\r\n    }\r\n\r\n    public void printStates() {\r\n        System.out.println(\"states:\" + states);\r\n    }\r\n\r\n    public Collection<DaikonTransition> getTransitions(String id) {\r\n        return transitions.get(id);\r\n    }\r\n\r\n    public DaikonTransition getTransition(String source, String target) {\r\n        Collection<DaikonTransition> transitions = this.transitions.get(source);\r\n        for (Iterator<DaikonTransition> i = transitions.iterator(); i.hasNext(); ) {\r\n            DaikonTransition transition = i.next();\r\n            if (target.equals(transition.getTarget())) {\r\n                return transition;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public int numberOfStates() {\r\n        return states.size();\r\n    }\r\n\r\n    public int numberOfTransitions() {\r\n        int size = 0;\r\n        for (Iterator<String> i = transitions.keySet().iterator(); i.hasNext(); ) {\r\n            String id = i.next();\r\n            Collection<DaikonTransition> transitions = this.transitions.get(id);\r\n            size += transitions.size();\r\n        }\r\n        return size;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonModel_0Test.java",
		"test_prompt": "// DaikonModel_0Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonModel}.\n* It contains ten unit test cases for the {@link DaikonModel#numberOfStates()} method.\n*/\nclass DaikonModel_0Test {"
	},
	{
		"original_code": "// DaikonModel.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * Describes constraints related to the states and transitions of the EFSM.\r\n * Each transition from a state is related to a set of invariants to describe when\r\n * a transition from a state is allowed to happen. Transitions also describe the\r\n * invariants related to when a transition is made from one state to another. This\r\n * is used in the geneted model to generate guards for input_output states.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonModel {\r\n\r\n    private Map<String, DaikonState> states = new HashMap<String, DaikonState>();\r\n\r\n    private Map<String, Collection<DaikonTransition>> transitions = new HashMap<String, Collection<DaikonTransition>>();\r\n\r\n    public void add(DaikonModelElement element) {\r\n        if (element instanceof DaikonState) {\r\n            add((DaikonState) element);\r\n            return;\r\n        }\r\n        add((DaikonTransition) element);\r\n    }\r\n\r\n    public void add(DaikonState state) {\r\n        String name = state.getFullName();\r\n        states.put(name, state);\r\n    }\r\n\r\n    public void add(DaikonTransition transition) {\r\n        String source = transition.getSource();\r\n        Collection<DaikonTransition> transitions = this.transitions.get(source);\r\n        if (transitions == null) {\r\n            transitions = new ArrayList<DaikonTransition>();\r\n            this.transitions.put(source, transitions);\r\n        }\r\n        transitions.add(transition);\r\n    }\r\n\r\n    public DaikonState getState(String id) {\r\n        return states.get(id);\r\n    }\r\n\r\n    public void printStates() {\r\n        System.out.println(\"states:\" + states);\r\n    }\r\n\r\n    public Collection<DaikonTransition> getTransitions(String id) {\r\n        return transitions.get(id);\r\n    }\r\n\r\n    public DaikonTransition getTransition(String source, String target) {\r\n        Collection<DaikonTransition> transitions = this.transitions.get(source);\r\n        for (Iterator<DaikonTransition> i = transitions.iterator(); i.hasNext(); ) {\r\n            DaikonTransition transition = i.next();\r\n            if (target.equals(transition.getTarget())) {\r\n                return transition;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public int numberOfStates() {\r\n        return states.size();\r\n    }\r\n\r\n    public int numberOfTransitions() {\r\n        int size = 0;\r\n        for (Iterator<String> i = transitions.keySet().iterator(); i.hasNext(); ) {\r\n            String id = i.next();\r\n            Collection<DaikonTransition> transitions = this.transitions.get(id);\r\n            size += transitions.size();\r\n        }\r\n        return size;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonModel_1Test.java",
		"test_prompt": "// DaikonModel_1Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonModel}.\n* It contains ten unit test cases for the {@link DaikonModel#numberOfTransitions()} method.\n*/\nclass DaikonModel_1Test {"
	},
	{
		"original_code": "// LesserOrEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always less or equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X <= 1, where X always has a value greater than 1, and X <= Y, where the value of X always\r\n * is less or equal to that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class LesserOrEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean leftArray = false;\r\n\r\n    private boolean rightArray = false;\r\n\r\n    public LesserOrEqualConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\";\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" <= \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" <= \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotLesserOrEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/LesserOrEqualConstraint_0Test.java",
		"test_prompt": "// LesserOrEqualConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LesserOrEqualConstraint}.\n* It contains ten unit test cases for the {@link LesserOrEqualConstraint#min()} method.\n*/\nclass LesserOrEqualConstraint_0Test {"
	},
	{
		"original_code": "// LesserOrEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always less or equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X <= 1, where X always has a value greater than 1, and X <= Y, where the value of X always\r\n * is less or equal to that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class LesserOrEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean leftArray = false;\r\n\r\n    private boolean rightArray = false;\r\n\r\n    public LesserOrEqualConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\";\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" <= \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" <= \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotLesserOrEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/LesserOrEqualConstraint_1Test.java",
		"test_prompt": "// LesserOrEqualConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LesserOrEqualConstraint}.\n* It contains ten unit test cases for the {@link LesserOrEqualConstraint#max()} method.\n*/\nclass LesserOrEqualConstraint_1Test {"
	},
	{
		"original_code": "// LesserOrEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always less or equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X <= 1, where X always has a value greater than 1, and X <= Y, where the value of X always\r\n * is less or equal to that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class LesserOrEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean leftArray = false;\r\n\r\n    private boolean rightArray = false;\r\n\r\n    public LesserOrEqualConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\";\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" <= \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" <= \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotLesserOrEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/LesserOrEqualConstraint_2Test.java",
		"test_prompt": "// LesserOrEqualConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LesserOrEqualConstraint}.\n* It contains ten unit test cases for the {@link LesserOrEqualConstraint#toJava()} method.\n*/\nclass LesserOrEqualConstraint_2Test {"
	},
	{
		"original_code": "// ArrayContentsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the contents of an array object are always the same.\r\n * For example, array Clients always containst \"myclient\" and nothing else.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ArrayContentsConstraint extends DaikonConstraint {\r\n\r\n    /**\r\n     * The expected contents of the array.\r\n     */\r\n    private final Collection<String> values = new ArrayList<String>();\r\n\r\n    public ArrayContentsConstraint(String left, String right) {\r\n        //this is an array\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        right = right.trim();\r\n        System.out.println(\"left:\" + left + \" right:\" + right);\r\n        right = right.substring(0, right.length() - 1);\r\n        String[] values = right.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            System.out.println(\"empty array\");\r\n            return;\r\n        }\r\n        for (int i = 0; i < values.length; i++) {\r\n            //      this.values.add(GuardAnalyser.parseValueObject(values[i]));\r\n            this.values.add(values[i]);\r\n        }\r\n        System.out.println(\"non-empty array\" + values);\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public Collection<String> getValues() {\r\n        return values;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" == \" + values;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String list = createRequiredList(\"\");\r\n        list += \"assertEquals(\" + returnVar + \", requiredValues);\" + ln;\r\n        //    list += \"    for (Object o : requiredValues) {\"+ln;\r\n        //    list += \"      assertTrue(\"+returnVar+\".contains(o));\"+ln;\r\n        //    list += \"    };\"+ln;\r\n        return list;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String prefix = createRequiredList(\"    \");\r\n        String conditional = left.getReferredVariable() + \".equals(requiredValues)\";\r\n        String check = createCondition(conditional);\r\n        return prefix + check;\r\n    }\r\n\r\n    protected String guardName() {\r\n        String name = left.getReferredVariable() + \"IsNot\";\r\n        if (values.isEmpty()) {\r\n            return name + \"Empty\";\r\n        }\r\n        for (Object o : values) {\r\n            name += \"_\" + o;\r\n        }\r\n        return name;\r\n    }\r\n\r\n    private String createRequiredList(String prefix) {\r\n        String java = prefix + \"Collection requiredValues = new ArrayList();\" + ln;\r\n        for (String value : values) {\r\n            java += prefix + \"requiredValues.add(\\\"\" + valueObjectToGuardString(value) + \"\\\");\" + ln;\r\n        }\r\n        return java;\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        System.out.println(\"left:\" + left + \" values:\" + values);\r\n        if (values.isEmpty() || values.contains(new Integer(0))) {\r\n            return \"\";\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ArrayContentsConstraint_0Test.java",
		"test_prompt": "// ArrayContentsConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArrayContentsConstraint}.\n* It contains ten unit test cases for the {@link ArrayContentsConstraint#arrayNames()} method.\n*/\nclass ArrayContentsConstraint_0Test {"
	},
	{
		"original_code": "// ArrayContentsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the contents of an array object are always the same.\r\n * For example, array Clients always containst \"myclient\" and nothing else.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ArrayContentsConstraint extends DaikonConstraint {\r\n\r\n    /**\r\n     * The expected contents of the array.\r\n     */\r\n    private final Collection<String> values = new ArrayList<String>();\r\n\r\n    public ArrayContentsConstraint(String left, String right) {\r\n        //this is an array\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        right = right.trim();\r\n        System.out.println(\"left:\" + left + \" right:\" + right);\r\n        right = right.substring(0, right.length() - 1);\r\n        String[] values = right.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            System.out.println(\"empty array\");\r\n            return;\r\n        }\r\n        for (int i = 0; i < values.length; i++) {\r\n            //      this.values.add(GuardAnalyser.parseValueObject(values[i]));\r\n            this.values.add(values[i]);\r\n        }\r\n        System.out.println(\"non-empty array\" + values);\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public Collection<String> getValues() {\r\n        return values;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" == \" + values;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String list = createRequiredList(\"\");\r\n        list += \"assertEquals(\" + returnVar + \", requiredValues);\" + ln;\r\n        //    list += \"    for (Object o : requiredValues) {\"+ln;\r\n        //    list += \"      assertTrue(\"+returnVar+\".contains(o));\"+ln;\r\n        //    list += \"    };\"+ln;\r\n        return list;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String prefix = createRequiredList(\"    \");\r\n        String conditional = left.getReferredVariable() + \".equals(requiredValues)\";\r\n        String check = createCondition(conditional);\r\n        return prefix + check;\r\n    }\r\n\r\n    protected String guardName() {\r\n        String name = left.getReferredVariable() + \"IsNot\";\r\n        if (values.isEmpty()) {\r\n            return name + \"Empty\";\r\n        }\r\n        for (Object o : values) {\r\n            name += \"_\" + o;\r\n        }\r\n        return name;\r\n    }\r\n\r\n    private String createRequiredList(String prefix) {\r\n        String java = prefix + \"Collection requiredValues = new ArrayList();\" + ln;\r\n        for (String value : values) {\r\n            java += prefix + \"requiredValues.add(\\\"\" + valueObjectToGuardString(value) + \"\\\");\" + ln;\r\n        }\r\n        return java;\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        System.out.println(\"left:\" + left + \" values:\" + values);\r\n        if (values.isEmpty() || values.contains(new Integer(0))) {\r\n            return \"\";\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ArrayContentsConstraint_1Test.java",
		"test_prompt": "// ArrayContentsConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArrayContentsConstraint}.\n* It contains ten unit test cases for the {@link ArrayContentsConstraint#asAssert(String)} method.\n*/\nclass ArrayContentsConstraint_1Test {"
	},
	{
		"original_code": "// ArrayContentsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the contents of an array object are always the same.\r\n * For example, array Clients always containst \"myclient\" and nothing else.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ArrayContentsConstraint extends DaikonConstraint {\r\n\r\n    /**\r\n     * The expected contents of the array.\r\n     */\r\n    private final Collection<String> values = new ArrayList<String>();\r\n\r\n    public ArrayContentsConstraint(String left, String right) {\r\n        //this is an array\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        right = right.trim();\r\n        System.out.println(\"left:\" + left + \" right:\" + right);\r\n        right = right.substring(0, right.length() - 1);\r\n        String[] values = right.split(\", \");\r\n        if (values[0].length() == 0) {\r\n            //skip empty arrays\r\n            System.out.println(\"empty array\");\r\n            return;\r\n        }\r\n        for (int i = 0; i < values.length; i++) {\r\n            //      this.values.add(GuardAnalyser.parseValueObject(values[i]));\r\n            this.values.add(values[i]);\r\n        }\r\n        System.out.println(\"non-empty array\" + values);\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public Collection<String> getValues() {\r\n        return values;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" == \" + values;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String list = createRequiredList(\"\");\r\n        list += \"assertEquals(\" + returnVar + \", requiredValues);\" + ln;\r\n        //    list += \"    for (Object o : requiredValues) {\"+ln;\r\n        //    list += \"      assertTrue(\"+returnVar+\".contains(o));\"+ln;\r\n        //    list += \"    };\"+ln;\r\n        return list;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String prefix = createRequiredList(\"    \");\r\n        String conditional = left.getReferredVariable() + \".equals(requiredValues)\";\r\n        String check = createCondition(conditional);\r\n        return prefix + check;\r\n    }\r\n\r\n    protected String guardName() {\r\n        String name = left.getReferredVariable() + \"IsNot\";\r\n        if (values.isEmpty()) {\r\n            return name + \"Empty\";\r\n        }\r\n        for (Object o : values) {\r\n            name += \"_\" + o;\r\n        }\r\n        return name;\r\n    }\r\n\r\n    private String createRequiredList(String prefix) {\r\n        String java = prefix + \"Collection requiredValues = new ArrayList();\" + ln;\r\n        for (String value : values) {\r\n            java += prefix + \"requiredValues.add(\\\"\" + valueObjectToGuardString(value) + \"\\\");\" + ln;\r\n        }\r\n        return java;\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        System.out.println(\"left:\" + left + \" values:\" + values);\r\n        if (values.isEmpty() || values.contains(new Integer(0))) {\r\n            return \"\";\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ArrayContentsConstraint_2Test.java",
		"test_prompt": "// ArrayContentsConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArrayContentsConstraint}.\n* It contains ten unit test cases for the {@link ArrayContentsConstraint#guardInvocation()} method.\n*/\nclass ArrayContentsConstraint_2Test {"
	},
	{
		"original_code": "// OneOfConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * This invariant says that the contents of a variable are always one of a given set of constant values.\r\n * For example, it may say that the value of Client is always either \"myclient\" or \"myclient2\".\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class OneOfConstraint extends DaikonConstraint {\r\n\r\n    private final Collection values = new ArrayList();\r\n\r\n    private boolean elements = false;\r\n\r\n    public OneOfConstraint(String left, String value) {\r\n        //always trim since } can have whitespace, linefeeds etc trailing\r\n        left = left.trim();\r\n        if (left.contains(\"elements\")) {\r\n            elements = true;\r\n            left = left.substring(0, left.indexOf(\"elements\")).trim();\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //we need to remove the } in the end\r\n        value = value.substring(0, value.length() - 1);\r\n        //if there is ] then it is a list of lists\r\n        String[] valueArray = value.split(\"\\\\],\");\r\n        if (valueArray.length > 1) {\r\n            addArrays(valueArray);\r\n        } else {\r\n            values.addAll(DaikonParser.parseObjectList(value));\r\n        }\r\n    }\r\n\r\n    private void addArrays(String[] arrays) {\r\n        for (String array : arrays) {\r\n            array = array.trim();\r\n            //remove \"[\" from start, \"],\" from end was removed by split earlier\r\n            array = array.substring(1, array.length());\r\n            if (array.endsWith(\"]\")) {\r\n                //for the last item there is no \"],\" so we need to remove \"]\" separately\r\n                array = array.substring(0, array.length() - 1);\r\n            }\r\n            values.add(DaikonParser.parseObjectList(array));\r\n        }\r\n    }\r\n\r\n    public double min() {\r\n        double min = super.min();\r\n        for (Object o : values) {\r\n            if (o instanceof Number) {\r\n                Number n = (Number) o;\r\n                if (n.doubleValue() < min) {\r\n                    min = n.doubleValue();\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n    public double max() {\r\n        double max = super.max();\r\n        for (Object o : values) {\r\n            if (o instanceof Number) {\r\n                Number n = (Number) o;\r\n                if (n.doubleValue() > max) {\r\n                    max = n.doubleValue();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String assertion = createValidValuesJava(\"\");\r\n        if (elements) {\r\n            assertion += \"for (Object o : \" + returnVar + \") {\" + ln;\r\n            assertion += \"  assertTrue(validValues.contains(o));\" + ln;\r\n            assertion += \"}\" + ln;\r\n        } else {\r\n            assertion += \"assertTrue(validValues.contains(\" + returnVar + \"));\" + ln;\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    public String toString() {\r\n        String values = \"{\";\r\n        for (Iterator i = this.values.iterator(); i.hasNext(); ) {\r\n            Object obj = i.next();\r\n            if (obj instanceof Collection) {\r\n                values += obj;\r\n            } else {\r\n                values += valueObjectToString(obj);\r\n            }\r\n            if (i.hasNext()) {\r\n                values += \",\";\r\n            } else {\r\n                values += \"}\";\r\n            }\r\n        }\r\n        String item = left.toString();\r\n        if (elements) {\r\n            item += \" elements\";\r\n        }\r\n        return item + \" one of \" + values;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String java = createValidValuesJava(\"    \");\r\n        if (elements) {\r\n            java += \"    for (Object o : \" + left.getReferredVariable() + \") {\" + ln;\r\n            java += createCondition(\"validValues.contains(o)\");\r\n            java += \"    }\" + ln;\r\n            return java;\r\n        } else {\r\n            String check = createCondition(\"validValues.contains(\" + left.getReferredVariable() + \")\");\r\n            return java + check;\r\n        }\r\n    }\r\n\r\n    private String createValidValuesJava(String prefix) {\r\n        String top = prefix + \"HashSet validValues = new HashSet();\" + ln;\r\n        String topAdd = \"\";\r\n        String java = \"\";\r\n        for (Object value : values) {\r\n            if (value instanceof Collection) {\r\n                topAdd = prefix + \"Collection value = new ArrayList();\" + ln;\r\n                java += prefix + \"value = new ArrayList();\" + ln;\r\n                Collection vc = (Collection) value;\r\n                for (Object v : vc) {\r\n                    java += prefix + \"value.add(\" + valueObjectToString(v) + \");\" + ln;\r\n                }\r\n                java += prefix + \"validValues.add(value);\" + ln;\r\n            } else {\r\n                java += prefix + \"validValues.add(\" + valueObjectToString(value) + \");\" + ln;\r\n            }\r\n        }\r\n        return top + topAdd + java;\r\n    }\r\n\r\n    protected String guardName() {\r\n        String valueStr = \"\";\r\n        for (Object value : values) {\r\n            if (value instanceof Collection) {\r\n                Collection values2 = (Collection) value;\r\n                for (Object value2 : values2) {\r\n                    valueStr += \"_\" + valueObjectToGuardString(value2) + \"_\";\r\n                }\r\n                continue;\r\n            }\r\n            valueStr += \"_\" + valueObjectToGuardString(value) + \"_\";\r\n        }\r\n        return left.getReferredVariable() + \"NotOneOf\" + valueStr;\r\n    }\r\n\r\n    /*\r\n  public String guardInvocation() {\r\n//    System.out.println(\"values:\"+values);\r\n    for (Object o : values) {\r\n      if (o instanceof Number) {\r\n        if (((Number)o).intValue() == 0) {\r\n//          System.out.println(\"c1\");\r\n          return \"\";\r\n        }\r\n      } else {\r\n//        System.out.println(\"c2\");\r\n        return \"\";\r\n      }\r\n    }\r\n    return \"    if(\"+left.getReferredVariable()+\".isEmpty()) return false;\"+ln;\r\n  }*/\r\n    public String guardInvocation() {\r\n        if (elements) {\r\n            return \"\";\r\n        }\r\n        if (values.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        for (Object v : values) {\r\n            if (v instanceof Collection && ((Collection) v).isEmpty()) {\r\n                return \"\";\r\n            }\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/OneOfConstraint_0Test.java",
		"test_prompt": "// OneOfConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OneOfConstraint}.\n* It contains ten unit test cases for the {@link OneOfConstraint#min()} method.\n*/\nclass OneOfConstraint_0Test {"
	},
	{
		"original_code": "// OneOfConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * This invariant says that the contents of a variable are always one of a given set of constant values.\r\n * For example, it may say that the value of Client is always either \"myclient\" or \"myclient2\".\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class OneOfConstraint extends DaikonConstraint {\r\n\r\n    private final Collection values = new ArrayList();\r\n\r\n    private boolean elements = false;\r\n\r\n    public OneOfConstraint(String left, String value) {\r\n        //always trim since } can have whitespace, linefeeds etc trailing\r\n        left = left.trim();\r\n        if (left.contains(\"elements\")) {\r\n            elements = true;\r\n            left = left.substring(0, left.indexOf(\"elements\")).trim();\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //we need to remove the } in the end\r\n        value = value.substring(0, value.length() - 1);\r\n        //if there is ] then it is a list of lists\r\n        String[] valueArray = value.split(\"\\\\],\");\r\n        if (valueArray.length > 1) {\r\n            addArrays(valueArray);\r\n        } else {\r\n            values.addAll(DaikonParser.parseObjectList(value));\r\n        }\r\n    }\r\n\r\n    private void addArrays(String[] arrays) {\r\n        for (String array : arrays) {\r\n            array = array.trim();\r\n            //remove \"[\" from start, \"],\" from end was removed by split earlier\r\n            array = array.substring(1, array.length());\r\n            if (array.endsWith(\"]\")) {\r\n                //for the last item there is no \"],\" so we need to remove \"]\" separately\r\n                array = array.substring(0, array.length() - 1);\r\n            }\r\n            values.add(DaikonParser.parseObjectList(array));\r\n        }\r\n    }\r\n\r\n    public double min() {\r\n        double min = super.min();\r\n        for (Object o : values) {\r\n            if (o instanceof Number) {\r\n                Number n = (Number) o;\r\n                if (n.doubleValue() < min) {\r\n                    min = n.doubleValue();\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n    public double max() {\r\n        double max = super.max();\r\n        for (Object o : values) {\r\n            if (o instanceof Number) {\r\n                Number n = (Number) o;\r\n                if (n.doubleValue() > max) {\r\n                    max = n.doubleValue();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String assertion = createValidValuesJava(\"\");\r\n        if (elements) {\r\n            assertion += \"for (Object o : \" + returnVar + \") {\" + ln;\r\n            assertion += \"  assertTrue(validValues.contains(o));\" + ln;\r\n            assertion += \"}\" + ln;\r\n        } else {\r\n            assertion += \"assertTrue(validValues.contains(\" + returnVar + \"));\" + ln;\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    public String toString() {\r\n        String values = \"{\";\r\n        for (Iterator i = this.values.iterator(); i.hasNext(); ) {\r\n            Object obj = i.next();\r\n            if (obj instanceof Collection) {\r\n                values += obj;\r\n            } else {\r\n                values += valueObjectToString(obj);\r\n            }\r\n            if (i.hasNext()) {\r\n                values += \",\";\r\n            } else {\r\n                values += \"}\";\r\n            }\r\n        }\r\n        String item = left.toString();\r\n        if (elements) {\r\n            item += \" elements\";\r\n        }\r\n        return item + \" one of \" + values;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String java = createValidValuesJava(\"    \");\r\n        if (elements) {\r\n            java += \"    for (Object o : \" + left.getReferredVariable() + \") {\" + ln;\r\n            java += createCondition(\"validValues.contains(o)\");\r\n            java += \"    }\" + ln;\r\n            return java;\r\n        } else {\r\n            String check = createCondition(\"validValues.contains(\" + left.getReferredVariable() + \")\");\r\n            return java + check;\r\n        }\r\n    }\r\n\r\n    private String createValidValuesJava(String prefix) {\r\n        String top = prefix + \"HashSet validValues = new HashSet();\" + ln;\r\n        String topAdd = \"\";\r\n        String java = \"\";\r\n        for (Object value : values) {\r\n            if (value instanceof Collection) {\r\n                topAdd = prefix + \"Collection value = new ArrayList();\" + ln;\r\n                java += prefix + \"value = new ArrayList();\" + ln;\r\n                Collection vc = (Collection) value;\r\n                for (Object v : vc) {\r\n                    java += prefix + \"value.add(\" + valueObjectToString(v) + \");\" + ln;\r\n                }\r\n                java += prefix + \"validValues.add(value);\" + ln;\r\n            } else {\r\n                java += prefix + \"validValues.add(\" + valueObjectToString(value) + \");\" + ln;\r\n            }\r\n        }\r\n        return top + topAdd + java;\r\n    }\r\n\r\n    protected String guardName() {\r\n        String valueStr = \"\";\r\n        for (Object value : values) {\r\n            if (value instanceof Collection) {\r\n                Collection values2 = (Collection) value;\r\n                for (Object value2 : values2) {\r\n                    valueStr += \"_\" + valueObjectToGuardString(value2) + \"_\";\r\n                }\r\n                continue;\r\n            }\r\n            valueStr += \"_\" + valueObjectToGuardString(value) + \"_\";\r\n        }\r\n        return left.getReferredVariable() + \"NotOneOf\" + valueStr;\r\n    }\r\n\r\n    /*\r\n  public String guardInvocation() {\r\n//    System.out.println(\"values:\"+values);\r\n    for (Object o : values) {\r\n      if (o instanceof Number) {\r\n        if (((Number)o).intValue() == 0) {\r\n//          System.out.println(\"c1\");\r\n          return \"\";\r\n        }\r\n      } else {\r\n//        System.out.println(\"c2\");\r\n        return \"\";\r\n      }\r\n    }\r\n    return \"    if(\"+left.getReferredVariable()+\".isEmpty()) return false;\"+ln;\r\n  }*/\r\n    public String guardInvocation() {\r\n        if (elements) {\r\n            return \"\";\r\n        }\r\n        if (values.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        for (Object v : values) {\r\n            if (v instanceof Collection && ((Collection) v).isEmpty()) {\r\n                return \"\";\r\n            }\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/OneOfConstraint_1Test.java",
		"test_prompt": "// OneOfConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OneOfConstraint}.\n* It contains ten unit test cases for the {@link OneOfConstraint#max()} method.\n*/\nclass OneOfConstraint_1Test {"
	},
	{
		"original_code": "// OneOfConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * This invariant says that the contents of a variable are always one of a given set of constant values.\r\n * For example, it may say that the value of Client is always either \"myclient\" or \"myclient2\".\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class OneOfConstraint extends DaikonConstraint {\r\n\r\n    private final Collection values = new ArrayList();\r\n\r\n    private boolean elements = false;\r\n\r\n    public OneOfConstraint(String left, String value) {\r\n        //always trim since } can have whitespace, linefeeds etc trailing\r\n        left = left.trim();\r\n        if (left.contains(\"elements\")) {\r\n            elements = true;\r\n            left = left.substring(0, left.indexOf(\"elements\")).trim();\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //we need to remove the } in the end\r\n        value = value.substring(0, value.length() - 1);\r\n        //if there is ] then it is a list of lists\r\n        String[] valueArray = value.split(\"\\\\],\");\r\n        if (valueArray.length > 1) {\r\n            addArrays(valueArray);\r\n        } else {\r\n            values.addAll(DaikonParser.parseObjectList(value));\r\n        }\r\n    }\r\n\r\n    private void addArrays(String[] arrays) {\r\n        for (String array : arrays) {\r\n            array = array.trim();\r\n            //remove \"[\" from start, \"],\" from end was removed by split earlier\r\n            array = array.substring(1, array.length());\r\n            if (array.endsWith(\"]\")) {\r\n                //for the last item there is no \"],\" so we need to remove \"]\" separately\r\n                array = array.substring(0, array.length() - 1);\r\n            }\r\n            values.add(DaikonParser.parseObjectList(array));\r\n        }\r\n    }\r\n\r\n    public double min() {\r\n        double min = super.min();\r\n        for (Object o : values) {\r\n            if (o instanceof Number) {\r\n                Number n = (Number) o;\r\n                if (n.doubleValue() < min) {\r\n                    min = n.doubleValue();\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n    public double max() {\r\n        double max = super.max();\r\n        for (Object o : values) {\r\n            if (o instanceof Number) {\r\n                Number n = (Number) o;\r\n                if (n.doubleValue() > max) {\r\n                    max = n.doubleValue();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String assertion = createValidValuesJava(\"\");\r\n        if (elements) {\r\n            assertion += \"for (Object o : \" + returnVar + \") {\" + ln;\r\n            assertion += \"  assertTrue(validValues.contains(o));\" + ln;\r\n            assertion += \"}\" + ln;\r\n        } else {\r\n            assertion += \"assertTrue(validValues.contains(\" + returnVar + \"));\" + ln;\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    public String toString() {\r\n        String values = \"{\";\r\n        for (Iterator i = this.values.iterator(); i.hasNext(); ) {\r\n            Object obj = i.next();\r\n            if (obj instanceof Collection) {\r\n                values += obj;\r\n            } else {\r\n                values += valueObjectToString(obj);\r\n            }\r\n            if (i.hasNext()) {\r\n                values += \",\";\r\n            } else {\r\n                values += \"}\";\r\n            }\r\n        }\r\n        String item = left.toString();\r\n        if (elements) {\r\n            item += \" elements\";\r\n        }\r\n        return item + \" one of \" + values;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String java = createValidValuesJava(\"    \");\r\n        if (elements) {\r\n            java += \"    for (Object o : \" + left.getReferredVariable() + \") {\" + ln;\r\n            java += createCondition(\"validValues.contains(o)\");\r\n            java += \"    }\" + ln;\r\n            return java;\r\n        } else {\r\n            String check = createCondition(\"validValues.contains(\" + left.getReferredVariable() + \")\");\r\n            return java + check;\r\n        }\r\n    }\r\n\r\n    private String createValidValuesJava(String prefix) {\r\n        String top = prefix + \"HashSet validValues = new HashSet();\" + ln;\r\n        String topAdd = \"\";\r\n        String java = \"\";\r\n        for (Object value : values) {\r\n            if (value instanceof Collection) {\r\n                topAdd = prefix + \"Collection value = new ArrayList();\" + ln;\r\n                java += prefix + \"value = new ArrayList();\" + ln;\r\n                Collection vc = (Collection) value;\r\n                for (Object v : vc) {\r\n                    java += prefix + \"value.add(\" + valueObjectToString(v) + \");\" + ln;\r\n                }\r\n                java += prefix + \"validValues.add(value);\" + ln;\r\n            } else {\r\n                java += prefix + \"validValues.add(\" + valueObjectToString(value) + \");\" + ln;\r\n            }\r\n        }\r\n        return top + topAdd + java;\r\n    }\r\n\r\n    protected String guardName() {\r\n        String valueStr = \"\";\r\n        for (Object value : values) {\r\n            if (value instanceof Collection) {\r\n                Collection values2 = (Collection) value;\r\n                for (Object value2 : values2) {\r\n                    valueStr += \"_\" + valueObjectToGuardString(value2) + \"_\";\r\n                }\r\n                continue;\r\n            }\r\n            valueStr += \"_\" + valueObjectToGuardString(value) + \"_\";\r\n        }\r\n        return left.getReferredVariable() + \"NotOneOf\" + valueStr;\r\n    }\r\n\r\n    /*\r\n  public String guardInvocation() {\r\n//    System.out.println(\"values:\"+values);\r\n    for (Object o : values) {\r\n      if (o instanceof Number) {\r\n        if (((Number)o).intValue() == 0) {\r\n//          System.out.println(\"c1\");\r\n          return \"\";\r\n        }\r\n      } else {\r\n//        System.out.println(\"c2\");\r\n        return \"\";\r\n      }\r\n    }\r\n    return \"    if(\"+left.getReferredVariable()+\".isEmpty()) return false;\"+ln;\r\n  }*/\r\n    public String guardInvocation() {\r\n        if (elements) {\r\n            return \"\";\r\n        }\r\n        if (values.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        for (Object v : values) {\r\n            if (v instanceof Collection && ((Collection) v).isEmpty()) {\r\n                return \"\";\r\n            }\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/OneOfConstraint_2Test.java",
		"test_prompt": "// OneOfConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OneOfConstraint}.\n* It contains ten unit test cases for the {@link OneOfConstraint#asAssert(String)} method.\n*/\nclass OneOfConstraint_2Test {"
	},
	{
		"original_code": "// OneOfConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Iterator;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * This invariant says that the contents of a variable are always one of a given set of constant values.\r\n * For example, it may say that the value of Client is always either \"myclient\" or \"myclient2\".\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class OneOfConstraint extends DaikonConstraint {\r\n\r\n    private final Collection values = new ArrayList();\r\n\r\n    private boolean elements = false;\r\n\r\n    public OneOfConstraint(String left, String value) {\r\n        //always trim since } can have whitespace, linefeeds etc trailing\r\n        left = left.trim();\r\n        if (left.contains(\"elements\")) {\r\n            elements = true;\r\n            left = left.substring(0, left.indexOf(\"elements\")).trim();\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //we need to remove the } in the end\r\n        value = value.substring(0, value.length() - 1);\r\n        //if there is ] then it is a list of lists\r\n        String[] valueArray = value.split(\"\\\\],\");\r\n        if (valueArray.length > 1) {\r\n            addArrays(valueArray);\r\n        } else {\r\n            values.addAll(DaikonParser.parseObjectList(value));\r\n        }\r\n    }\r\n\r\n    private void addArrays(String[] arrays) {\r\n        for (String array : arrays) {\r\n            array = array.trim();\r\n            //remove \"[\" from start, \"],\" from end was removed by split earlier\r\n            array = array.substring(1, array.length());\r\n            if (array.endsWith(\"]\")) {\r\n                //for the last item there is no \"],\" so we need to remove \"]\" separately\r\n                array = array.substring(0, array.length() - 1);\r\n            }\r\n            values.add(DaikonParser.parseObjectList(array));\r\n        }\r\n    }\r\n\r\n    public double min() {\r\n        double min = super.min();\r\n        for (Object o : values) {\r\n            if (o instanceof Number) {\r\n                Number n = (Number) o;\r\n                if (n.doubleValue() < min) {\r\n                    min = n.doubleValue();\r\n                }\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n    public double max() {\r\n        double max = super.max();\r\n        for (Object o : values) {\r\n            if (o instanceof Number) {\r\n                Number n = (Number) o;\r\n                if (n.doubleValue() > max) {\r\n                    max = n.doubleValue();\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String assertion = createValidValuesJava(\"\");\r\n        if (elements) {\r\n            assertion += \"for (Object o : \" + returnVar + \") {\" + ln;\r\n            assertion += \"  assertTrue(validValues.contains(o));\" + ln;\r\n            assertion += \"}\" + ln;\r\n        } else {\r\n            assertion += \"assertTrue(validValues.contains(\" + returnVar + \"));\" + ln;\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    public String toString() {\r\n        String values = \"{\";\r\n        for (Iterator i = this.values.iterator(); i.hasNext(); ) {\r\n            Object obj = i.next();\r\n            if (obj instanceof Collection) {\r\n                values += obj;\r\n            } else {\r\n                values += valueObjectToString(obj);\r\n            }\r\n            if (i.hasNext()) {\r\n                values += \",\";\r\n            } else {\r\n                values += \"}\";\r\n            }\r\n        }\r\n        String item = left.toString();\r\n        if (elements) {\r\n            item += \" elements\";\r\n        }\r\n        return item + \" one of \" + values;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String java = createValidValuesJava(\"    \");\r\n        if (elements) {\r\n            java += \"    for (Object o : \" + left.getReferredVariable() + \") {\" + ln;\r\n            java += createCondition(\"validValues.contains(o)\");\r\n            java += \"    }\" + ln;\r\n            return java;\r\n        } else {\r\n            String check = createCondition(\"validValues.contains(\" + left.getReferredVariable() + \")\");\r\n            return java + check;\r\n        }\r\n    }\r\n\r\n    private String createValidValuesJava(String prefix) {\r\n        String top = prefix + \"HashSet validValues = new HashSet();\" + ln;\r\n        String topAdd = \"\";\r\n        String java = \"\";\r\n        for (Object value : values) {\r\n            if (value instanceof Collection) {\r\n                topAdd = prefix + \"Collection value = new ArrayList();\" + ln;\r\n                java += prefix + \"value = new ArrayList();\" + ln;\r\n                Collection vc = (Collection) value;\r\n                for (Object v : vc) {\r\n                    java += prefix + \"value.add(\" + valueObjectToString(v) + \");\" + ln;\r\n                }\r\n                java += prefix + \"validValues.add(value);\" + ln;\r\n            } else {\r\n                java += prefix + \"validValues.add(\" + valueObjectToString(value) + \");\" + ln;\r\n            }\r\n        }\r\n        return top + topAdd + java;\r\n    }\r\n\r\n    protected String guardName() {\r\n        String valueStr = \"\";\r\n        for (Object value : values) {\r\n            if (value instanceof Collection) {\r\n                Collection values2 = (Collection) value;\r\n                for (Object value2 : values2) {\r\n                    valueStr += \"_\" + valueObjectToGuardString(value2) + \"_\";\r\n                }\r\n                continue;\r\n            }\r\n            valueStr += \"_\" + valueObjectToGuardString(value) + \"_\";\r\n        }\r\n        return left.getReferredVariable() + \"NotOneOf\" + valueStr;\r\n    }\r\n\r\n    /*\r\n  public String guardInvocation() {\r\n//    System.out.println(\"values:\"+values);\r\n    for (Object o : values) {\r\n      if (o instanceof Number) {\r\n        if (((Number)o).intValue() == 0) {\r\n//          System.out.println(\"c1\");\r\n          return \"\";\r\n        }\r\n      } else {\r\n//        System.out.println(\"c2\");\r\n        return \"\";\r\n      }\r\n    }\r\n    return \"    if(\"+left.getReferredVariable()+\".isEmpty()) return false;\"+ln;\r\n  }*/\r\n    public String guardInvocation() {\r\n        if (elements) {\r\n            return \"\";\r\n        }\r\n        if (values.isEmpty()) {\r\n            return \"\";\r\n        }\r\n        for (Object v : values) {\r\n            if (v instanceof Collection && ((Collection) v).isEmpty()) {\r\n                return \"\";\r\n            }\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/OneOfConstraint_3Test.java",
		"test_prompt": "// OneOfConstraint_3Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OneOfConstraint}.\n* It contains ten unit test cases for the {@link OneOfConstraint#guardInvocation()} method.\n*/\nclass OneOfConstraint_3Test {"
	},
	{
		"original_code": "// SizeOfConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the size of an array variable is always constant, while its contents may change.\r\n * For example, Clients size is always 1 or Clients size is always x+1, where x may be any other variable\r\n * at that point of execution.\r\n * TODO: what is the difference with constantsizeconstraint? ->> apparently this is not supported,the other is\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class SizeOfConstraint extends ConstraintWithAddition {\r\n\r\n    public SizeOfConstraint(String left, String right) {\r\n        //    System.out.println(\"left:\"+left+\" right:\"+right);\r\n        left = left.trim();\r\n        left = parseAddition(left, true);\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        right = right.trim();\r\n        right = parseAddition(right, false);\r\n        //this is an array\r\n        //remove last )\r\n        right = right.substring(0, right.length() - 1);\r\n        this.right = (ReferenceValue) DaikonParser.parseValueObject(right);\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        String lstr = left.toString();\r\n        String rstr = \"sizeof(\" + right + \")\";\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" == \" + rstr;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        //this throws but we dont currently support this type of assert anyway\r\n        return super.asAssert(returnVar);\r\n    }\r\n\r\n    public String toJava() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String lstr = value.getReferredVariable() + \".size()\" + additionToString(false);\r\n        String rstr = left.getReferredVariable() + additionToString(true);\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" == \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        return value.getReferredVariable() + \"SizeDoesNotEqual\" + left.getReferredVariable();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/SizeOfConstraint_0Test.java",
		"test_prompt": "// SizeOfConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SizeOfConstraint}.\n* It contains ten unit test cases for the {@link SizeOfConstraint#arrayNames()} method.\n*/\nclass SizeOfConstraint_0Test {"
	},
	{
		"original_code": "// SizeOfConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the size of an array variable is always constant, while its contents may change.\r\n * For example, Clients size is always 1 or Clients size is always x+1, where x may be any other variable\r\n * at that point of execution.\r\n * TODO: what is the difference with constantsizeconstraint? ->> apparently this is not supported,the other is\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class SizeOfConstraint extends ConstraintWithAddition {\r\n\r\n    public SizeOfConstraint(String left, String right) {\r\n        //    System.out.println(\"left:\"+left+\" right:\"+right);\r\n        left = left.trim();\r\n        left = parseAddition(left, true);\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        right = right.trim();\r\n        right = parseAddition(right, false);\r\n        //this is an array\r\n        //remove last )\r\n        right = right.substring(0, right.length() - 1);\r\n        this.right = (ReferenceValue) DaikonParser.parseValueObject(right);\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        String lstr = left.toString();\r\n        String rstr = \"sizeof(\" + right + \")\";\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" == \" + rstr;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        //this throws but we dont currently support this type of assert anyway\r\n        return super.asAssert(returnVar);\r\n    }\r\n\r\n    public String toJava() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String lstr = value.getReferredVariable() + \".size()\" + additionToString(false);\r\n        String rstr = left.getReferredVariable() + additionToString(true);\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" == \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        return value.getReferredVariable() + \"SizeDoesNotEqual\" + left.getReferredVariable();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/SizeOfConstraint_1Test.java",
		"test_prompt": "// SizeOfConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SizeOfConstraint}.\n* It contains ten unit test cases for the {@link SizeOfConstraint#asAssert(String)} method.\n*/\nclass SizeOfConstraint_1Test {"
	},
	{
		"original_code": "// SizeOfConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the size of an array variable is always constant, while its contents may change.\r\n * For example, Clients size is always 1 or Clients size is always x+1, where x may be any other variable\r\n * at that point of execution.\r\n * TODO: what is the difference with constantsizeconstraint? ->> apparently this is not supported,the other is\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class SizeOfConstraint extends ConstraintWithAddition {\r\n\r\n    public SizeOfConstraint(String left, String right) {\r\n        //    System.out.println(\"left:\"+left+\" right:\"+right);\r\n        left = left.trim();\r\n        left = parseAddition(left, true);\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        right = right.trim();\r\n        right = parseAddition(right, false);\r\n        //this is an array\r\n        //remove last )\r\n        right = right.substring(0, right.length() - 1);\r\n        this.right = (ReferenceValue) DaikonParser.parseValueObject(right);\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        String lstr = left.toString();\r\n        String rstr = \"sizeof(\" + right + \")\";\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" == \" + rstr;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        //this throws but we dont currently support this type of assert anyway\r\n        return super.asAssert(returnVar);\r\n    }\r\n\r\n    public String toJava() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String lstr = value.getReferredVariable() + \".size()\" + additionToString(false);\r\n        String rstr = left.getReferredVariable() + additionToString(true);\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" == \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        return value.getReferredVariable() + \"SizeDoesNotEqual\" + left.getReferredVariable();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/SizeOfConstraint_2Test.java",
		"test_prompt": "// SizeOfConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SizeOfConstraint}.\n* It contains ten unit test cases for the {@link SizeOfConstraint#toJava()} method.\n*/\nclass SizeOfConstraint_2Test {"
	},
	{
		"original_code": "// EqualsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * An invariant that says the contents of a variable always match a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X = 1, where X always has the value of 1, and X = Y, where the contents of X always\r\n * match the contents of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EqualsConstraint extends DaikonConstraint {\r\n\r\n    public EqualsConstraint(String left, String value) {\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" == \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        /*    String expected = valueObjectToString(value);\r\n    String assertion = \"\";\r\n    if (value instanceof ReferenceValue) {\r\n      assertion += \"String expected = create\"+left.getReferredVariable()+\"For(\"+valueObjectToString(value)+\");\"+ln;\r\n      expected = \"expected\";\r\n    }\r\n    assertion += \"assertEquals(\"+expected+\", \"+returnVar+\");\"+ln;\r\n    */\r\n        return \"assertEquals(\" + valueObjectToString(right) + \", \" + returnVar + \");\" + ln;\r\n    }\r\n\r\n    /*  public Collection<String> getAssertObjectValues() {\r\n    if (value instanceof ReferenceValue) {\r\n      Collection<String> result = new ArrayList<String>();\r\n      result.add(valueObjectToString(value));\r\n      return result;\r\n    }\r\n    return Collections.EMPTY_LIST;\r\n  }*/\r\n    public String toJava() {\r\n        return createCondition(left.getReferredVariable() + \".equals(\" + valueObjectToString(right) + \")\");\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"DoesNotEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/EqualsConstraint_0Test.java",
		"test_prompt": "// EqualsConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EqualsConstraint}.\n* It contains ten unit test cases for the {@link EqualsConstraint#min()} method.\n*/\nclass EqualsConstraint_0Test {"
	},
	{
		"original_code": "// EqualsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * An invariant that says the contents of a variable always match a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X = 1, where X always has the value of 1, and X = Y, where the contents of X always\r\n * match the contents of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EqualsConstraint extends DaikonConstraint {\r\n\r\n    public EqualsConstraint(String left, String value) {\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" == \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        /*    String expected = valueObjectToString(value);\r\n    String assertion = \"\";\r\n    if (value instanceof ReferenceValue) {\r\n      assertion += \"String expected = create\"+left.getReferredVariable()+\"For(\"+valueObjectToString(value)+\");\"+ln;\r\n      expected = \"expected\";\r\n    }\r\n    assertion += \"assertEquals(\"+expected+\", \"+returnVar+\");\"+ln;\r\n    */\r\n        return \"assertEquals(\" + valueObjectToString(right) + \", \" + returnVar + \");\" + ln;\r\n    }\r\n\r\n    /*  public Collection<String> getAssertObjectValues() {\r\n    if (value instanceof ReferenceValue) {\r\n      Collection<String> result = new ArrayList<String>();\r\n      result.add(valueObjectToString(value));\r\n      return result;\r\n    }\r\n    return Collections.EMPTY_LIST;\r\n  }*/\r\n    public String toJava() {\r\n        return createCondition(left.getReferredVariable() + \".equals(\" + valueObjectToString(right) + \")\");\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"DoesNotEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/EqualsConstraint_1Test.java",
		"test_prompt": "// EqualsConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EqualsConstraint}.\n* It contains ten unit test cases for the {@link EqualsConstraint#max()} method.\n*/\nclass EqualsConstraint_1Test {"
	},
	{
		"original_code": "// EqualsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * An invariant that says the contents of a variable always match a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X = 1, where X always has the value of 1, and X = Y, where the contents of X always\r\n * match the contents of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EqualsConstraint extends DaikonConstraint {\r\n\r\n    public EqualsConstraint(String left, String value) {\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" == \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        /*    String expected = valueObjectToString(value);\r\n    String assertion = \"\";\r\n    if (value instanceof ReferenceValue) {\r\n      assertion += \"String expected = create\"+left.getReferredVariable()+\"For(\"+valueObjectToString(value)+\");\"+ln;\r\n      expected = \"expected\";\r\n    }\r\n    assertion += \"assertEquals(\"+expected+\", \"+returnVar+\");\"+ln;\r\n    */\r\n        return \"assertEquals(\" + valueObjectToString(right) + \", \" + returnVar + \");\" + ln;\r\n    }\r\n\r\n    /*  public Collection<String> getAssertObjectValues() {\r\n    if (value instanceof ReferenceValue) {\r\n      Collection<String> result = new ArrayList<String>();\r\n      result.add(valueObjectToString(value));\r\n      return result;\r\n    }\r\n    return Collections.EMPTY_LIST;\r\n  }*/\r\n    public String toJava() {\r\n        return createCondition(left.getReferredVariable() + \".equals(\" + valueObjectToString(right) + \")\");\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"DoesNotEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/EqualsConstraint_2Test.java",
		"test_prompt": "// EqualsConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EqualsConstraint}.\n* It contains ten unit test cases for the {@link EqualsConstraint#asAssert(String)} method.\n*/\nclass EqualsConstraint_2Test {"
	},
	{
		"original_code": "// EqualsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * An invariant that says the contents of a variable always match a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X = 1, where X always has the value of 1, and X = Y, where the contents of X always\r\n * match the contents of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class EqualsConstraint extends DaikonConstraint {\r\n\r\n    public EqualsConstraint(String left, String value) {\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" == \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        /*    String expected = valueObjectToString(value);\r\n    String assertion = \"\";\r\n    if (value instanceof ReferenceValue) {\r\n      assertion += \"String expected = create\"+left.getReferredVariable()+\"For(\"+valueObjectToString(value)+\");\"+ln;\r\n      expected = \"expected\";\r\n    }\r\n    assertion += \"assertEquals(\"+expected+\", \"+returnVar+\");\"+ln;\r\n    */\r\n        return \"assertEquals(\" + valueObjectToString(right) + \", \" + returnVar + \");\" + ln;\r\n    }\r\n\r\n    /*  public Collection<String> getAssertObjectValues() {\r\n    if (value instanceof ReferenceValue) {\r\n      Collection<String> result = new ArrayList<String>();\r\n      result.add(valueObjectToString(value));\r\n      return result;\r\n    }\r\n    return Collections.EMPTY_LIST;\r\n  }*/\r\n    public String toJava() {\r\n        return createCondition(left.getReferredVariable() + \".equals(\" + valueObjectToString(right) + \")\");\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"DoesNotEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/EqualsConstraint_3Test.java",
		"test_prompt": "// EqualsConstraint_3Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EqualsConstraint}.\n* It contains ten unit test cases for the {@link EqualsConstraint#toJava()} method.\n*/\nclass EqualsConstraint_3Test {"
	},
	{
		"original_code": "// NonEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are never equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X != 1, where X is always different from 1, and X != Y, where the value of X always\r\n * is from from that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class NonEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean rightArray = false;\r\n\r\n    private boolean leftArray = false;\r\n\r\n    public NonEqualConstraint(String left, String value) {\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String value = valueObjectToString(right);\r\n        if (rightArray) {\r\n            value += \".size()\" + additionToString(false);\r\n        }\r\n        if (leftArray) {\r\n            returnVar += \".size()\" + additionToString(true);\r\n        }\r\n        return \"assertTrue(\" + returnVar + \" != \" + value + \");\" + ln;\r\n    }\r\n\r\n    public String toString() {\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\";\r\n        }\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" != \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" != \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"Equals\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/NonEqualConstraint_0Test.java",
		"test_prompt": "// NonEqualConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonEqualConstraint}.\n* It contains ten unit test cases for the {@link NonEqualConstraint#asAssert(String)} method.\n*/\nclass NonEqualConstraint_0Test {"
	},
	{
		"original_code": "// NonEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are never equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X != 1, where X is always different from 1, and X != Y, where the value of X always\r\n * is from from that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class NonEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean rightArray = false;\r\n\r\n    private boolean leftArray = false;\r\n\r\n    public NonEqualConstraint(String left, String value) {\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String value = valueObjectToString(right);\r\n        if (rightArray) {\r\n            value += \".size()\" + additionToString(false);\r\n        }\r\n        if (leftArray) {\r\n            returnVar += \".size()\" + additionToString(true);\r\n        }\r\n        return \"assertTrue(\" + returnVar + \" != \" + value + \");\" + ln;\r\n    }\r\n\r\n    public String toString() {\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\";\r\n        }\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" != \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" != \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"Equals\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/NonEqualConstraint_1Test.java",
		"test_prompt": "// NonEqualConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NonEqualConstraint}.\n* It contains ten unit test cases for the {@link NonEqualConstraint#toJava()} method.\n*/\nclass NonEqualConstraint_1Test {"
	},
	{
		"original_code": "// GreaterConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always greater than a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X > 1, where X always has a value greater than 1, and X > Y, where the value of X always\r\n * is greater than that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class GreaterConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean array = false;\r\n\r\n    public GreaterConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            array = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        return super.max();\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        String rstr = valueObjectToString(right);\r\n        if (array) {\r\n            rstr += \".size()\";\r\n        }\r\n        return \"assertTrue(\" + returnVar + additionToString(true) + \" > \" + rstr + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String rstr = right.toString();\r\n        if (array) {\r\n            rstr = \"sizeof(\" + rstr + \")\";\r\n        }\r\n        return left + additionToString(true) + \" > \" + rstr + additionToString(false);\r\n    }\r\n\r\n    protected String toJava() {\r\n        checkEnabled();\r\n        String rstr = right.toString();\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue value = (ReferenceValue) right;\r\n            rstr = value.getReferredVariable();\r\n        }\r\n        if (array) {\r\n            rstr += \".size()\";\r\n        }\r\n        String condition = left.getReferredVariable() + additionToString(true) + \" > \" + rstr + additionToString(false);\r\n        return createCondition(condition);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotGreaterThan\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/GreaterConstraint_0Test.java",
		"test_prompt": "// GreaterConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GreaterConstraint}.\n* It contains ten unit test cases for the {@link GreaterConstraint#min()} method.\n*/\nclass GreaterConstraint_0Test {"
	},
	{
		"original_code": "// GreaterConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always greater than a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X > 1, where X always has a value greater than 1, and X > Y, where the value of X always\r\n * is greater than that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class GreaterConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean array = false;\r\n\r\n    public GreaterConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            array = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        return super.max();\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        String rstr = valueObjectToString(right);\r\n        if (array) {\r\n            rstr += \".size()\";\r\n        }\r\n        return \"assertTrue(\" + returnVar + additionToString(true) + \" > \" + rstr + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String rstr = right.toString();\r\n        if (array) {\r\n            rstr = \"sizeof(\" + rstr + \")\";\r\n        }\r\n        return left + additionToString(true) + \" > \" + rstr + additionToString(false);\r\n    }\r\n\r\n    protected String toJava() {\r\n        checkEnabled();\r\n        String rstr = right.toString();\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue value = (ReferenceValue) right;\r\n            rstr = value.getReferredVariable();\r\n        }\r\n        if (array) {\r\n            rstr += \".size()\";\r\n        }\r\n        String condition = left.getReferredVariable() + additionToString(true) + \" > \" + rstr + additionToString(false);\r\n        return createCondition(condition);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotGreaterThan\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/GreaterConstraint_1Test.java",
		"test_prompt": "// GreaterConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GreaterConstraint}.\n* It contains ten unit test cases for the {@link GreaterConstraint#max()} method.\n*/\nclass GreaterConstraint_1Test {"
	},
	{
		"original_code": "// GreaterConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always greater than a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X > 1, where X always has a value greater than 1, and X > Y, where the value of X always\r\n * is greater than that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class GreaterConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean array = false;\r\n\r\n    public GreaterConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            array = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        return super.max();\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        String rstr = valueObjectToString(right);\r\n        if (array) {\r\n            rstr += \".size()\";\r\n        }\r\n        return \"assertTrue(\" + returnVar + additionToString(true) + \" > \" + rstr + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String rstr = right.toString();\r\n        if (array) {\r\n            rstr = \"sizeof(\" + rstr + \")\";\r\n        }\r\n        return left + additionToString(true) + \" > \" + rstr + additionToString(false);\r\n    }\r\n\r\n    protected String toJava() {\r\n        checkEnabled();\r\n        String rstr = right.toString();\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue value = (ReferenceValue) right;\r\n            rstr = value.getReferredVariable();\r\n        }\r\n        if (array) {\r\n            rstr += \".size()\";\r\n        }\r\n        String condition = left.getReferredVariable() + additionToString(true) + \" > \" + rstr + additionToString(false);\r\n        return createCondition(condition);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotGreaterThan\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/GreaterConstraint_2Test.java",
		"test_prompt": "// GreaterConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GreaterConstraint}.\n* It contains ten unit test cases for the {@link GreaterConstraint#asAssert(String)} method.\n*/\nclass GreaterConstraint_2Test {"
	},
	{
		"original_code": "// GreaterOrEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always greater or equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X >= 1, where X always has a value greater or equal to 1, and X >= Y, where the value of X always\r\n * is greater or equal to Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class GreaterOrEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean leftArray = false;\r\n\r\n    private boolean rightArray = false;\r\n\r\n    public GreaterOrEqualConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        String fail = null;\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        return \"assertTrue(\" + returnVar + additionToString(true) + \" >= \" + valueObjectToString(right) + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\" + additionToString(true);\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\" + additionToString(false);\r\n        }\r\n        return lstr + \" >= \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        checkEnabled();\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" >= \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotGreaterOrEqualThan\" + valueObjectToGuardObject(right);\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            if (n.intValue() == 0) {\r\n                return \"\";\r\n            }\r\n            return \"    if(\" + left.getReferredVariable() + \".size() < \" + n + \") return false;\" + ln;\r\n        }\r\n        return \"\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/GreaterOrEqualConstraint_0Test.java",
		"test_prompt": "// GreaterOrEqualConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GreaterOrEqualConstraint}.\n* It contains ten unit test cases for the {@link GreaterOrEqualConstraint#asAssert(String)} method.\n*/\nclass GreaterOrEqualConstraint_0Test {"
	},
	{
		"original_code": "// GreaterOrEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always greater or equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X >= 1, where X always has a value greater or equal to 1, and X >= Y, where the value of X always\r\n * is greater or equal to Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class GreaterOrEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean leftArray = false;\r\n\r\n    private boolean rightArray = false;\r\n\r\n    public GreaterOrEqualConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        String fail = null;\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        return \"assertTrue(\" + returnVar + additionToString(true) + \" >= \" + valueObjectToString(right) + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\" + additionToString(true);\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\" + additionToString(false);\r\n        }\r\n        return lstr + \" >= \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        checkEnabled();\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" >= \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotGreaterOrEqualThan\" + valueObjectToGuardObject(right);\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            if (n.intValue() == 0) {\r\n                return \"\";\r\n            }\r\n            return \"    if(\" + left.getReferredVariable() + \".size() < \" + n + \") return false;\" + ln;\r\n        }\r\n        return \"\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/GreaterOrEqualConstraint_1Test.java",
		"test_prompt": "// GreaterOrEqualConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GreaterOrEqualConstraint}.\n* It contains ten unit test cases for the {@link GreaterOrEqualConstraint#min()} method.\n*/\nclass GreaterOrEqualConstraint_1Test {"
	},
	{
		"original_code": "// GreaterOrEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always greater or equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X >= 1, where X always has a value greater or equal to 1, and X >= Y, where the value of X always\r\n * is greater or equal to Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class GreaterOrEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean leftArray = false;\r\n\r\n    private boolean rightArray = false;\r\n\r\n    public GreaterOrEqualConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        String fail = null;\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        return \"assertTrue(\" + returnVar + additionToString(true) + \" >= \" + valueObjectToString(right) + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\" + additionToString(true);\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\" + additionToString(false);\r\n        }\r\n        return lstr + \" >= \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        checkEnabled();\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" >= \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotGreaterOrEqualThan\" + valueObjectToGuardObject(right);\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            if (n.intValue() == 0) {\r\n                return \"\";\r\n            }\r\n            return \"    if(\" + left.getReferredVariable() + \".size() < \" + n + \") return false;\" + ln;\r\n        }\r\n        return \"\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/GreaterOrEqualConstraint_2Test.java",
		"test_prompt": "// GreaterOrEqualConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GreaterOrEqualConstraint}.\n* It contains ten unit test cases for the {@link GreaterOrEqualConstraint#max()} method.\n*/\nclass GreaterOrEqualConstraint_2Test {"
	},
	{
		"original_code": "// GreaterOrEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always greater or equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X >= 1, where X always has a value greater or equal to 1, and X >= Y, where the value of X always\r\n * is greater or equal to Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class GreaterOrEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean leftArray = false;\r\n\r\n    private boolean rightArray = false;\r\n\r\n    public GreaterOrEqualConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        String fail = null;\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        return \"assertTrue(\" + returnVar + additionToString(true) + \" >= \" + valueObjectToString(right) + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\" + additionToString(true);\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\" + additionToString(false);\r\n        }\r\n        return lstr + \" >= \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        checkEnabled();\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" >= \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotGreaterOrEqualThan\" + valueObjectToGuardObject(right);\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            if (n.intValue() == 0) {\r\n                return \"\";\r\n            }\r\n            return \"    if(\" + left.getReferredVariable() + \".size() < \" + n + \") return false;\" + ln;\r\n        }\r\n        return \"\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/GreaterOrEqualConstraint_3Test.java",
		"test_prompt": "// GreaterOrEqualConstraint_3Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GreaterOrEqualConstraint}.\n* It contains ten unit test cases for the {@link GreaterOrEqualConstraint#toJava()} method.\n*/\nclass GreaterOrEqualConstraint_3Test {"
	},
	{
		"original_code": "// GreaterOrEqualConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always greater or equal to a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X >= 1, where X always has a value greater or equal to 1, and X >= Y, where the value of X always\r\n * is greater or equal to Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class GreaterOrEqualConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean leftArray = false;\r\n\r\n    private boolean rightArray = false;\r\n\r\n    public GreaterOrEqualConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        String fail = null;\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        return \"assertTrue(\" + returnVar + additionToString(true) + \" >= \" + valueObjectToString(right) + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    public double min() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        return super.max();\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + lstr + \")\" + additionToString(true);\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + rstr + \")\" + additionToString(false);\r\n        }\r\n        return lstr + \" >= \" + rstr;\r\n    }\r\n\r\n    public String toJava() {\r\n        checkEnabled();\r\n        String lstr = left.getReferredVariable();\r\n        String rstr = valueObjectToString(right);\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" >= \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotGreaterOrEqualThan\" + valueObjectToGuardObject(right);\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            if (n.intValue() == 0) {\r\n                return \"\";\r\n            }\r\n            return \"    if(\" + left.getReferredVariable() + \".size() < \" + n + \") return false;\" + ln;\r\n        }\r\n        return \"\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/GreaterOrEqualConstraint_4Test.java",
		"test_prompt": "// GreaterOrEqualConstraint_4Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link GreaterOrEqualConstraint}.\n* It contains ten unit test cases for the {@link GreaterOrEqualConstraint#guardInvocation()} method.\n*/\nclass GreaterOrEqualConstraint_4Test {"
	},
	{
		"original_code": "// ConstantSizeConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the size of an array variable is always constant, while its contents may change.\r\n * For example, Clients size is always 1 or Clients size is always x+1, where x may be any other variable\r\n * at that point of execution. This invariant cal also say that the size is one of several constant values.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ConstantSizeConstraint extends ConstraintWithAddition {\r\n\r\n    public ConstantSizeConstraint(String left, String right) {\r\n        left = parseAddition(left, true);\r\n        right = right.trim();\r\n        //Remove \"size(\" from start and \")\" from end\r\n        left = left.substring(5, left.length() - 1);\r\n        //this is an array\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        if (right.startsWith(\"size(\")) {\r\n            right = parseAddition(right, false);\r\n            //this is an array\r\n            right = right.substring(5, right.length() - 1);\r\n            this.right = DaikonParser.parseValueObject(right);\r\n        } else if (right.endsWith(\"}\")) {\r\n            //remove } from the end\r\n            right = right.substring(0, right.length() - 1);\r\n            this.right = DaikonParser.parseObjectList(right);\r\n        } else {\r\n            this.right = DaikonParser.parseValueObject(right);\r\n        }\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue reference = (ReferenceValue) right;\r\n            if (reference.isArray()) {\r\n                names.add(reference.getReferredVariable());\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        if (right instanceof Collection) {\r\n            String list = stringFrom((Collection) right);\r\n            return \"sizeof(\" + left + \") one of {\" + list + \"}\";\r\n        }\r\n        if (!(right instanceof ReferenceValue)) {\r\n            return \"sizeof(\" + left + \") == \" + right;\r\n        }\r\n        ReferenceValue reference = (ReferenceValue) right;\r\n        if (reference.isArray()) {\r\n            return \"sizeof(\" + left + \")\" + additionToString(true) + \" == sizeof(\" + right + \")\" + additionToString(false);\r\n        }\r\n        return \"sizeof(\" + left + \")\" + additionToString(true) + \" == \" + right;\r\n    }\r\n\r\n    protected String toJava() {\r\n        if (right instanceof Collection) {\r\n            return collectionJava();\r\n        }\r\n        String lstr = left.getReferredVariable() + \".size()\";\r\n        String rstr = valueObjectToString(right);\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue reference = (ReferenceValue) right;\r\n            if (reference.isArray()) {\r\n                rstr = reference.getReferredVariable() + \".size()\";\r\n            } else {\r\n                rstr = reference.getReferredVariable();\r\n            }\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" == \" + rstr);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        if (right instanceof Collection) {\r\n            Collection values = (Collection) right;\r\n            String assertion = \"Collection validSizes = new HashSet();\" + ln;\r\n            for (Object o : values) {\r\n                assertion += \"validSizes.add(\" + valueObjectToString(o) + \");\" + ln;\r\n            }\r\n            assertion += \"assertTrue(validSizes.contains(new Double(\" + returnVar + \".size()\" + additionToString(false) + \")));\" + ln;\r\n            return assertion;\r\n        }\r\n        return \"assertEquals(\" + valueObjectToString(right) + \", \" + returnVar + \".size()\" + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    private String collectionJava() {\r\n        String java = \"    Collection validSizes = new HashSet();\" + ln;\r\n        Collection values = (Collection) right;\r\n        for (Object o : values) {\r\n            java += \"    validSizes.add(\" + valueObjectToString(o) + \");\" + ln;\r\n        }\r\n        String condition = \"validSizes.contains(new Double(\" + left.getReferredVariable() + \".size()\" + additionToString(false) + \"))\";\r\n        String check = createCondition(condition);\r\n        return java + check;\r\n    }\r\n\r\n    protected String guardName() {\r\n        if (right instanceof Collection) {\r\n            String result = left.getReferredVariable() + \"SizeDoesNotEquals\";\r\n            Collection stuff = (Collection) right;\r\n            for (Object o : stuff) {\r\n                result += \"_\" + valueObjectToGuardObject(o);\r\n            }\r\n            return result;\r\n        }\r\n        return left.getReferredVariable() + \"SizeDoesNotEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        //    if (!(right instanceof Collection) && !(right instanceof Number)) {\r\n        //      return \"\";\r\n        //    }\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            if (n.intValue() == 0) {\r\n                return \"\";\r\n            }\r\n        } else if (right instanceof Collection) {\r\n            Collection values = (Collection) right;\r\n            for (Object o : values) {\r\n                if (o instanceof Number) {\r\n                    if (((Number) o).intValue() == 0) {\r\n                        //            System.out.println(\"c1\");\r\n                        return \"\";\r\n                    }\r\n                } else {\r\n                    //          System.out.println(\"c2\");\r\n                    return \"\";\r\n                }\r\n            }\r\n        } else {\r\n            return \"\";\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ConstantSizeConstraint_0Test.java",
		"test_prompt": "// ConstantSizeConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConstantSizeConstraint}.\n* It contains ten unit test cases for the {@link ConstantSizeConstraint#arrayNames()} method.\n*/\nclass ConstantSizeConstraint_0Test {"
	},
	{
		"original_code": "// ConstantSizeConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the size of an array variable is always constant, while its contents may change.\r\n * For example, Clients size is always 1 or Clients size is always x+1, where x may be any other variable\r\n * at that point of execution. This invariant cal also say that the size is one of several constant values.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ConstantSizeConstraint extends ConstraintWithAddition {\r\n\r\n    public ConstantSizeConstraint(String left, String right) {\r\n        left = parseAddition(left, true);\r\n        right = right.trim();\r\n        //Remove \"size(\" from start and \")\" from end\r\n        left = left.substring(5, left.length() - 1);\r\n        //this is an array\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        if (right.startsWith(\"size(\")) {\r\n            right = parseAddition(right, false);\r\n            //this is an array\r\n            right = right.substring(5, right.length() - 1);\r\n            this.right = DaikonParser.parseValueObject(right);\r\n        } else if (right.endsWith(\"}\")) {\r\n            //remove } from the end\r\n            right = right.substring(0, right.length() - 1);\r\n            this.right = DaikonParser.parseObjectList(right);\r\n        } else {\r\n            this.right = DaikonParser.parseValueObject(right);\r\n        }\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue reference = (ReferenceValue) right;\r\n            if (reference.isArray()) {\r\n                names.add(reference.getReferredVariable());\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        if (right instanceof Collection) {\r\n            String list = stringFrom((Collection) right);\r\n            return \"sizeof(\" + left + \") one of {\" + list + \"}\";\r\n        }\r\n        if (!(right instanceof ReferenceValue)) {\r\n            return \"sizeof(\" + left + \") == \" + right;\r\n        }\r\n        ReferenceValue reference = (ReferenceValue) right;\r\n        if (reference.isArray()) {\r\n            return \"sizeof(\" + left + \")\" + additionToString(true) + \" == sizeof(\" + right + \")\" + additionToString(false);\r\n        }\r\n        return \"sizeof(\" + left + \")\" + additionToString(true) + \" == \" + right;\r\n    }\r\n\r\n    protected String toJava() {\r\n        if (right instanceof Collection) {\r\n            return collectionJava();\r\n        }\r\n        String lstr = left.getReferredVariable() + \".size()\";\r\n        String rstr = valueObjectToString(right);\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue reference = (ReferenceValue) right;\r\n            if (reference.isArray()) {\r\n                rstr = reference.getReferredVariable() + \".size()\";\r\n            } else {\r\n                rstr = reference.getReferredVariable();\r\n            }\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" == \" + rstr);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        if (right instanceof Collection) {\r\n            Collection values = (Collection) right;\r\n            String assertion = \"Collection validSizes = new HashSet();\" + ln;\r\n            for (Object o : values) {\r\n                assertion += \"validSizes.add(\" + valueObjectToString(o) + \");\" + ln;\r\n            }\r\n            assertion += \"assertTrue(validSizes.contains(new Double(\" + returnVar + \".size()\" + additionToString(false) + \")));\" + ln;\r\n            return assertion;\r\n        }\r\n        return \"assertEquals(\" + valueObjectToString(right) + \", \" + returnVar + \".size()\" + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    private String collectionJava() {\r\n        String java = \"    Collection validSizes = new HashSet();\" + ln;\r\n        Collection values = (Collection) right;\r\n        for (Object o : values) {\r\n            java += \"    validSizes.add(\" + valueObjectToString(o) + \");\" + ln;\r\n        }\r\n        String condition = \"validSizes.contains(new Double(\" + left.getReferredVariable() + \".size()\" + additionToString(false) + \"))\";\r\n        String check = createCondition(condition);\r\n        return java + check;\r\n    }\r\n\r\n    protected String guardName() {\r\n        if (right instanceof Collection) {\r\n            String result = left.getReferredVariable() + \"SizeDoesNotEquals\";\r\n            Collection stuff = (Collection) right;\r\n            for (Object o : stuff) {\r\n                result += \"_\" + valueObjectToGuardObject(o);\r\n            }\r\n            return result;\r\n        }\r\n        return left.getReferredVariable() + \"SizeDoesNotEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        //    if (!(right instanceof Collection) && !(right instanceof Number)) {\r\n        //      return \"\";\r\n        //    }\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            if (n.intValue() == 0) {\r\n                return \"\";\r\n            }\r\n        } else if (right instanceof Collection) {\r\n            Collection values = (Collection) right;\r\n            for (Object o : values) {\r\n                if (o instanceof Number) {\r\n                    if (((Number) o).intValue() == 0) {\r\n                        //            System.out.println(\"c1\");\r\n                        return \"\";\r\n                    }\r\n                } else {\r\n                    //          System.out.println(\"c2\");\r\n                    return \"\";\r\n                }\r\n            }\r\n        } else {\r\n            return \"\";\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ConstantSizeConstraint_1Test.java",
		"test_prompt": "// ConstantSizeConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConstantSizeConstraint}.\n* It contains ten unit test cases for the {@link ConstantSizeConstraint#asAssert(String)} method.\n*/\nclass ConstantSizeConstraint_1Test {"
	},
	{
		"original_code": "// ConstantSizeConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the size of an array variable is always constant, while its contents may change.\r\n * For example, Clients size is always 1 or Clients size is always x+1, where x may be any other variable\r\n * at that point of execution. This invariant cal also say that the size is one of several constant values.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ConstantSizeConstraint extends ConstraintWithAddition {\r\n\r\n    public ConstantSizeConstraint(String left, String right) {\r\n        left = parseAddition(left, true);\r\n        right = right.trim();\r\n        //Remove \"size(\" from start and \")\" from end\r\n        left = left.substring(5, left.length() - 1);\r\n        //this is an array\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        if (right.startsWith(\"size(\")) {\r\n            right = parseAddition(right, false);\r\n            //this is an array\r\n            right = right.substring(5, right.length() - 1);\r\n            this.right = DaikonParser.parseValueObject(right);\r\n        } else if (right.endsWith(\"}\")) {\r\n            //remove } from the end\r\n            right = right.substring(0, right.length() - 1);\r\n            this.right = DaikonParser.parseObjectList(right);\r\n        } else {\r\n            this.right = DaikonParser.parseValueObject(right);\r\n        }\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue reference = (ReferenceValue) right;\r\n            if (reference.isArray()) {\r\n                names.add(reference.getReferredVariable());\r\n            }\r\n        }\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        if (right instanceof Collection) {\r\n            String list = stringFrom((Collection) right);\r\n            return \"sizeof(\" + left + \") one of {\" + list + \"}\";\r\n        }\r\n        if (!(right instanceof ReferenceValue)) {\r\n            return \"sizeof(\" + left + \") == \" + right;\r\n        }\r\n        ReferenceValue reference = (ReferenceValue) right;\r\n        if (reference.isArray()) {\r\n            return \"sizeof(\" + left + \")\" + additionToString(true) + \" == sizeof(\" + right + \")\" + additionToString(false);\r\n        }\r\n        return \"sizeof(\" + left + \")\" + additionToString(true) + \" == \" + right;\r\n    }\r\n\r\n    protected String toJava() {\r\n        if (right instanceof Collection) {\r\n            return collectionJava();\r\n        }\r\n        String lstr = left.getReferredVariable() + \".size()\";\r\n        String rstr = valueObjectToString(right);\r\n        if (right instanceof ReferenceValue) {\r\n            ReferenceValue reference = (ReferenceValue) right;\r\n            if (reference.isArray()) {\r\n                rstr = reference.getReferredVariable() + \".size()\";\r\n            } else {\r\n                rstr = reference.getReferredVariable();\r\n            }\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" == \" + rstr);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        if (right instanceof Collection) {\r\n            Collection values = (Collection) right;\r\n            String assertion = \"Collection validSizes = new HashSet();\" + ln;\r\n            for (Object o : values) {\r\n                assertion += \"validSizes.add(\" + valueObjectToString(o) + \");\" + ln;\r\n            }\r\n            assertion += \"assertTrue(validSizes.contains(new Double(\" + returnVar + \".size()\" + additionToString(false) + \")));\" + ln;\r\n            return assertion;\r\n        }\r\n        return \"assertEquals(\" + valueObjectToString(right) + \", \" + returnVar + \".size()\" + additionToString(false) + \");\" + ln;\r\n    }\r\n\r\n    private String collectionJava() {\r\n        String java = \"    Collection validSizes = new HashSet();\" + ln;\r\n        Collection values = (Collection) right;\r\n        for (Object o : values) {\r\n            java += \"    validSizes.add(\" + valueObjectToString(o) + \");\" + ln;\r\n        }\r\n        String condition = \"validSizes.contains(new Double(\" + left.getReferredVariable() + \".size()\" + additionToString(false) + \"))\";\r\n        String check = createCondition(condition);\r\n        return java + check;\r\n    }\r\n\r\n    protected String guardName() {\r\n        if (right instanceof Collection) {\r\n            String result = left.getReferredVariable() + \"SizeDoesNotEquals\";\r\n            Collection stuff = (Collection) right;\r\n            for (Object o : stuff) {\r\n                result += \"_\" + valueObjectToGuardObject(o);\r\n            }\r\n            return result;\r\n        }\r\n        return left.getReferredVariable() + \"SizeDoesNotEqual\" + valueObjectToGuardObject(right);\r\n    }\r\n\r\n    public String guardInvocation() {\r\n        //    if (!(right instanceof Collection) && !(right instanceof Number)) {\r\n        //      return \"\";\r\n        //    }\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            if (n.intValue() == 0) {\r\n                return \"\";\r\n            }\r\n        } else if (right instanceof Collection) {\r\n            Collection values = (Collection) right;\r\n            for (Object o : values) {\r\n                if (o instanceof Number) {\r\n                    if (((Number) o).intValue() == 0) {\r\n                        //            System.out.println(\"c1\");\r\n                        return \"\";\r\n                    }\r\n                } else {\r\n                    //          System.out.println(\"c2\");\r\n                    return \"\";\r\n                }\r\n            }\r\n        } else {\r\n            return \"\";\r\n        }\r\n        return \"    if(\" + left.getReferredVariable() + \".isEmpty()) return false;\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ConstantSizeConstraint_2Test.java",
		"test_prompt": "// ConstantSizeConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConstantSizeConstraint}.\n* It contains ten unit test cases for the {@link ConstantSizeConstraint#guardInvocation()} method.\n*/\nclass ConstantSizeConstraint_2Test {"
	},
	{
		"original_code": "// ReferenceValue.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\n/**\r\n * Represents a value in an invariant that is a reference to another variable. That is, if the invariant\r\n * is X < 1, then X is a reference value as it refers to a variable, and 1 is a primitive value.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ReferenceValue {\r\n\r\n    private final String referredVariable;\r\n\r\n    private int index = -1;\r\n\r\n    private boolean global = false;\r\n\r\n    private boolean returnValue = false;\r\n\r\n    private final boolean array;\r\n\r\n    public static final ReferenceValue EMPTY_ARRAY = new ReferenceValue();\r\n\r\n    private ReferenceValue() {\r\n        referredVariable = null;\r\n        array = true;\r\n    }\r\n\r\n    public ReferenceValue(String referredVariable, boolean array) {\r\n        String[] parts = referredVariable.split(\"\\\\?\");\r\n        this.referredVariable = parts[0];\r\n        this.array = array;\r\n        if (parts[1].equals(\"g\")) {\r\n            //it is a global variable. must use char (g) as some constraints search for \"-\" and \"+\"\r\n            global = true;\r\n            return;\r\n        }\r\n        if (parts[1].equals(\"r\")) {\r\n            //it is a return value variable. must use char (r) as some constraints search for \"-\" and \"+\"\r\n            returnValue = true;\r\n            return;\r\n        }\r\n        int index = Integer.parseInt(parts[1]);\r\n        if (index < 0) {\r\n            throw new IllegalArgumentException(\"Parameter index should be >= 0, 'g' for globals or 'r' for return values. Was:\" + index + \".\");\r\n        }\r\n        this.index = index;\r\n    }\r\n\r\n    public String getReferredVariable() {\r\n        return referredVariable;\r\n    }\r\n\r\n    public int getIndex() {\r\n        return index;\r\n    }\r\n\r\n    public boolean isArray() {\r\n        return array;\r\n    }\r\n\r\n    public boolean isGlobal() {\r\n        return global;\r\n    }\r\n\r\n    public boolean isReturnValue() {\r\n        return returnValue;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"reference:\" + referredVariable;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ReferenceValue_0Test.java",
		"test_prompt": "// ReferenceValue_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReferenceValue}.\n* It contains ten unit test cases for the {@link ReferenceValue#isArray()} method.\n*/\nclass ReferenceValue_0Test {"
	},
	{
		"original_code": "// ReferenceValue.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\n/**\r\n * Represents a value in an invariant that is a reference to another variable. That is, if the invariant\r\n * is X < 1, then X is a reference value as it refers to a variable, and 1 is a primitive value.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ReferenceValue {\r\n\r\n    private final String referredVariable;\r\n\r\n    private int index = -1;\r\n\r\n    private boolean global = false;\r\n\r\n    private boolean returnValue = false;\r\n\r\n    private final boolean array;\r\n\r\n    public static final ReferenceValue EMPTY_ARRAY = new ReferenceValue();\r\n\r\n    private ReferenceValue() {\r\n        referredVariable = null;\r\n        array = true;\r\n    }\r\n\r\n    public ReferenceValue(String referredVariable, boolean array) {\r\n        String[] parts = referredVariable.split(\"\\\\?\");\r\n        this.referredVariable = parts[0];\r\n        this.array = array;\r\n        if (parts[1].equals(\"g\")) {\r\n            //it is a global variable. must use char (g) as some constraints search for \"-\" and \"+\"\r\n            global = true;\r\n            return;\r\n        }\r\n        if (parts[1].equals(\"r\")) {\r\n            //it is a return value variable. must use char (r) as some constraints search for \"-\" and \"+\"\r\n            returnValue = true;\r\n            return;\r\n        }\r\n        int index = Integer.parseInt(parts[1]);\r\n        if (index < 0) {\r\n            throw new IllegalArgumentException(\"Parameter index should be >= 0, 'g' for globals or 'r' for return values. Was:\" + index + \".\");\r\n        }\r\n        this.index = index;\r\n    }\r\n\r\n    public String getReferredVariable() {\r\n        return referredVariable;\r\n    }\r\n\r\n    public int getIndex() {\r\n        return index;\r\n    }\r\n\r\n    public boolean isArray() {\r\n        return array;\r\n    }\r\n\r\n    public boolean isGlobal() {\r\n        return global;\r\n    }\r\n\r\n    public boolean isReturnValue() {\r\n        return returnValue;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"reference:\" + referredVariable;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ReferenceValue_1Test.java",
		"test_prompt": "// ReferenceValue_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReferenceValue}.\n* It contains ten unit test cases for the {@link ReferenceValue#isGlobal()} method.\n*/\nclass ReferenceValue_1Test {"
	},
	{
		"original_code": "// ReferenceValue.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\n/**\r\n * Represents a value in an invariant that is a reference to another variable. That is, if the invariant\r\n * is X < 1, then X is a reference value as it refers to a variable, and 1 is a primitive value.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ReferenceValue {\r\n\r\n    private final String referredVariable;\r\n\r\n    private int index = -1;\r\n\r\n    private boolean global = false;\r\n\r\n    private boolean returnValue = false;\r\n\r\n    private final boolean array;\r\n\r\n    public static final ReferenceValue EMPTY_ARRAY = new ReferenceValue();\r\n\r\n    private ReferenceValue() {\r\n        referredVariable = null;\r\n        array = true;\r\n    }\r\n\r\n    public ReferenceValue(String referredVariable, boolean array) {\r\n        String[] parts = referredVariable.split(\"\\\\?\");\r\n        this.referredVariable = parts[0];\r\n        this.array = array;\r\n        if (parts[1].equals(\"g\")) {\r\n            //it is a global variable. must use char (g) as some constraints search for \"-\" and \"+\"\r\n            global = true;\r\n            return;\r\n        }\r\n        if (parts[1].equals(\"r\")) {\r\n            //it is a return value variable. must use char (r) as some constraints search for \"-\" and \"+\"\r\n            returnValue = true;\r\n            return;\r\n        }\r\n        int index = Integer.parseInt(parts[1]);\r\n        if (index < 0) {\r\n            throw new IllegalArgumentException(\"Parameter index should be >= 0, 'g' for globals or 'r' for return values. Was:\" + index + \".\");\r\n        }\r\n        this.index = index;\r\n    }\r\n\r\n    public String getReferredVariable() {\r\n        return referredVariable;\r\n    }\r\n\r\n    public int getIndex() {\r\n        return index;\r\n    }\r\n\r\n    public boolean isArray() {\r\n        return array;\r\n    }\r\n\r\n    public boolean isGlobal() {\r\n        return global;\r\n    }\r\n\r\n    public boolean isReturnValue() {\r\n        return returnValue;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"reference:\" + referredVariable;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ReferenceValue_2Test.java",
		"test_prompt": "// ReferenceValue_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReferenceValue}.\n* It contains ten unit test cases for the {@link ReferenceValue#isReturnValue()} method.\n*/\nclass ReferenceValue_2Test {"
	},
	{
		"original_code": "// LesserConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always less than a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X < 1, where X always has a value less than 1, and X < Y, where the value of X always\r\n * is less than that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class LesserConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean rightArray = false;\r\n\r\n    private boolean leftArray = false;\r\n\r\n    public LesserConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        return \"assertTrue(\" + returnVar + \" < \" + valueObjectToString(right) + \");\" + ln;\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + left + \")\";\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + right + \")\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" < \" + rstr;\r\n    }\r\n\r\n    protected String toJava() {\r\n        checkEnabled();\r\n        String lstr = left.getReferredVariable();\r\n        if (!(right instanceof ReferenceValue)) {\r\n            return createCondition(lstr + \" < \" + valueObjectToString(right));\r\n        }\r\n        String rstr = ((ReferenceValue) right).getReferredVariable();\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" < \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotLesserThan\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/LesserConstraint_0Test.java",
		"test_prompt": "// LesserConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LesserConstraint}.\n* It contains ten unit test cases for the {@link LesserConstraint#min()} method.\n*/\nclass LesserConstraint_0Test {"
	},
	{
		"original_code": "// LesserConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always less than a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X < 1, where X always has a value less than 1, and X < Y, where the value of X always\r\n * is less than that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class LesserConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean rightArray = false;\r\n\r\n    private boolean leftArray = false;\r\n\r\n    public LesserConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        return \"assertTrue(\" + returnVar + \" < \" + valueObjectToString(right) + \");\" + ln;\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + left + \")\";\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + right + \")\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" < \" + rstr;\r\n    }\r\n\r\n    protected String toJava() {\r\n        checkEnabled();\r\n        String lstr = left.getReferredVariable();\r\n        if (!(right instanceof ReferenceValue)) {\r\n            return createCondition(lstr + \" < \" + valueObjectToString(right));\r\n        }\r\n        String rstr = ((ReferenceValue) right).getReferredVariable();\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" < \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotLesserThan\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/LesserConstraint_1Test.java",
		"test_prompt": "// LesserConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LesserConstraint}.\n* It contains ten unit test cases for the {@link LesserConstraint#max()} method.\n*/\nclass LesserConstraint_1Test {"
	},
	{
		"original_code": "// LesserConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\n\r\n/**\r\n * An invariant that says the contents of a variable are always less than a certain value. The\r\n * matched value may be a constant primitive value or the contents of another variable.\r\n * For example, if X is the name of the variable which this invariant describes, possibilities\r\n * include X < 1, where X always has a value less than 1, and X < Y, where the value of X always\r\n * is less than that of Y.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class LesserConstraint extends ConstraintWithAddition {\r\n\r\n    private boolean rightArray = false;\r\n\r\n    private boolean leftArray = false;\r\n\r\n    public LesserConstraint(String left, String value) {\r\n        if (parseLexical(value)) {\r\n            return;\r\n        }\r\n        if (left.startsWith(\"size\")) {\r\n            leftArray = true;\r\n            parseAddition(left, true);\r\n            left = parseArrayName(left);\r\n        }\r\n        if (value.startsWith(\"size\")) {\r\n            rightArray = true;\r\n            parseAddition(value, false);\r\n            value = parseArrayName(value);\r\n        }\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public double min() {\r\n        return super.min();\r\n    }\r\n\r\n    public double max() {\r\n        if (right instanceof Number) {\r\n            Number n = (Number) right;\r\n            return n.doubleValue();\r\n        }\r\n        return super.max();\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        checkEnabled();\r\n        return \"assertTrue(\" + returnVar + \" < \" + valueObjectToString(right) + \");\" + ln;\r\n    }\r\n\r\n    public String toString() {\r\n        checkEnabled();\r\n        String lstr = left.toString();\r\n        String rstr = right.toString();\r\n        if (leftArray) {\r\n            lstr = \"sizeof(\" + left + \")\";\r\n        }\r\n        if (rightArray) {\r\n            rstr = \"sizeof(\" + right + \")\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return lstr + \" < \" + rstr;\r\n    }\r\n\r\n    protected String toJava() {\r\n        checkEnabled();\r\n        String lstr = left.getReferredVariable();\r\n        if (!(right instanceof ReferenceValue)) {\r\n            return createCondition(lstr + \" < \" + valueObjectToString(right));\r\n        }\r\n        String rstr = ((ReferenceValue) right).getReferredVariable();\r\n        if (leftArray) {\r\n            lstr += \".size()\";\r\n        }\r\n        if (rightArray) {\r\n            rstr += \".size()\";\r\n        }\r\n        lstr += additionToString(true);\r\n        rstr += additionToString(false);\r\n        return createCondition(lstr + \" < \" + rstr);\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"IsNotLesserThan\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/LesserConstraint_2Test.java",
		"test_prompt": "// LesserConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LesserConstraint}.\n* It contains ten unit test cases for the {@link LesserConstraint#asAssert(String)} method.\n*/\nclass LesserConstraint_2Test {"
	},
	{
		"original_code": "// AlwaysInArrayConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the value of a given variable is always one that is at that time contained\r\n * in another list variable. For example, variable Client is \"myclient\" and list variable Clients is\r\n * [\"myclient\", \"myclient2\"] and the same applies whatever the value of Client is at some point of\r\n * program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class AlwaysInArrayConstraint extends DaikonConstraint {\r\n\r\n    public AlwaysInArrayConstraint(String left, String value) {\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //this is an array\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.right = (ReferenceValue) DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public boolean isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" always in \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"assertTrue(\" + arrayName + \".contains(\" + returnVar + \"));\" + ln;\r\n    }\r\n\r\n    protected String toJava() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        String itemName = left.getReferredVariable();\r\n        String conditional = arrayName + \".contains(\" + itemName + \")\";\r\n        return createCondition(conditional);\r\n    }\r\n\r\n    public String guardName() {\r\n        return left.getReferredVariable() + \"IsNotIn\" + valueObjectToGuardString(right);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"    return (\" + type + \") randomItemFrom(\" + arrayName + \");\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/AlwaysInArrayConstraint_0Test.java",
		"test_prompt": "// AlwaysInArrayConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AlwaysInArrayConstraint}.\n* It contains ten unit test cases for the {@link AlwaysInArrayConstraint#isEnabled()} method.\n*/\nclass AlwaysInArrayConstraint_0Test {"
	},
	{
		"original_code": "// AlwaysInArrayConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the value of a given variable is always one that is at that time contained\r\n * in another list variable. For example, variable Client is \"myclient\" and list variable Clients is\r\n * [\"myclient\", \"myclient2\"] and the same applies whatever the value of Client is at some point of\r\n * program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class AlwaysInArrayConstraint extends DaikonConstraint {\r\n\r\n    public AlwaysInArrayConstraint(String left, String value) {\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //this is an array\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.right = (ReferenceValue) DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public boolean isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" always in \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"assertTrue(\" + arrayName + \".contains(\" + returnVar + \"));\" + ln;\r\n    }\r\n\r\n    protected String toJava() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        String itemName = left.getReferredVariable();\r\n        String conditional = arrayName + \".contains(\" + itemName + \")\";\r\n        return createCondition(conditional);\r\n    }\r\n\r\n    public String guardName() {\r\n        return left.getReferredVariable() + \"IsNotIn\" + valueObjectToGuardString(right);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"    return (\" + type + \") randomItemFrom(\" + arrayName + \");\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/AlwaysInArrayConstraint_1Test.java",
		"test_prompt": "// AlwaysInArrayConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AlwaysInArrayConstraint}.\n* It contains ten unit test cases for the {@link AlwaysInArrayConstraint#arrayNames()} method.\n*/\nclass AlwaysInArrayConstraint_1Test {"
	},
	{
		"original_code": "// AlwaysInArrayConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the value of a given variable is always one that is at that time contained\r\n * in another list variable. For example, variable Client is \"myclient\" and list variable Clients is\r\n * [\"myclient\", \"myclient2\"] and the same applies whatever the value of Client is at some point of\r\n * program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class AlwaysInArrayConstraint extends DaikonConstraint {\r\n\r\n    public AlwaysInArrayConstraint(String left, String value) {\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //this is an array\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.right = (ReferenceValue) DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public boolean isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" always in \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"assertTrue(\" + arrayName + \".contains(\" + returnVar + \"));\" + ln;\r\n    }\r\n\r\n    protected String toJava() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        String itemName = left.getReferredVariable();\r\n        String conditional = arrayName + \".contains(\" + itemName + \")\";\r\n        return createCondition(conditional);\r\n    }\r\n\r\n    public String guardName() {\r\n        return left.getReferredVariable() + \"IsNotIn\" + valueObjectToGuardString(right);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"    return (\" + type + \") randomItemFrom(\" + arrayName + \");\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/AlwaysInArrayConstraint_2Test.java",
		"test_prompt": "// AlwaysInArrayConstraint_2Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AlwaysInArrayConstraint}.\n* It contains ten unit test cases for the {@link AlwaysInArrayConstraint#asAssert(String)} method.\n*/\nclass AlwaysInArrayConstraint_2Test {"
	},
	{
		"original_code": "// AlwaysInArrayConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the value of a given variable is always one that is at that time contained\r\n * in another list variable. For example, variable Client is \"myclient\" and list variable Clients is\r\n * [\"myclient\", \"myclient2\"] and the same applies whatever the value of Client is at some point of\r\n * program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class AlwaysInArrayConstraint extends DaikonConstraint {\r\n\r\n    public AlwaysInArrayConstraint(String left, String value) {\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //this is an array\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.right = (ReferenceValue) DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public boolean isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" always in \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"assertTrue(\" + arrayName + \".contains(\" + returnVar + \"));\" + ln;\r\n    }\r\n\r\n    protected String toJava() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        String itemName = left.getReferredVariable();\r\n        String conditional = arrayName + \".contains(\" + itemName + \")\";\r\n        return createCondition(conditional);\r\n    }\r\n\r\n    public String guardName() {\r\n        return left.getReferredVariable() + \"IsNotIn\" + valueObjectToGuardString(right);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"    return (\" + type + \") randomItemFrom(\" + arrayName + \");\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/AlwaysInArrayConstraint_3Test.java",
		"test_prompt": "// AlwaysInArrayConstraint_3Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AlwaysInArrayConstraint}.\n* It contains ten unit test cases for the {@link AlwaysInArrayConstraint#guardName()} method.\n*/\nclass AlwaysInArrayConstraint_3Test {"
	},
	{
		"original_code": "// AlwaysInArrayConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that the value of a given variable is always one that is at that time contained\r\n * in another list variable. For example, variable Client is \"myclient\" and list variable Clients is\r\n * [\"myclient\", \"myclient2\"] and the same applies whatever the value of Client is at some point of\r\n * program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class AlwaysInArrayConstraint extends DaikonConstraint {\r\n\r\n    public AlwaysInArrayConstraint(String left, String value) {\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        value = value.trim();\r\n        //this is an array\r\n        //this should always be a reference value, else it makes no sense and exception should be given as is\r\n        this.right = (ReferenceValue) DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public boolean isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" always in \" + right;\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"assertTrue(\" + arrayName + \".contains(\" + returnVar + \"));\" + ln;\r\n    }\r\n\r\n    protected String toJava() {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        String itemName = left.getReferredVariable();\r\n        String conditional = arrayName + \".contains(\" + itemName + \")\";\r\n        return createCondition(conditional);\r\n    }\r\n\r\n    public String guardName() {\r\n        return left.getReferredVariable() + \"IsNotIn\" + valueObjectToGuardString(right);\r\n    }\r\n\r\n    public String parameterValues(String type) {\r\n        ReferenceValue value = (ReferenceValue) right;\r\n        String arrayName = value.getReferredVariable();\r\n        return \"    return (\" + type + \") randomItemFrom(\" + arrayName + \");\" + ln;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/AlwaysInArrayConstraint_4Test.java",
		"test_prompt": "// AlwaysInArrayConstraint_4Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AlwaysInArrayConstraint}.\n* It contains ten unit test cases for the {@link AlwaysInArrayConstraint#parameterValues(String)} method.\n*/\nclass AlwaysInArrayConstraint_4Test {"
	},
	{
		"original_code": "// ArrayElementsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that only the given object is contained in an array at any point of\r\n * program execution. For example, array Clients is [\"myclient\"] and this never changes at\r\n * any of the monitored points of program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ArrayElementsConstraint extends DaikonConstraint {\r\n\r\n    public ArrayElementsConstraint(String left, String value) {\r\n        //this is an array\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" elements == \" + valueObjectToString(right);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String java = \"for (Object o : \" + returnVar + \") {\" + ln;\r\n        java += \"  assertEquals(\" + valueObjectToString(right) + \", o);\" + ln;\r\n        java += \"}\" + ln;\r\n        return java;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String java = \"    Object expected = \" + valueObjectToString(right) + \";\" + ln;\r\n        java += \"    for (Object o : \" + left.getReferredVariable() + \") {\" + ln;\r\n        String check = createCondition(\"expected.equals(o)\", 1);\r\n        java += check;\r\n        java += \"    }\" + ln;\r\n        return java;\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"AreDifferentFrom\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ArrayElementsConstraint_0Test.java",
		"test_prompt": "// ArrayElementsConstraint_0Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArrayElementsConstraint}.\n* It contains ten unit test cases for the {@link ArrayElementsConstraint#arrayNames()} method.\n*/\nclass ArrayElementsConstraint_0Test {"
	},
	{
		"original_code": "// ArrayElementsConstraint.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon.constraints;\r\n\r\nimport fi.vtt.noen.testgen.parser.DaikonParser;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\n\r\n/**\r\n * This invariant says that only the given object is contained in an array at any point of\r\n * program execution. For example, array Clients is [\"myclient\"] and this never changes at\r\n * any of the monitored points of program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ArrayElementsConstraint extends DaikonConstraint {\r\n\r\n    public ArrayElementsConstraint(String left, String value) {\r\n        //this is an array\r\n        this.left = (ReferenceValue) DaikonParser.parseValueObject(left);\r\n        this.right = DaikonParser.parseValueObject(value);\r\n    }\r\n\r\n    public Collection<String> arrayNames() {\r\n        Collection<String> names = new HashSet<String>();\r\n        names.add(left.getReferredVariable());\r\n        return names;\r\n    }\r\n\r\n    public String toString() {\r\n        return left + \" elements == \" + valueObjectToString(right);\r\n    }\r\n\r\n    public String asAssert(String returnVar) {\r\n        String java = \"for (Object o : \" + returnVar + \") {\" + ln;\r\n        java += \"  assertEquals(\" + valueObjectToString(right) + \", o);\" + ln;\r\n        java += \"}\" + ln;\r\n        return java;\r\n    }\r\n\r\n    protected String toJava() {\r\n        String java = \"    Object expected = \" + valueObjectToString(right) + \";\" + ln;\r\n        java += \"    for (Object o : \" + left.getReferredVariable() + \") {\" + ln;\r\n        String check = createCondition(\"expected.equals(o)\", 1);\r\n        java += check;\r\n        java += \"    }\" + ln;\r\n        return java;\r\n    }\r\n\r\n    protected String guardName() {\r\n        return left.getReferredVariable() + \"AreDifferentFrom\" + valueObjectToGuardObject(right);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/constraints/ArrayElementsConstraint_1Test.java",
		"test_prompt": "// ArrayElementsConstraint_1Test.java\npackage fi.vtt.noen.testgen.model.daikon.constraints;\n\nimport fi.vtt.noen.testgen.parser.DaikonParser;\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.model.daikon.constraints.ReferenceValue;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArrayElementsConstraint}.\n* It contains ten unit test cases for the {@link ArrayElementsConstraint#asAssert(String)} method.\n*/\nclass ArrayElementsConstraint_1Test {"
	},
	{
		"original_code": "// DaikonTransition.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Describes the invariants related to given values when a transition is made from one state to another state.\r\n * In practice, this means invariants over the relevant variable values at the time when the first state was\r\n * entered, causing a transition from this input state to output state afterwards. This is not relevant in\r\n * cases where the originating state is not an input state of course.. unless you do sequences where\r\n * several output states are in a sequence, which is not really supported right now..\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonTransition extends DaikonModelElement {\r\n\r\n    private String source = null;\r\n\r\n    private String target = null;\r\n\r\n    public static final String ln = \"\\n\";\r\n\r\n    public DaikonTransition(String fullName) {\r\n        super(fullName);\r\n        String[] names = fullName.split(\",\");\r\n        if (names.length != 2) {\r\n            throw new IllegalArgumentException(\"Transition format must be 'source,target' but it was '\" + fullName + \"'\");\r\n        }\r\n        this.source = names[0];\r\n        this.target = names[1];\r\n    }\r\n\r\n    public String getSource() {\r\n        return source;\r\n    }\r\n\r\n    public String getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += ln + dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String createAsserts(String returnVar) {\r\n        String assertion = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isReturnValue()) {\r\n                assertion += dc.asAssert(returnVar);\r\n            }\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    public String createTransitionGuards() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //only global variable constraints are important for guards\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonTransition_0Test.java",
		"test_prompt": "// DaikonTransition_0Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonTransition}.\n* It contains ten unit test cases for the {@link DaikonTransition#guardContentMethods(Set)} method.\n*/\nclass DaikonTransition_0Test {"
	},
	{
		"original_code": "// DaikonTransition.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Describes the invariants related to given values when a transition is made from one state to another state.\r\n * In practice, this means invariants over the relevant variable values at the time when the first state was\r\n * entered, causing a transition from this input state to output state afterwards. This is not relevant in\r\n * cases where the originating state is not an input state of course.. unless you do sequences where\r\n * several output states are in a sequence, which is not really supported right now..\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonTransition extends DaikonModelElement {\r\n\r\n    private String source = null;\r\n\r\n    private String target = null;\r\n\r\n    public static final String ln = \"\\n\";\r\n\r\n    public DaikonTransition(String fullName) {\r\n        super(fullName);\r\n        String[] names = fullName.split(\",\");\r\n        if (names.length != 2) {\r\n            throw new IllegalArgumentException(\"Transition format must be 'source,target' but it was '\" + fullName + \"'\");\r\n        }\r\n        this.source = names[0];\r\n        this.target = names[1];\r\n    }\r\n\r\n    public String getSource() {\r\n        return source;\r\n    }\r\n\r\n    public String getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += ln + dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String createAsserts(String returnVar) {\r\n        String assertion = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isReturnValue()) {\r\n                assertion += dc.asAssert(returnVar);\r\n            }\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    public String createTransitionGuards() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //only global variable constraints are important for guards\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonTransition_1Test.java",
		"test_prompt": "// DaikonTransition_1Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonTransition}.\n* It contains ten unit test cases for the {@link DaikonTransition#createAsserts(String)} method.\n*/\nclass DaikonTransition_1Test {"
	},
	{
		"original_code": "// DaikonTransition.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.model.daikon;\r\n\r\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\r\nimport fi.vtt.noen.testgen.StringUtils;\r\nimport java.util.Iterator;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Describes the invariants related to given values when a transition is made from one state to another state.\r\n * In practice, this means invariants over the relevant variable values at the time when the first state was\r\n * entered, causing a transition from this input state to output state afterwards. This is not relevant in\r\n * cases where the originating state is not an input state of course.. unless you do sequences where\r\n * several output states are in a sequence, which is not really supported right now..\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonTransition extends DaikonModelElement {\r\n\r\n    private String source = null;\r\n\r\n    private String target = null;\r\n\r\n    public static final String ln = \"\\n\";\r\n\r\n    public DaikonTransition(String fullName) {\r\n        super(fullName);\r\n        String[] names = fullName.split(\",\");\r\n        if (names.length != 2) {\r\n            throw new IllegalArgumentException(\"Transition format must be 'source,target' but it was '\" + fullName + \"'\");\r\n        }\r\n        this.source = names[0];\r\n        this.target = names[1];\r\n    }\r\n\r\n    public String getSource() {\r\n        return source;\r\n    }\r\n\r\n    public String getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public String guardContentMethods(Set<String> generatedMethods) {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //onle generate each method once\r\n                String id = dc.guardInvocation();\r\n                if (generatedMethods.contains(id)) {\r\n                    continue;\r\n                }\r\n                generatedMethods.add(id);\r\n                guard += ln + dc.guardMethod();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n\r\n    public String createAsserts(String returnVar) {\r\n        String assertion = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isReturnValue()) {\r\n                assertion += dc.asAssert(returnVar);\r\n            }\r\n        }\r\n        return assertion;\r\n    }\r\n\r\n    public String createTransitionGuards() {\r\n        String guard = \"\";\r\n        for (DaikonConstraint dc : constraints) {\r\n            if (dc.isGlobal()) {\r\n                //only global variable constraints are important for guards\r\n                guard += dc.guardInvocation();\r\n            }\r\n        }\r\n        return guard;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/model/daikon/DaikonTransition_2Test.java",
		"test_prompt": "// DaikonTransition_2Test.java\npackage fi.vtt.noen.testgen.model.daikon;\n\nimport fi.vtt.noen.testgen.model.daikon.constraints.DaikonConstraint;\nimport fi.vtt.noen.testgen.StringUtils;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonTransition}.\n* It contains ten unit test cases for the {@link DaikonTransition#createTransitionGuards()} method.\n*/\nclass DaikonTransition_2Test {"
	},
	{
		"original_code": "// DaikonFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.*;\r\nimport fi.vtt.noen.testgen.model.Const;\r\nimport fi.vtt.noen.testgen.Main;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\nimport java.util.HashSet;\r\nimport java.util.Collection;\r\nimport java.util.Properties;\r\nimport java.util.ArrayList;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.FileInputStream;\r\n\r\n/**\r\n * Produces a log file in Daikon format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonFormatter extends BasicFormatter {\r\n\r\n    private Set<String> declarations = new HashSet<String>();\r\n\r\n    private boolean simple = false;\r\n\r\n    private final Collection<String> inputs;\r\n\r\n    //private final Collection<Class> inputs;\r\n    //private final Collection<Class> outputs;\r\n    public DaikonFormatter(String fileName, boolean simple) throws IOException {\r\n        super(fileName);\r\n        this.simple = simple;\r\n        if (simple) {\r\n            inputs = null;\r\n            return;\r\n        }\r\n        try {\r\n            inputs = InterfaceParser.methodNames(inputs());\r\n            System.out.println(\"inputs:\" + inputs);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            throw new RuntimeException(\"failed to load input and output interface definitions for daikon formatter\", e);\r\n        }\r\n    }\r\n\r\n    public DaikonFormatter(String fileName, Collection<String> inputs) throws IOException {\r\n        super(fileName);\r\n        this.inputs = inputs;\r\n        System.out.println(\"inputs:\" + inputs);\r\n    }\r\n\r\n    private static Class classForProperty(String property) throws Exception {\r\n        Properties configuration = new Properties();\r\n        configuration.load(new FileInputStream(\"testgen.properties\"));\r\n        String className = configuration.getProperty(property);\r\n        if (className == null) {\r\n            return null;\r\n        }\r\n        System.out.println(\"creating class for:\" + className);\r\n        return Class.forName(className);\r\n    }\r\n\r\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\r\n        Collection<Class> classes = new ArrayList<Class>();\r\n        int index = 1;\r\n        while (true) {\r\n            Class clazz = classForProperty(prefix + index);\r\n            index++;\r\n            if (clazz == null) {\r\n                break;\r\n            }\r\n            classes.add(clazz);\r\n        }\r\n        return classes;\r\n    }\r\n\r\n    public static Collection<Class> inputs() throws Exception {\r\n        return classesForMultipleProperties(\"InputInterface\");\r\n    }\r\n\r\n    public static Collection<Class> outputs() throws Exception {\r\n        return classesForMultipleProperties(\"OutputInterface\");\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"decl-version 2.0\");\r\n        out.append(\"var-comparability implicit\");\r\n        return out.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        return \"\";\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"dtrace\";\r\n    }\r\n\r\n    public String observations(ProgramRun run) {\r\n        OutputBuffer out = new OutputBuffer();\r\n        Event previousEvent = null;\r\n        Event event = Const.INITIAL_STATE;\r\n        for (Iterator<Event> ei = run.iterator(); ei.hasNext(); ) {\r\n            previousEvent = event;\r\n            event = ei.next();\r\n            if (simple) {\r\n                simplePoint(event, \"10\", out);\r\n                continue;\r\n            }\r\n            if ((inputs.contains(previousEvent.getName()) && inputs.contains(event.getName())) || (!previousEvent.isExit() && event.isExit() && (previousEvent.getName() + \"_EXIT\").equals(event.getName()))) {\r\n                point(previousEvent.getName(), previousEvent, \"11\", out);\r\n            }\r\n            if (previousEvent.isExit()) {\r\n                //this is needed for return value assertion\r\n                point(previousEvent.getName(), previousEvent, \"22\", out);\r\n            } else {\r\n                //this is needed for transition conditions\r\n                if (inputs.contains(previousEvent.getName()) && !inputs.contains(event.getName()) && !previousEvent.isExit() && !event.isExit()) {\r\n                    String name = previousEvent.getName() + \",\" + event.getName();\r\n                    point(name, previousEvent, \"22\", out);\r\n                }\r\n            }\r\n            //      if (inputs.contains(event.getName())) {\r\n            //        point(event.getName(), event, \"11\", out);\r\n            //      }\r\n        }\r\n        //    System.out.println(\"last event:\"+event.getName());\r\n        //this is here since up above only previous events are logged, this can lead to losing the last event\r\n        if (!simple) {\r\n            if (inputs.contains(event.getName()) || event.isExit()) {\r\n                point(event.getName(), event, \"11\", out);\r\n            }\r\n        }\r\n        return out.toString();\r\n    }\r\n\r\n    private void simplePoint(Event event, String comparability, OutputBuffer out) {\r\n        String name = event.getName();\r\n        name = name.replace(' ', '_');\r\n        if (!event.isExit()) {\r\n            name += \":::ENTER\";\r\n        } else {\r\n            //for some reason daikon seems to insist on having the line numbers here.. otherwise you get a complaint about combined points?\r\n            name += \":::EXIT1\";\r\n        }\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void point(String name, Event event, String comparability, OutputBuffer out) {\r\n        name = name.replace(' ', '_');\r\n        name += \":::ENTER\";\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void declarations(Event event, String eventName, OutputBuffer out, String comparability) {\r\n        if (declarations.contains(eventName)) {\r\n            return;\r\n        }\r\n        declarations.add(eventName);\r\n        out.append(\"\");\r\n        out.append(\"ppt \" + eventName);\r\n        if (event.isExit()) {\r\n            out.append(\"ppt-type exit\");\r\n        } else {\r\n            out.append(\"ppt-type enter\");\r\n        }\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(\"  variable \" + attribute.getName() + \"[]\");\r\n                out.append(\"    var-kind array\");\r\n            } else {\r\n                out.append(\"  variable \" + attribute.getName());\r\n                out.append(\"    var-kind variable\");\r\n            }\r\n            out.append(\"    dec-type \" + attribute.getType());\r\n            out.append(\"    rep-type \" + attribute.getType());\r\n            out.append(\"    comparability \" + comparability);\r\n        }\r\n    }\r\n\r\n    private void attributes(Event event, OutputBuffer out) {\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(attribute.getName() + \"[]\");\r\n            } else {\r\n                out.append(attribute.getName());\r\n            }\r\n            if (attribute.getType().equals(EventAttribute.TYPE_STRING)) {\r\n                //daikon log requires surrounding string values with double quotes\r\n                out.append('\"' + attribute.getValue() + '\"');\r\n            } else {\r\n                out.append(attribute.getValue());\r\n            }\r\n            out.append(\"1\");\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/DaikonFormatter_0Test.java",
		"test_prompt": "// DaikonFormatter_0Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.*;\nimport fi.vtt.noen.testgen.model.Const;\nimport fi.vtt.noen.testgen.Main;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Properties;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.FileInputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonFormatter}.\n* It contains ten unit test cases for the {@link DaikonFormatter#inputs()} method.\n*/\nclass DaikonFormatter_0Test {"
	},
	{
		"original_code": "// DaikonFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.*;\r\nimport fi.vtt.noen.testgen.model.Const;\r\nimport fi.vtt.noen.testgen.Main;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\nimport java.util.HashSet;\r\nimport java.util.Collection;\r\nimport java.util.Properties;\r\nimport java.util.ArrayList;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.FileInputStream;\r\n\r\n/**\r\n * Produces a log file in Daikon format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonFormatter extends BasicFormatter {\r\n\r\n    private Set<String> declarations = new HashSet<String>();\r\n\r\n    private boolean simple = false;\r\n\r\n    private final Collection<String> inputs;\r\n\r\n    //private final Collection<Class> inputs;\r\n    //private final Collection<Class> outputs;\r\n    public DaikonFormatter(String fileName, boolean simple) throws IOException {\r\n        super(fileName);\r\n        this.simple = simple;\r\n        if (simple) {\r\n            inputs = null;\r\n            return;\r\n        }\r\n        try {\r\n            inputs = InterfaceParser.methodNames(inputs());\r\n            System.out.println(\"inputs:\" + inputs);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            throw new RuntimeException(\"failed to load input and output interface definitions for daikon formatter\", e);\r\n        }\r\n    }\r\n\r\n    public DaikonFormatter(String fileName, Collection<String> inputs) throws IOException {\r\n        super(fileName);\r\n        this.inputs = inputs;\r\n        System.out.println(\"inputs:\" + inputs);\r\n    }\r\n\r\n    private static Class classForProperty(String property) throws Exception {\r\n        Properties configuration = new Properties();\r\n        configuration.load(new FileInputStream(\"testgen.properties\"));\r\n        String className = configuration.getProperty(property);\r\n        if (className == null) {\r\n            return null;\r\n        }\r\n        System.out.println(\"creating class for:\" + className);\r\n        return Class.forName(className);\r\n    }\r\n\r\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\r\n        Collection<Class> classes = new ArrayList<Class>();\r\n        int index = 1;\r\n        while (true) {\r\n            Class clazz = classForProperty(prefix + index);\r\n            index++;\r\n            if (clazz == null) {\r\n                break;\r\n            }\r\n            classes.add(clazz);\r\n        }\r\n        return classes;\r\n    }\r\n\r\n    public static Collection<Class> inputs() throws Exception {\r\n        return classesForMultipleProperties(\"InputInterface\");\r\n    }\r\n\r\n    public static Collection<Class> outputs() throws Exception {\r\n        return classesForMultipleProperties(\"OutputInterface\");\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"decl-version 2.0\");\r\n        out.append(\"var-comparability implicit\");\r\n        return out.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        return \"\";\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"dtrace\";\r\n    }\r\n\r\n    public String observations(ProgramRun run) {\r\n        OutputBuffer out = new OutputBuffer();\r\n        Event previousEvent = null;\r\n        Event event = Const.INITIAL_STATE;\r\n        for (Iterator<Event> ei = run.iterator(); ei.hasNext(); ) {\r\n            previousEvent = event;\r\n            event = ei.next();\r\n            if (simple) {\r\n                simplePoint(event, \"10\", out);\r\n                continue;\r\n            }\r\n            if ((inputs.contains(previousEvent.getName()) && inputs.contains(event.getName())) || (!previousEvent.isExit() && event.isExit() && (previousEvent.getName() + \"_EXIT\").equals(event.getName()))) {\r\n                point(previousEvent.getName(), previousEvent, \"11\", out);\r\n            }\r\n            if (previousEvent.isExit()) {\r\n                //this is needed for return value assertion\r\n                point(previousEvent.getName(), previousEvent, \"22\", out);\r\n            } else {\r\n                //this is needed for transition conditions\r\n                if (inputs.contains(previousEvent.getName()) && !inputs.contains(event.getName()) && !previousEvent.isExit() && !event.isExit()) {\r\n                    String name = previousEvent.getName() + \",\" + event.getName();\r\n                    point(name, previousEvent, \"22\", out);\r\n                }\r\n            }\r\n            //      if (inputs.contains(event.getName())) {\r\n            //        point(event.getName(), event, \"11\", out);\r\n            //      }\r\n        }\r\n        //    System.out.println(\"last event:\"+event.getName());\r\n        //this is here since up above only previous events are logged, this can lead to losing the last event\r\n        if (!simple) {\r\n            if (inputs.contains(event.getName()) || event.isExit()) {\r\n                point(event.getName(), event, \"11\", out);\r\n            }\r\n        }\r\n        return out.toString();\r\n    }\r\n\r\n    private void simplePoint(Event event, String comparability, OutputBuffer out) {\r\n        String name = event.getName();\r\n        name = name.replace(' ', '_');\r\n        if (!event.isExit()) {\r\n            name += \":::ENTER\";\r\n        } else {\r\n            //for some reason daikon seems to insist on having the line numbers here.. otherwise you get a complaint about combined points?\r\n            name += \":::EXIT1\";\r\n        }\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void point(String name, Event event, String comparability, OutputBuffer out) {\r\n        name = name.replace(' ', '_');\r\n        name += \":::ENTER\";\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void declarations(Event event, String eventName, OutputBuffer out, String comparability) {\r\n        if (declarations.contains(eventName)) {\r\n            return;\r\n        }\r\n        declarations.add(eventName);\r\n        out.append(\"\");\r\n        out.append(\"ppt \" + eventName);\r\n        if (event.isExit()) {\r\n            out.append(\"ppt-type exit\");\r\n        } else {\r\n            out.append(\"ppt-type enter\");\r\n        }\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(\"  variable \" + attribute.getName() + \"[]\");\r\n                out.append(\"    var-kind array\");\r\n            } else {\r\n                out.append(\"  variable \" + attribute.getName());\r\n                out.append(\"    var-kind variable\");\r\n            }\r\n            out.append(\"    dec-type \" + attribute.getType());\r\n            out.append(\"    rep-type \" + attribute.getType());\r\n            out.append(\"    comparability \" + comparability);\r\n        }\r\n    }\r\n\r\n    private void attributes(Event event, OutputBuffer out) {\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(attribute.getName() + \"[]\");\r\n            } else {\r\n                out.append(attribute.getName());\r\n            }\r\n            if (attribute.getType().equals(EventAttribute.TYPE_STRING)) {\r\n                //daikon log requires surrounding string values with double quotes\r\n                out.append('\"' + attribute.getValue() + '\"');\r\n            } else {\r\n                out.append(attribute.getValue());\r\n            }\r\n            out.append(\"1\");\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/DaikonFormatter_1Test.java",
		"test_prompt": "// DaikonFormatter_1Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.*;\nimport fi.vtt.noen.testgen.model.Const;\nimport fi.vtt.noen.testgen.Main;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Properties;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.FileInputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonFormatter}.\n* It contains ten unit test cases for the {@link DaikonFormatter#outputs()} method.\n*/\nclass DaikonFormatter_1Test {"
	},
	{
		"original_code": "// DaikonFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.*;\r\nimport fi.vtt.noen.testgen.model.Const;\r\nimport fi.vtt.noen.testgen.Main;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\nimport java.util.HashSet;\r\nimport java.util.Collection;\r\nimport java.util.Properties;\r\nimport java.util.ArrayList;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.FileInputStream;\r\n\r\n/**\r\n * Produces a log file in Daikon format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonFormatter extends BasicFormatter {\r\n\r\n    private Set<String> declarations = new HashSet<String>();\r\n\r\n    private boolean simple = false;\r\n\r\n    private final Collection<String> inputs;\r\n\r\n    //private final Collection<Class> inputs;\r\n    //private final Collection<Class> outputs;\r\n    public DaikonFormatter(String fileName, boolean simple) throws IOException {\r\n        super(fileName);\r\n        this.simple = simple;\r\n        if (simple) {\r\n            inputs = null;\r\n            return;\r\n        }\r\n        try {\r\n            inputs = InterfaceParser.methodNames(inputs());\r\n            System.out.println(\"inputs:\" + inputs);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            throw new RuntimeException(\"failed to load input and output interface definitions for daikon formatter\", e);\r\n        }\r\n    }\r\n\r\n    public DaikonFormatter(String fileName, Collection<String> inputs) throws IOException {\r\n        super(fileName);\r\n        this.inputs = inputs;\r\n        System.out.println(\"inputs:\" + inputs);\r\n    }\r\n\r\n    private static Class classForProperty(String property) throws Exception {\r\n        Properties configuration = new Properties();\r\n        configuration.load(new FileInputStream(\"testgen.properties\"));\r\n        String className = configuration.getProperty(property);\r\n        if (className == null) {\r\n            return null;\r\n        }\r\n        System.out.println(\"creating class for:\" + className);\r\n        return Class.forName(className);\r\n    }\r\n\r\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\r\n        Collection<Class> classes = new ArrayList<Class>();\r\n        int index = 1;\r\n        while (true) {\r\n            Class clazz = classForProperty(prefix + index);\r\n            index++;\r\n            if (clazz == null) {\r\n                break;\r\n            }\r\n            classes.add(clazz);\r\n        }\r\n        return classes;\r\n    }\r\n\r\n    public static Collection<Class> inputs() throws Exception {\r\n        return classesForMultipleProperties(\"InputInterface\");\r\n    }\r\n\r\n    public static Collection<Class> outputs() throws Exception {\r\n        return classesForMultipleProperties(\"OutputInterface\");\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"decl-version 2.0\");\r\n        out.append(\"var-comparability implicit\");\r\n        return out.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        return \"\";\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"dtrace\";\r\n    }\r\n\r\n    public String observations(ProgramRun run) {\r\n        OutputBuffer out = new OutputBuffer();\r\n        Event previousEvent = null;\r\n        Event event = Const.INITIAL_STATE;\r\n        for (Iterator<Event> ei = run.iterator(); ei.hasNext(); ) {\r\n            previousEvent = event;\r\n            event = ei.next();\r\n            if (simple) {\r\n                simplePoint(event, \"10\", out);\r\n                continue;\r\n            }\r\n            if ((inputs.contains(previousEvent.getName()) && inputs.contains(event.getName())) || (!previousEvent.isExit() && event.isExit() && (previousEvent.getName() + \"_EXIT\").equals(event.getName()))) {\r\n                point(previousEvent.getName(), previousEvent, \"11\", out);\r\n            }\r\n            if (previousEvent.isExit()) {\r\n                //this is needed for return value assertion\r\n                point(previousEvent.getName(), previousEvent, \"22\", out);\r\n            } else {\r\n                //this is needed for transition conditions\r\n                if (inputs.contains(previousEvent.getName()) && !inputs.contains(event.getName()) && !previousEvent.isExit() && !event.isExit()) {\r\n                    String name = previousEvent.getName() + \",\" + event.getName();\r\n                    point(name, previousEvent, \"22\", out);\r\n                }\r\n            }\r\n            //      if (inputs.contains(event.getName())) {\r\n            //        point(event.getName(), event, \"11\", out);\r\n            //      }\r\n        }\r\n        //    System.out.println(\"last event:\"+event.getName());\r\n        //this is here since up above only previous events are logged, this can lead to losing the last event\r\n        if (!simple) {\r\n            if (inputs.contains(event.getName()) || event.isExit()) {\r\n                point(event.getName(), event, \"11\", out);\r\n            }\r\n        }\r\n        return out.toString();\r\n    }\r\n\r\n    private void simplePoint(Event event, String comparability, OutputBuffer out) {\r\n        String name = event.getName();\r\n        name = name.replace(' ', '_');\r\n        if (!event.isExit()) {\r\n            name += \":::ENTER\";\r\n        } else {\r\n            //for some reason daikon seems to insist on having the line numbers here.. otherwise you get a complaint about combined points?\r\n            name += \":::EXIT1\";\r\n        }\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void point(String name, Event event, String comparability, OutputBuffer out) {\r\n        name = name.replace(' ', '_');\r\n        name += \":::ENTER\";\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void declarations(Event event, String eventName, OutputBuffer out, String comparability) {\r\n        if (declarations.contains(eventName)) {\r\n            return;\r\n        }\r\n        declarations.add(eventName);\r\n        out.append(\"\");\r\n        out.append(\"ppt \" + eventName);\r\n        if (event.isExit()) {\r\n            out.append(\"ppt-type exit\");\r\n        } else {\r\n            out.append(\"ppt-type enter\");\r\n        }\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(\"  variable \" + attribute.getName() + \"[]\");\r\n                out.append(\"    var-kind array\");\r\n            } else {\r\n                out.append(\"  variable \" + attribute.getName());\r\n                out.append(\"    var-kind variable\");\r\n            }\r\n            out.append(\"    dec-type \" + attribute.getType());\r\n            out.append(\"    rep-type \" + attribute.getType());\r\n            out.append(\"    comparability \" + comparability);\r\n        }\r\n    }\r\n\r\n    private void attributes(Event event, OutputBuffer out) {\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(attribute.getName() + \"[]\");\r\n            } else {\r\n                out.append(attribute.getName());\r\n            }\r\n            if (attribute.getType().equals(EventAttribute.TYPE_STRING)) {\r\n                //daikon log requires surrounding string values with double quotes\r\n                out.append('\"' + attribute.getValue() + '\"');\r\n            } else {\r\n                out.append(attribute.getValue());\r\n            }\r\n            out.append(\"1\");\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/DaikonFormatter_2Test.java",
		"test_prompt": "// DaikonFormatter_2Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.*;\nimport fi.vtt.noen.testgen.model.Const;\nimport fi.vtt.noen.testgen.Main;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Properties;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.FileInputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonFormatter}.\n* It contains ten unit test cases for the {@link DaikonFormatter#header()} method.\n*/\nclass DaikonFormatter_2Test {"
	},
	{
		"original_code": "// DaikonFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.*;\r\nimport fi.vtt.noen.testgen.model.Const;\r\nimport fi.vtt.noen.testgen.Main;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\nimport java.util.HashSet;\r\nimport java.util.Collection;\r\nimport java.util.Properties;\r\nimport java.util.ArrayList;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.FileInputStream;\r\n\r\n/**\r\n * Produces a log file in Daikon format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonFormatter extends BasicFormatter {\r\n\r\n    private Set<String> declarations = new HashSet<String>();\r\n\r\n    private boolean simple = false;\r\n\r\n    private final Collection<String> inputs;\r\n\r\n    //private final Collection<Class> inputs;\r\n    //private final Collection<Class> outputs;\r\n    public DaikonFormatter(String fileName, boolean simple) throws IOException {\r\n        super(fileName);\r\n        this.simple = simple;\r\n        if (simple) {\r\n            inputs = null;\r\n            return;\r\n        }\r\n        try {\r\n            inputs = InterfaceParser.methodNames(inputs());\r\n            System.out.println(\"inputs:\" + inputs);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            throw new RuntimeException(\"failed to load input and output interface definitions for daikon formatter\", e);\r\n        }\r\n    }\r\n\r\n    public DaikonFormatter(String fileName, Collection<String> inputs) throws IOException {\r\n        super(fileName);\r\n        this.inputs = inputs;\r\n        System.out.println(\"inputs:\" + inputs);\r\n    }\r\n\r\n    private static Class classForProperty(String property) throws Exception {\r\n        Properties configuration = new Properties();\r\n        configuration.load(new FileInputStream(\"testgen.properties\"));\r\n        String className = configuration.getProperty(property);\r\n        if (className == null) {\r\n            return null;\r\n        }\r\n        System.out.println(\"creating class for:\" + className);\r\n        return Class.forName(className);\r\n    }\r\n\r\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\r\n        Collection<Class> classes = new ArrayList<Class>();\r\n        int index = 1;\r\n        while (true) {\r\n            Class clazz = classForProperty(prefix + index);\r\n            index++;\r\n            if (clazz == null) {\r\n                break;\r\n            }\r\n            classes.add(clazz);\r\n        }\r\n        return classes;\r\n    }\r\n\r\n    public static Collection<Class> inputs() throws Exception {\r\n        return classesForMultipleProperties(\"InputInterface\");\r\n    }\r\n\r\n    public static Collection<Class> outputs() throws Exception {\r\n        return classesForMultipleProperties(\"OutputInterface\");\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"decl-version 2.0\");\r\n        out.append(\"var-comparability implicit\");\r\n        return out.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        return \"\";\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"dtrace\";\r\n    }\r\n\r\n    public String observations(ProgramRun run) {\r\n        OutputBuffer out = new OutputBuffer();\r\n        Event previousEvent = null;\r\n        Event event = Const.INITIAL_STATE;\r\n        for (Iterator<Event> ei = run.iterator(); ei.hasNext(); ) {\r\n            previousEvent = event;\r\n            event = ei.next();\r\n            if (simple) {\r\n                simplePoint(event, \"10\", out);\r\n                continue;\r\n            }\r\n            if ((inputs.contains(previousEvent.getName()) && inputs.contains(event.getName())) || (!previousEvent.isExit() && event.isExit() && (previousEvent.getName() + \"_EXIT\").equals(event.getName()))) {\r\n                point(previousEvent.getName(), previousEvent, \"11\", out);\r\n            }\r\n            if (previousEvent.isExit()) {\r\n                //this is needed for return value assertion\r\n                point(previousEvent.getName(), previousEvent, \"22\", out);\r\n            } else {\r\n                //this is needed for transition conditions\r\n                if (inputs.contains(previousEvent.getName()) && !inputs.contains(event.getName()) && !previousEvent.isExit() && !event.isExit()) {\r\n                    String name = previousEvent.getName() + \",\" + event.getName();\r\n                    point(name, previousEvent, \"22\", out);\r\n                }\r\n            }\r\n            //      if (inputs.contains(event.getName())) {\r\n            //        point(event.getName(), event, \"11\", out);\r\n            //      }\r\n        }\r\n        //    System.out.println(\"last event:\"+event.getName());\r\n        //this is here since up above only previous events are logged, this can lead to losing the last event\r\n        if (!simple) {\r\n            if (inputs.contains(event.getName()) || event.isExit()) {\r\n                point(event.getName(), event, \"11\", out);\r\n            }\r\n        }\r\n        return out.toString();\r\n    }\r\n\r\n    private void simplePoint(Event event, String comparability, OutputBuffer out) {\r\n        String name = event.getName();\r\n        name = name.replace(' ', '_');\r\n        if (!event.isExit()) {\r\n            name += \":::ENTER\";\r\n        } else {\r\n            //for some reason daikon seems to insist on having the line numbers here.. otherwise you get a complaint about combined points?\r\n            name += \":::EXIT1\";\r\n        }\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void point(String name, Event event, String comparability, OutputBuffer out) {\r\n        name = name.replace(' ', '_');\r\n        name += \":::ENTER\";\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void declarations(Event event, String eventName, OutputBuffer out, String comparability) {\r\n        if (declarations.contains(eventName)) {\r\n            return;\r\n        }\r\n        declarations.add(eventName);\r\n        out.append(\"\");\r\n        out.append(\"ppt \" + eventName);\r\n        if (event.isExit()) {\r\n            out.append(\"ppt-type exit\");\r\n        } else {\r\n            out.append(\"ppt-type enter\");\r\n        }\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(\"  variable \" + attribute.getName() + \"[]\");\r\n                out.append(\"    var-kind array\");\r\n            } else {\r\n                out.append(\"  variable \" + attribute.getName());\r\n                out.append(\"    var-kind variable\");\r\n            }\r\n            out.append(\"    dec-type \" + attribute.getType());\r\n            out.append(\"    rep-type \" + attribute.getType());\r\n            out.append(\"    comparability \" + comparability);\r\n        }\r\n    }\r\n\r\n    private void attributes(Event event, OutputBuffer out) {\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(attribute.getName() + \"[]\");\r\n            } else {\r\n                out.append(attribute.getName());\r\n            }\r\n            if (attribute.getType().equals(EventAttribute.TYPE_STRING)) {\r\n                //daikon log requires surrounding string values with double quotes\r\n                out.append('\"' + attribute.getValue() + '\"');\r\n            } else {\r\n                out.append(attribute.getValue());\r\n            }\r\n            out.append(\"1\");\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/DaikonFormatter_3Test.java",
		"test_prompt": "// DaikonFormatter_3Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.*;\nimport fi.vtt.noen.testgen.model.Const;\nimport fi.vtt.noen.testgen.Main;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Properties;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.FileInputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonFormatter}.\n* It contains ten unit test cases for the {@link DaikonFormatter#footer()} method.\n*/\nclass DaikonFormatter_3Test {"
	},
	{
		"original_code": "// DaikonFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.*;\r\nimport fi.vtt.noen.testgen.model.Const;\r\nimport fi.vtt.noen.testgen.Main;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\nimport java.util.HashSet;\r\nimport java.util.Collection;\r\nimport java.util.Properties;\r\nimport java.util.ArrayList;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.FileInputStream;\r\n\r\n/**\r\n * Produces a log file in Daikon format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonFormatter extends BasicFormatter {\r\n\r\n    private Set<String> declarations = new HashSet<String>();\r\n\r\n    private boolean simple = false;\r\n\r\n    private final Collection<String> inputs;\r\n\r\n    //private final Collection<Class> inputs;\r\n    //private final Collection<Class> outputs;\r\n    public DaikonFormatter(String fileName, boolean simple) throws IOException {\r\n        super(fileName);\r\n        this.simple = simple;\r\n        if (simple) {\r\n            inputs = null;\r\n            return;\r\n        }\r\n        try {\r\n            inputs = InterfaceParser.methodNames(inputs());\r\n            System.out.println(\"inputs:\" + inputs);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            throw new RuntimeException(\"failed to load input and output interface definitions for daikon formatter\", e);\r\n        }\r\n    }\r\n\r\n    public DaikonFormatter(String fileName, Collection<String> inputs) throws IOException {\r\n        super(fileName);\r\n        this.inputs = inputs;\r\n        System.out.println(\"inputs:\" + inputs);\r\n    }\r\n\r\n    private static Class classForProperty(String property) throws Exception {\r\n        Properties configuration = new Properties();\r\n        configuration.load(new FileInputStream(\"testgen.properties\"));\r\n        String className = configuration.getProperty(property);\r\n        if (className == null) {\r\n            return null;\r\n        }\r\n        System.out.println(\"creating class for:\" + className);\r\n        return Class.forName(className);\r\n    }\r\n\r\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\r\n        Collection<Class> classes = new ArrayList<Class>();\r\n        int index = 1;\r\n        while (true) {\r\n            Class clazz = classForProperty(prefix + index);\r\n            index++;\r\n            if (clazz == null) {\r\n                break;\r\n            }\r\n            classes.add(clazz);\r\n        }\r\n        return classes;\r\n    }\r\n\r\n    public static Collection<Class> inputs() throws Exception {\r\n        return classesForMultipleProperties(\"InputInterface\");\r\n    }\r\n\r\n    public static Collection<Class> outputs() throws Exception {\r\n        return classesForMultipleProperties(\"OutputInterface\");\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"decl-version 2.0\");\r\n        out.append(\"var-comparability implicit\");\r\n        return out.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        return \"\";\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"dtrace\";\r\n    }\r\n\r\n    public String observations(ProgramRun run) {\r\n        OutputBuffer out = new OutputBuffer();\r\n        Event previousEvent = null;\r\n        Event event = Const.INITIAL_STATE;\r\n        for (Iterator<Event> ei = run.iterator(); ei.hasNext(); ) {\r\n            previousEvent = event;\r\n            event = ei.next();\r\n            if (simple) {\r\n                simplePoint(event, \"10\", out);\r\n                continue;\r\n            }\r\n            if ((inputs.contains(previousEvent.getName()) && inputs.contains(event.getName())) || (!previousEvent.isExit() && event.isExit() && (previousEvent.getName() + \"_EXIT\").equals(event.getName()))) {\r\n                point(previousEvent.getName(), previousEvent, \"11\", out);\r\n            }\r\n            if (previousEvent.isExit()) {\r\n                //this is needed for return value assertion\r\n                point(previousEvent.getName(), previousEvent, \"22\", out);\r\n            } else {\r\n                //this is needed for transition conditions\r\n                if (inputs.contains(previousEvent.getName()) && !inputs.contains(event.getName()) && !previousEvent.isExit() && !event.isExit()) {\r\n                    String name = previousEvent.getName() + \",\" + event.getName();\r\n                    point(name, previousEvent, \"22\", out);\r\n                }\r\n            }\r\n            //      if (inputs.contains(event.getName())) {\r\n            //        point(event.getName(), event, \"11\", out);\r\n            //      }\r\n        }\r\n        //    System.out.println(\"last event:\"+event.getName());\r\n        //this is here since up above only previous events are logged, this can lead to losing the last event\r\n        if (!simple) {\r\n            if (inputs.contains(event.getName()) || event.isExit()) {\r\n                point(event.getName(), event, \"11\", out);\r\n            }\r\n        }\r\n        return out.toString();\r\n    }\r\n\r\n    private void simplePoint(Event event, String comparability, OutputBuffer out) {\r\n        String name = event.getName();\r\n        name = name.replace(' ', '_');\r\n        if (!event.isExit()) {\r\n            name += \":::ENTER\";\r\n        } else {\r\n            //for some reason daikon seems to insist on having the line numbers here.. otherwise you get a complaint about combined points?\r\n            name += \":::EXIT1\";\r\n        }\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void point(String name, Event event, String comparability, OutputBuffer out) {\r\n        name = name.replace(' ', '_');\r\n        name += \":::ENTER\";\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void declarations(Event event, String eventName, OutputBuffer out, String comparability) {\r\n        if (declarations.contains(eventName)) {\r\n            return;\r\n        }\r\n        declarations.add(eventName);\r\n        out.append(\"\");\r\n        out.append(\"ppt \" + eventName);\r\n        if (event.isExit()) {\r\n            out.append(\"ppt-type exit\");\r\n        } else {\r\n            out.append(\"ppt-type enter\");\r\n        }\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(\"  variable \" + attribute.getName() + \"[]\");\r\n                out.append(\"    var-kind array\");\r\n            } else {\r\n                out.append(\"  variable \" + attribute.getName());\r\n                out.append(\"    var-kind variable\");\r\n            }\r\n            out.append(\"    dec-type \" + attribute.getType());\r\n            out.append(\"    rep-type \" + attribute.getType());\r\n            out.append(\"    comparability \" + comparability);\r\n        }\r\n    }\r\n\r\n    private void attributes(Event event, OutputBuffer out) {\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(attribute.getName() + \"[]\");\r\n            } else {\r\n                out.append(attribute.getName());\r\n            }\r\n            if (attribute.getType().equals(EventAttribute.TYPE_STRING)) {\r\n                //daikon log requires surrounding string values with double quotes\r\n                out.append('\"' + attribute.getValue() + '\"');\r\n            } else {\r\n                out.append(attribute.getValue());\r\n            }\r\n            out.append(\"1\");\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/DaikonFormatter_4Test.java",
		"test_prompt": "// DaikonFormatter_4Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.*;\nimport fi.vtt.noen.testgen.model.Const;\nimport fi.vtt.noen.testgen.Main;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Properties;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.FileInputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonFormatter}.\n* It contains ten unit test cases for the {@link DaikonFormatter#fileNameExtension()} method.\n*/\nclass DaikonFormatter_4Test {"
	},
	{
		"original_code": "// DaikonFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.*;\r\nimport fi.vtt.noen.testgen.model.Const;\r\nimport fi.vtt.noen.testgen.Main;\r\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\r\nimport java.util.Iterator;\r\nimport java.util.Set;\r\nimport java.util.HashSet;\r\nimport java.util.Collection;\r\nimport java.util.Properties;\r\nimport java.util.ArrayList;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\nimport java.io.FileInputStream;\r\n\r\n/**\r\n * Produces a log file in Daikon format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DaikonFormatter extends BasicFormatter {\r\n\r\n    private Set<String> declarations = new HashSet<String>();\r\n\r\n    private boolean simple = false;\r\n\r\n    private final Collection<String> inputs;\r\n\r\n    //private final Collection<Class> inputs;\r\n    //private final Collection<Class> outputs;\r\n    public DaikonFormatter(String fileName, boolean simple) throws IOException {\r\n        super(fileName);\r\n        this.simple = simple;\r\n        if (simple) {\r\n            inputs = null;\r\n            return;\r\n        }\r\n        try {\r\n            inputs = InterfaceParser.methodNames(inputs());\r\n            System.out.println(\"inputs:\" + inputs);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            throw new RuntimeException(\"failed to load input and output interface definitions for daikon formatter\", e);\r\n        }\r\n    }\r\n\r\n    public DaikonFormatter(String fileName, Collection<String> inputs) throws IOException {\r\n        super(fileName);\r\n        this.inputs = inputs;\r\n        System.out.println(\"inputs:\" + inputs);\r\n    }\r\n\r\n    private static Class classForProperty(String property) throws Exception {\r\n        Properties configuration = new Properties();\r\n        configuration.load(new FileInputStream(\"testgen.properties\"));\r\n        String className = configuration.getProperty(property);\r\n        if (className == null) {\r\n            return null;\r\n        }\r\n        System.out.println(\"creating class for:\" + className);\r\n        return Class.forName(className);\r\n    }\r\n\r\n    private static Collection<Class> classesForMultipleProperties(String prefix) throws Exception {\r\n        Collection<Class> classes = new ArrayList<Class>();\r\n        int index = 1;\r\n        while (true) {\r\n            Class clazz = classForProperty(prefix + index);\r\n            index++;\r\n            if (clazz == null) {\r\n                break;\r\n            }\r\n            classes.add(clazz);\r\n        }\r\n        return classes;\r\n    }\r\n\r\n    public static Collection<Class> inputs() throws Exception {\r\n        return classesForMultipleProperties(\"InputInterface\");\r\n    }\r\n\r\n    public static Collection<Class> outputs() throws Exception {\r\n        return classesForMultipleProperties(\"OutputInterface\");\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"decl-version 2.0\");\r\n        out.append(\"var-comparability implicit\");\r\n        return out.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        return \"\";\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"dtrace\";\r\n    }\r\n\r\n    public String observations(ProgramRun run) {\r\n        OutputBuffer out = new OutputBuffer();\r\n        Event previousEvent = null;\r\n        Event event = Const.INITIAL_STATE;\r\n        for (Iterator<Event> ei = run.iterator(); ei.hasNext(); ) {\r\n            previousEvent = event;\r\n            event = ei.next();\r\n            if (simple) {\r\n                simplePoint(event, \"10\", out);\r\n                continue;\r\n            }\r\n            if ((inputs.contains(previousEvent.getName()) && inputs.contains(event.getName())) || (!previousEvent.isExit() && event.isExit() && (previousEvent.getName() + \"_EXIT\").equals(event.getName()))) {\r\n                point(previousEvent.getName(), previousEvent, \"11\", out);\r\n            }\r\n            if (previousEvent.isExit()) {\r\n                //this is needed for return value assertion\r\n                point(previousEvent.getName(), previousEvent, \"22\", out);\r\n            } else {\r\n                //this is needed for transition conditions\r\n                if (inputs.contains(previousEvent.getName()) && !inputs.contains(event.getName()) && !previousEvent.isExit() && !event.isExit()) {\r\n                    String name = previousEvent.getName() + \",\" + event.getName();\r\n                    point(name, previousEvent, \"22\", out);\r\n                }\r\n            }\r\n            //      if (inputs.contains(event.getName())) {\r\n            //        point(event.getName(), event, \"11\", out);\r\n            //      }\r\n        }\r\n        //    System.out.println(\"last event:\"+event.getName());\r\n        //this is here since up above only previous events are logged, this can lead to losing the last event\r\n        if (!simple) {\r\n            if (inputs.contains(event.getName()) || event.isExit()) {\r\n                point(event.getName(), event, \"11\", out);\r\n            }\r\n        }\r\n        return out.toString();\r\n    }\r\n\r\n    private void simplePoint(Event event, String comparability, OutputBuffer out) {\r\n        String name = event.getName();\r\n        name = name.replace(' ', '_');\r\n        if (!event.isExit()) {\r\n            name += \":::ENTER\";\r\n        } else {\r\n            //for some reason daikon seems to insist on having the line numbers here.. otherwise you get a complaint about combined points?\r\n            name += \":::EXIT1\";\r\n        }\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void point(String name, Event event, String comparability, OutputBuffer out) {\r\n        name = name.replace(' ', '_');\r\n        name += \":::ENTER\";\r\n        declarations(event, name, out, comparability);\r\n        out.append(\"\");\r\n        out.append(name);\r\n        attributes(event, out);\r\n    }\r\n\r\n    private void declarations(Event event, String eventName, OutputBuffer out, String comparability) {\r\n        if (declarations.contains(eventName)) {\r\n            return;\r\n        }\r\n        declarations.add(eventName);\r\n        out.append(\"\");\r\n        out.append(\"ppt \" + eventName);\r\n        if (event.isExit()) {\r\n            out.append(\"ppt-type exit\");\r\n        } else {\r\n            out.append(\"ppt-type enter\");\r\n        }\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(\"  variable \" + attribute.getName() + \"[]\");\r\n                out.append(\"    var-kind array\");\r\n            } else {\r\n                out.append(\"  variable \" + attribute.getName());\r\n                out.append(\"    var-kind variable\");\r\n            }\r\n            out.append(\"    dec-type \" + attribute.getType());\r\n            out.append(\"    rep-type \" + attribute.getType());\r\n            out.append(\"    comparability \" + comparability);\r\n        }\r\n    }\r\n\r\n    private void attributes(Event event, OutputBuffer out) {\r\n        for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n            EventAttribute attribute = ai.next();\r\n            if (attribute instanceof ArrayAttribute) {\r\n                out.append(attribute.getName() + \"[]\");\r\n            } else {\r\n                out.append(attribute.getName());\r\n            }\r\n            if (attribute.getType().equals(EventAttribute.TYPE_STRING)) {\r\n                //daikon log requires surrounding string values with double quotes\r\n                out.append('\"' + attribute.getValue() + '\"');\r\n            } else {\r\n                out.append(attribute.getValue());\r\n            }\r\n            out.append(\"1\");\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/DaikonFormatter_5Test.java",
		"test_prompt": "// DaikonFormatter_5Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.*;\nimport fi.vtt.noen.testgen.model.Const;\nimport fi.vtt.noen.testgen.Main;\nimport fi.vtt.noen.testgen.parser.InterfaceParser;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Collection;\nimport java.util.Properties;\nimport java.util.ArrayList;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.FileInputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DaikonFormatter}.\n* It contains ten unit test cases for the {@link DaikonFormatter#observations(ProgramRun)} method.\n*/\nclass DaikonFormatter_5Test {"
	},
	{
		"original_code": "// PromFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.Event;\r\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\r\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\r\nimport java.util.Iterator;\r\nimport java.util.Date;\r\nimport java.util.GregorianCalendar;\r\nimport java.util.Calendar;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\n\r\n/**\r\n * Produces a log file in ProM format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class PromFormatter extends BasicFormatter {\r\n\r\n    private static int processId = 0;\r\n\r\n    public PromFormatter(OutputStream out) {\r\n        super(out);\r\n    }\r\n\r\n    public PromFormatter(String fileName) throws IOException {\r\n        super(fileName);\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"mxml\";\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n        buf.append(\"<WorkflowLog xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" + \"xsi:noNamespaceSchemaLocation=\\\"WorkflowLog.xsd\\\" description=\\\"Test data\\\">\");\r\n        buf.append(\"<Source program=\\\"Test suite for blaablaa\\\"/>\");\r\n        buf.append(\"<Process id=\\\"0\\\" description=\\\"test suite name\\\">\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String observations(ProgramRun test) {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<ProcessInstance id=\\\"\" + processId + \"\\\" description=\\\"\" + test.getName() + \"\\\">\");\r\n        processId++;\r\n        for (Iterator<Event> ei = test.iterator(); ei.hasNext(); ) {\r\n            Event event = ei.next();\r\n            buf.append(\"<AuditTrailEntry>\");\r\n            buf.append(\"<WorkflowModelElement>\" + event.getName() + \"</WorkflowModelElement>\");\r\n            if (event.isExit()) {\r\n                buf.append(\"<EventType>complete</EventType>\");\r\n            } else {\r\n                buf.append(\"<EventType>start</EventType>\");\r\n            }\r\n            //      if (false) { //this is used to disable attributes as PROM hangs on big log files and attributes are not used in PROM right now\r\n            if (event.attributes().hasNext()) {\r\n                buf.append(\"<Data>\");\r\n                for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n                    EventAttribute attribute = ai.next();\r\n                    buf.append(\"<Attribute name=\\\"\" + attribute.getName() + \"\\\">\" + attribute.getValue() + \"</Attribute>\");\r\n                }\r\n                buf.append(\"</Data>\");\r\n            }\r\n            //XPROM modification\r\n            buf.append(\"<Timestamp>\" + formatTime(event) + \"</Timestamp>\");\r\n            //      buf.append(\"<Timestamp>2008-01-02T12:23:00.000</Timestamp>\");\r\n            buf.append(\"</AuditTrailEntry>\");\r\n        }\r\n        buf.append(\"</ProcessInstance>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    private String formatTime(Event event) {\r\n        Date time = event.getTime();\r\n        if (testMode) {\r\n            time = new Date(0);\r\n        }\r\n        GregorianCalendar calendar = new GregorianCalendar();\r\n        calendar.setTime(time);\r\n        String format = \"\" + calendar.get(Calendar.YEAR);\r\n        format += \"-\" + doubleDigit(calendar.get(Calendar.MONTH) + 1);\r\n        format += \"-\" + doubleDigit(calendar.get(Calendar.DAY_OF_MONTH));\r\n        format += \"T\" + calendar.get(Calendar.HOUR_OF_DAY);\r\n        format += \":\" + calendar.get(Calendar.MINUTE);\r\n        format += \":\" + calendar.get(Calendar.SECOND);\r\n        format += \".\" + calendar.get(Calendar.MILLISECOND);\r\n        return format;\r\n    }\r\n\r\n    private String doubleDigit(int digit) {\r\n        String str = \"\" + digit;\r\n        if (str.length() == 1) {\r\n            str = \"0\" + str;\r\n        }\r\n        return str;\r\n    }\r\n\r\n    public String footer() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"</Process>\");\r\n        buf.append(\"</WorkflowLog>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    /*\r\n  public String format(ProgramRunSuite suite) {\r\n    String result = header();\r\n    for (Iterator<ProgramRun> i = suite.iterator(); i.hasNext();) {\r\n      ProgramRun test = i.next();\r\n      result += observations(test);\r\n    }\r\n    result += footer();\r\n    return result;\r\n  }\r\n*/\r\n    public static void reset() {\r\n        processId = 0;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/PromFormatter_0Test.java",
		"test_prompt": "// PromFormatter_0Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.Event;\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\nimport java.util.Iterator;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Calendar;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PromFormatter}.\n* It contains ten unit test cases for the {@link PromFormatter#fileNameExtension()} method.\n*/\nclass PromFormatter_0Test {"
	},
	{
		"original_code": "// PromFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.Event;\r\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\r\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\r\nimport java.util.Iterator;\r\nimport java.util.Date;\r\nimport java.util.GregorianCalendar;\r\nimport java.util.Calendar;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\n\r\n/**\r\n * Produces a log file in ProM format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class PromFormatter extends BasicFormatter {\r\n\r\n    private static int processId = 0;\r\n\r\n    public PromFormatter(OutputStream out) {\r\n        super(out);\r\n    }\r\n\r\n    public PromFormatter(String fileName) throws IOException {\r\n        super(fileName);\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"mxml\";\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n        buf.append(\"<WorkflowLog xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" + \"xsi:noNamespaceSchemaLocation=\\\"WorkflowLog.xsd\\\" description=\\\"Test data\\\">\");\r\n        buf.append(\"<Source program=\\\"Test suite for blaablaa\\\"/>\");\r\n        buf.append(\"<Process id=\\\"0\\\" description=\\\"test suite name\\\">\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String observations(ProgramRun test) {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<ProcessInstance id=\\\"\" + processId + \"\\\" description=\\\"\" + test.getName() + \"\\\">\");\r\n        processId++;\r\n        for (Iterator<Event> ei = test.iterator(); ei.hasNext(); ) {\r\n            Event event = ei.next();\r\n            buf.append(\"<AuditTrailEntry>\");\r\n            buf.append(\"<WorkflowModelElement>\" + event.getName() + \"</WorkflowModelElement>\");\r\n            if (event.isExit()) {\r\n                buf.append(\"<EventType>complete</EventType>\");\r\n            } else {\r\n                buf.append(\"<EventType>start</EventType>\");\r\n            }\r\n            //      if (false) { //this is used to disable attributes as PROM hangs on big log files and attributes are not used in PROM right now\r\n            if (event.attributes().hasNext()) {\r\n                buf.append(\"<Data>\");\r\n                for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n                    EventAttribute attribute = ai.next();\r\n                    buf.append(\"<Attribute name=\\\"\" + attribute.getName() + \"\\\">\" + attribute.getValue() + \"</Attribute>\");\r\n                }\r\n                buf.append(\"</Data>\");\r\n            }\r\n            //XPROM modification\r\n            buf.append(\"<Timestamp>\" + formatTime(event) + \"</Timestamp>\");\r\n            //      buf.append(\"<Timestamp>2008-01-02T12:23:00.000</Timestamp>\");\r\n            buf.append(\"</AuditTrailEntry>\");\r\n        }\r\n        buf.append(\"</ProcessInstance>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    private String formatTime(Event event) {\r\n        Date time = event.getTime();\r\n        if (testMode) {\r\n            time = new Date(0);\r\n        }\r\n        GregorianCalendar calendar = new GregorianCalendar();\r\n        calendar.setTime(time);\r\n        String format = \"\" + calendar.get(Calendar.YEAR);\r\n        format += \"-\" + doubleDigit(calendar.get(Calendar.MONTH) + 1);\r\n        format += \"-\" + doubleDigit(calendar.get(Calendar.DAY_OF_MONTH));\r\n        format += \"T\" + calendar.get(Calendar.HOUR_OF_DAY);\r\n        format += \":\" + calendar.get(Calendar.MINUTE);\r\n        format += \":\" + calendar.get(Calendar.SECOND);\r\n        format += \".\" + calendar.get(Calendar.MILLISECOND);\r\n        return format;\r\n    }\r\n\r\n    private String doubleDigit(int digit) {\r\n        String str = \"\" + digit;\r\n        if (str.length() == 1) {\r\n            str = \"0\" + str;\r\n        }\r\n        return str;\r\n    }\r\n\r\n    public String footer() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"</Process>\");\r\n        buf.append(\"</WorkflowLog>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    /*\r\n  public String format(ProgramRunSuite suite) {\r\n    String result = header();\r\n    for (Iterator<ProgramRun> i = suite.iterator(); i.hasNext();) {\r\n      ProgramRun test = i.next();\r\n      result += observations(test);\r\n    }\r\n    result += footer();\r\n    return result;\r\n  }\r\n*/\r\n    public static void reset() {\r\n        processId = 0;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/PromFormatter_1Test.java",
		"test_prompt": "// PromFormatter_1Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.Event;\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\nimport java.util.Iterator;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Calendar;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PromFormatter}.\n* It contains ten unit test cases for the {@link PromFormatter#header()} method.\n*/\nclass PromFormatter_1Test {"
	},
	{
		"original_code": "// PromFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.Event;\r\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\r\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\r\nimport java.util.Iterator;\r\nimport java.util.Date;\r\nimport java.util.GregorianCalendar;\r\nimport java.util.Calendar;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\n\r\n/**\r\n * Produces a log file in ProM format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class PromFormatter extends BasicFormatter {\r\n\r\n    private static int processId = 0;\r\n\r\n    public PromFormatter(OutputStream out) {\r\n        super(out);\r\n    }\r\n\r\n    public PromFormatter(String fileName) throws IOException {\r\n        super(fileName);\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"mxml\";\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n        buf.append(\"<WorkflowLog xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" + \"xsi:noNamespaceSchemaLocation=\\\"WorkflowLog.xsd\\\" description=\\\"Test data\\\">\");\r\n        buf.append(\"<Source program=\\\"Test suite for blaablaa\\\"/>\");\r\n        buf.append(\"<Process id=\\\"0\\\" description=\\\"test suite name\\\">\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String observations(ProgramRun test) {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<ProcessInstance id=\\\"\" + processId + \"\\\" description=\\\"\" + test.getName() + \"\\\">\");\r\n        processId++;\r\n        for (Iterator<Event> ei = test.iterator(); ei.hasNext(); ) {\r\n            Event event = ei.next();\r\n            buf.append(\"<AuditTrailEntry>\");\r\n            buf.append(\"<WorkflowModelElement>\" + event.getName() + \"</WorkflowModelElement>\");\r\n            if (event.isExit()) {\r\n                buf.append(\"<EventType>complete</EventType>\");\r\n            } else {\r\n                buf.append(\"<EventType>start</EventType>\");\r\n            }\r\n            //      if (false) { //this is used to disable attributes as PROM hangs on big log files and attributes are not used in PROM right now\r\n            if (event.attributes().hasNext()) {\r\n                buf.append(\"<Data>\");\r\n                for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n                    EventAttribute attribute = ai.next();\r\n                    buf.append(\"<Attribute name=\\\"\" + attribute.getName() + \"\\\">\" + attribute.getValue() + \"</Attribute>\");\r\n                }\r\n                buf.append(\"</Data>\");\r\n            }\r\n            //XPROM modification\r\n            buf.append(\"<Timestamp>\" + formatTime(event) + \"</Timestamp>\");\r\n            //      buf.append(\"<Timestamp>2008-01-02T12:23:00.000</Timestamp>\");\r\n            buf.append(\"</AuditTrailEntry>\");\r\n        }\r\n        buf.append(\"</ProcessInstance>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    private String formatTime(Event event) {\r\n        Date time = event.getTime();\r\n        if (testMode) {\r\n            time = new Date(0);\r\n        }\r\n        GregorianCalendar calendar = new GregorianCalendar();\r\n        calendar.setTime(time);\r\n        String format = \"\" + calendar.get(Calendar.YEAR);\r\n        format += \"-\" + doubleDigit(calendar.get(Calendar.MONTH) + 1);\r\n        format += \"-\" + doubleDigit(calendar.get(Calendar.DAY_OF_MONTH));\r\n        format += \"T\" + calendar.get(Calendar.HOUR_OF_DAY);\r\n        format += \":\" + calendar.get(Calendar.MINUTE);\r\n        format += \":\" + calendar.get(Calendar.SECOND);\r\n        format += \".\" + calendar.get(Calendar.MILLISECOND);\r\n        return format;\r\n    }\r\n\r\n    private String doubleDigit(int digit) {\r\n        String str = \"\" + digit;\r\n        if (str.length() == 1) {\r\n            str = \"0\" + str;\r\n        }\r\n        return str;\r\n    }\r\n\r\n    public String footer() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"</Process>\");\r\n        buf.append(\"</WorkflowLog>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    /*\r\n  public String format(ProgramRunSuite suite) {\r\n    String result = header();\r\n    for (Iterator<ProgramRun> i = suite.iterator(); i.hasNext();) {\r\n      ProgramRun test = i.next();\r\n      result += observations(test);\r\n    }\r\n    result += footer();\r\n    return result;\r\n  }\r\n*/\r\n    public static void reset() {\r\n        processId = 0;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/PromFormatter_2Test.java",
		"test_prompt": "// PromFormatter_2Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.Event;\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\nimport java.util.Iterator;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Calendar;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PromFormatter}.\n* It contains ten unit test cases for the {@link PromFormatter#observations(ProgramRun)} method.\n*/\nclass PromFormatter_2Test {"
	},
	{
		"original_code": "// PromFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.Event;\r\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\r\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\r\nimport java.util.Iterator;\r\nimport java.util.Date;\r\nimport java.util.GregorianCalendar;\r\nimport java.util.Calendar;\r\nimport java.io.IOException;\r\nimport java.io.OutputStream;\r\n\r\n/**\r\n * Produces a log file in ProM format. Uses as input the events and attributes captured from\r\n * monitoring program execution.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class PromFormatter extends BasicFormatter {\r\n\r\n    private static int processId = 0;\r\n\r\n    public PromFormatter(OutputStream out) {\r\n        super(out);\r\n    }\r\n\r\n    public PromFormatter(String fileName) throws IOException {\r\n        super(fileName);\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"mxml\";\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n        buf.append(\"<WorkflowLog xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" \" + \"xsi:noNamespaceSchemaLocation=\\\"WorkflowLog.xsd\\\" description=\\\"Test data\\\">\");\r\n        buf.append(\"<Source program=\\\"Test suite for blaablaa\\\"/>\");\r\n        buf.append(\"<Process id=\\\"0\\\" description=\\\"test suite name\\\">\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String observations(ProgramRun test) {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<ProcessInstance id=\\\"\" + processId + \"\\\" description=\\\"\" + test.getName() + \"\\\">\");\r\n        processId++;\r\n        for (Iterator<Event> ei = test.iterator(); ei.hasNext(); ) {\r\n            Event event = ei.next();\r\n            buf.append(\"<AuditTrailEntry>\");\r\n            buf.append(\"<WorkflowModelElement>\" + event.getName() + \"</WorkflowModelElement>\");\r\n            if (event.isExit()) {\r\n                buf.append(\"<EventType>complete</EventType>\");\r\n            } else {\r\n                buf.append(\"<EventType>start</EventType>\");\r\n            }\r\n            //      if (false) { //this is used to disable attributes as PROM hangs on big log files and attributes are not used in PROM right now\r\n            if (event.attributes().hasNext()) {\r\n                buf.append(\"<Data>\");\r\n                for (Iterator<EventAttribute> ai = event.attributes(); ai.hasNext(); ) {\r\n                    EventAttribute attribute = ai.next();\r\n                    buf.append(\"<Attribute name=\\\"\" + attribute.getName() + \"\\\">\" + attribute.getValue() + \"</Attribute>\");\r\n                }\r\n                buf.append(\"</Data>\");\r\n            }\r\n            //XPROM modification\r\n            buf.append(\"<Timestamp>\" + formatTime(event) + \"</Timestamp>\");\r\n            //      buf.append(\"<Timestamp>2008-01-02T12:23:00.000</Timestamp>\");\r\n            buf.append(\"</AuditTrailEntry>\");\r\n        }\r\n        buf.append(\"</ProcessInstance>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    private String formatTime(Event event) {\r\n        Date time = event.getTime();\r\n        if (testMode) {\r\n            time = new Date(0);\r\n        }\r\n        GregorianCalendar calendar = new GregorianCalendar();\r\n        calendar.setTime(time);\r\n        String format = \"\" + calendar.get(Calendar.YEAR);\r\n        format += \"-\" + doubleDigit(calendar.get(Calendar.MONTH) + 1);\r\n        format += \"-\" + doubleDigit(calendar.get(Calendar.DAY_OF_MONTH));\r\n        format += \"T\" + calendar.get(Calendar.HOUR_OF_DAY);\r\n        format += \":\" + calendar.get(Calendar.MINUTE);\r\n        format += \":\" + calendar.get(Calendar.SECOND);\r\n        format += \".\" + calendar.get(Calendar.MILLISECOND);\r\n        return format;\r\n    }\r\n\r\n    private String doubleDigit(int digit) {\r\n        String str = \"\" + digit;\r\n        if (str.length() == 1) {\r\n            str = \"0\" + str;\r\n        }\r\n        return str;\r\n    }\r\n\r\n    public String footer() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"</Process>\");\r\n        buf.append(\"</WorkflowLog>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    /*\r\n  public String format(ProgramRunSuite suite) {\r\n    String result = header();\r\n    for (Iterator<ProgramRun> i = suite.iterator(); i.hasNext();) {\r\n      ProgramRun test = i.next();\r\n      result += observations(test);\r\n    }\r\n    result += footer();\r\n    return result;\r\n  }\r\n*/\r\n    public static void reset() {\r\n        processId = 0;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/PromFormatter_3Test.java",
		"test_prompt": "// PromFormatter_3Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.Event;\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\nimport java.util.Iterator;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.Calendar;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PromFormatter}.\n* It contains ten unit test cases for the {@link PromFormatter#footer()} method.\n*/\nclass PromFormatter_3Test {"
	},
	{
		"original_code": "// NoenFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\r\nimport fi.vtt.noen.testgen.observations.data.Event;\r\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\r\nimport fi.vtt.noen.testgen.observations.data.ArrayAttribute;\r\nimport java.io.OutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Iterator;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class NoenFormatter extends BasicFormatter {\r\n\r\n    private static int scenarioId = 0;\r\n\r\n    public NoenFormatter(OutputStream out) {\r\n        super(out);\r\n    }\r\n\r\n    public NoenFormatter(String fileName) throws IOException {\r\n        super(fileName);\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n        buf.append(\"<Observations>\");\r\n        buf.append(\"<Source program=\\\"ToBeImplemented\\\"/>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"</Observations>\");\r\n        //TODO: write is done in OutputBuffer. This needs to be fixed as returning a value is confusing when its not what is written\r\n        return out.toString();\r\n    }\r\n\r\n    public String observations(ProgramRun test) {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<ExecutionScenario id=\\\"\" + scenarioId + \"\\\" description=\\\"\" + test.getName() + \"\\\">\");\r\n        scenarioId++;\r\n        for (Iterator<Event> ei = test.iterator(); ei.hasNext(); ) {\r\n            Event event = ei.next();\r\n            if (event.isExit()) {\r\n                continue;\r\n            }\r\n            buf.append(\"<Event name=\\\"\" + event.getName() + \"\\\">\");\r\n            Iterator<EventAttribute> ai = event.attributes();\r\n            while (ai.hasNext()) {\r\n                EventAttribute attribute = ai.next();\r\n                if (attribute instanceof ArrayAttribute) {\r\n                    ArrayAttribute array = (ArrayAttribute) attribute;\r\n                    Collection<String> attributes = array.getAttributes();\r\n                    int n = 0;\r\n                    for (String next : attributes) {\r\n                        buf.append(\"<Attribute type=\\\"array\\\">\" + next + \"</Attribute>\");\r\n                        n++;\r\n                    }\r\n                    if (n == 0) {\r\n                        buf.append(\"<Attribute type=\\\"array\\\"/>\");\r\n                    }\r\n                } else {\r\n                    buf.append(\"<Attribute name=\\\"\" + attribute.getName() + \"\\\">\" + attribute.getValue() + \"</Attribute>\");\r\n                }\r\n            }\r\n            buf.append(\"</Event>\");\r\n        }\r\n        buf.append(\"</ExecutionScenario>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"xml\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/NoenFormatter_0Test.java",
		"test_prompt": "// NoenFormatter_0Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\nimport fi.vtt.noen.testgen.observations.data.Event;\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\nimport fi.vtt.noen.testgen.observations.data.ArrayAttribute;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NoenFormatter}.\n* It contains ten unit test cases for the {@link NoenFormatter#header()} method.\n*/\nclass NoenFormatter_0Test {"
	},
	{
		"original_code": "// NoenFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\r\nimport fi.vtt.noen.testgen.observations.data.Event;\r\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\r\nimport fi.vtt.noen.testgen.observations.data.ArrayAttribute;\r\nimport java.io.OutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Iterator;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class NoenFormatter extends BasicFormatter {\r\n\r\n    private static int scenarioId = 0;\r\n\r\n    public NoenFormatter(OutputStream out) {\r\n        super(out);\r\n    }\r\n\r\n    public NoenFormatter(String fileName) throws IOException {\r\n        super(fileName);\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n        buf.append(\"<Observations>\");\r\n        buf.append(\"<Source program=\\\"ToBeImplemented\\\"/>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"</Observations>\");\r\n        //TODO: write is done in OutputBuffer. This needs to be fixed as returning a value is confusing when its not what is written\r\n        return out.toString();\r\n    }\r\n\r\n    public String observations(ProgramRun test) {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<ExecutionScenario id=\\\"\" + scenarioId + \"\\\" description=\\\"\" + test.getName() + \"\\\">\");\r\n        scenarioId++;\r\n        for (Iterator<Event> ei = test.iterator(); ei.hasNext(); ) {\r\n            Event event = ei.next();\r\n            if (event.isExit()) {\r\n                continue;\r\n            }\r\n            buf.append(\"<Event name=\\\"\" + event.getName() + \"\\\">\");\r\n            Iterator<EventAttribute> ai = event.attributes();\r\n            while (ai.hasNext()) {\r\n                EventAttribute attribute = ai.next();\r\n                if (attribute instanceof ArrayAttribute) {\r\n                    ArrayAttribute array = (ArrayAttribute) attribute;\r\n                    Collection<String> attributes = array.getAttributes();\r\n                    int n = 0;\r\n                    for (String next : attributes) {\r\n                        buf.append(\"<Attribute type=\\\"array\\\">\" + next + \"</Attribute>\");\r\n                        n++;\r\n                    }\r\n                    if (n == 0) {\r\n                        buf.append(\"<Attribute type=\\\"array\\\"/>\");\r\n                    }\r\n                } else {\r\n                    buf.append(\"<Attribute name=\\\"\" + attribute.getName() + \"\\\">\" + attribute.getValue() + \"</Attribute>\");\r\n                }\r\n            }\r\n            buf.append(\"</Event>\");\r\n        }\r\n        buf.append(\"</ExecutionScenario>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"xml\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/NoenFormatter_1Test.java",
		"test_prompt": "// NoenFormatter_1Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\nimport fi.vtt.noen.testgen.observations.data.Event;\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\nimport fi.vtt.noen.testgen.observations.data.ArrayAttribute;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NoenFormatter}.\n* It contains ten unit test cases for the {@link NoenFormatter#footer()} method.\n*/\nclass NoenFormatter_1Test {"
	},
	{
		"original_code": "// NoenFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\r\nimport fi.vtt.noen.testgen.observations.data.Event;\r\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\r\nimport fi.vtt.noen.testgen.observations.data.ArrayAttribute;\r\nimport java.io.OutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Iterator;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class NoenFormatter extends BasicFormatter {\r\n\r\n    private static int scenarioId = 0;\r\n\r\n    public NoenFormatter(OutputStream out) {\r\n        super(out);\r\n    }\r\n\r\n    public NoenFormatter(String fileName) throws IOException {\r\n        super(fileName);\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n        buf.append(\"<Observations>\");\r\n        buf.append(\"<Source program=\\\"ToBeImplemented\\\"/>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"</Observations>\");\r\n        //TODO: write is done in OutputBuffer. This needs to be fixed as returning a value is confusing when its not what is written\r\n        return out.toString();\r\n    }\r\n\r\n    public String observations(ProgramRun test) {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<ExecutionScenario id=\\\"\" + scenarioId + \"\\\" description=\\\"\" + test.getName() + \"\\\">\");\r\n        scenarioId++;\r\n        for (Iterator<Event> ei = test.iterator(); ei.hasNext(); ) {\r\n            Event event = ei.next();\r\n            if (event.isExit()) {\r\n                continue;\r\n            }\r\n            buf.append(\"<Event name=\\\"\" + event.getName() + \"\\\">\");\r\n            Iterator<EventAttribute> ai = event.attributes();\r\n            while (ai.hasNext()) {\r\n                EventAttribute attribute = ai.next();\r\n                if (attribute instanceof ArrayAttribute) {\r\n                    ArrayAttribute array = (ArrayAttribute) attribute;\r\n                    Collection<String> attributes = array.getAttributes();\r\n                    int n = 0;\r\n                    for (String next : attributes) {\r\n                        buf.append(\"<Attribute type=\\\"array\\\">\" + next + \"</Attribute>\");\r\n                        n++;\r\n                    }\r\n                    if (n == 0) {\r\n                        buf.append(\"<Attribute type=\\\"array\\\"/>\");\r\n                    }\r\n                } else {\r\n                    buf.append(\"<Attribute name=\\\"\" + attribute.getName() + \"\\\">\" + attribute.getValue() + \"</Attribute>\");\r\n                }\r\n            }\r\n            buf.append(\"</Event>\");\r\n        }\r\n        buf.append(\"</ExecutionScenario>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"xml\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/NoenFormatter_2Test.java",
		"test_prompt": "// NoenFormatter_2Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\nimport fi.vtt.noen.testgen.observations.data.Event;\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\nimport fi.vtt.noen.testgen.observations.data.ArrayAttribute;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NoenFormatter}.\n* It contains ten unit test cases for the {@link NoenFormatter#observations(ProgramRun)} method.\n*/\nclass NoenFormatter_2Test {"
	},
	{
		"original_code": "// NoenFormatter.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.formatter;\r\n\r\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\r\nimport fi.vtt.noen.testgen.observations.data.Event;\r\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\r\nimport fi.vtt.noen.testgen.observations.data.ArrayAttribute;\r\nimport java.io.OutputStream;\r\nimport java.io.IOException;\r\nimport java.util.Iterator;\r\nimport java.util.Collection;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class NoenFormatter extends BasicFormatter {\r\n\r\n    private static int scenarioId = 0;\r\n\r\n    public NoenFormatter(OutputStream out) {\r\n        super(out);\r\n    }\r\n\r\n    public NoenFormatter(String fileName) throws IOException {\r\n        super(fileName);\r\n    }\r\n\r\n    public String header() {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\r\n        buf.append(\"<Observations>\");\r\n        buf.append(\"<Source program=\\\"ToBeImplemented\\\"/>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String footer() {\r\n        OutputBuffer out = new OutputBuffer();\r\n        out.append(\"</Observations>\");\r\n        //TODO: write is done in OutputBuffer. This needs to be fixed as returning a value is confusing when its not what is written\r\n        return out.toString();\r\n    }\r\n\r\n    public String observations(ProgramRun test) {\r\n        OutputBuffer buf = new OutputBuffer();\r\n        buf.append(\"<ExecutionScenario id=\\\"\" + scenarioId + \"\\\" description=\\\"\" + test.getName() + \"\\\">\");\r\n        scenarioId++;\r\n        for (Iterator<Event> ei = test.iterator(); ei.hasNext(); ) {\r\n            Event event = ei.next();\r\n            if (event.isExit()) {\r\n                continue;\r\n            }\r\n            buf.append(\"<Event name=\\\"\" + event.getName() + \"\\\">\");\r\n            Iterator<EventAttribute> ai = event.attributes();\r\n            while (ai.hasNext()) {\r\n                EventAttribute attribute = ai.next();\r\n                if (attribute instanceof ArrayAttribute) {\r\n                    ArrayAttribute array = (ArrayAttribute) attribute;\r\n                    Collection<String> attributes = array.getAttributes();\r\n                    int n = 0;\r\n                    for (String next : attributes) {\r\n                        buf.append(\"<Attribute type=\\\"array\\\">\" + next + \"</Attribute>\");\r\n                        n++;\r\n                    }\r\n                    if (n == 0) {\r\n                        buf.append(\"<Attribute type=\\\"array\\\"/>\");\r\n                    }\r\n                } else {\r\n                    buf.append(\"<Attribute name=\\\"\" + attribute.getName() + \"\\\">\" + attribute.getValue() + \"</Attribute>\");\r\n                }\r\n            }\r\n            buf.append(\"</Event>\");\r\n        }\r\n        buf.append(\"</ExecutionScenario>\");\r\n        return buf.toString();\r\n    }\r\n\r\n    public String fileNameExtension() {\r\n        return \"xml\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/formatter/NoenFormatter_3Test.java",
		"test_prompt": "// NoenFormatter_3Test.java\npackage fi.vtt.noen.testgen.observations.formatter;\n\nimport fi.vtt.noen.testgen.observations.data.ProgramRun;\nimport fi.vtt.noen.testgen.observations.data.Event;\nimport fi.vtt.noen.testgen.observations.data.EventAttribute;\nimport fi.vtt.noen.testgen.observations.data.ArrayAttribute;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link NoenFormatter}.\n* It contains ten unit test cases for the {@link NoenFormatter#fileNameExtension()} method.\n*/\nclass NoenFormatter_3Test {"
	},
	{
		"original_code": "// ArrayAttribute.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.data;\r\n\r\nimport java.util.Collection;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * An attribute that is of type array (java collections).\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ArrayAttribute extends EventAttribute {\r\n\r\n    private Collection<String> attributes = null;\r\n\r\n    public ArrayAttribute(String name, Collection<String> value) {\r\n        this.name = name;\r\n        this.type = \"java.lang.String[]\";\r\n        this.value = format(value);\r\n        this.attributes = value;\r\n    }\r\n\r\n    public Collection<String> getAttributes() {\r\n        return attributes;\r\n    }\r\n\r\n    public static String format(Collection data) {\r\n        String format = \"[\";\r\n        for (Iterator i = data.iterator(); i.hasNext(); ) {\r\n            Object o = i.next();\r\n            //      format += o.hashCode();\r\n            format += '\"' + o.toString() + '\"';\r\n            if (i.hasNext()) {\r\n                format += \" \";\r\n            }\r\n        }\r\n        format += \"]\";\r\n        return format;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/data/ArrayAttribute.java",
		"test_prompt": "// ArrayAttributeTest.java\npackage fi.vtt.noen.testgen.observations.data;\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ArrayAttribute}.\n* It contains ten unit test cases for the {@link ArrayAttribute#format(Collection)} method.\n*/\nclass ArrayAttributeTest {"
	},
	{
		"original_code": "// Event.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.data;\r\n\r\nimport fi.vtt.noen.testgen.model.Const;\r\nimport java.util.*;\r\n\r\n/**\r\n * An event in the execution of a program, such as a message passed through its external interface.\r\n * So like in practice it could be a method call to input or output interface. Or anything else, but\r\n * thats what it is so far.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class Event {\r\n\r\n    private final String name;\r\n\r\n    private final long timestamp;\r\n\r\n    private final boolean exit;\r\n\r\n    private final Collection<EventAttribute> attributes = new ArrayList<EventAttribute>();\r\n\r\n    public Event(String name) {\r\n        this.name = name;\r\n        this.timestamp = System.currentTimeMillis();\r\n        exit = false;\r\n    }\r\n\r\n    public Event(String name, long timestamp) {\r\n        this.name = name;\r\n        this.timestamp = timestamp;\r\n        exit = false;\r\n    }\r\n\r\n    public Event(String name, boolean exit) {\r\n        this.name = name;\r\n        this.timestamp = System.currentTimeMillis();\r\n        this.exit = exit;\r\n    }\r\n\r\n    public boolean isExit() {\r\n        return exit;\r\n    }\r\n\r\n    public Date getTime() {\r\n        return new Date(timestamp);\r\n    }\r\n\r\n    public String getName() {\r\n        //    if (exit) {\r\n        //      return name+\"_EXIT\";\r\n        //    }\r\n        return name;\r\n    }\r\n\r\n    public void addAttribute(String name, Object obj) {\r\n        attributes.add(new EventAttribute(name, obj));\r\n    }\r\n\r\n    public void addAttribute(String name, Collection values) {\r\n        attributes.add(new ArrayAttribute(name, values));\r\n    }\r\n\r\n    public Iterator<EventAttribute> attributes() {\r\n        return attributes.iterator();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/data/Event_0Test.java",
		"test_prompt": "// Event_0Test.java\npackage fi.vtt.noen.testgen.observations.data;\n\nimport fi.vtt.noen.testgen.model.Const;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Event}.\n* It contains ten unit test cases for the {@link Event#isExit()} method.\n*/\nclass Event_0Test {"
	},
	{
		"original_code": "// Event.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.data;\r\n\r\nimport fi.vtt.noen.testgen.model.Const;\r\nimport java.util.*;\r\n\r\n/**\r\n * An event in the execution of a program, such as a message passed through its external interface.\r\n * So like in practice it could be a method call to input or output interface. Or anything else, but\r\n * thats what it is so far.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class Event {\r\n\r\n    private final String name;\r\n\r\n    private final long timestamp;\r\n\r\n    private final boolean exit;\r\n\r\n    private final Collection<EventAttribute> attributes = new ArrayList<EventAttribute>();\r\n\r\n    public Event(String name) {\r\n        this.name = name;\r\n        this.timestamp = System.currentTimeMillis();\r\n        exit = false;\r\n    }\r\n\r\n    public Event(String name, long timestamp) {\r\n        this.name = name;\r\n        this.timestamp = timestamp;\r\n        exit = false;\r\n    }\r\n\r\n    public Event(String name, boolean exit) {\r\n        this.name = name;\r\n        this.timestamp = System.currentTimeMillis();\r\n        this.exit = exit;\r\n    }\r\n\r\n    public boolean isExit() {\r\n        return exit;\r\n    }\r\n\r\n    public Date getTime() {\r\n        return new Date(timestamp);\r\n    }\r\n\r\n    public String getName() {\r\n        //    if (exit) {\r\n        //      return name+\"_EXIT\";\r\n        //    }\r\n        return name;\r\n    }\r\n\r\n    public void addAttribute(String name, Object obj) {\r\n        attributes.add(new EventAttribute(name, obj));\r\n    }\r\n\r\n    public void addAttribute(String name, Collection values) {\r\n        attributes.add(new ArrayAttribute(name, values));\r\n    }\r\n\r\n    public Iterator<EventAttribute> attributes() {\r\n        return attributes.iterator();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/data/Event_1Test.java",
		"test_prompt": "// Event_1Test.java\npackage fi.vtt.noen.testgen.observations.data;\n\nimport fi.vtt.noen.testgen.model.Const;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Event}.\n* It contains ten unit test cases for the {@link Event#attributes()} method.\n*/\nclass Event_1Test {"
	},
	{
		"original_code": "// ProgramRun.java\n/*\r\n * Copyright (C) 2009 VTT Technical Research Centre of Finland.\r\n *\r\n * This file is part of NOEN framework.\r\n *\r\n * NOEN framework is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; version 2.\r\n *\r\n * NOEN framework is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License\r\n * along with this program; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.testgen.observations.data;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * Describes one execution of the analysed program, that is used as a basis for invariant inference\r\n * and FSM generation.\r\n *\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ProgramRun {\r\n\r\n    private final long startTime;\r\n\r\n    private final String name;\r\n\r\n    private final List<Event> events = new ArrayList<Event>();\r\n\r\n    public ProgramRun(String name) {\r\n        this.startTime = System.currentTimeMillis();\r\n        this.name = name;\r\n    }\r\n\r\n    public void add(Event event) {\r\n        events.add(event);\r\n    }\r\n\r\n    public Iterator<Event> iterator() {\r\n        return events.iterator();\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/testgen/observations/data/ProgramRun.java",
		"test_prompt": "// ProgramRunTest.java\npackage fi.vtt.noen.testgen.observations.data;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProgramRun}.\n* It contains ten unit test cases for the {@link ProgramRun#iterator()} method.\n*/\nclass ProgramRunTest {"
	},
	{
		"original_code": "// ConfigurableTestProbeAgent.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.configurabletester;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseProbeAgent;\r\nimport java.util.Collection;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ConfigurableTestProbeAgent extends BaseProbeAgent {\r\n\r\n    private String name = null;\r\n\r\n    private int count = 0;\r\n\r\n    @Override\r\n    public void init(Properties properties) {\r\n        super.init(properties);\r\n        name = properties.getProperty(\"name\");\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        count++;\r\n        return new BaseMeasure(name + \" measure \" + count);\r\n    }\r\n\r\n    public void startProbe() {\r\n    }\r\n\r\n    public void stopProbe() {\r\n    }\r\n\r\n    public void setConfiguration(Map<String, String> configuration) {\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getConfigurationParameters() {\r\n        return null;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/configurabletester/ConfigurableTestProbeAgent.java",
		"test_prompt": "// ConfigurableTestProbeAgentTest.java\npackage fi.vtt.noen.mfw.probes.configurabletester;\n\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseProbeAgent;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ConfigurableTestProbeAgent}.\n* It contains ten unit test cases for the {@link ConfigurableTestProbeAgent#measure()} method.\n*/\nclass ConfigurableTestProbeAgentTest {"
	},
	{
		"original_code": "// SSHProbeAgent.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.ssh;\r\n\r\nimport ch.ethz.ssh2.Connection;\r\nimport ch.ethz.ssh2.SCPClient;\r\nimport ch.ethz.ssh2.Session;\r\nimport ch.ethz.ssh2.StreamGobbler;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseProbeAgent;\r\nimport java.io.BufferedReader;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * A probe-agent for performing measurements over the SSH protocol. Connects to the configured IP address,\r\n * sends a (configured) script file over with SCP to the host, does a login over SSH using the given credentials,\r\n * and uses the configured shell command to execute the script in question. Provides the system.out output of the\r\n * script as a base measure.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class SSHProbeAgent extends BaseProbeAgent {\r\n\r\n    private final static Logger log = new Logger(SSHProbeAgent.class);\r\n\r\n    private final static Map<String, Connection> connections = new HashMap<String, Connection>();\r\n\r\n    //filename of the script. should be relative to the \"working directory\"\r\n    private String filename = null;\r\n\r\n    private String username = null;\r\n\r\n    private String password = null;\r\n\r\n    //shell command to execute the script\r\n    private String command = null;\r\n\r\n    private String errors = null;\r\n\r\n    public void init(Properties properties) {\r\n        super.init(properties);\r\n        filename = properties.getProperty((Const.SSH_SCRIPT_FILENAME));\r\n        username = properties.getProperty((Const.SSH_USERNAME));\r\n        password = properties.getProperty((Const.SSH_PASSWORD));\r\n        command = properties.getProperty((Const.SSH_SCRIPT_COMMAND));\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        try {\r\n            String result = executeScript();\r\n            log.debug(\"measurement result:\" + result);\r\n            return new BaseMeasure(result);\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Failed to perform measure for \" + pi.getTargetName() + \", \" + pi.getBmClass() + \", \", e);\r\n        }\r\n    }\r\n\r\n    public void startProbe() {\r\n    }\r\n\r\n    public void stopProbe() {\r\n        for (Connection connection : connections.values()) {\r\n            connection.close();\r\n        }\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getConfigurationParameters() {\r\n        Collection<ProbeConfiguration> config = getBaseConfigurationParameters();\r\n        try {\r\n            FileInputStream file = new FileInputStream(filename);\r\n            String commands = readOutput(file);\r\n            config.add(new ProbeConfiguration(Const.SSH_SCRIPT_FILE_CONTENTS, \"Script to collect the BM\", true, commands));\r\n        } catch (IOException e) {\r\n            log.error(\"Error while reading file:\" + filename, e);\r\n            throw new RuntimeException(\"Error reading file:\" + filename, e);\r\n        }\r\n        //with hashset this replaces the original\r\n        config.add(new ProbeConfiguration(Const.PROBE_TARGET_NAME, \"Target IP address\", true, pi.getTargetName()));\r\n        config.add(new ProbeConfiguration(Const.SSH_SCRIPT_FILENAME, \"Script file name\", true, filename));\r\n        config.add(new ProbeConfiguration(Const.SSH_USERNAME, \"User name for login\", true, username));\r\n        config.add(new ProbeConfiguration(Const.SSH_PASSWORD, \"Password for login\", true, password));\r\n        config.add(new ProbeConfiguration(Const.SSH_SCRIPT_COMMAND, \"Command to execute script\", true, command));\r\n        return config;\r\n    }\r\n\r\n    public void setConfiguration(Map<String, String> config) {\r\n        setBaseConfigurationParameters(config);\r\n        try {\r\n            String commands = config.get(Const.SSH_SCRIPT_FILE_CONTENTS);\r\n            FileOutputStream file = new FileOutputStream(filename);\r\n            file.write(commands.getBytes());\r\n            file.close();\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"Failed to write to file:\" + filename, e);\r\n        }\r\n    }\r\n\r\n    //executes the configured shell script on the configured target\r\n    private String executeScript() throws Exception {\r\n        String targetName = pi.getTargetName();\r\n        Connection conn = connections.get(targetName);\r\n        if (conn == null) {\r\n            conn = new Connection(targetName);\r\n            log.debug(\"connecting now to:\" + targetName);\r\n            /* Now connect */\r\n            conn.connect();\r\n            log.debug(\"connected ok\");\r\n            boolean authenticated = conn.authenticateWithPassword(username, password);\r\n            if (!authenticated)\r\n                throw new IOException(\"Authentication failed.\");\r\n            log.debug(\"authenticated ok\");\r\n            connections.put(targetName, conn);\r\n        }\r\n        log.debug(\"executing script on target:\" + targetName);\r\n        SCPClient client = conn.createSCPClient();\r\n        client.put(filename, \".\");\r\n        log.debug(\"script file moved to server\");\r\n        Session sess = conn.openSession();\r\n        sess.execCommand(command + \" \" + filename);\r\n        InputStream stdout = new StreamGobbler(sess.getStdout());\r\n        InputStream stderr = new StreamGobbler(sess.getStderr());\r\n        String output = readOutput(stdout);\r\n        errors = readOutput(stderr);\r\n        System.out.println(\"done reading, errors:\" + errors);\r\n        /* Show exit status, if available (otherwise \"null\") */\r\n        //    System.out.println(\"ExitCode: \" + sess.getExitStatus());\r\n        /* Close this session */\r\n        sess.close();\r\n        /* Close the connection */\r\n        //conn.close();\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * This is just for testing.\r\n     *\r\n     * @return Error messages from remote host.\r\n     */\r\n    public String getErrors() {\r\n        return errors;\r\n    }\r\n\r\n    private String readOutput(InputStream in) throws IOException {\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(in));\r\n        StringBuffer result = new StringBuffer();\r\n        while (true) {\r\n            String line = br.readLine();\r\n            if (line == null)\r\n                break;\r\n            result.append(line);\r\n            result.append(\"\\n\");\r\n        }\r\n        return result.toString();\r\n    }\r\n\r\n    //for testing\r\n    public static void main(String[] args) throws Exception {\r\n        /* Create a connection instance */\r\n        Connection conn = new Connection(\"192.168.60.128\");\r\n        /* Now connect */\r\n        conn.connect();\r\n        /* Authenticate.\r\n     * If you get an IOException saying something like\r\n     * \"Authentication method password not supported by the server at this stage.\"\r\n     * then please check the FAQ.\r\n     */\r\n        String username = \"hii\";\r\n        String password = \"haa\";\r\n        String filename = \"java\\\\distro\\\\distro.zip\";\r\n        boolean authenticated = conn.authenticateWithPassword(username, password);\r\n        if (authenticated == false)\r\n            throw new IOException(\"Authentication failed.\");\r\n        SCPClient client = conn.createSCPClient();\r\n        client.put(filename, \".\");\r\n        conn.close();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/ssh/SSHProbeAgent.java",
		"test_prompt": "// SSHProbeAgentTest.java\npackage fi.vtt.noen.mfw.probes.ssh;\n\nimport ch.ethz.ssh2.Connection;\nimport ch.ethz.ssh2.SCPClient;\nimport ch.ethz.ssh2.Session;\nimport ch.ethz.ssh2.StreamGobbler;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseProbeAgent;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SSHProbeAgent}.\n* It contains ten unit test cases for the {@link SSHProbeAgent#measure()} method.\n*/\nclass SSHProbeAgentTest {"
	},
	{
		"original_code": "// HttpServiceTracker.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.http;\r\n\r\n//import com.sun.jersey.spi.container.servlet.ServletContainer;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.felix.http.api.ExtHttpService;\r\nimport org.osgi.framework.BundleContext;\r\nimport org.osgi.framework.ServiceReference;\r\nimport org.osgi.service.http.HttpService;\r\nimport org.osgi.util.tracker.ServiceTracker;\r\n\r\n/**\r\n * Looks for the OSGI HTTP service and registers this probe-agent to as a filter to this service when available.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class HttpServiceTracker extends ServiceTracker {\r\n\r\n    private final static Logger log = new Logger(HttpServiceTracker.class);\r\n\r\n    private ExtHttpService httpService = null;\r\n\r\n    public HttpServiceTracker(BundleContext bc) {\r\n        super(bc, HttpService.class.getName(), null);\r\n    }\r\n\r\n    @Override\r\n    public Object addingService(ServiceReference sr) {\r\n        httpService = (ExtHttpService) super.addingService(sr);\r\n        try {\r\n            httpService.registerFilter(new BaseMeasureFilter(), \"/mfw/bm/.*\", null, 0, null);\r\n            //      httpService.registerServlet(\"/test/*\", new BaseMeasureServlet(), null, null);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to register servlet\", e);\r\n        }\r\n        /*\r\n    Dictionary<String, String> jerseyParameters = new Hashtable<String, String>();\r\n    jerseyParameters.put(\"javax.ws.rs.Application\", JerseyApplication.class.getName());\r\n    try {\r\n      httpService.registerServlet(\"/jersey\", new ServletContainer(), jerseyParameters, null);\r\n    } catch (Exception e) {\r\n      log.error(\"Failed to register Jersey servlet\", e);\r\n    }*/\r\n        return httpService;\r\n    }\r\n\r\n    @Override\r\n    public void removedService(ServiceReference reference, Object service) {\r\n        super.removedService(reference, service);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/http/HttpServiceTracker.java",
		"test_prompt": "// HttpServiceTrackerTest.java\npackage fi.vtt.noen.mfw.probes.http;\n\n//import com.sun.jersey.spi.container.servlet.ServletContainer;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.felix.http.api.ExtHttpService;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.ServiceReference;\nimport org.osgi.service.http.HttpService;\nimport org.osgi.util.tracker.ServiceTracker;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HttpServiceTracker}.\n* It contains ten unit test cases for the {@link HttpServiceTracker#addingService(ServiceReference)} method.\n*/\nclass HttpServiceTrackerTest {"
	},
	{
		"original_code": "// HTTPProbeAgent.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.http;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseProbeAgent;\r\nimport java.io.BufferedReader;\r\nimport java.io.DataOutputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.net.HttpURLConnection;\r\nimport java.net.URL;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Grabs a base measure from a HTTP request posted at the address http://<address>/{bm-name}.\r\n * The base measure name is the part in the url and the content is the body of the http request.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class HTTPProbeAgent extends BaseProbeAgent {\r\n\r\n    public BaseMeasure measure() {\r\n        return BaseMeasureFilter.values.get(getInformation().getBmName());\r\n    }\r\n\r\n    public void startProbe() {\r\n    }\r\n\r\n    public void stopProbe() {\r\n    }\r\n\r\n    public void setConfiguration(Map<String, String> configuration) {\r\n    }\r\n\r\n    public List<ProbeConfiguration> getConfigurationParameters() {\r\n        return null;\r\n    }\r\n\r\n    //for self-testing\r\n    public static void main(String[] args) throws Exception {\r\n        // URL of CGI-Bin script.\r\n        URL target = new URL(\"http://localhost:8081/mfw/bm/os_version\");\r\n        HttpURLConnection url = (HttpURLConnection) target.openConnection();\r\n        // Let the run-time system (RTS) know that we want input.\r\n        url.setDoInput(true);\r\n        // Let the RTS know that we want to do output.\r\n        url.setDoOutput(true);\r\n        // No caching, we want the real thing.\r\n        url.setUseCaches(false);\r\n        // Specify the content type.\r\n        url.setRequestProperty(\"Content-Type\", \"text/plain\");\r\n        // Send POST output.\r\n        url.setRequestMethod(\"POST\");\r\n        DataOutputStream printout = new DataOutputStream(url.getOutputStream());\r\n        String content = \"A value has been observed.\";\r\n        printout.writeBytes(content);\r\n        printout.flush();\r\n        printout.close();\r\n        // Get response data.\r\n        BufferedReader br = new BufferedReader(new InputStreamReader(url.getInputStream()));\r\n        String str;\r\n        while (null != ((str = br.readLine()))) {\r\n            System.out.println(str);\r\n        }\r\n        br.close();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/http/HTTPProbeAgent.java",
		"test_prompt": "// HTTPProbeAgentTest.java\npackage fi.vtt.noen.mfw.probes.http;\n\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseProbeAgent;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTTPProbeAgent}.\n* It contains ten unit test cases for the {@link HTTPProbeAgent#measure()} method.\n*/\nclass HTTPProbeAgentTest {"
	},
	{
		"original_code": "// TestProbe4.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.tester;\r\n\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\n\r\n/**\r\n * Test probe to provide test data to the server-agent.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class TestProbe4 extends TestProbe {\r\n\r\n    private int counter = 0;\r\n\r\n    public static final String PROBE_DESCRIPTION = \"Test Probe 4\";\r\n\r\n    public static final String TARGET_NAME = \"Bob4\";\r\n\r\n    public static final String TARGET_TYPE = \"Mail server\";\r\n\r\n    public static final String BM_CLASS = \"Authentication enabled\";\r\n\r\n    public static final String BM_NAME = \"Bobby4\";\r\n\r\n    public static final String BM_DESCRIPTION = \"Checks that authentication is present\";\r\n\r\n    public TestProbe4() {\r\n        super(TARGET_NAME, TARGET_TYPE, BM_CLASS, BM_NAME, BM_DESCRIPTION, PROBE_DESCRIPTION, 1);\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        String result = \"test probe4 measure \" + counter;\r\n        counter++;\r\n        return new BaseMeasure(result);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/tester/TestProbe4.java",
		"test_prompt": "// TestProbe4Test.java\npackage fi.vtt.noen.mfw.probes.tester;\n\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TestProbe4}.\n* It contains ten unit test cases for the {@link TestProbe4#measure()} method.\n*/\nclass TestProbe4Test {"
	},
	{
		"original_code": "// TestProbe.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.tester;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.Probe;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Base class to create test probes that provide test-data to the server-agent.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class TestProbe implements Probe {\r\n\r\n    private final static Logger log = new Logger(TestProbe.class);\r\n\r\n    private final String targetName;\r\n\r\n    private final String targetType;\r\n\r\n    private final String bmClass;\r\n\r\n    private final String bmName;\r\n\r\n    private final String bmDescription;\r\n\r\n    private final String probeDescription;\r\n\r\n    private final String result;\r\n\r\n    private final int precision;\r\n\r\n    private Properties properties;\r\n\r\n    private Map<String, ProbeConfiguration> configuration = new HashMap<String, ProbeConfiguration>();\r\n\r\n    public TestProbe(String targetName, String targetType, String bmClass, String bmName, String bmDescription, String probeDescription, int precision) {\r\n        this(targetName, targetType, bmClass, bmName, bmDescription, probeDescription, null, precision);\r\n    }\r\n\r\n    public TestProbe(String targetName, String targetType, String bmClass, String bmName, String bmDescription, String probeDescription, String result, int precision) {\r\n        this.targetName = targetName;\r\n        this.targetType = targetType;\r\n        this.bmClass = bmClass;\r\n        this.bmName = bmName;\r\n        this.bmDescription = bmDescription;\r\n        this.probeDescription = probeDescription;\r\n        this.result = result;\r\n        this.precision = precision;\r\n    }\r\n\r\n    public ProbeInformation getInformation() {\r\n        return new ProbeInformation(targetName, targetType, bmClass, bmName, bmDescription, probeDescription, precision, null);\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        log.debug(\"Testprobe provides measure:\" + result);\r\n        return new BaseMeasure(result);\r\n    }\r\n\r\n    public void startProbe() {\r\n    }\r\n\r\n    public void stopProbe() {\r\n    }\r\n\r\n    public void init(Properties properties) {\r\n        log.debug(\"initializing with:\" + properties);\r\n        this.properties = properties;\r\n    }\r\n\r\n    public Properties getProperties() {\r\n        return properties;\r\n    }\r\n\r\n    protected void addConfigurationParameter(ProbeConfiguration pc) {\r\n        configuration.put(pc.getName(), pc);\r\n    }\r\n\r\n    public void setConfiguration(Map<String, String> newConfiguration) {\r\n        log.debug(\"Received values:\" + newConfiguration);\r\n        for (String key : newConfiguration.keySet()) {\r\n            ProbeConfiguration config = this.configuration.get(key);\r\n            String value = newConfiguration.get(key);\r\n            if (config == null) {\r\n                config = new ProbeConfiguration(key, \"Runtime added configuration option\", false, value);\r\n                this.configuration.put(key, config);\r\n            } else {\r\n                config.setValue(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getConfigurationParameters() {\r\n        Collection<ProbeConfiguration> result = new ArrayList<ProbeConfiguration>();\r\n        result.addAll(configuration.values());\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/tester/TestProbe.java",
		"test_prompt": "// TestProbeTest.java\npackage fi.vtt.noen.mfw.probes.tester;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.Probe;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TestProbe}.\n* It contains ten unit test cases for the {@link TestProbe#measure()} method.\n*/\nclass TestProbeTest {"
	},
	{
		"original_code": "// TestProbe2.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.tester;\r\n\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\n\r\n/**\r\n * Test probe to provide test data to the server-agent.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class TestProbe2 extends TestProbe {\r\n\r\n    private int counter = 0;\r\n\r\n    public static final String PROBE_DESCRIPTION = \"Test Probe 2\";\r\n\r\n    public static final String TARGET_NAME = \"Bob2\";\r\n\r\n    public static final String TARGET_TYPE = \"Spam Filter\";\r\n\r\n    public static final String BM_CLASS = \"configuration file\";\r\n\r\n    public static final String BM_NAME = \"Bobby\";\r\n\r\n    public static final String BM_DESCRIPTION = \"Provides the configuration file\";\r\n\r\n    public TestProbe2() {\r\n        super(TARGET_NAME, TARGET_TYPE, BM_CLASS, BM_NAME, BM_DESCRIPTION, PROBE_DESCRIPTION, 1);\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        //    String result = \"test probe2 measure \" + counter;\r\n        String result = Integer.toString(counter % 100);\r\n        counter++;\r\n        return new BaseMeasure(result);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/tester/TestProbe2.java",
		"test_prompt": "// TestProbe2Test.java\npackage fi.vtt.noen.mfw.probes.tester;\n\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TestProbe2}.\n* It contains ten unit test cases for the {@link TestProbe2#measure()} method.\n*/\nclass TestProbe2Test {"
	},
	{
		"original_code": "// TestProbe3.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.tester;\r\n\r\nimport java.util.Random;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\n\r\n/**\r\n * Test probe to provide test data to the server-agent.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class TestProbe3 extends TestProbe {\r\n\r\n    private int counter = 0;\r\n\r\n    private Random random;\r\n\r\n    public static final String PROBE_DESCRIPTION = \"Test Probe 3\";\r\n\r\n    public static final String TARGET_NAME = \"Bob3\";\r\n\r\n    public static final String TARGET_TYPE = \"Communication protocol\";\r\n\r\n    public static final String BM_CLASS = \"Encryption key length\";\r\n\r\n    public static final String BM_NAME = \"Bobby3\";\r\n\r\n    public static final String BM_DESCRIPTION = \"Provides the key length for encryption\";\r\n\r\n    public TestProbe3() {\r\n        super(TARGET_NAME, TARGET_TYPE, BM_CLASS, BM_NAME, BM_DESCRIPTION, PROBE_DESCRIPTION, 1);\r\n        random = new Random();\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        //String result = \"test probe3 measure \" + counter;\r\n        String result = Integer.toString(random.nextInt(100) + 1);\r\n        counter++;\r\n        return new BaseMeasure(result);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/tester/TestProbe3.java",
		"test_prompt": "// TestProbe3Test.java\npackage fi.vtt.noen.mfw.probes.tester;\n\nimport java.util.Random;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TestProbe3}.\n* It contains ten unit test cases for the {@link TestProbe3#measure()} method.\n*/\nclass TestProbe3Test {"
	},
	{
		"original_code": "// TestProbeWithCompareMode.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.tester;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\n\r\n/**\r\n * Test probe to provide test data to the server-agent.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class TestProbeWithCompareMode extends TestProbe {\r\n\r\n    private int counter = 0;\r\n\r\n    private int value = 0;\r\n\r\n    public static final String PROBE_DESCRIPTION = \"Test Probe with compare mode\";\r\n\r\n    public static final String TARGET_NAME = \"Bob5\";\r\n\r\n    public static final String TARGET_TYPE = \"Bob\";\r\n\r\n    public static final String BM_CLASS = \"compare tester\";\r\n\r\n    public static final String BM_NAME = \"Bobby5\";\r\n\r\n    public static final String BM_DESCRIPTION = \"Provides compare mode testing values\";\r\n\r\n    private final long DELAY = 30000;\r\n\r\n    private long oldTime = 0;\r\n\r\n    private long currentTime = 0;\r\n\r\n    public TestProbeWithCompareMode() {\r\n        super(TARGET_NAME, TARGET_TYPE, BM_CLASS, BM_NAME, BM_DESCRIPTION, PROBE_DESCRIPTION, 1);\r\n        addConfig(\"mode\", \"to use compare or normal mode\", true, \"compare\");\r\n    }\r\n\r\n    private void addConfig(String name, String description, boolean mandatory, String value) {\r\n        ProbeConfiguration pc = new ProbeConfiguration(name, description, mandatory, value);\r\n        addConfigurationParameter(pc);\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        //    if (counter % 10 == 0) {\r\n        //      value = counter;\r\n        //    }\r\n        currentTime = System.currentTimeMillis();\r\n        if (currentTime > (oldTime + DELAY)) {\r\n            oldTime = currentTime;\r\n            value = counter;\r\n        }\r\n        String result = \"compare mode test probe value \" + value;\r\n        counter++;\r\n        return new BaseMeasure(result);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/tester/TestProbeWithCompareMode.java",
		"test_prompt": "// TestProbeWithCompareModeTest.java\npackage fi.vtt.noen.mfw.probes.tester;\n\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TestProbeWithCompareMode}.\n* It contains ten unit test cases for the {@link TestProbeWithCompareMode#measure()} method.\n*/\nclass TestProbeWithCompareModeTest {"
	},
	{
		"original_code": "// TestProbe1.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.tester;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\n\r\n/**\r\n * Test probe to provide test data to the server-agent.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class TestProbe1 extends TestProbe {\r\n\r\n    private final static Logger log = new Logger(TestProbe1.class);\r\n\r\n    private int counter = 0;\r\n\r\n    public static final String PROBE_DESCRIPTION = \"Test Probe 1\";\r\n\r\n    public static final String TARGET_NAME = \"Bob1\";\r\n\r\n    public static final String TARGET_TYPE = \"Firewall\";\r\n\r\n    public static final String BM_CLASS = \"Configuration file\";\r\n\r\n    public static final String BM_NAME = \"Bobby1\";\r\n\r\n    public static final String BM_DESCRIPTION = \"Reads the configuration, but only better\";\r\n\r\n    public TestProbe1() {\r\n        super(TARGET_NAME, TARGET_TYPE, BM_CLASS, BM_NAME, BM_DESCRIPTION, PROBE_DESCRIPTION, 1);\r\n        addConfig(\"height\", \"the probe height\", true, \"10 meters\");\r\n        addConfig(\"width\", \"the probe width\", true, \"3 meters\");\r\n    }\r\n\r\n    private void addConfig(String name, String description, boolean mandatory, String value) {\r\n        ProbeConfiguration pc = new ProbeConfiguration(name, description, mandatory, value);\r\n        addConfigurationParameter(pc);\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        String result = \"test probe1 measure \" + counter + \" test to see if going over the limit of 100 characters ends up as truncating the text at a specific point\";\r\n        counter++;\r\n        log.debug(\"Performed measure:\" + result);\r\n        return new BaseMeasure(result);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/tester/TestProbe1.java",
		"test_prompt": "// TestProbe1Test.java\npackage fi.vtt.noen.mfw.probes.tester;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TestProbe1}.\n* It contains ten unit test cases for the {@link TestProbe1#measure()} method.\n*/\nclass TestProbe1Test {"
	},
	{
		"original_code": "// TestProbe1v2.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.tester;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\n\r\n/**\r\n * Test probe to provide test data to the server-agent.\r\n * The same as TestProbe1 but with a higher precision.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class TestProbe1v2 extends TestProbe {\r\n\r\n    private final static Logger log = new Logger(TestProbe1v2.class);\r\n\r\n    private int counter = 0;\r\n\r\n    public static final String PROBE_DESCRIPTION = \"Test Probe 1v2\";\r\n\r\n    public static final String TARGET_NAME = \"Bob1\";\r\n\r\n    public static final String TARGET_TYPE = \"Firewall\";\r\n\r\n    public static final String BM_CLASS = \"Configuration file\";\r\n\r\n    public static final String BM_NAME = \"Bobby1\";\r\n\r\n    public static final String BM_DESCRIPTION = \"Reads the configuration, but only better\";\r\n\r\n    public TestProbe1v2() {\r\n        super(TARGET_NAME, TARGET_TYPE, BM_CLASS, BM_NAME, BM_DESCRIPTION, PROBE_DESCRIPTION, 2);\r\n        addConfig(\"x\", \"x coord\", true, \"0px\");\r\n        addConfig(\"y\", \"y coord\", true, \"0px\");\r\n    }\r\n\r\n    private void addConfig(String name, String description, boolean mandatory, String value) {\r\n        ProbeConfiguration pc = new ProbeConfiguration(name, description, mandatory, value);\r\n        addConfigurationParameter(pc);\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        String result = \"test probe1v2 measure \" + counter;\r\n        counter++;\r\n        log.debug(\"Performed measure:\" + result);\r\n        return new BaseMeasure(result);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/tester/TestProbe1v2.java",
		"test_prompt": "// TestProbe1v2Test.java\npackage fi.vtt.noen.mfw.probes.tester;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TestProbe1v2}.\n* It contains ten unit test cases for the {@link TestProbe1v2#measure()} method.\n*/\nclass TestProbe1v2Test {"
	},
	{
		"original_code": "// CustomProbeFacade.java\n/*\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.mfw.probes.custom;\n\nimport ch.ethz.ssh2.Connection;\nimport ch.ethz.ssh2.Session;\nimport ch.ethz.ssh2.StreamGobbler;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.Probe;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEventBus;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport org.osgi.framework.BundleContext;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Properties;\n\n/**\n * This class includes the functionality of custom probes as added from the SAC interface.\n *\n * @author Teemu Kanstren\n */\npublic class CustomProbeFacade implements Probe {\n\n    private final static Logger log = new Logger(CustomProbeActivator.class);\n\n    //these KEY_XXX values are the configuration values for each probe\n    private static final String KEY_SCRIPT = \"script\";\n\n    private static final String KEY_PASSWORD = \"password\";\n\n    private static final String KEY_LOGIN = \"login\";\n\n    private static final String KEY_TARGET = \"target\";\n\n    private static final String KEY_BMDESCRIPTION = \"bmdescription\";\n\n    //this allows us to provide events to the web-ui\n    private final ProbeEventBus eventBus;\n\n    //access to shared state/resources\n    private final CustomCore core;\n\n    //the 5 variables below are the ones given in the \"add\" parameter\n    private final String targetName;\n\n    private final String targetType;\n\n    private final String bmClass;\n\n    private final String bmName;\n\n    private final String name;\n\n    //the 5 variables below are the ones that can be set one at a time from the SAC interface\n    private String target;\n\n    private String login;\n\n    private String password;\n\n    private String script;\n\n    private String bmDescription;\n\n    public CustomProbeFacade(CustomCore core, BundleContext bc, String url) {\n        this.core = core;\n        //here the \"url\" is the \"add\" parameter value from CoreConfigurationHandler\n        //it is expected to have the form \"targettype/targetname/bmclass/bmname/probename\"\n        String[] items = url.split(\"/\");\n        targetType = items[0];\n        targetName = items[1];\n        bmClass = items[2];\n        bmName = items[3];\n        name = items[4];\n        this.eventBus = new ProbeEventBus(bc);\n        log.debug(\"Created probe with target type=\" + targetType + \", target name=\" + targetName + \" bmclass=\" + bmClass + \" bmname=\" + bmName + \" name=\" + name);\n    }\n\n    public ProbeInformation getInformation() {\n        //this is how the generic probe-agent knows what this can measure\n        return new ProbeInformation(targetName, targetType, bmClass, bmName, bmDescription, name, 1, null);\n    }\n\n    //here is the actual measurement done\n    //give it a string value and return it, and the result will be delivered to the SAC\n    public BaseMeasure measure() {\n        //we can only run the SSH script if we have all required items: address, login, password, script\n        String error = checkParameter(target, KEY_TARGET, \"\");\n        error = checkParameter(login, KEY_LOGIN, error);\n        error = checkParameter(password, KEY_PASSWORD, error);\n        error = checkParameter(script, KEY_SCRIPT, error);\n        if (error.length() > 0) {\n            eventBus.event(getInformation(), \"Unable to measure:\" + error);\n            return null;\n        }\n        try {\n            String result = executeScript();\n            log.debug(\"measurement result:\" + result);\n            return new BaseMeasure(result);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to perform measure for \" + target + \", \" + bmClass + \", \", e);\n        }\n    }\n\n    private String checkParameter(String value, String name, String error) {\n        if (value != null) {\n            return error;\n        }\n        if (error.length() > 0) {\n            error += \", \";\n        }\n        error += name;\n        return error;\n    }\n\n    public void startProbe() {\n    }\n\n    public void stopProbe() {\n    }\n\n    //here we handle the setting of the parameters from the SAC\n    public void setConfiguration(Map<String, String> configuration) {\n        String target = configuration.get(KEY_TARGET);\n        String login = configuration.get(KEY_LOGIN);\n        String password = configuration.get(KEY_PASSWORD);\n        String script = configuration.get(KEY_SCRIPT);\n        String bmDescription = configuration.get(KEY_BMDESCRIPTION);\n        if (target != null) {\n            this.target = target;\n        }\n        if (login != null) {\n            this.login = login;\n        }\n        if (password != null) {\n            this.password = password;\n        }\n        if (script != null) {\n            this.script = script;\n        }\n        if (bmDescription != null) {\n            this.bmDescription = bmDescription;\n        }\n    }\n\n    //return the current configuration parameters to the SAC when requested\n    public Collection<ProbeConfiguration> getConfigurationParameters() {\n        Collection<ProbeConfiguration> config = new ArrayList<ProbeConfiguration>();\n        config.add(new ProbeConfiguration(KEY_TARGET, \"Target address\", true, target));\n        config.add(new ProbeConfiguration(KEY_LOGIN, \"Username for login\", true, login));\n        config.add(new ProbeConfiguration(KEY_PASSWORD, \"Password for login\", true, password));\n        config.add(new ProbeConfiguration(KEY_BMDESCRIPTION, \"BM Description\", true, bmDescription));\n        config.add(new ProbeConfiguration(KEY_SCRIPT, \"SSH Script to collect the measure\", true, script));\n        return config;\n    }\n\n    public void init(Properties properties) {\n    }\n\n    //execute the script over SSH\n    private String executeScript() throws Exception {\n        //get the shared connection resource\n        Connection connection = core.getConnection(target, login, password);\n        log.debug(\"executing script on target:\" + target);\n        Session session = connection.openSession();\n        session.execCommand(script);\n        InputStream stdout = new StreamGobbler(session.getStdout());\n        InputStream stderr = new StreamGobbler(session.getStderr());\n        String output = readOutput(stdout);\n        String errors = readOutput(stderr);\n        log.debug(\"done reading, errors:\" + errors);\n        /* Close this session */\n        session.close();\n        return output;\n    }\n\n    private String readOutput(InputStream in) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(in));\n        StringBuffer result = new StringBuffer();\n        while (true) {\n            String line = br.readLine();\n            if (line == null)\n                break;\n            result.append(line);\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/custom/CustomProbeFacade.java",
		"test_prompt": "// CustomProbeFacadeTest.java\npackage fi.vtt.noen.mfw.probes.custom;\n\nimport ch.ethz.ssh2.Connection;\nimport ch.ethz.ssh2.Session;\nimport ch.ethz.ssh2.StreamGobbler;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.Probe;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEventBus;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport org.osgi.framework.BundleContext;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CustomProbeFacade}.\n* It contains ten unit test cases for the {@link CustomProbeFacade#measure()} method.\n*/\nclass CustomProbeFacadeTest {"
	},
	{
		"original_code": "// CoreConfigurationHandler.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.probes.custom;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.Probe;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.util.Collection;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class CoreConfigurationHandler implements Probe {\r\n\r\n    private final CustomCore core;\r\n\r\n    //this is the OSGI reference that allows all the plugins to find each other\r\n    private final BundleContext bc;\r\n\r\n    public CoreConfigurationHandler(CustomCore core, BundleContext bc) {\r\n        this.core = core;\r\n        this.bc = bc;\r\n    }\r\n\r\n    public ProbeInformation getInformation() {\r\n        //you should in practice replace the values here with something of your own.\r\n        //as this probe is there just to let new probes be installed on the fly, there is no valid measurement\r\n        return new ProbeInformation(\"CustomTarget1\", \"ProbeConfigurationHandler\", \"None\", \"None\", \"None\", \"This probe is only a facade to add other probes\", 0, null);\r\n    }\r\n\r\n    public BaseMeasure measure() {\r\n        //always returns null, causing endless errors in the MFW \"events\" page when activated\r\n        return null;\r\n    }\r\n\r\n    public void startProbe() {\r\n    }\r\n\r\n    public void stopProbe() {\r\n    }\r\n\r\n    public void setConfiguration(Map<String, String> configuration) {\r\n        String url = configuration.get(\"add\");\r\n        //if there is a parameter named \"add\" present, we create a new probe from the information embedded in it\r\n        //check the CustomProbeFacade constructor for the parsing of the data.\r\n        //NOTE: There is no real error handling here, you should check your parameters for real\r\n        if (url != null) {\r\n            CustomProbeFacade facade = new CustomProbeFacade(core, bc, url);\r\n            bc.registerService(Probe.class.getName(), facade, null);\r\n        }\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getConfigurationParameters() {\r\n        return null;\r\n    }\r\n\r\n    public void init(Properties properties) {\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/probes/custom/CoreConfigurationHandler.java",
		"test_prompt": "// CoreConfigurationHandlerTest.java\npackage fi.vtt.noen.mfw.probes.custom;\n\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.Probe;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport org.osgi.framework.BundleContext;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CoreConfigurationHandler}.\n* It contains ten unit test cases for the {@link CoreConfigurationHandler#measure()} method.\n*/\nclass CoreConfigurationHandlerTest {"
	},
	{
		"original_code": "// DMProcessor.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.derivedmeasure;\r\n\r\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport javax.script.ScriptEngine;\r\nimport javax.script.ScriptEngineManager;\r\nimport javax.script.ScriptException;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\n\r\n/**\r\n * A component that takes care of actual processing of derived measures according to received requests.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMProcessor {\r\n\r\n    private final static Logger log = new Logger(DMProcessor.class);\r\n\r\n    private final Collection<BMDescription> requiredValues;\r\n\r\n    //this is a set to keep only the latest value available\r\n    protected final Map<BMDescription, Value> values = new TreeMap<BMDescription, Value>();\r\n\r\n    private final String name;\r\n\r\n    private final DMDefinition dmDefinition;\r\n\r\n    protected final Blackboard bb;\r\n\r\n    //  private final DMPlugin plugin;\r\n    public DMProcessor(Blackboard bb, DMDefinition dmDefinition) {\r\n        this.dmDefinition = dmDefinition;\r\n        this.requiredValues = dmDefinition.getRequiredBM();\r\n        this.name = dmDefinition.getName();\r\n        this.bb = bb;\r\n        //    this.plugin = plugin;\r\n    }\r\n\r\n    public String name() {\r\n        return name;\r\n    }\r\n\r\n    public void process(Value toProcess) throws DMProcessingException {\r\n        checkAndSaveValue(toProcess);\r\n        Collection<BMDescription> missingValues = getMissingValues();\r\n        log.debug(\"Missing values:\" + missingValues);\r\n        DMValue dmValue = null;\r\n        if (missingValues.size() > 0) {\r\n            dmValue = new DMValue(dmDefinition, System.currentTimeMillis(), missingValues);\r\n        } else if (dmDefinition.getScript() == null) {\r\n            //todo: create an event here..\r\n            //      dmValue = new DMValue(\"No script defined\");\r\n        } else {\r\n            dmValue = executeScript();\r\n        }\r\n        log.debug(\"publishing DM value:\" + dmValue);\r\n        bb.process(dmValue);\r\n    }\r\n\r\n    public void checkAndSaveValue(Value value) {\r\n        log.debug(\"processing value:\" + value);\r\n        for (BMDescription bm : requiredValues) {\r\n            if (bm.matches(value)) {\r\n                Value old = values.get(bm);\r\n                //todo: timeout for when do we take the new measure into use if higher precision is old?\r\n                if (old == null || value.getPrecision() >= old.getPrecision()) {\r\n                    values.put(bm, value);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private Collection<BMDescription> getMissingValues() {\r\n        Set<BMDescription> missing = new HashSet<BMDescription>();\r\n        log.debug(\"required values:\" + requiredValues);\r\n        for (BMDescription bm : requiredValues) {\r\n            if (values.get(bm) == null) {\r\n                missing.add(bm);\r\n            }\r\n        }\r\n        return missing;\r\n    }\r\n\r\n    private DMValue executeScript() throws DMProcessingException {\r\n        ScriptEngineManager mgr = new ScriptEngineManager();\r\n        ScriptEngine jsEngine = mgr.getEngineByName(\"JavaScript\");\r\n        String script = createFullScript();\r\n        log.debug(\"Trying to execute script:\" + script);\r\n        Object result = null;\r\n        try {\r\n            result = jsEngine.eval(script);\r\n        } catch (ScriptException e) {\r\n            throw new DMProcessingException(\"Error in processing derived measure \" + name, e);\r\n        }\r\n        long time = System.currentTimeMillis();\r\n        if (result instanceof Number) {\r\n            Number n = (Number) result;\r\n            double d = n.doubleValue();\r\n            return new DMValue(dmDefinition, d, time);\r\n        }\r\n        if (result instanceof Boolean) {\r\n            Boolean b = (Boolean) result;\r\n            return new DMValue(dmDefinition, b, time);\r\n        }\r\n        if (result instanceof String) {\r\n            String str = (String) result;\r\n            return new DMValue(dmDefinition, str, time);\r\n        }\r\n        throw new DMProcessingException(\"Unable to map script return type to value type (not one of Number, Boolean or String) for DM \" + name);\r\n    }\r\n\r\n    public String createFullScript() throws DMProcessingException {\r\n        Collection<BMDescription> missingValues = getMissingValues();\r\n        if (missingValues.size() > 0) {\r\n            throw new DMProcessingException(\"Cannot create script for derived measure:\" + name + \" - missing values: \" + missingValues);\r\n        }\r\n        String script = \"\";\r\n        int i = 1;\r\n        for (Value value : values.values()) {\r\n            script += \"bm\" + (i++) + \" = \" + value.valueString() + \";\\n\";\r\n        }\r\n        script += dmDefinition.getScript();\r\n        return script;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/derivedmeasure/DMProcessor_0Test.java",
		"test_prompt": "// DMProcessor_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.derivedmeasure;\n\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMProcessor}.\n* It contains ten unit test cases for the {@link DMProcessor#name()} method.\n*/\nclass DMProcessor_0Test {"
	},
	{
		"original_code": "// DMProcessor.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.derivedmeasure;\r\n\r\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport javax.script.ScriptEngine;\r\nimport javax.script.ScriptEngineManager;\r\nimport javax.script.ScriptException;\r\nimport java.util.Collection;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\n\r\n/**\r\n * A component that takes care of actual processing of derived measures according to received requests.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMProcessor {\r\n\r\n    private final static Logger log = new Logger(DMProcessor.class);\r\n\r\n    private final Collection<BMDescription> requiredValues;\r\n\r\n    //this is a set to keep only the latest value available\r\n    protected final Map<BMDescription, Value> values = new TreeMap<BMDescription, Value>();\r\n\r\n    private final String name;\r\n\r\n    private final DMDefinition dmDefinition;\r\n\r\n    protected final Blackboard bb;\r\n\r\n    //  private final DMPlugin plugin;\r\n    public DMProcessor(Blackboard bb, DMDefinition dmDefinition) {\r\n        this.dmDefinition = dmDefinition;\r\n        this.requiredValues = dmDefinition.getRequiredBM();\r\n        this.name = dmDefinition.getName();\r\n        this.bb = bb;\r\n        //    this.plugin = plugin;\r\n    }\r\n\r\n    public String name() {\r\n        return name;\r\n    }\r\n\r\n    public void process(Value toProcess) throws DMProcessingException {\r\n        checkAndSaveValue(toProcess);\r\n        Collection<BMDescription> missingValues = getMissingValues();\r\n        log.debug(\"Missing values:\" + missingValues);\r\n        DMValue dmValue = null;\r\n        if (missingValues.size() > 0) {\r\n            dmValue = new DMValue(dmDefinition, System.currentTimeMillis(), missingValues);\r\n        } else if (dmDefinition.getScript() == null) {\r\n            //todo: create an event here..\r\n            //      dmValue = new DMValue(\"No script defined\");\r\n        } else {\r\n            dmValue = executeScript();\r\n        }\r\n        log.debug(\"publishing DM value:\" + dmValue);\r\n        bb.process(dmValue);\r\n    }\r\n\r\n    public void checkAndSaveValue(Value value) {\r\n        log.debug(\"processing value:\" + value);\r\n        for (BMDescription bm : requiredValues) {\r\n            if (bm.matches(value)) {\r\n                Value old = values.get(bm);\r\n                //todo: timeout for when do we take the new measure into use if higher precision is old?\r\n                if (old == null || value.getPrecision() >= old.getPrecision()) {\r\n                    values.put(bm, value);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private Collection<BMDescription> getMissingValues() {\r\n        Set<BMDescription> missing = new HashSet<BMDescription>();\r\n        log.debug(\"required values:\" + requiredValues);\r\n        for (BMDescription bm : requiredValues) {\r\n            if (values.get(bm) == null) {\r\n                missing.add(bm);\r\n            }\r\n        }\r\n        return missing;\r\n    }\r\n\r\n    private DMValue executeScript() throws DMProcessingException {\r\n        ScriptEngineManager mgr = new ScriptEngineManager();\r\n        ScriptEngine jsEngine = mgr.getEngineByName(\"JavaScript\");\r\n        String script = createFullScript();\r\n        log.debug(\"Trying to execute script:\" + script);\r\n        Object result = null;\r\n        try {\r\n            result = jsEngine.eval(script);\r\n        } catch (ScriptException e) {\r\n            throw new DMProcessingException(\"Error in processing derived measure \" + name, e);\r\n        }\r\n        long time = System.currentTimeMillis();\r\n        if (result instanceof Number) {\r\n            Number n = (Number) result;\r\n            double d = n.doubleValue();\r\n            return new DMValue(dmDefinition, d, time);\r\n        }\r\n        if (result instanceof Boolean) {\r\n            Boolean b = (Boolean) result;\r\n            return new DMValue(dmDefinition, b, time);\r\n        }\r\n        if (result instanceof String) {\r\n            String str = (String) result;\r\n            return new DMValue(dmDefinition, str, time);\r\n        }\r\n        throw new DMProcessingException(\"Unable to map script return type to value type (not one of Number, Boolean or String) for DM \" + name);\r\n    }\r\n\r\n    public String createFullScript() throws DMProcessingException {\r\n        Collection<BMDescription> missingValues = getMissingValues();\r\n        if (missingValues.size() > 0) {\r\n            throw new DMProcessingException(\"Cannot create script for derived measure:\" + name + \" - missing values: \" + missingValues);\r\n        }\r\n        String script = \"\";\r\n        int i = 1;\r\n        for (Value value : values.values()) {\r\n            script += \"bm\" + (i++) + \" = \" + value.valueString() + \";\\n\";\r\n        }\r\n        script += dmDefinition.getScript();\r\n        return script;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/derivedmeasure/DMProcessor_1Test.java",
		"test_prompt": "// DMProcessor_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.derivedmeasure;\n\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMProcessor}.\n* It contains ten unit test cases for the {@link DMProcessor#createFullScript()} method.\n*/\nclass DMProcessor_1Test {"
	},
	{
		"original_code": "// AvailabilityThreadFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ThreadFactory;\r\n\r\n/**\r\n * Creates threads for the thread pool. Delegates to Executors.detaultThreadFactory with the difference that\r\n * all threads created as defined as daemon threads.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class AvailabilityThreadFactory implements ThreadFactory {\r\n\r\n    private final static Logger log = new Logger(AvailabilityThreadFactory.class);\r\n\r\n    private final ThreadFactory delegate = Executors.defaultThreadFactory();\r\n\r\n    public Thread newThread(Runnable r) {\r\n        log.debug(\"new thread created\");\r\n        Thread t = delegate.newThread(r);\r\n        t.setDaemon(true);\r\n        return t;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/AvailabilityThreadFactory.java",
		"test_prompt": "// AvailabilityThreadFactoryTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AvailabilityThreadFactory}.\n* It contains ten unit test cases for the {@link AvailabilityThreadFactory#newThread(Runnable)} method.\n*/\nclass AvailabilityThreadFactoryTest {"
	},
	{
		"original_code": "// SACPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.Availability;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.SACClient;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n//import java.util.Vector;\r\n/**\r\n * The actual component that links the MFW server to the BUGYO Beyond cockpit.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class SACPlugin extends BasePlugin implements RegistryUser, ServerUser {\r\n\r\n    private final static Logger log = new Logger(SACPlugin.class);\r\n\r\n    //for the server-agent to communicate with the probe-agents\r\n    private ServerPlugin server;\r\n\r\n    //for accessing runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    private Map<Long, String> sacsUrls;\r\n\r\n    private Map<Long, SAC> sacs = new HashMap<Long, SAC>();\r\n\r\n    private AvailabilityProvider availabilityProvider;\r\n\r\n    private long mfwId = 1;\r\n\r\n    public SACPlugin(BundleContext bc, Map<Long, String> sacsUrls, int availabilityInterval, long mfwId) {\r\n        super(bc, log);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n        this.sacsUrls = sacsUrls;\r\n        availabilityProvider = new AvailabilityProvider(this, availabilityInterval, mfwId);\r\n        this.mfwId = mfwId;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    //Gives a list of available BM.\r\n    public List<BMDescription> getAvailableBMList() {\r\n        return registry.getAvailableBM();\r\n    }\r\n\r\n    //Requests for a given measurement to be provided.\r\n    public boolean requestBM(long sacId, long bmId) {\r\n        //TODO: failure handling, if invalid SAC ID or BM ID is given, this should fail as well as all the other calls in this class\r\n        boolean result = false;\r\n        log.info(\"SAC Requesting BM - SAC ID:\" + sacId + \" BM ID:\" + bmId);\r\n        try {\r\n            ProbeDescription probe = registry.getProbeForBM(bmId);\r\n            long subscriptionId = registry.addMeasurementRequest(sacId, probe.getBm(), probe.getProbeId());\r\n            server.requestBM(bmId, subscriptionId);\r\n            result = true;\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to fetch requested BM: \" + bmId, e);\r\n            event(new ServerEvent(System.currentTimeMillis(), EventType.GENERAL_ERROR, \"SACPlugin\", e.getMessage()));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Requests for a given measurement to be provided.\r\n     *\r\n     * @param sacId identifies the SAC\r\n     * @param bmId identifies the BM\r\n     * @param interval How often should we sample? In milliseconds.\r\n     */\r\n    public void subscribeToBM(long sacId, long bmId, long interval) {\r\n        log.info(\"SAC subscribing to BM - SAC ID:\" + sacId + \" BM ID:\" + bmId + \" interval:\" + interval);\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addSubscription(sacId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(bmId, interval, subscriptionId);\r\n    }\r\n\r\n    //removes an existing subscription\r\n    public void unSubscribeToBM(long sacId, long bmId) {\r\n        log.info(\"SAC unsubscribing to BM - SAC ID:\" + sacId + \" BM ID:\" + bmId);\r\n        long subscriptionId = registry.getIdForSubscription(sacId, bmId);\r\n        server.unSubscribeToBM(bmId, subscriptionId);\r\n        registry.removeSubscription(sacId, subscriptionId);\r\n    }\r\n\r\n    //This should return a list of probes connected to the MFW.\r\n    public List<ProbeDescription> getProbeList() {\r\n        return registry.getProbes();\r\n    }\r\n\r\n    //list of targets of measurement (some call them devices)\r\n    public Collection<TargetDescription> getTargetList() {\r\n        return registry.getTargets();\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getProbeConfigurationParameters(long probeId) {\r\n        Collection<ProbeConfiguration> configuration = server.requestProbeConfigurationParameters(probeId);\r\n        return configuration;\r\n    }\r\n\r\n    //This should set the configuration for a given probe.\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        boolean ok = server.setProbeConfiguration(probeId, configuration);\r\n        return ok;\r\n    }\r\n\r\n    //This gives some information about the MFW.\r\n    public String getMFWInformation() {\r\n        return \"Your favourite MFW is here\";\r\n        //TODO: need to return id, version, IFs???, company, time\r\n    }\r\n\r\n    /**\r\n     * Sends an event to the SAC. Since the SAC interface currently supports no events, this is left here for\r\n     * the time when people again realize it should.\r\n     *\r\n     * @param event The event to be passed.\r\n     */\r\n    public void event(ServerEvent event) {\r\n        if (sacs.isEmpty()) {\r\n            log.debug(\"No SAC defined, ignoring event\");\r\n            return;\r\n        }\r\n        for (SAC sac : sacs.values()) {\r\n            String msg = event.getMessage();\r\n            log.debug(\"passing event:\" + event);\r\n            sac.event(msg);\r\n        }\r\n    }\r\n\r\n    public boolean sacRegistered(long sacId) {\r\n        return register(sacId);\r\n    }\r\n\r\n    public boolean register(long sacId) {\r\n        //if sac not registered\r\n        if (!sacs.containsKey(sacId)) {\r\n            String sacUrl = sacsUrls.get(sacId);\r\n            //if sacId/sacUrl found (read from property file on startup)\r\n            if (sacUrl != null) {\r\n                SACClient sacClient = new SACClient(this, sacUrl, sacId, mfwId);\r\n                //log.debug(\"Registering SAC (ID:\" +sacId+ \")\");\r\n                //sacs.put(sacId, sacClient);\r\n                register(sacId, sacClient);\r\n                bb.process(new ServerEvent(System.currentTimeMillis(), EventType.SAC_REGISTERED, \"SAC:\" + sacId, \"New SAC registered URL:\" + sacUrl));\r\n            } else {\r\n                bb.process(new ServerEvent(System.currentTimeMillis(), EventType.SAC_REGISTERED, \"SAC:\" + sacId, \"Attempt to register a SAC with unknown ID failed.\"));\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void register(long sacId, SAC sac) {\r\n        log.info(\"Registering SAC (ID:\" + sacId + \")\");\r\n        sacs.put(sacId, sac);\r\n        availabilityProvider.registerSAC(sacId, sac);\r\n    }\r\n\r\n    //called by the server-agent to provide a BM value to the SAC as it has requested\r\n    public void bmValue(Value value) {\r\n        log.info(\"Received BM value:\" + value);\r\n        //get sacId for subscriptionId\r\n        long sid = value.getSubscriptionId();\r\n        long sacId = registry.getSacIdForSubscription(sid);\r\n        log.debug(\"subscriptionId: \" + sid + \", sacId: \" + sacId);\r\n        if (sacId == 0) {\r\n            //received measurement value for subscription that was not found (removed)\r\n            //(re)send unsubscription\r\n            //server.unSubscribeToBM(value.getBm().getBmId(), value.getSubscriptionId());\r\n        }\r\n        //get sac for sacId\r\n        SAC sac = sacs.get(sacId);\r\n        log.debug(\"SAC:\" + sac);\r\n        if (sac == null) {\r\n            log.error(\"No SAC registered for measurement, not sending BM Value\");\r\n            return;\r\n        }\r\n        //if one time measurement, remove subscription from registry\r\n        if (registry.getFrequencyForSubscription(sid) == 0) {\r\n            log.debug(\"remove call\");\r\n            registry.removeSubscription(sacId, sid);\r\n            log.debug(\"remove call done\");\r\n        }\r\n        log.debug(\"providing value to:\" + sac);\r\n        sac.bmResult(value);\r\n    }\r\n\r\n    /*  \r\n  public void setAvailability(Availability availability) {\r\n    if (sacs.isEmpty()) {      \r\n      log.error(\"No SAC registered, not reporting availability change\");\r\n      return;\r\n    }\r\n    for (SAC sac : sacs.values()) {\r\n      sac.setAvailability(availability);\r\n    }\r\n  }\r\n*/\r\n    //list of information to be received from the blackboard\r\n    public Set getCommands() {\r\n        return createCommandSet(Value.class, ServerEvent.class, ProbeRegistered.class, ProbeDisabled.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            log.debug(\"received value:\" + value);\r\n            bmValue(value);\r\n        } else if (data instanceof ServerEvent) {\r\n            ServerEvent event = (ServerEvent) data;\r\n            log.debug(\"received event:\" + event);\r\n            event(event);\r\n            /*      if (event.type.equals(EventType.PROBE_HUNG)) {\r\n        ProbeDescription probe = registry.getProbeForSubscription(event.getSubscriptionId());\r\n        registry.setProbeDisabled(probe);\r\n      }*/\r\n        } else if (data instanceof ProbeRegistered) {\r\n            /*\r\n      ProbeRegistered pr = (ProbeRegistered) data;\r\n      log.debug(\"received probe registered:\" + pr);\r\n      \r\n      if (sacs.isEmpty()) {      \r\n        log.error(\"No SAC registered, not reporting Probe registration\");\r\n        return;\r\n      }\r\n      //ProbeDescription pd = pr.getProbeDescription();\r\n      for (SAC sac : sacs.values()) {\r\n        sac.probeRegistered(pr);\r\n      }\r\n      //todo: create event     \r\n*/\r\n            //availabilityProvider.setAvailabilityChanged();\r\n            ProbeRegistered pr = (ProbeRegistered) data;\r\n            log.debug(\"received probe registered:\" + pr);\r\n            availabilityProvider.probeRegistered(pr);\r\n        } else if (data instanceof ProbeDisabled) {\r\n            /*\r\n      ProbeDisabled msg = (ProbeDisabled) data;\r\n      log.debug(\"received probe disabled:\" + msg);\r\n      \r\n      if (sacs.isEmpty()) {      \r\n        log.error(\"No SAC registered, not reporting Probe disabled\");\r\n        return;\r\n      }\r\n      //ProbeDescription pd = msg.getProbeDescription();\r\n      for (SAC sac : sacs.values()) {\r\n        sac.probeDisabled(msg);\r\n      }\r\n*/\r\n            //availabilityProvider.setAvailabilityChanged();\r\n            ProbeDisabled msg = (ProbeDisabled) data;\r\n            log.debug(\"received probe disabled:\" + msg);\r\n            availabilityProvider.probeDisabled(msg);\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/SACPlugin_0Test.java",
		"test_prompt": "// SACPlugin_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.Availability;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.SACClient;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.osgi.framework.BundleContext;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SACPlugin}.\n* It contains ten unit test cases for the {@link SACPlugin#requestBM(long, long)} method.\n*/\nclass SACPlugin_0Test {"
	},
	{
		"original_code": "// SACPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.Availability;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.SACClient;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n//import java.util.Vector;\r\n/**\r\n * The actual component that links the MFW server to the BUGYO Beyond cockpit.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class SACPlugin extends BasePlugin implements RegistryUser, ServerUser {\r\n\r\n    private final static Logger log = new Logger(SACPlugin.class);\r\n\r\n    //for the server-agent to communicate with the probe-agents\r\n    private ServerPlugin server;\r\n\r\n    //for accessing runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    private Map<Long, String> sacsUrls;\r\n\r\n    private Map<Long, SAC> sacs = new HashMap<Long, SAC>();\r\n\r\n    private AvailabilityProvider availabilityProvider;\r\n\r\n    private long mfwId = 1;\r\n\r\n    public SACPlugin(BundleContext bc, Map<Long, String> sacsUrls, int availabilityInterval, long mfwId) {\r\n        super(bc, log);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n        this.sacsUrls = sacsUrls;\r\n        availabilityProvider = new AvailabilityProvider(this, availabilityInterval, mfwId);\r\n        this.mfwId = mfwId;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    //Gives a list of available BM.\r\n    public List<BMDescription> getAvailableBMList() {\r\n        return registry.getAvailableBM();\r\n    }\r\n\r\n    //Requests for a given measurement to be provided.\r\n    public boolean requestBM(long sacId, long bmId) {\r\n        //TODO: failure handling, if invalid SAC ID or BM ID is given, this should fail as well as all the other calls in this class\r\n        boolean result = false;\r\n        log.info(\"SAC Requesting BM - SAC ID:\" + sacId + \" BM ID:\" + bmId);\r\n        try {\r\n            ProbeDescription probe = registry.getProbeForBM(bmId);\r\n            long subscriptionId = registry.addMeasurementRequest(sacId, probe.getBm(), probe.getProbeId());\r\n            server.requestBM(bmId, subscriptionId);\r\n            result = true;\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to fetch requested BM: \" + bmId, e);\r\n            event(new ServerEvent(System.currentTimeMillis(), EventType.GENERAL_ERROR, \"SACPlugin\", e.getMessage()));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Requests for a given measurement to be provided.\r\n     *\r\n     * @param sacId identifies the SAC\r\n     * @param bmId identifies the BM\r\n     * @param interval How often should we sample? In milliseconds.\r\n     */\r\n    public void subscribeToBM(long sacId, long bmId, long interval) {\r\n        log.info(\"SAC subscribing to BM - SAC ID:\" + sacId + \" BM ID:\" + bmId + \" interval:\" + interval);\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addSubscription(sacId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(bmId, interval, subscriptionId);\r\n    }\r\n\r\n    //removes an existing subscription\r\n    public void unSubscribeToBM(long sacId, long bmId) {\r\n        log.info(\"SAC unsubscribing to BM - SAC ID:\" + sacId + \" BM ID:\" + bmId);\r\n        long subscriptionId = registry.getIdForSubscription(sacId, bmId);\r\n        server.unSubscribeToBM(bmId, subscriptionId);\r\n        registry.removeSubscription(sacId, subscriptionId);\r\n    }\r\n\r\n    //This should return a list of probes connected to the MFW.\r\n    public List<ProbeDescription> getProbeList() {\r\n        return registry.getProbes();\r\n    }\r\n\r\n    //list of targets of measurement (some call them devices)\r\n    public Collection<TargetDescription> getTargetList() {\r\n        return registry.getTargets();\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getProbeConfigurationParameters(long probeId) {\r\n        Collection<ProbeConfiguration> configuration = server.requestProbeConfigurationParameters(probeId);\r\n        return configuration;\r\n    }\r\n\r\n    //This should set the configuration for a given probe.\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        boolean ok = server.setProbeConfiguration(probeId, configuration);\r\n        return ok;\r\n    }\r\n\r\n    //This gives some information about the MFW.\r\n    public String getMFWInformation() {\r\n        return \"Your favourite MFW is here\";\r\n        //TODO: need to return id, version, IFs???, company, time\r\n    }\r\n\r\n    /**\r\n     * Sends an event to the SAC. Since the SAC interface currently supports no events, this is left here for\r\n     * the time when people again realize it should.\r\n     *\r\n     * @param event The event to be passed.\r\n     */\r\n    public void event(ServerEvent event) {\r\n        if (sacs.isEmpty()) {\r\n            log.debug(\"No SAC defined, ignoring event\");\r\n            return;\r\n        }\r\n        for (SAC sac : sacs.values()) {\r\n            String msg = event.getMessage();\r\n            log.debug(\"passing event:\" + event);\r\n            sac.event(msg);\r\n        }\r\n    }\r\n\r\n    public boolean sacRegistered(long sacId) {\r\n        return register(sacId);\r\n    }\r\n\r\n    public boolean register(long sacId) {\r\n        //if sac not registered\r\n        if (!sacs.containsKey(sacId)) {\r\n            String sacUrl = sacsUrls.get(sacId);\r\n            //if sacId/sacUrl found (read from property file on startup)\r\n            if (sacUrl != null) {\r\n                SACClient sacClient = new SACClient(this, sacUrl, sacId, mfwId);\r\n                //log.debug(\"Registering SAC (ID:\" +sacId+ \")\");\r\n                //sacs.put(sacId, sacClient);\r\n                register(sacId, sacClient);\r\n                bb.process(new ServerEvent(System.currentTimeMillis(), EventType.SAC_REGISTERED, \"SAC:\" + sacId, \"New SAC registered URL:\" + sacUrl));\r\n            } else {\r\n                bb.process(new ServerEvent(System.currentTimeMillis(), EventType.SAC_REGISTERED, \"SAC:\" + sacId, \"Attempt to register a SAC with unknown ID failed.\"));\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void register(long sacId, SAC sac) {\r\n        log.info(\"Registering SAC (ID:\" + sacId + \")\");\r\n        sacs.put(sacId, sac);\r\n        availabilityProvider.registerSAC(sacId, sac);\r\n    }\r\n\r\n    //called by the server-agent to provide a BM value to the SAC as it has requested\r\n    public void bmValue(Value value) {\r\n        log.info(\"Received BM value:\" + value);\r\n        //get sacId for subscriptionId\r\n        long sid = value.getSubscriptionId();\r\n        long sacId = registry.getSacIdForSubscription(sid);\r\n        log.debug(\"subscriptionId: \" + sid + \", sacId: \" + sacId);\r\n        if (sacId == 0) {\r\n            //received measurement value for subscription that was not found (removed)\r\n            //(re)send unsubscription\r\n            //server.unSubscribeToBM(value.getBm().getBmId(), value.getSubscriptionId());\r\n        }\r\n        //get sac for sacId\r\n        SAC sac = sacs.get(sacId);\r\n        log.debug(\"SAC:\" + sac);\r\n        if (sac == null) {\r\n            log.error(\"No SAC registered for measurement, not sending BM Value\");\r\n            return;\r\n        }\r\n        //if one time measurement, remove subscription from registry\r\n        if (registry.getFrequencyForSubscription(sid) == 0) {\r\n            log.debug(\"remove call\");\r\n            registry.removeSubscription(sacId, sid);\r\n            log.debug(\"remove call done\");\r\n        }\r\n        log.debug(\"providing value to:\" + sac);\r\n        sac.bmResult(value);\r\n    }\r\n\r\n    /*  \r\n  public void setAvailability(Availability availability) {\r\n    if (sacs.isEmpty()) {      \r\n      log.error(\"No SAC registered, not reporting availability change\");\r\n      return;\r\n    }\r\n    for (SAC sac : sacs.values()) {\r\n      sac.setAvailability(availability);\r\n    }\r\n  }\r\n*/\r\n    //list of information to be received from the blackboard\r\n    public Set getCommands() {\r\n        return createCommandSet(Value.class, ServerEvent.class, ProbeRegistered.class, ProbeDisabled.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            log.debug(\"received value:\" + value);\r\n            bmValue(value);\r\n        } else if (data instanceof ServerEvent) {\r\n            ServerEvent event = (ServerEvent) data;\r\n            log.debug(\"received event:\" + event);\r\n            event(event);\r\n            /*      if (event.type.equals(EventType.PROBE_HUNG)) {\r\n        ProbeDescription probe = registry.getProbeForSubscription(event.getSubscriptionId());\r\n        registry.setProbeDisabled(probe);\r\n      }*/\r\n        } else if (data instanceof ProbeRegistered) {\r\n            /*\r\n      ProbeRegistered pr = (ProbeRegistered) data;\r\n      log.debug(\"received probe registered:\" + pr);\r\n      \r\n      if (sacs.isEmpty()) {      \r\n        log.error(\"No SAC registered, not reporting Probe registration\");\r\n        return;\r\n      }\r\n      //ProbeDescription pd = pr.getProbeDescription();\r\n      for (SAC sac : sacs.values()) {\r\n        sac.probeRegistered(pr);\r\n      }\r\n      //todo: create event     \r\n*/\r\n            //availabilityProvider.setAvailabilityChanged();\r\n            ProbeRegistered pr = (ProbeRegistered) data;\r\n            log.debug(\"received probe registered:\" + pr);\r\n            availabilityProvider.probeRegistered(pr);\r\n        } else if (data instanceof ProbeDisabled) {\r\n            /*\r\n      ProbeDisabled msg = (ProbeDisabled) data;\r\n      log.debug(\"received probe disabled:\" + msg);\r\n      \r\n      if (sacs.isEmpty()) {      \r\n        log.error(\"No SAC registered, not reporting Probe disabled\");\r\n        return;\r\n      }\r\n      //ProbeDescription pd = msg.getProbeDescription();\r\n      for (SAC sac : sacs.values()) {\r\n        sac.probeDisabled(msg);\r\n      }\r\n*/\r\n            //availabilityProvider.setAvailabilityChanged();\r\n            ProbeDisabled msg = (ProbeDisabled) data;\r\n            log.debug(\"received probe disabled:\" + msg);\r\n            availabilityProvider.probeDisabled(msg);\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/SACPlugin_1Test.java",
		"test_prompt": "// SACPlugin_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.Availability;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.SACClient;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.osgi.framework.BundleContext;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SACPlugin}.\n* It contains ten unit test cases for the {@link SACPlugin#sacRegistered(long)} method.\n*/\nclass SACPlugin_1Test {"
	},
	{
		"original_code": "// SACPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.Availability;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.SACClient;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n//import java.util.Vector;\r\n/**\r\n * The actual component that links the MFW server to the BUGYO Beyond cockpit.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class SACPlugin extends BasePlugin implements RegistryUser, ServerUser {\r\n\r\n    private final static Logger log = new Logger(SACPlugin.class);\r\n\r\n    //for the server-agent to communicate with the probe-agents\r\n    private ServerPlugin server;\r\n\r\n    //for accessing runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    private Map<Long, String> sacsUrls;\r\n\r\n    private Map<Long, SAC> sacs = new HashMap<Long, SAC>();\r\n\r\n    private AvailabilityProvider availabilityProvider;\r\n\r\n    private long mfwId = 1;\r\n\r\n    public SACPlugin(BundleContext bc, Map<Long, String> sacsUrls, int availabilityInterval, long mfwId) {\r\n        super(bc, log);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n        this.sacsUrls = sacsUrls;\r\n        availabilityProvider = new AvailabilityProvider(this, availabilityInterval, mfwId);\r\n        this.mfwId = mfwId;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    //Gives a list of available BM.\r\n    public List<BMDescription> getAvailableBMList() {\r\n        return registry.getAvailableBM();\r\n    }\r\n\r\n    //Requests for a given measurement to be provided.\r\n    public boolean requestBM(long sacId, long bmId) {\r\n        //TODO: failure handling, if invalid SAC ID or BM ID is given, this should fail as well as all the other calls in this class\r\n        boolean result = false;\r\n        log.info(\"SAC Requesting BM - SAC ID:\" + sacId + \" BM ID:\" + bmId);\r\n        try {\r\n            ProbeDescription probe = registry.getProbeForBM(bmId);\r\n            long subscriptionId = registry.addMeasurementRequest(sacId, probe.getBm(), probe.getProbeId());\r\n            server.requestBM(bmId, subscriptionId);\r\n            result = true;\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to fetch requested BM: \" + bmId, e);\r\n            event(new ServerEvent(System.currentTimeMillis(), EventType.GENERAL_ERROR, \"SACPlugin\", e.getMessage()));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Requests for a given measurement to be provided.\r\n     *\r\n     * @param sacId identifies the SAC\r\n     * @param bmId identifies the BM\r\n     * @param interval How often should we sample? In milliseconds.\r\n     */\r\n    public void subscribeToBM(long sacId, long bmId, long interval) {\r\n        log.info(\"SAC subscribing to BM - SAC ID:\" + sacId + \" BM ID:\" + bmId + \" interval:\" + interval);\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addSubscription(sacId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(bmId, interval, subscriptionId);\r\n    }\r\n\r\n    //removes an existing subscription\r\n    public void unSubscribeToBM(long sacId, long bmId) {\r\n        log.info(\"SAC unsubscribing to BM - SAC ID:\" + sacId + \" BM ID:\" + bmId);\r\n        long subscriptionId = registry.getIdForSubscription(sacId, bmId);\r\n        server.unSubscribeToBM(bmId, subscriptionId);\r\n        registry.removeSubscription(sacId, subscriptionId);\r\n    }\r\n\r\n    //This should return a list of probes connected to the MFW.\r\n    public List<ProbeDescription> getProbeList() {\r\n        return registry.getProbes();\r\n    }\r\n\r\n    //list of targets of measurement (some call them devices)\r\n    public Collection<TargetDescription> getTargetList() {\r\n        return registry.getTargets();\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getProbeConfigurationParameters(long probeId) {\r\n        Collection<ProbeConfiguration> configuration = server.requestProbeConfigurationParameters(probeId);\r\n        return configuration;\r\n    }\r\n\r\n    //This should set the configuration for a given probe.\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        boolean ok = server.setProbeConfiguration(probeId, configuration);\r\n        return ok;\r\n    }\r\n\r\n    //This gives some information about the MFW.\r\n    public String getMFWInformation() {\r\n        return \"Your favourite MFW is here\";\r\n        //TODO: need to return id, version, IFs???, company, time\r\n    }\r\n\r\n    /**\r\n     * Sends an event to the SAC. Since the SAC interface currently supports no events, this is left here for\r\n     * the time when people again realize it should.\r\n     *\r\n     * @param event The event to be passed.\r\n     */\r\n    public void event(ServerEvent event) {\r\n        if (sacs.isEmpty()) {\r\n            log.debug(\"No SAC defined, ignoring event\");\r\n            return;\r\n        }\r\n        for (SAC sac : sacs.values()) {\r\n            String msg = event.getMessage();\r\n            log.debug(\"passing event:\" + event);\r\n            sac.event(msg);\r\n        }\r\n    }\r\n\r\n    public boolean sacRegistered(long sacId) {\r\n        return register(sacId);\r\n    }\r\n\r\n    public boolean register(long sacId) {\r\n        //if sac not registered\r\n        if (!sacs.containsKey(sacId)) {\r\n            String sacUrl = sacsUrls.get(sacId);\r\n            //if sacId/sacUrl found (read from property file on startup)\r\n            if (sacUrl != null) {\r\n                SACClient sacClient = new SACClient(this, sacUrl, sacId, mfwId);\r\n                //log.debug(\"Registering SAC (ID:\" +sacId+ \")\");\r\n                //sacs.put(sacId, sacClient);\r\n                register(sacId, sacClient);\r\n                bb.process(new ServerEvent(System.currentTimeMillis(), EventType.SAC_REGISTERED, \"SAC:\" + sacId, \"New SAC registered URL:\" + sacUrl));\r\n            } else {\r\n                bb.process(new ServerEvent(System.currentTimeMillis(), EventType.SAC_REGISTERED, \"SAC:\" + sacId, \"Attempt to register a SAC with unknown ID failed.\"));\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void register(long sacId, SAC sac) {\r\n        log.info(\"Registering SAC (ID:\" + sacId + \")\");\r\n        sacs.put(sacId, sac);\r\n        availabilityProvider.registerSAC(sacId, sac);\r\n    }\r\n\r\n    //called by the server-agent to provide a BM value to the SAC as it has requested\r\n    public void bmValue(Value value) {\r\n        log.info(\"Received BM value:\" + value);\r\n        //get sacId for subscriptionId\r\n        long sid = value.getSubscriptionId();\r\n        long sacId = registry.getSacIdForSubscription(sid);\r\n        log.debug(\"subscriptionId: \" + sid + \", sacId: \" + sacId);\r\n        if (sacId == 0) {\r\n            //received measurement value for subscription that was not found (removed)\r\n            //(re)send unsubscription\r\n            //server.unSubscribeToBM(value.getBm().getBmId(), value.getSubscriptionId());\r\n        }\r\n        //get sac for sacId\r\n        SAC sac = sacs.get(sacId);\r\n        log.debug(\"SAC:\" + sac);\r\n        if (sac == null) {\r\n            log.error(\"No SAC registered for measurement, not sending BM Value\");\r\n            return;\r\n        }\r\n        //if one time measurement, remove subscription from registry\r\n        if (registry.getFrequencyForSubscription(sid) == 0) {\r\n            log.debug(\"remove call\");\r\n            registry.removeSubscription(sacId, sid);\r\n            log.debug(\"remove call done\");\r\n        }\r\n        log.debug(\"providing value to:\" + sac);\r\n        sac.bmResult(value);\r\n    }\r\n\r\n    /*  \r\n  public void setAvailability(Availability availability) {\r\n    if (sacs.isEmpty()) {      \r\n      log.error(\"No SAC registered, not reporting availability change\");\r\n      return;\r\n    }\r\n    for (SAC sac : sacs.values()) {\r\n      sac.setAvailability(availability);\r\n    }\r\n  }\r\n*/\r\n    //list of information to be received from the blackboard\r\n    public Set getCommands() {\r\n        return createCommandSet(Value.class, ServerEvent.class, ProbeRegistered.class, ProbeDisabled.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            log.debug(\"received value:\" + value);\r\n            bmValue(value);\r\n        } else if (data instanceof ServerEvent) {\r\n            ServerEvent event = (ServerEvent) data;\r\n            log.debug(\"received event:\" + event);\r\n            event(event);\r\n            /*      if (event.type.equals(EventType.PROBE_HUNG)) {\r\n        ProbeDescription probe = registry.getProbeForSubscription(event.getSubscriptionId());\r\n        registry.setProbeDisabled(probe);\r\n      }*/\r\n        } else if (data instanceof ProbeRegistered) {\r\n            /*\r\n      ProbeRegistered pr = (ProbeRegistered) data;\r\n      log.debug(\"received probe registered:\" + pr);\r\n      \r\n      if (sacs.isEmpty()) {      \r\n        log.error(\"No SAC registered, not reporting Probe registration\");\r\n        return;\r\n      }\r\n      //ProbeDescription pd = pr.getProbeDescription();\r\n      for (SAC sac : sacs.values()) {\r\n        sac.probeRegistered(pr);\r\n      }\r\n      //todo: create event     \r\n*/\r\n            //availabilityProvider.setAvailabilityChanged();\r\n            ProbeRegistered pr = (ProbeRegistered) data;\r\n            log.debug(\"received probe registered:\" + pr);\r\n            availabilityProvider.probeRegistered(pr);\r\n        } else if (data instanceof ProbeDisabled) {\r\n            /*\r\n      ProbeDisabled msg = (ProbeDisabled) data;\r\n      log.debug(\"received probe disabled:\" + msg);\r\n      \r\n      if (sacs.isEmpty()) {      \r\n        log.error(\"No SAC registered, not reporting Probe disabled\");\r\n        return;\r\n      }\r\n      //ProbeDescription pd = msg.getProbeDescription();\r\n      for (SAC sac : sacs.values()) {\r\n        sac.probeDisabled(msg);\r\n      }\r\n*/\r\n            //availabilityProvider.setAvailabilityChanged();\r\n            ProbeDisabled msg = (ProbeDisabled) data;\r\n            log.debug(\"received probe disabled:\" + msg);\r\n            availabilityProvider.probeDisabled(msg);\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/SACPlugin_2Test.java",
		"test_prompt": "// SACPlugin_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.Availability;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.SACClient;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.osgi.framework.BundleContext;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SACPlugin}.\n* It contains ten unit test cases for the {@link SACPlugin#register(long)} method.\n*/\nclass SACPlugin_2Test {"
	},
	{
		"original_code": "// BM.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element name=\"device_id\" type=\"{http://www.w3.org/2001/XMLSchema}long\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"class\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"description\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\", propOrder = { \"deviceId\" })\r\n@XmlRootElement(name = \"BM\")\r\npublic class BM {\r\n\r\n    @XmlElement(name = \"device_id\", namespace = \"\", type = Long.class)\r\n    protected List<Long> deviceId;\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"class\")\r\n    protected String clazz;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"description\")\r\n    protected String description;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the deviceId property.\r\n     *\r\n     * <p>\r\n     * This accessor method returns a reference to the live list,\r\n     * not a snapshot. Therefore any modification you make to the\r\n     * returned list will be present inside the JAXB object.\r\n     * This is why there is not a <CODE>set</CODE> method for the deviceId property.\r\n     *\r\n     * <p>\r\n     * For example, to add a new item, do as follows:\r\n     * <pre>\r\n     *    getDeviceId().add(newItem);\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Objects of the following type(s) are allowed in the list\r\n     * {@link Long }\r\n     */\r\n    public List<Long> getDeviceId() {\r\n        if (deviceId == null) {\r\n            deviceId = new ArrayList<Long>();\r\n        }\r\n        return this.deviceId;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the clazz property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getClazz() {\r\n        return clazz;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the clazz property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setClazz(String value) {\r\n        this.clazz = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the description property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the description property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setDescription(String value) {\r\n        this.description = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/BM.java",
		"test_prompt": "// BMTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BM}.\n* It contains ten unit test cases for the {@link BM#isDisabled()} method.\n*/\nclass BMTest {"
	},
	{
		"original_code": "// ProbeParameter.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"name\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"description\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"mandatory\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *       &lt;attribute name=\"value\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"ProbeParameter\")\r\npublic class ProbeParameter {\r\n\r\n    @XmlAttribute(name = \"name\", required = true)\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"description\", required = true)\r\n    protected String description;\r\n\r\n    @XmlAttribute(name = \"mandatory\", required = true)\r\n    protected boolean mandatory;\r\n\r\n    @XmlAttribute(name = \"value\", required = true)\r\n    protected String value;\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the description property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the description property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setDescription(String value) {\r\n        this.description = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the mandatory property.\r\n     */\r\n    public boolean isMandatory() {\r\n        return mandatory;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the mandatory property.\r\n     */\r\n    public void setMandatory(boolean value) {\r\n        this.mandatory = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the value property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the value property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ProbeParameter.java",
		"test_prompt": "// ProbeParameterTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeParameter}.\n* It contains ten unit test cases for the {@link ProbeParameter#isMandatory()} method.\n*/\nclass ProbeParameterTest {"
	},
	{
		"original_code": "// Probe.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element name=\"bm_id\" type=\"{http://www.w3.org/2001/XMLSchema}long\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\", propOrder = { \"bmId\" })\r\n@XmlRootElement(name = \"Probe\")\r\npublic class Probe {\r\n\r\n    @XmlElement(name = \"bm_id\", namespace = \"\", type = Long.class)\r\n    protected List<Long> bmId;\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the bmId property.\r\n     *\r\n     * <p>\r\n     * This accessor method returns a reference to the live list,\r\n     * not a snapshot. Therefore any modification you make to the\r\n     * returned list will be present inside the JAXB object.\r\n     * This is why there is not a <CODE>set</CODE> method for the bmId property.\r\n     *\r\n     * <p>\r\n     * For example, to add a new item, do as follows:\r\n     * <pre>\r\n     *    getBmId().add(newItem);\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Objects of the following type(s) are allowed in the list\r\n     * {@link Long }\r\n     */\r\n    public List<Long> getBmId() {\r\n        if (bmId == null) {\r\n            bmId = new ArrayList<Long>();\r\n        }\r\n        return this.bmId;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/Probe.java",
		"test_prompt": "// ProbeTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Probe}.\n* It contains ten unit test cases for the {@link Probe#isDisabled()} method.\n*/\nclass ProbeTest {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_0Test.java",
		"test_prompt": "// ObjectFactory_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createOperationResult()} method.\n*/\nclass ObjectFactory_0Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_1Test.java",
		"test_prompt": "// ObjectFactory_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createMFW()} method.\n*/\nclass ObjectFactory_1Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_2Test.java",
		"test_prompt": "// ObjectFactory_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createDevice()} method.\n*/\nclass ObjectFactory_2Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_3Test.java",
		"test_prompt": "// ObjectFactory_3Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createGetMFW()} method.\n*/\nclass ObjectFactory_3Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_4Test.java",
		"test_prompt": "// ObjectFactory_4Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createGetAvailability()} method.\n*/\nclass ObjectFactory_4Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_5Test.java",
		"test_prompt": "// ObjectFactory_5Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbe()} method.\n*/\nclass ObjectFactory_5Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_6Test.java",
		"test_prompt": "// ObjectFactory_6Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParameter()} method.\n*/\nclass ObjectFactory_6Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_7Test.java",
		"test_prompt": "// ObjectFactory_7Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParameters()} method.\n*/\nclass ObjectFactory_7Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_8Test.java",
		"test_prompt": "// ObjectFactory_8Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParameterValue()} method.\n*/\nclass ObjectFactory_8Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_9Test.java",
		"test_prompt": "// ObjectFactory_9Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createAvailability()} method.\n*/\nclass ObjectFactory_9Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_10Test.java",
		"test_prompt": "// ObjectFactory_10Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBM()} method.\n*/\nclass ObjectFactory_10Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_11Test.java",
		"test_prompt": "// ObjectFactory_11Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParametersRequest()} method.\n*/\nclass ObjectFactory_11Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_12Test.java",
		"test_prompt": "// ObjectFactory_12Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResultRequest()} method.\n*/\nclass ObjectFactory_12Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_13Test.java",
		"test_prompt": "// ObjectFactory_13Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResultsRequest()} method.\n*/\nclass ObjectFactory_13Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/ObjectFactory_14Test.java",
		"test_prompt": "// ObjectFactory_14Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParameterValues()} method.\n*/\nclass ObjectFactory_14Test {"
	},
	{
		"original_code": "// Device.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"type\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"Device\")\r\npublic class Device {\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"type\")\r\n    protected String type;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the type property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the type property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setType(String value) {\r\n        this.type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/Device.java",
		"test_prompt": "// DeviceTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Device}.\n* It contains ten unit test cases for the {@link Device#isDisabled()} method.\n*/\nclass DeviceTest {"
	},
	{
		"original_code": "// OperationResult.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"error\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"OperationResult\")\r\npublic class OperationResult {\r\n\r\n    @XmlAttribute(name = \"error\", required = true)\r\n    protected boolean error;\r\n\r\n    /**\r\n     * Gets the value of the error property.\r\n     */\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the error property.\r\n     */\r\n    public void setError(boolean value) {\r\n        this.error = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/mfwservice/OperationResult.java",
		"test_prompt": "// OperationResultTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.mfwservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OperationResult}.\n* It contains ten unit test cases for the {@link OperationResult#isError()} method.\n*/\nclass OperationResultTest {"
	},
	{
		"original_code": "// BM.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element name=\"device_id\" type=\"{http://www.w3.org/2001/XMLSchema}long\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"class\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"description\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\", propOrder = { \"deviceId\" })\r\n@XmlRootElement(name = \"BM\")\r\npublic class BM {\r\n\r\n    @XmlElement(name = \"device_id\", namespace = \"\", type = Long.class)\r\n    protected List<Long> deviceId;\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"class\")\r\n    protected String clazz;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"description\")\r\n    protected String description;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the deviceId property.\r\n     *\r\n     * <p>\r\n     * This accessor method returns a reference to the live list,\r\n     * not a snapshot. Therefore any modification you make to the\r\n     * returned list will be present inside the JAXB object.\r\n     * This is why there is not a <CODE>set</CODE> method for the deviceId property.\r\n     *\r\n     * <p>\r\n     * For example, to add a new item, do as follows:\r\n     * <pre>\r\n     *    getDeviceId().add(newItem);\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Objects of the following type(s) are allowed in the list\r\n     * {@link Long }\r\n     */\r\n    public List<Long> getDeviceId() {\r\n        if (deviceId == null) {\r\n            deviceId = new ArrayList<Long>();\r\n        }\r\n        return this.deviceId;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the clazz property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getClazz() {\r\n        return clazz;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the clazz property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setClazz(String value) {\r\n        this.clazz = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the description property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the description property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setDescription(String value) {\r\n        this.description = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/BM.java",
		"test_prompt": "// BMTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BM}.\n* It contains ten unit test cases for the {@link BM#isDisabled()} method.\n*/\nclass BMTest {"
	},
	{
		"original_code": "// BMResult.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlSchemaType;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"error\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *       &lt;attribute name=\"value\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"timeStamp\" type=\"{http://www.w3.org/2001/XMLSchema}dateTime\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"BMResult\")\r\npublic class BMResult {\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"error\")\r\n    protected Boolean error;\r\n\r\n    @XmlAttribute(name = \"value\")\r\n    protected String value;\r\n\r\n    @XmlAttribute(name = \"timeStamp\")\r\n    @XmlSchemaType(name = \"dateTime\")\r\n    protected XMLGregorianCalendar timeStamp;\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the error property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the error property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setError(Boolean value) {\r\n        this.error = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the value property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the value property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the timeStamp property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link XMLGregorianCalendar }\r\n     */\r\n    public XMLGregorianCalendar getTimeStamp() {\r\n        return timeStamp;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the timeStamp property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link XMLGregorianCalendar }\r\n     */\r\n    public void setTimeStamp(XMLGregorianCalendar value) {\r\n        this.timeStamp = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/BMResult.java",
		"test_prompt": "// BMResultTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlSchemaType;\nimport javax.xml.bind.annotation.XmlType;\nimport javax.xml.datatype.XMLGregorianCalendar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMResult}.\n* It contains ten unit test cases for the {@link BMResult#isError()} method.\n*/\nclass BMResultTest {"
	},
	{
		"original_code": "// Probe.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element name=\"bm_id\" type=\"{http://www.w3.org/2001/XMLSchema}long\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\", propOrder = { \"bmId\" })\r\n@XmlRootElement(name = \"Probe\")\r\npublic class Probe {\r\n\r\n    @XmlElement(name = \"bm_id\", namespace = \"\", type = Long.class)\r\n    protected List<Long> bmId;\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the bmId property.\r\n     *\r\n     * <p>\r\n     * This accessor method returns a reference to the live list,\r\n     * not a snapshot. Therefore any modification you make to the\r\n     * returned list will be present inside the JAXB object.\r\n     * This is why there is not a <CODE>set</CODE> method for the bmId property.\r\n     *\r\n     * <p>\r\n     * For example, to add a new item, do as follows:\r\n     * <pre>\r\n     *    getBmId().add(newItem);\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Objects of the following type(s) are allowed in the list\r\n     * {@link Long }\r\n     */\r\n    public List<Long> getBmId() {\r\n        if (bmId == null) {\r\n            bmId = new ArrayList<Long>();\r\n        }\r\n        return this.bmId;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/Probe.java",
		"test_prompt": "// ProbeTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Probe}.\n* It contains ten unit test cases for the {@link Probe#isDisabled()} method.\n*/\nclass ProbeTest {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_0Test.java",
		"test_prompt": "// ObjectFactory_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResults()} method.\n*/\nclass ObjectFactory_0Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_1Test.java",
		"test_prompt": "// ObjectFactory_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createOperationResult()} method.\n*/\nclass ObjectFactory_1Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_2Test.java",
		"test_prompt": "// ObjectFactory_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createGetSAC()} method.\n*/\nclass ObjectFactory_2Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_3Test.java",
		"test_prompt": "// ObjectFactory_3Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createSAC()} method.\n*/\nclass ObjectFactory_3Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_4Test.java",
		"test_prompt": "// ObjectFactory_4Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createDevice()} method.\n*/\nclass ObjectFactory_4Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_5Test.java",
		"test_prompt": "// ObjectFactory_5Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createAvailability()} method.\n*/\nclass ObjectFactory_5Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_6Test.java",
		"test_prompt": "// ObjectFactory_6Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBM()} method.\n*/\nclass ObjectFactory_6Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_7Test.java",
		"test_prompt": "// ObjectFactory_7Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbe()} method.\n*/\nclass ObjectFactory_7Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_8Test.java",
		"test_prompt": "// ObjectFactory_8Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResult()} method.\n*/\nclass ObjectFactory_8Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/ObjectFactory_9Test.java",
		"test_prompt": "// ObjectFactory_9Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResultsPerDevice()} method.\n*/\nclass ObjectFactory_9Test {"
	},
	{
		"original_code": "// Device.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"type\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"Device\")\r\npublic class Device {\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"type\")\r\n    protected String type;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the type property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the type property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setType(String value) {\r\n        this.type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/Device.java",
		"test_prompt": "// DeviceTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Device}.\n* It contains ten unit test cases for the {@link Device#isDisabled()} method.\n*/\nclass DeviceTest {"
	},
	{
		"original_code": "// OperationResult.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"error\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"OperationResult\")\r\npublic class OperationResult {\r\n\r\n    @XmlAttribute(name = \"error\", required = true)\r\n    protected boolean error;\r\n\r\n    /**\r\n     * Gets the value of the error property.\r\n     */\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the error property.\r\n     */\r\n    public void setError(boolean value) {\r\n        this.error = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/OperationResult.java",
		"test_prompt": "// OperationResultTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OperationResult}.\n* It contains ten unit test cases for the {@link OperationResult#isError()} method.\n*/\nclass OperationResultTest {"
	},
	{
		"original_code": "// SACClient.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.SAC;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.SACPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.BMResults.PerDevice;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport javax.xml.datatype.DatatypeFactory;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\nimport javax.xml.namespace.QName;\r\nimport java.net.URL;\r\nimport java.util.Collection;\r\nimport java.util.GregorianCalendar;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class SACClient implements SAC {\r\n\r\n    private final static Logger log = new Logger(SACClient.class);\r\n\r\n    private static final QName SERVICE_NAME = new QName(\"http://www.bugyobeyond.org/MFW_SAC/\", \"MFW_SAC_service\");\r\n\r\n    private URL wsdlURL;\r\n\r\n    private MFWSACService ss;\r\n\r\n    private MFWSAC port;\r\n\r\n    private long SACId;\r\n\r\n    private SACPlugin sacPlugin;\r\n\r\n    private String sacURL;\r\n\r\n    private long mfwId = 1;\r\n\r\n    public SACClient(SACPlugin sacPlugin, String sacURL, long sacId, long mfwId) {\r\n        wsdlURL = MFWSACService.WSDL_LOCATION;\r\n        ss = new MFWSACService(wsdlURL, SERVICE_NAME);\r\n        this.sacURL = sacURL;\r\n        port = ss.getMFWSAC(sacURL);\r\n        this.SACId = sacId;\r\n        this.sacPlugin = sacPlugin;\r\n        this.mfwId = mfwId;\r\n    }\r\n\r\n    public void event(String message) {\r\n        // its not possible to send events to sac anymore...\r\n    }\r\n\r\n    public void bmResult(Value value) {\r\n        try {\r\n            log.info(\"Invoking setBMResults on the SAC (ID:\" + SACId + \")\");\r\n            BMResults bmResults = new BMResults();\r\n            bmResults.setMfwId(mfwId);\r\n            BMResult bmResult = new BMResult();\r\n            bmResult.setId(value.getBm().getBmId());\r\n            bmResult.setValue(value.getString());\r\n            bmResult.setError(value.isError());\r\n            GregorianCalendar calendar = new GregorianCalendar();\r\n            calendar.setTime(value.getTime());\r\n            DatatypeFactory factory = DatatypeFactory.newInstance();\r\n            XMLGregorianCalendar XMLCalendar = factory.newXMLGregorianCalendar(calendar);\r\n            bmResult.setTimeStamp(XMLCalendar);\r\n            PerDevice perDevice = new PerDevice();\r\n            perDevice.getBMResult().add(bmResult);\r\n            perDevice.setDeviceId(value.getBm().getTarget().getTargetId());\r\n            bmResults.getPerDevice().add(perDevice);\r\n            OperationResult result = port.setBMResults(bmResults);\r\n            if (result.isError()) {\r\n                log.debug(\"Error invoking setBMResults on the SAC (ID:\" + SACId + \")\");\r\n            }\r\n        } catch (Exception e) {\r\n            log.error(\"Error invoking setBMResults on the SAC (ID:\" + SACId + \")\", e);\r\n            return;\r\n        }\r\n    }\r\n\r\n    public void probeRegistered(ProbeRegistered pr) {\r\n        log.info(\"Probe Registered: Invoking setAvailability on the SAC (ID:\" + SACId + \")\");\r\n        Availability availability = new Availability();\r\n        availability.setMfwId(mfwId);\r\n        /*    \r\n    //this is \"fixed\" to send complete availability information every time something has changed\r\n    Collection<TargetDescription> devices = sacPlugin.getTargetList();\r\n    if (devices != null) {\r\n      for (TargetDescription target : devices) {\r\n        createAndAddDevice(target, availability.getDevice(), false);\r\n      }\r\n    }\r\n    List<BMDescription> availableBMs = sacPlugin.getAvailableBMList();\r\n    if (availableBMs != null) {\r\n      for (BMDescription bmDesc : availableBMs) {\r\n        createAndAddBM(bmDesc, availability.getBM(), false);\r\n      }\r\n    }\r\n    List<ProbeDescription> probes = sacPlugin.getProbeList();\r\n    if (probes != null) {\r\n      for (ProbeDescription probeDesc : probes) {\r\n        createAndAddProbe(probeDesc, availability.getProbe(), false);\r\n      }\r\n    }\r\n*/\r\n        //todo: one probe becoming disabled does not mean all bm and targets related should be disabled. add tests for this\r\n        ProbeDescription probe = pr.getProbeDescription();\r\n        if (pr.isNewTarget()) {\r\n            createAndAddDevice(probe.getTarget(), availability.getDevice(), false);\r\n        }\r\n        if (pr.isNewBM()) {\r\n            createAndAddBM(probe.getBm(), availability.getBM(), false);\r\n        }\r\n        createAndAddProbe(probe, availability.getProbe(), false);\r\n        OperationResult result = null;\r\n        try {\r\n            result = port.setAvailability(availability);\r\n        } catch (Exception e) {\r\n            //ignore until better mechanism in place\r\n            log.error(\"Error invoking setAvailability on the SAC (ID:\" + SACId + \")\", e);\r\n            //return is needed to avoid nullpointer after this try-catch\r\n            return;\r\n        }\r\n        if (result.isError()) {\r\n            //todo: create event\r\n            log.debug(\"Error invoking setAvailability on the SAC (ID:\" + SACId + \")\");\r\n        }\r\n    }\r\n\r\n    public void probeDisabled(ProbeDisabled pd) {\r\n        log.info(\"Probe Disabled: Invoking setAvailability on the SAC (ID:\" + SACId + \")\");\r\n        Availability availability = new Availability();\r\n        availability.setMfwId(mfwId);\r\n        /*    \r\n    //this is \"fixed\" to send complete availability information every time something has changed\r\n    Collection<TargetDescription> devices = sacPlugin.getTargetList();\r\n    if (devices != null) {\r\n      for (TargetDescription target : devices) {\r\n        createAndAddDevice(target, availability.getDevice(), false);\r\n      }\r\n    }\r\n    List<BMDescription> availableBMs = sacPlugin.getAvailableBMList();\r\n    if (availableBMs != null) {\r\n      for (BMDescription bmDesc : availableBMs) {\r\n        createAndAddBM(bmDesc, availability.getBM(), false);\r\n      }\r\n    }\r\n    List<ProbeDescription> probes = sacPlugin.getProbeList();\r\n    if (probes != null) {\r\n      for (ProbeDescription probeDesc : probes) {\r\n        createAndAddProbe(probeDesc, availability.getProbe(), false);\r\n      }\r\n    }\r\n*/\r\n        //todo: one probe becoming disabled does not mean all bm and targets related should be disabled. add tests for this\r\n        ProbeDescription probe = pd.getProbeDescription();\r\n        if (pd.isTargetDisabled()) {\r\n            createAndAddDevice(probe.getTarget(), availability.getDevice(), true);\r\n        }\r\n        if (pd.isBmDisabled()) {\r\n            createAndAddBM(probe.getBm(), availability.getBM(), true);\r\n        }\r\n        createAndAddProbe(probe, availability.getProbe(), true);\r\n        OperationResult result = null;\r\n        try {\r\n            result = port.setAvailability(availability);\r\n        } catch (Exception e) {\r\n            //todo:fix the class to create some sensible connection mechanism\r\n            log.error(\"Error invoking setAvailability on the SAC (ID:\" + SACId + \")\", e);\r\n            //return is needed to avoid nullpointer after this try-catch\r\n            return;\r\n        }\r\n        if (result.isError()) {\r\n            //todo: create event\r\n            log.debug(\"Error invoking setAvailability on the SAC (ID:\" + SACId + \")\");\r\n        }\r\n    }\r\n\r\n    private void createAndAddDevice(TargetDescription target, Collection<Device> devices, boolean disabled) {\r\n        Device device = new Device();\r\n        device.setId(target.getTargetId());\r\n        device.setName(target.getTargetName());\r\n        device.setType(target.getTargetType());\r\n        device.setDisabled(disabled);\r\n        devices.add(device);\r\n    }\r\n\r\n    private void createAndAddBM(BMDescription bmDescription, Collection<BM> bms, boolean disabled) {\r\n        BM bm = new BM();\r\n        bm.setClazz(bmDescription.getBmClass());\r\n        bm.setDescription(bmDescription.getBmDescription());\r\n        bm.setId(bmDescription.getBmId());\r\n        bm.setName(bmDescription.getBmName());\r\n        bm.setDisabled(disabled);\r\n        bm.getDeviceId().add(bmDescription.getTarget().getTargetId());\r\n        bms.add(bm);\r\n    }\r\n\r\n    private void createAndAddProbe(ProbeDescription pd, Collection<Probe> probes, boolean disabled) {\r\n        Probe probe = new Probe();\r\n        probe.setId(pd.getProbeId());\r\n        probe.setName(pd.getProbeName());\r\n        probe.setDisabled(disabled);\r\n        probe.getBmId().add(pd.getBm().getBmId());\r\n        probes.add(probe);\r\n    }\r\n\r\n    public long getSAC(long MFWId) {\r\n        GetSAC getSAC = new GetSAC();\r\n        getSAC.setMfwId(MFWId);\r\n        fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.SAC SACInfo = null;\r\n        try {\r\n            SACInfo = port.getSAC(getSAC);\r\n        } catch (Exception e) {\r\n            log.error(\"Error invoking getSAC on the SAC (ID:\" + SACId + \")\", e);\r\n            e.printStackTrace();\r\n            return -1;\r\n        }\r\n        if (SACInfo != null) {\r\n            return SACInfo.getId();\r\n        } else {\r\n            log.debug(\"Error invoking getSAC on the SAC. SACInfo null\");\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    public void setAvailability(Availability availability) {\r\n        log.info(\"Invoking setAvailability on the SAC (ID:\" + SACId + \")\");\r\n        OperationResult result = null;\r\n        try {\r\n            result = port.setAvailability(availability);\r\n        } catch (Exception e) {\r\n            log.error(\"Error invoking setAvailability on the SAC (ID:\" + SACId + \")\", e);\r\n            return;\r\n        }\r\n        if (!result.isError()) {\r\n        } else {\r\n            log.debug(\"Error invoking setAvailability on the SAC (ID:\" + SACId + \")\");\r\n        }\r\n    }\r\n\r\n    public boolean initAvailability() {\r\n        log.info(\"Initializing and invoking setAvailability on the SAC (ID:\" + SACId + \")\");\r\n        Availability availability = new Availability();\r\n        availability.setMfwId(mfwId);\r\n        Collection<TargetDescription> devices = sacPlugin.getTargetList();\r\n        if (devices != null) {\r\n            for (TargetDescription target : devices) {\r\n                createAndAddDevice(target, availability.getDevice(), false);\r\n            }\r\n        }\r\n        List<BMDescription> availableBMs = sacPlugin.getAvailableBMList();\r\n        if (availableBMs != null) {\r\n            for (BMDescription bmDesc : availableBMs) {\r\n                createAndAddBM(bmDesc, availability.getBM(), false);\r\n            }\r\n        }\r\n        List<ProbeDescription> probes = sacPlugin.getProbeList();\r\n        if (probes != null) {\r\n            for (ProbeDescription probeDesc : probes) {\r\n                createAndAddProbe(probeDesc, availability.getProbe(), false);\r\n            }\r\n        }\r\n        OperationResult result = null;\r\n        try {\r\n            result = port.setAvailability(availability);\r\n        } catch (Exception e) {\r\n            //log.error(\"Error invoking setAvailability on the SAC\", e);\r\n            return false;\r\n        }\r\n        if (!result.isError()) {\r\n            return true;\r\n        } else {\r\n            log.debug(\"Error invoking setAvailability on the SAC\");\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/sac/sacclient/SACClient.java",
		"test_prompt": "// SACClientTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.SAC;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.SACPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.sac.sacclient.BMResults.PerDevice;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport javax.xml.datatype.DatatypeFactory;\nimport javax.xml.datatype.XMLGregorianCalendar;\nimport javax.xml.namespace.QName;\nimport java.net.URL;\nimport java.util.Collection;\nimport java.util.GregorianCalendar;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SACClient}.\n* It contains ten unit test cases for the {@link SACClient#initAvailability()} method.\n*/\nclass SACClientTest {"
	},
	{
		"original_code": "// PersistencePluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.persistence;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.osgi.framework.BundleContext;\r\nimport javax.persistence.EntityManager;\r\nimport javax.persistence.EntityManagerFactory;\r\nimport javax.persistence.EntityTransaction;\r\nimport javax.persistence.Persistence;\r\nimport javax.persistence.Query;\r\nimport java.sql.Date;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Persists measurement data, events, derivedmeasure, etc. Basically anything from the blackboard.\r\n *\r\n * @author Teemu Kanstren\r\n * @see KnowledgeSource\r\n */\r\npublic class PersistencePluginImpl extends BasePlugin implements PersistencePlugin {\r\n\r\n    private final static Logger log = new Logger(PersistencePluginImpl.class);\r\n\r\n    private EntityManagerFactory emf;\r\n\r\n    private boolean stopped = false;\r\n\r\n    public PersistencePluginImpl(BundleContext bc) {\r\n        super(bc, log);\r\n        //we need to switch the ThreadContext classloader when getting the EntityManagerFactory\r\n        //otherwise we get \"javax.persistence.PersistenceException: No Persistence provider for EntityManager named ...\"\r\n        ClassLoader oldCL = Thread.currentThread().getContextClassLoader();\r\n        Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());\r\n        log.debug(\"creating entitymanagerfactory\");\r\n        //this now finds persistence.xml in the bundle META-INF directory with the correct classloader\r\n        emf = Persistence.createEntityManagerFactory(\"mfw-persistence-manager\");\r\n        log.debug(\"entitymanagerfactory created\");\r\n        //switch back after retrieving the entitymanagerfactory\r\n        Thread.currentThread().setContextClassLoader(oldCL);\r\n    }\r\n\r\n    /**\r\n     * Called from BlackBoard when data this plugin subscribes to is available.\r\n     *\r\n     * @param data The new data that is available for processing.\r\n     */\r\n    public void process(DataObject data) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        EntityTransaction transaction = em.getTransaction();\r\n        try {\r\n            //we store the data in the database\r\n            //since it is the same for Value and Event (only ones subscribed to), we can do it like this..\r\n            transaction.begin();\r\n            em.persist(data);\r\n            transaction.commit();\r\n        } finally {\r\n            //check for rollback and close the entitymanager\r\n            //it seems that leaving the entitymanager open for long causes some transactions to be left open so we close it here\r\n            //according to online documentation this should not be a hugely expensive operation..\r\n            if (transaction.isActive()) {\r\n                transaction.rollback();\r\n            }\r\n            em.close();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the PersistenceBundleActivator when the bundle is shutting down.\r\n     */\r\n    public void stop() {\r\n        log.debug(\"Persistence plugin stop\");\r\n        emf.close();\r\n        stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Defines what the blackboard gives us (process()).\r\n     *\r\n     * @return The subscribed data types.\r\n     */\r\n    public Set<Class> getCommands() {\r\n        return createCommandSet(Value.class, ServerEvent.class);\r\n    }\r\n\r\n    /**\r\n     * Reads a set of events from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Event objects matching the given criteria.\r\n     */\r\n    public List<ServerEvent> getEvents(int first, int count, ServerEvent.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == ServerEvent.SortKey.MESSAGE) {\r\n            //sort the results based on the string message describing the event\r\n            sortBy = \"ORDER BY e.message\";\r\n        } else if (sortKey == ServerEvent.SortKey.TIME) {\r\n            //sort the results based on the time when the event was observed\r\n            sortBy = \"ORDER BY e.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for event:\" + sortKey);\r\n        }\r\n        //ASC and DESC are from the SQL spec but practically the same also in JPA\r\n        //ASC means the results are given in ascending order (1,2,3,4,...) and DESC descending order (..., 4,3,2,1)\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        sortBy += \" \" + order;\r\n        EntityManager em = emf.createEntityManager();\r\n        List<ServerEvent> result;\r\n        try {\r\n            //get the events from the DB according to the given search and sorting criteria\r\n            Query query = em.createQuery(\"select e from ServerEvent e \" + sortBy).setFirstResult(first).setMaxResults(count);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gives the number of events stored in the database.\r\n     *\r\n     * @return Number of events stored in the database.\r\n     */\r\n    public int getEventCount() {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        Number result;\r\n        try {\r\n            Query query = em.createQuery(\"select count(e) from ServerEvent e\");\r\n            result = (Number) query.getSingleResult();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result.intValue();\r\n    }\r\n\r\n    /**\r\n     * Reads a set of values from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Value objects matching the given criteria.\r\n     */\r\n    public List<Value> getValues(int first, int count, Value.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == Value.SortKey.PRECISION) {\r\n            //sort the results by the precision of the stored value\r\n            sortBy = \"ORDER BY v.precision\";\r\n        } else if (sortKey == Value.SortKey.VALUE) {\r\n            //sort the results by the string value of the stored value\r\n            sortBy = \"ORDER BY v.value\";\r\n        } else if (sortKey == Value.SortKey.MEASUREURI) {\r\n            //sort the results by the measureURI of the value, that identifies which measure it is\r\n            sortBy = \"ORDER BY v.bm.target.targetType, v.bm.target.targetName, v.bm.bmClass, v.bm.bmName\";\r\n        } else if (sortKey == Value.SortKey.TIME) {\r\n            //sort the results by the time when the measurement was stored\r\n            sortBy = \"ORDER BY v.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for value:\" + sortKey);\r\n        }\r\n        //sort in ascending or descenging order, same as for events above\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        sortBy += \" \" + order;\r\n        EntityManager em = emf.createEntityManager();\r\n        List<Value> result;\r\n        try {\r\n            //get the results from the DB according to the given criteria\r\n            Query query = em.createQuery(\"select v from Value v \" + sortBy).setFirstResult(first).setMaxResults(count);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Reads a set of values from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Value objects matching the given criteria.\r\n     */\r\n    public List<Value> getValues(long startTime, long endTime, Long[] bmIds, Value.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == Value.SortKey.PRECISION) {\r\n            //sort the results by the precision of the stored value\r\n            sortBy = \"ORDER BY v.precision\";\r\n        } else if (sortKey == Value.SortKey.VALUE) {\r\n            //sort the results by the string value of the stored value\r\n            sortBy = \"ORDER BY v.value\";\r\n        } else if (sortKey == Value.SortKey.MEASUREURI) {\r\n            //sort the results by the measureURI of the value, that identifies which measure it is\r\n            sortBy = \"ORDER BY v.bm.target.targetType, v.bm.target.targetName, v.bm.bmClass, v.bm.bmName\";\r\n        } else if (sortKey == Value.SortKey.TIME) {\r\n            //sort the results by the time when the measurement was stored\r\n            sortBy = \"ORDER BY v.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for value:\" + sortKey);\r\n        }\r\n        //sort in ascending or descenging order, same as for events above\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        StringBuilder bms = new StringBuilder();\r\n        for (int i = 0; i < bmIds.length; i++) {\r\n            bms.append(\"v.bm.bmId=\").append(bmIds[i]);\r\n            if (i < bmIds.length - 1) {\r\n                bms.append(\" or \");\r\n            }\r\n        }\r\n        sortBy += \" \" + order;\r\n        Date sd = new Date(startTime);\r\n        Date se = new Date(endTime);\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n        String where = \"where v.time between '\" + sdf.format(sd) + \"' and '\" + sdf.format(se) + \"'\";\r\n        where += \" and (\" + bms.toString() + \")\";\r\n        //    log.debug( \"--- where: \" + where );\r\n        EntityManager em = emf.createEntityManager();\r\n        List<Value> result = null;\r\n        try {\r\n            //get the results from the DB according to the given criteria\r\n            Query query = em.createQuery(\"select v from Value v \" + where + \" \" + sortBy);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gives the number of values stored in the database.\r\n     *\r\n     * @return Number of values stored in the database.\r\n     */\r\n    public int getValueCount() {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        Number result;\r\n        try {\r\n            Query query = em.createQuery(\"select count(v) from Value v\");\r\n            result = (Number) query.getSingleResult();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result.intValue();\r\n    }\r\n\r\n    /**\r\n     * Creates a ProbeDescription for the given information. Checks the DB for an existing suitable description.\r\n     * If none is found, a new one is created and stored into the database. Whichever succeeds, the result is returned.\r\n     *\r\n     * @param properties The information describing the probe.\r\n     * @return The ProbeDescription object matching the given information.\r\n     */\r\n    public ProbeDescription createProbeDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        ProbeDescription probe;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct pd from ProbeDescription pd where pd.probeName = :pname and pd.target.targetName = :tname \" + \"and pd.target.targetType = :ttype and pd.bm.bmClass = :bmClass and pd.bm.bmName = :bmName\");\r\n            String probeName = properties.get(Const.PROBE_NAME);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String bmClass = properties.get(Const.PROBE_BM_CLASS);\r\n            String bmName = properties.get(Const.PROBE_BM_NAME);\r\n            query.setParameter(\"pname\", probeName);\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            query.setParameter(\"bmClass\", bmClass);\r\n            query.setParameter(\"bmName\", bmName);\r\n            List<ProbeDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one probe description in the database with unique probe name, target type, target name, bm class and bm name.\" + \" had \" + resultList.size() + \" for {\" + probeName + \",\" + targetType + \",\" + targetName + \",\" + bmClass + \",\" + bmName + \"}\";\r\n            EntityTransaction transaction = em.getTransaction();\r\n            if (resultList.size() == 1) {\r\n                probe = resultList.get(0);\r\n                //we need to update the endpoint address since that may have changed.. :)\r\n                //todo: rollbacks\r\n                transaction.begin();\r\n                probe.updateEndpoint(properties);\r\n                em.persist(probe);\r\n                transaction.commit();\r\n                return probe;\r\n            }\r\n            //get the target object for the probedescription\r\n            TargetDescription target = createTargetDescription(properties);\r\n            //get the bm description for the probedescription\r\n            BMDescription bm = createBMDescription(properties);\r\n            transaction.begin();\r\n            probe = new ProbeDescription(properties, target, bm);\r\n            em.persist(probe);\r\n            transaction.commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return probe;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a BMDescription for the given properties. If one is found in the database, it is\r\n     * returned. If not, a new one is created, stored into the database, and returned. The relevant values are\r\n     * target name, target type, bm class, and bm name.\r\n     *\r\n     * @param properties Information for the BMDescription to be created.\r\n     * @return The BMDescription matching the given arguments.\r\n     */\r\n    public BMDescription createBMDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        BMDescription bm;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct bm from BMDescription bm where bm.target.targetName = :tname \" + \"and bm.target.targetType = :ttype and bm.bmClass = :bmClass and bm.bmName = :bmName\");\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            String bmClass = properties.get(Const.PROBE_BM_CLASS);\r\n            String bmName = properties.get(Const.PROBE_BM_NAME);\r\n            String bmDescription = properties.get(Const.PROBE_BM_DESCRIPTION);\r\n            if (targetType == null || targetName == null || bmClass == null || bmName == null) {\r\n                throw new IllegalArgumentException(\"BM cannot be created with null values for any of TargetType, TargetName, BMClass, BMName. \" + \"Got \" + targetType + \", \" + targetName + \", \" + bmClass + \", \" + bmName + \".\");\r\n            }\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            query.setParameter(\"bmClass\", bmClass);\r\n            query.setParameter(\"bmName\", bmName);\r\n            List<BMDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one BM description in the database with unique target type, target name, bm class and bm name.\" + \" had \" + resultList.size() + \" for {\" + targetType + \",\" + targetName + \",\" + bmClass + \",\" + bmName + \"}\";\r\n            if (resultList.size() == 1) {\r\n                return resultList.get(0);\r\n            }\r\n            //get the target object for the probedescription\r\n            TargetDescription target = createTargetDescription(properties);\r\n            em.getTransaction().begin();\r\n            bm = new BMDescription(target, bmClass, bmName, bmDescription);\r\n            em.persist(bm);\r\n            em.getTransaction().commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return bm;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a TargetDescription for the given properties. If one is found in the database, it is\r\n     * returned. If not, a new one is created, stored into the database, and returned. The relevant values are\r\n     * target name and target type.\r\n     *\r\n     * @param properties Information for the TargetDescription to be created.\r\n     * @return The TargetDescription matching the given arguments.\r\n     */\r\n    public TargetDescription createTargetDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        TargetDescription target;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct t from TargetDescription t where t.targetName = :tname \" + \"and t.targetType = :ttype\");\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            if (targetType == null || targetName == null) {\r\n                throw new IllegalArgumentException(\"Target cannot be created with null values for any of TargetType, TargetName. \" + \"Got \" + targetType + \", \" + targetName + \".\");\r\n            }\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            List<TargetDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one target description in the database with unique target name,and target type.\" + \" had \" + resultList.size() + \" for {\" + targetType + \",\" + targetName + \"}\";\r\n            if (resultList.size() == 1) {\r\n                return resultList.get(0);\r\n            }\r\n            em.getTransaction().begin();\r\n            target = new TargetDescription(targetType, targetName);\r\n            em.persist(target);\r\n            em.getTransaction().commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return target;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/persistence/PersistencePluginImpl_0Test.java",
		"test_prompt": "// PersistencePluginImpl_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.persistence;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.osgi.framework.BundleContext;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.EntityTransaction;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport java.sql.Date;\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistencePluginImpl}.\n* It contains ten unit test cases for the {@link PersistencePluginImpl#createProbeDescription(Map)} method.\n*/\nclass PersistencePluginImpl_0Test {"
	},
	{
		"original_code": "// PersistencePluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.persistence;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.osgi.framework.BundleContext;\r\nimport javax.persistence.EntityManager;\r\nimport javax.persistence.EntityManagerFactory;\r\nimport javax.persistence.EntityTransaction;\r\nimport javax.persistence.Persistence;\r\nimport javax.persistence.Query;\r\nimport java.sql.Date;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Persists measurement data, events, derivedmeasure, etc. Basically anything from the blackboard.\r\n *\r\n * @author Teemu Kanstren\r\n * @see KnowledgeSource\r\n */\r\npublic class PersistencePluginImpl extends BasePlugin implements PersistencePlugin {\r\n\r\n    private final static Logger log = new Logger(PersistencePluginImpl.class);\r\n\r\n    private EntityManagerFactory emf;\r\n\r\n    private boolean stopped = false;\r\n\r\n    public PersistencePluginImpl(BundleContext bc) {\r\n        super(bc, log);\r\n        //we need to switch the ThreadContext classloader when getting the EntityManagerFactory\r\n        //otherwise we get \"javax.persistence.PersistenceException: No Persistence provider for EntityManager named ...\"\r\n        ClassLoader oldCL = Thread.currentThread().getContextClassLoader();\r\n        Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());\r\n        log.debug(\"creating entitymanagerfactory\");\r\n        //this now finds persistence.xml in the bundle META-INF directory with the correct classloader\r\n        emf = Persistence.createEntityManagerFactory(\"mfw-persistence-manager\");\r\n        log.debug(\"entitymanagerfactory created\");\r\n        //switch back after retrieving the entitymanagerfactory\r\n        Thread.currentThread().setContextClassLoader(oldCL);\r\n    }\r\n\r\n    /**\r\n     * Called from BlackBoard when data this plugin subscribes to is available.\r\n     *\r\n     * @param data The new data that is available for processing.\r\n     */\r\n    public void process(DataObject data) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        EntityTransaction transaction = em.getTransaction();\r\n        try {\r\n            //we store the data in the database\r\n            //since it is the same for Value and Event (only ones subscribed to), we can do it like this..\r\n            transaction.begin();\r\n            em.persist(data);\r\n            transaction.commit();\r\n        } finally {\r\n            //check for rollback and close the entitymanager\r\n            //it seems that leaving the entitymanager open for long causes some transactions to be left open so we close it here\r\n            //according to online documentation this should not be a hugely expensive operation..\r\n            if (transaction.isActive()) {\r\n                transaction.rollback();\r\n            }\r\n            em.close();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the PersistenceBundleActivator when the bundle is shutting down.\r\n     */\r\n    public void stop() {\r\n        log.debug(\"Persistence plugin stop\");\r\n        emf.close();\r\n        stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Defines what the blackboard gives us (process()).\r\n     *\r\n     * @return The subscribed data types.\r\n     */\r\n    public Set<Class> getCommands() {\r\n        return createCommandSet(Value.class, ServerEvent.class);\r\n    }\r\n\r\n    /**\r\n     * Reads a set of events from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Event objects matching the given criteria.\r\n     */\r\n    public List<ServerEvent> getEvents(int first, int count, ServerEvent.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == ServerEvent.SortKey.MESSAGE) {\r\n            //sort the results based on the string message describing the event\r\n            sortBy = \"ORDER BY e.message\";\r\n        } else if (sortKey == ServerEvent.SortKey.TIME) {\r\n            //sort the results based on the time when the event was observed\r\n            sortBy = \"ORDER BY e.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for event:\" + sortKey);\r\n        }\r\n        //ASC and DESC are from the SQL spec but practically the same also in JPA\r\n        //ASC means the results are given in ascending order (1,2,3,4,...) and DESC descending order (..., 4,3,2,1)\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        sortBy += \" \" + order;\r\n        EntityManager em = emf.createEntityManager();\r\n        List<ServerEvent> result;\r\n        try {\r\n            //get the events from the DB according to the given search and sorting criteria\r\n            Query query = em.createQuery(\"select e from ServerEvent e \" + sortBy).setFirstResult(first).setMaxResults(count);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gives the number of events stored in the database.\r\n     *\r\n     * @return Number of events stored in the database.\r\n     */\r\n    public int getEventCount() {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        Number result;\r\n        try {\r\n            Query query = em.createQuery(\"select count(e) from ServerEvent e\");\r\n            result = (Number) query.getSingleResult();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result.intValue();\r\n    }\r\n\r\n    /**\r\n     * Reads a set of values from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Value objects matching the given criteria.\r\n     */\r\n    public List<Value> getValues(int first, int count, Value.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == Value.SortKey.PRECISION) {\r\n            //sort the results by the precision of the stored value\r\n            sortBy = \"ORDER BY v.precision\";\r\n        } else if (sortKey == Value.SortKey.VALUE) {\r\n            //sort the results by the string value of the stored value\r\n            sortBy = \"ORDER BY v.value\";\r\n        } else if (sortKey == Value.SortKey.MEASUREURI) {\r\n            //sort the results by the measureURI of the value, that identifies which measure it is\r\n            sortBy = \"ORDER BY v.bm.target.targetType, v.bm.target.targetName, v.bm.bmClass, v.bm.bmName\";\r\n        } else if (sortKey == Value.SortKey.TIME) {\r\n            //sort the results by the time when the measurement was stored\r\n            sortBy = \"ORDER BY v.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for value:\" + sortKey);\r\n        }\r\n        //sort in ascending or descenging order, same as for events above\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        sortBy += \" \" + order;\r\n        EntityManager em = emf.createEntityManager();\r\n        List<Value> result;\r\n        try {\r\n            //get the results from the DB according to the given criteria\r\n            Query query = em.createQuery(\"select v from Value v \" + sortBy).setFirstResult(first).setMaxResults(count);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Reads a set of values from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Value objects matching the given criteria.\r\n     */\r\n    public List<Value> getValues(long startTime, long endTime, Long[] bmIds, Value.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == Value.SortKey.PRECISION) {\r\n            //sort the results by the precision of the stored value\r\n            sortBy = \"ORDER BY v.precision\";\r\n        } else if (sortKey == Value.SortKey.VALUE) {\r\n            //sort the results by the string value of the stored value\r\n            sortBy = \"ORDER BY v.value\";\r\n        } else if (sortKey == Value.SortKey.MEASUREURI) {\r\n            //sort the results by the measureURI of the value, that identifies which measure it is\r\n            sortBy = \"ORDER BY v.bm.target.targetType, v.bm.target.targetName, v.bm.bmClass, v.bm.bmName\";\r\n        } else if (sortKey == Value.SortKey.TIME) {\r\n            //sort the results by the time when the measurement was stored\r\n            sortBy = \"ORDER BY v.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for value:\" + sortKey);\r\n        }\r\n        //sort in ascending or descenging order, same as for events above\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        StringBuilder bms = new StringBuilder();\r\n        for (int i = 0; i < bmIds.length; i++) {\r\n            bms.append(\"v.bm.bmId=\").append(bmIds[i]);\r\n            if (i < bmIds.length - 1) {\r\n                bms.append(\" or \");\r\n            }\r\n        }\r\n        sortBy += \" \" + order;\r\n        Date sd = new Date(startTime);\r\n        Date se = new Date(endTime);\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n        String where = \"where v.time between '\" + sdf.format(sd) + \"' and '\" + sdf.format(se) + \"'\";\r\n        where += \" and (\" + bms.toString() + \")\";\r\n        //    log.debug( \"--- where: \" + where );\r\n        EntityManager em = emf.createEntityManager();\r\n        List<Value> result = null;\r\n        try {\r\n            //get the results from the DB according to the given criteria\r\n            Query query = em.createQuery(\"select v from Value v \" + where + \" \" + sortBy);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gives the number of values stored in the database.\r\n     *\r\n     * @return Number of values stored in the database.\r\n     */\r\n    public int getValueCount() {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        Number result;\r\n        try {\r\n            Query query = em.createQuery(\"select count(v) from Value v\");\r\n            result = (Number) query.getSingleResult();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result.intValue();\r\n    }\r\n\r\n    /**\r\n     * Creates a ProbeDescription for the given information. Checks the DB for an existing suitable description.\r\n     * If none is found, a new one is created and stored into the database. Whichever succeeds, the result is returned.\r\n     *\r\n     * @param properties The information describing the probe.\r\n     * @return The ProbeDescription object matching the given information.\r\n     */\r\n    public ProbeDescription createProbeDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        ProbeDescription probe;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct pd from ProbeDescription pd where pd.probeName = :pname and pd.target.targetName = :tname \" + \"and pd.target.targetType = :ttype and pd.bm.bmClass = :bmClass and pd.bm.bmName = :bmName\");\r\n            String probeName = properties.get(Const.PROBE_NAME);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String bmClass = properties.get(Const.PROBE_BM_CLASS);\r\n            String bmName = properties.get(Const.PROBE_BM_NAME);\r\n            query.setParameter(\"pname\", probeName);\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            query.setParameter(\"bmClass\", bmClass);\r\n            query.setParameter(\"bmName\", bmName);\r\n            List<ProbeDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one probe description in the database with unique probe name, target type, target name, bm class and bm name.\" + \" had \" + resultList.size() + \" for {\" + probeName + \",\" + targetType + \",\" + targetName + \",\" + bmClass + \",\" + bmName + \"}\";\r\n            EntityTransaction transaction = em.getTransaction();\r\n            if (resultList.size() == 1) {\r\n                probe = resultList.get(0);\r\n                //we need to update the endpoint address since that may have changed.. :)\r\n                //todo: rollbacks\r\n                transaction.begin();\r\n                probe.updateEndpoint(properties);\r\n                em.persist(probe);\r\n                transaction.commit();\r\n                return probe;\r\n            }\r\n            //get the target object for the probedescription\r\n            TargetDescription target = createTargetDescription(properties);\r\n            //get the bm description for the probedescription\r\n            BMDescription bm = createBMDescription(properties);\r\n            transaction.begin();\r\n            probe = new ProbeDescription(properties, target, bm);\r\n            em.persist(probe);\r\n            transaction.commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return probe;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a BMDescription for the given properties. If one is found in the database, it is\r\n     * returned. If not, a new one is created, stored into the database, and returned. The relevant values are\r\n     * target name, target type, bm class, and bm name.\r\n     *\r\n     * @param properties Information for the BMDescription to be created.\r\n     * @return The BMDescription matching the given arguments.\r\n     */\r\n    public BMDescription createBMDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        BMDescription bm;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct bm from BMDescription bm where bm.target.targetName = :tname \" + \"and bm.target.targetType = :ttype and bm.bmClass = :bmClass and bm.bmName = :bmName\");\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            String bmClass = properties.get(Const.PROBE_BM_CLASS);\r\n            String bmName = properties.get(Const.PROBE_BM_NAME);\r\n            String bmDescription = properties.get(Const.PROBE_BM_DESCRIPTION);\r\n            if (targetType == null || targetName == null || bmClass == null || bmName == null) {\r\n                throw new IllegalArgumentException(\"BM cannot be created with null values for any of TargetType, TargetName, BMClass, BMName. \" + \"Got \" + targetType + \", \" + targetName + \", \" + bmClass + \", \" + bmName + \".\");\r\n            }\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            query.setParameter(\"bmClass\", bmClass);\r\n            query.setParameter(\"bmName\", bmName);\r\n            List<BMDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one BM description in the database with unique target type, target name, bm class and bm name.\" + \" had \" + resultList.size() + \" for {\" + targetType + \",\" + targetName + \",\" + bmClass + \",\" + bmName + \"}\";\r\n            if (resultList.size() == 1) {\r\n                return resultList.get(0);\r\n            }\r\n            //get the target object for the probedescription\r\n            TargetDescription target = createTargetDescription(properties);\r\n            em.getTransaction().begin();\r\n            bm = new BMDescription(target, bmClass, bmName, bmDescription);\r\n            em.persist(bm);\r\n            em.getTransaction().commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return bm;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a TargetDescription for the given properties. If one is found in the database, it is\r\n     * returned. If not, a new one is created, stored into the database, and returned. The relevant values are\r\n     * target name and target type.\r\n     *\r\n     * @param properties Information for the TargetDescription to be created.\r\n     * @return The TargetDescription matching the given arguments.\r\n     */\r\n    public TargetDescription createTargetDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        TargetDescription target;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct t from TargetDescription t where t.targetName = :tname \" + \"and t.targetType = :ttype\");\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            if (targetType == null || targetName == null) {\r\n                throw new IllegalArgumentException(\"Target cannot be created with null values for any of TargetType, TargetName. \" + \"Got \" + targetType + \", \" + targetName + \".\");\r\n            }\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            List<TargetDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one target description in the database with unique target name,and target type.\" + \" had \" + resultList.size() + \" for {\" + targetType + \",\" + targetName + \"}\";\r\n            if (resultList.size() == 1) {\r\n                return resultList.get(0);\r\n            }\r\n            em.getTransaction().begin();\r\n            target = new TargetDescription(targetType, targetName);\r\n            em.persist(target);\r\n            em.getTransaction().commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return target;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/persistence/PersistencePluginImpl_1Test.java",
		"test_prompt": "// PersistencePluginImpl_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.persistence;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.osgi.framework.BundleContext;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.EntityTransaction;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport java.sql.Date;\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistencePluginImpl}.\n* It contains ten unit test cases for the {@link PersistencePluginImpl#createBMDescription(Map)} method.\n*/\nclass PersistencePluginImpl_1Test {"
	},
	{
		"original_code": "// PersistencePluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.persistence;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.osgi.framework.BundleContext;\r\nimport javax.persistence.EntityManager;\r\nimport javax.persistence.EntityManagerFactory;\r\nimport javax.persistence.EntityTransaction;\r\nimport javax.persistence.Persistence;\r\nimport javax.persistence.Query;\r\nimport java.sql.Date;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Persists measurement data, events, derivedmeasure, etc. Basically anything from the blackboard.\r\n *\r\n * @author Teemu Kanstren\r\n * @see KnowledgeSource\r\n */\r\npublic class PersistencePluginImpl extends BasePlugin implements PersistencePlugin {\r\n\r\n    private final static Logger log = new Logger(PersistencePluginImpl.class);\r\n\r\n    private EntityManagerFactory emf;\r\n\r\n    private boolean stopped = false;\r\n\r\n    public PersistencePluginImpl(BundleContext bc) {\r\n        super(bc, log);\r\n        //we need to switch the ThreadContext classloader when getting the EntityManagerFactory\r\n        //otherwise we get \"javax.persistence.PersistenceException: No Persistence provider for EntityManager named ...\"\r\n        ClassLoader oldCL = Thread.currentThread().getContextClassLoader();\r\n        Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());\r\n        log.debug(\"creating entitymanagerfactory\");\r\n        //this now finds persistence.xml in the bundle META-INF directory with the correct classloader\r\n        emf = Persistence.createEntityManagerFactory(\"mfw-persistence-manager\");\r\n        log.debug(\"entitymanagerfactory created\");\r\n        //switch back after retrieving the entitymanagerfactory\r\n        Thread.currentThread().setContextClassLoader(oldCL);\r\n    }\r\n\r\n    /**\r\n     * Called from BlackBoard when data this plugin subscribes to is available.\r\n     *\r\n     * @param data The new data that is available for processing.\r\n     */\r\n    public void process(DataObject data) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        EntityTransaction transaction = em.getTransaction();\r\n        try {\r\n            //we store the data in the database\r\n            //since it is the same for Value and Event (only ones subscribed to), we can do it like this..\r\n            transaction.begin();\r\n            em.persist(data);\r\n            transaction.commit();\r\n        } finally {\r\n            //check for rollback and close the entitymanager\r\n            //it seems that leaving the entitymanager open for long causes some transactions to be left open so we close it here\r\n            //according to online documentation this should not be a hugely expensive operation..\r\n            if (transaction.isActive()) {\r\n                transaction.rollback();\r\n            }\r\n            em.close();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the PersistenceBundleActivator when the bundle is shutting down.\r\n     */\r\n    public void stop() {\r\n        log.debug(\"Persistence plugin stop\");\r\n        emf.close();\r\n        stopped = true;\r\n    }\r\n\r\n    /**\r\n     * Defines what the blackboard gives us (process()).\r\n     *\r\n     * @return The subscribed data types.\r\n     */\r\n    public Set<Class> getCommands() {\r\n        return createCommandSet(Value.class, ServerEvent.class);\r\n    }\r\n\r\n    /**\r\n     * Reads a set of events from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Event objects matching the given criteria.\r\n     */\r\n    public List<ServerEvent> getEvents(int first, int count, ServerEvent.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == ServerEvent.SortKey.MESSAGE) {\r\n            //sort the results based on the string message describing the event\r\n            sortBy = \"ORDER BY e.message\";\r\n        } else if (sortKey == ServerEvent.SortKey.TIME) {\r\n            //sort the results based on the time when the event was observed\r\n            sortBy = \"ORDER BY e.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for event:\" + sortKey);\r\n        }\r\n        //ASC and DESC are from the SQL spec but practically the same also in JPA\r\n        //ASC means the results are given in ascending order (1,2,3,4,...) and DESC descending order (..., 4,3,2,1)\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        sortBy += \" \" + order;\r\n        EntityManager em = emf.createEntityManager();\r\n        List<ServerEvent> result;\r\n        try {\r\n            //get the events from the DB according to the given search and sorting criteria\r\n            Query query = em.createQuery(\"select e from ServerEvent e \" + sortBy).setFirstResult(first).setMaxResults(count);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gives the number of events stored in the database.\r\n     *\r\n     * @return Number of events stored in the database.\r\n     */\r\n    public int getEventCount() {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        Number result;\r\n        try {\r\n            Query query = em.createQuery(\"select count(e) from ServerEvent e\");\r\n            result = (Number) query.getSingleResult();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result.intValue();\r\n    }\r\n\r\n    /**\r\n     * Reads a set of values from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Value objects matching the given criteria.\r\n     */\r\n    public List<Value> getValues(int first, int count, Value.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == Value.SortKey.PRECISION) {\r\n            //sort the results by the precision of the stored value\r\n            sortBy = \"ORDER BY v.precision\";\r\n        } else if (sortKey == Value.SortKey.VALUE) {\r\n            //sort the results by the string value of the stored value\r\n            sortBy = \"ORDER BY v.value\";\r\n        } else if (sortKey == Value.SortKey.MEASUREURI) {\r\n            //sort the results by the measureURI of the value, that identifies which measure it is\r\n            sortBy = \"ORDER BY v.bm.target.targetType, v.bm.target.targetName, v.bm.bmClass, v.bm.bmName\";\r\n        } else if (sortKey == Value.SortKey.TIME) {\r\n            //sort the results by the time when the measurement was stored\r\n            sortBy = \"ORDER BY v.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for value:\" + sortKey);\r\n        }\r\n        //sort in ascending or descenging order, same as for events above\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        sortBy += \" \" + order;\r\n        EntityManager em = emf.createEntityManager();\r\n        List<Value> result;\r\n        try {\r\n            //get the results from the DB according to the given criteria\r\n            Query query = em.createQuery(\"select v from Value v \" + sortBy).setFirstResult(first).setMaxResults(count);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Reads a set of values from the database according to the given criteria.\r\n     *\r\n     * @param first     The index of the first item to load.\r\n     * @param count     The number of how many items to load.\r\n     * @param sortKey   The key according to which the results and search should be sorted.\r\n     * @param ascending Whether the results should be sorted in ascending or descending order.\r\n     * @return The set of Value objects matching the given criteria.\r\n     */\r\n    public List<Value> getValues(long startTime, long endTime, Long[] bmIds, Value.SortKey sortKey, boolean ascending) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        String sortBy = null;\r\n        if (sortKey == Value.SortKey.PRECISION) {\r\n            //sort the results by the precision of the stored value\r\n            sortBy = \"ORDER BY v.precision\";\r\n        } else if (sortKey == Value.SortKey.VALUE) {\r\n            //sort the results by the string value of the stored value\r\n            sortBy = \"ORDER BY v.value\";\r\n        } else if (sortKey == Value.SortKey.MEASUREURI) {\r\n            //sort the results by the measureURI of the value, that identifies which measure it is\r\n            sortBy = \"ORDER BY v.bm.target.targetType, v.bm.target.targetName, v.bm.bmClass, v.bm.bmName\";\r\n        } else if (sortKey == Value.SortKey.TIME) {\r\n            //sort the results by the time when the measurement was stored\r\n            sortBy = \"ORDER BY v.time\";\r\n        }\r\n        if (sortBy == null) {\r\n            throw new IllegalArgumentException(\"Unsupported sort key for value:\" + sortKey);\r\n        }\r\n        //sort in ascending or descenging order, same as for events above\r\n        String order = \"asc\";\r\n        if (!ascending) {\r\n            order = \"desc\";\r\n        }\r\n        StringBuilder bms = new StringBuilder();\r\n        for (int i = 0; i < bmIds.length; i++) {\r\n            bms.append(\"v.bm.bmId=\").append(bmIds[i]);\r\n            if (i < bmIds.length - 1) {\r\n                bms.append(\" or \");\r\n            }\r\n        }\r\n        sortBy += \" \" + order;\r\n        Date sd = new Date(startTime);\r\n        Date se = new Date(endTime);\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\r\n        String where = \"where v.time between '\" + sdf.format(sd) + \"' and '\" + sdf.format(se) + \"'\";\r\n        where += \" and (\" + bms.toString() + \")\";\r\n        //    log.debug( \"--- where: \" + where );\r\n        EntityManager em = emf.createEntityManager();\r\n        List<Value> result = null;\r\n        try {\r\n            //get the results from the DB according to the given criteria\r\n            Query query = em.createQuery(\"select v from Value v \" + where + \" \" + sortBy);\r\n            result = query.getResultList();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Gives the number of values stored in the database.\r\n     *\r\n     * @return Number of values stored in the database.\r\n     */\r\n    public int getValueCount() {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        Number result;\r\n        try {\r\n            Query query = em.createQuery(\"select count(v) from Value v\");\r\n            result = (Number) query.getSingleResult();\r\n        } finally {\r\n            em.close();\r\n        }\r\n        return result.intValue();\r\n    }\r\n\r\n    /**\r\n     * Creates a ProbeDescription for the given information. Checks the DB for an existing suitable description.\r\n     * If none is found, a new one is created and stored into the database. Whichever succeeds, the result is returned.\r\n     *\r\n     * @param properties The information describing the probe.\r\n     * @return The ProbeDescription object matching the given information.\r\n     */\r\n    public ProbeDescription createProbeDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        ProbeDescription probe;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct pd from ProbeDescription pd where pd.probeName = :pname and pd.target.targetName = :tname \" + \"and pd.target.targetType = :ttype and pd.bm.bmClass = :bmClass and pd.bm.bmName = :bmName\");\r\n            String probeName = properties.get(Const.PROBE_NAME);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String bmClass = properties.get(Const.PROBE_BM_CLASS);\r\n            String bmName = properties.get(Const.PROBE_BM_NAME);\r\n            query.setParameter(\"pname\", probeName);\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            query.setParameter(\"bmClass\", bmClass);\r\n            query.setParameter(\"bmName\", bmName);\r\n            List<ProbeDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one probe description in the database with unique probe name, target type, target name, bm class and bm name.\" + \" had \" + resultList.size() + \" for {\" + probeName + \",\" + targetType + \",\" + targetName + \",\" + bmClass + \",\" + bmName + \"}\";\r\n            EntityTransaction transaction = em.getTransaction();\r\n            if (resultList.size() == 1) {\r\n                probe = resultList.get(0);\r\n                //we need to update the endpoint address since that may have changed.. :)\r\n                //todo: rollbacks\r\n                transaction.begin();\r\n                probe.updateEndpoint(properties);\r\n                em.persist(probe);\r\n                transaction.commit();\r\n                return probe;\r\n            }\r\n            //get the target object for the probedescription\r\n            TargetDescription target = createTargetDescription(properties);\r\n            //get the bm description for the probedescription\r\n            BMDescription bm = createBMDescription(properties);\r\n            transaction.begin();\r\n            probe = new ProbeDescription(properties, target, bm);\r\n            em.persist(probe);\r\n            transaction.commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return probe;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a BMDescription for the given properties. If one is found in the database, it is\r\n     * returned. If not, a new one is created, stored into the database, and returned. The relevant values are\r\n     * target name, target type, bm class, and bm name.\r\n     *\r\n     * @param properties Information for the BMDescription to be created.\r\n     * @return The BMDescription matching the given arguments.\r\n     */\r\n    public BMDescription createBMDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        BMDescription bm;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct bm from BMDescription bm where bm.target.targetName = :tname \" + \"and bm.target.targetType = :ttype and bm.bmClass = :bmClass and bm.bmName = :bmName\");\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            String bmClass = properties.get(Const.PROBE_BM_CLASS);\r\n            String bmName = properties.get(Const.PROBE_BM_NAME);\r\n            String bmDescription = properties.get(Const.PROBE_BM_DESCRIPTION);\r\n            if (targetType == null || targetName == null || bmClass == null || bmName == null) {\r\n                throw new IllegalArgumentException(\"BM cannot be created with null values for any of TargetType, TargetName, BMClass, BMName. \" + \"Got \" + targetType + \", \" + targetName + \", \" + bmClass + \", \" + bmName + \".\");\r\n            }\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            query.setParameter(\"bmClass\", bmClass);\r\n            query.setParameter(\"bmName\", bmName);\r\n            List<BMDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one BM description in the database with unique target type, target name, bm class and bm name.\" + \" had \" + resultList.size() + \" for {\" + targetType + \",\" + targetName + \",\" + bmClass + \",\" + bmName + \"}\";\r\n            if (resultList.size() == 1) {\r\n                return resultList.get(0);\r\n            }\r\n            //get the target object for the probedescription\r\n            TargetDescription target = createTargetDescription(properties);\r\n            em.getTransaction().begin();\r\n            bm = new BMDescription(target, bmClass, bmName, bmDescription);\r\n            em.persist(bm);\r\n            em.getTransaction().commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return bm;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a TargetDescription for the given properties. If one is found in the database, it is\r\n     * returned. If not, a new one is created, stored into the database, and returned. The relevant values are\r\n     * target name and target type.\r\n     *\r\n     * @param properties Information for the TargetDescription to be created.\r\n     * @return The TargetDescription matching the given arguments.\r\n     */\r\n    public TargetDescription createTargetDescription(Map<String, String> properties) {\r\n        if (stopped)\r\n            throw new IllegalStateException(\"Attempting to use a stopped persistence plugin.\");\r\n        EntityManager em = emf.createEntityManager();\r\n        TargetDescription target;\r\n        try {\r\n            Query query = em.createQuery(\"select distinct t from TargetDescription t where t.targetName = :tname \" + \"and t.targetType = :ttype\");\r\n            String targetType = properties.get(Const.PROBE_TARGET_TYPE);\r\n            String targetName = properties.get(Const.PROBE_TARGET_NAME);\r\n            if (targetType == null || targetName == null) {\r\n                throw new IllegalArgumentException(\"Target cannot be created with null values for any of TargetType, TargetName. \" + \"Got \" + targetType + \", \" + targetName + \".\");\r\n            }\r\n            query.setParameter(\"tname\", targetName);\r\n            query.setParameter(\"ttype\", targetType);\r\n            List<TargetDescription> resultList = query.getResultList();\r\n            assert resultList.size() <= 1 : \"There should be maximum of one target description in the database with unique target name,and target type.\" + \" had \" + resultList.size() + \" for {\" + targetType + \",\" + targetName + \"}\";\r\n            if (resultList.size() == 1) {\r\n                return resultList.get(0);\r\n            }\r\n            em.getTransaction().begin();\r\n            target = new TargetDescription(targetType, targetName);\r\n            em.persist(target);\r\n            em.getTransaction().commit();\r\n        } finally {\r\n            if (em.getTransaction().isActive()) {\r\n                em.getTransaction().rollback();\r\n            }\r\n            em.close();\r\n        }\r\n        return target;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/persistence/PersistencePluginImpl_2Test.java",
		"test_prompt": "// PersistencePluginImpl_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.persistence;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.osgi.framework.BundleContext;\nimport javax.persistence.EntityManager;\nimport javax.persistence.EntityManagerFactory;\nimport javax.persistence.EntityTransaction;\nimport javax.persistence.Persistence;\nimport javax.persistence.Query;\nimport java.sql.Date;\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PersistencePluginImpl}.\n* It contains ten unit test cases for the {@link PersistencePluginImpl#createTargetDescription(Map)} method.\n*/\nclass PersistencePluginImpl_2Test {"
	},
	{
		"original_code": "// RegistryPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RegistryPluginImpl extends BasePlugin implements RegistryPlugin, PersistenceUser, ServerUser, Runnable {\r\n\r\n    private final static Logger log = new Logger(RegistryPluginImpl.class);\r\n\r\n    //key = measureURI\r\n    private final Map<String, BMDescription> availableBM = new HashMap<String, BMDescription>();\r\n\r\n    //key = long bmid provided by sac\r\n    private final Map<Long, BMDescription> bmIds = new HashMap<Long, BMDescription>();\r\n\r\n    //key = targetType+targetName\r\n    private final Map<String, TargetDescription> targets = new HashMap<String, TargetDescription>();\r\n\r\n    //key = probeId, value = ProbeDescription\r\n    private final Map<Long, ProbeDescription> probes = new HashMap<Long, ProbeDescription>();\r\n\r\n    //all DM definitions created\r\n    private final Collection<DMDefinition> dms = new HashSet<DMDefinition>();\r\n\r\n    private int nextDmId = 1;\r\n\r\n    //maximum delay for receiving keep-alive messages before a probe-agent is reported as lost\r\n    private int maxDelay = DEFAULT_DELAY;\r\n\r\n    //how much time to wait between checking the keep-alive status of probe-agents\r\n    private int delayIncrement = DEFAULT_INCREMENT;\r\n\r\n    //default keep-alive threshold if nothing is configured\r\n    //10 seconds\r\n    private static final int DEFAULT_DELAY = 10 * 1000;\r\n\r\n    //default keep-alive wait time if nothing is configured\r\n    //1 second\r\n    private static final int DEFAULT_INCREMENT = 1000;\r\n\r\n    //should the registry keep running its threads or shut down?\r\n    private boolean shouldRun = true;\r\n\r\n    //access to the persistent state\r\n    private PersistencePlugin persistence = null;\r\n\r\n    private ServerPlugin server = null;\r\n\r\n    private SubscriptionRegistry subscriptionRegistry;\r\n\r\n    public RegistryPluginImpl(BundleContext bc, int maxDelay, int delayIncrement) {\r\n        super(bc, log);\r\n        if (maxDelay > 0) {\r\n            //assume that if one is set, both are set\r\n            this.maxDelay = maxDelay;\r\n            this.delayIncrement = delayIncrement;\r\n        } else {\r\n            try {\r\n                Properties props = readConfiguration();\r\n                this.maxDelay = Integer.parseInt(props.getProperty(Const.MAX_KEEPALIVE_DELAY));\r\n            } catch (IOException e) {\r\n                log.error(\"Error in reading configuration file. Using defaults.\", e);\r\n            }\r\n        }\r\n        //start a thread to monitor keep-alive messages\r\n        Thread t = new Thread(this);\r\n        t.setDaemon(true);\r\n        t.start();\r\n        //register a listener to capture the persistenceplugin when available\r\n        PersistenceServiceListener pl = new PersistenceServiceListener(bc, log, this);\r\n        pl.init();\r\n        //register a listener to capture the server-agent when available\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        subscriptionRegistry = new SubscriptionRegistry(bc);\r\n    }\r\n\r\n    public void stop() {\r\n        shouldRun = false;\r\n    }\r\n\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    //get the BMDescription for the given measureURI (measure identifier)\r\n    public BMDescription descriptionFor(String measureURI) {\r\n        return availableBM.get(measureURI);\r\n    }\r\n\r\n    //provides a list of all registered probes\r\n    public List<ProbeDescription> getProbes() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<ProbeDescription> result = new ArrayList<ProbeDescription>(probes.size());\r\n        result.addAll(probes.values());\r\n        return result;\r\n    }\r\n\r\n    //get current list of registered probes\r\n    public synchronized List<BMDescription> getAvailableBM() {\r\n        Collection<BMDescription> values = availableBM.values();\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<BMDescription> result = new ArrayList<BMDescription>(values.size());\r\n        result.addAll(values);\r\n        return result;\r\n    }\r\n\r\n    //list of all currently defined DM\r\n    public synchronized List<DMDefinition> getDerivedMeasures() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<DMDefinition> result = new ArrayList<DMDefinition>(dms.size());\r\n        result.addAll(dms);\r\n        return result;\r\n    }\r\n\r\n    //list of all active targets (with probes registered for them)\r\n    public Collection<TargetDescription> getTargets() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<TargetDescription> targets = new ArrayList<TargetDescription>();\r\n        targets.addAll(this.targets.values());\r\n        return targets;\r\n    }\r\n\r\n    //create a derived measure. currently not a core feature, not persisted, etc.\r\n    public void createDM(String name, String script) {\r\n        DMDefinition newDm = new DMDefinition(nextDmId++, name, script);\r\n        dms.add(newDm);\r\n        bb.process(newDm);\r\n        log.debug(\"Registered DM:\" + name);\r\n    }\r\n\r\n    //gives probe description for given probeid\r\n    public ProbeDescription getProbeFor(long probeId) {\r\n        return probes.get(probeId);\r\n    }\r\n\r\n    //give the best available probe for given BM (with highest precision)\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        BMDescription bm = bmIds.get(bmId);\r\n        String measureURI = bm.getMeasureURI();\r\n        ProbeDescription result = null;\r\n        for (ProbeDescription probe : probes.values()) {\r\n            if (!probe.getMeasureURI().equals(measureURI)) {\r\n                continue;\r\n            }\r\n            if (result != null) {\r\n                if (result.getPrecision() < probe.getPrecision()) {\r\n                    result = probe;\r\n                }\r\n            } else {\r\n                result = probe;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //find the target id for the given measureURI\r\n    public long targetIdFor(String measureURI) {\r\n        //parse type from uri\r\n        String targetType = parseTargetType(measureURI);\r\n        //parse name from uri\r\n        String targetName = parseTargetName(measureURI);\r\n        //get the name from the target map\r\n        TargetDescription target = targets.get(targetType + targetName);\r\n        if (target == null) {\r\n            throw new IllegalArgumentException(\"No target found for measureURI:\" + measureURI);\r\n        }\r\n        return target.getTargetId();\r\n    }\r\n\r\n    //parse target type from a measureURI\r\n    public String parseTargetType(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        return measureURI.substring(bounds[0], bounds[1]);\r\n    }\r\n\r\n    //get start and end index of target type inside given measureURI\r\n    private int[] getTargetTypeBounds(String measureURI) {\r\n        int si = measureURI.indexOf(\"//\");\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        si += 2;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return new int[] { si, ei };\r\n    }\r\n\r\n    //parse target name from given measureURI\r\n    public String parseTargetName(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        //end of type + \"/\"\r\n        int si = bounds[1] + 1;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return measureURI.substring(si, ei);\r\n    }\r\n\r\n    //when a probe sends a keep-alive message, this is invoked\r\n    public boolean processKeepAlive(long probeId) {\r\n        ProbeDescription probe = probes.get(probeId);\r\n        if (probe != null) {\r\n            probe.resetDelay();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a registration is received from a probe-agent.\r\n     *\r\n     * @param properties A set of key-value pairs describing the probe. For key and their description see.. what? :)\r\n     * @return The probe identifier for the registered probe.\r\n     */\r\n    public synchronized long registerProbe(Map<String, String> properties) {\r\n        log.debug(\"registering probe\");\r\n        BMDescription bm = null;\r\n        boolean newTarget = false;\r\n        boolean newBM = false;\r\n        try {\r\n            log.debug(\"creating target description\");\r\n            TargetDescription target = persistence.createTargetDescription(properties);\r\n            if (!targets.containsValue(target)) {\r\n                newTarget = true;\r\n            }\r\n            targets.put(target.getTargetType() + target.getTargetName(), target);\r\n            log.debug(\"creating bm description\");\r\n            bm = persistence.createBMDescription(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to create target/bm for probe description.\", e);\r\n            return Const.ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE;\r\n        }\r\n        if (!bmIds.containsKey(bm.getBmId())) {\r\n            newBM = true;\r\n        }\r\n        availableBM.put(bm.getMeasureURI(), bm);\r\n        bmIds.put(bm.getBmId(), bm);\r\n        //we use the database to manage the probe information\r\n        log.debug(\"creating probe description\");\r\n        ProbeDescription desc = persistence.createProbeDescription(properties);\r\n        //we keep a mapping from id to desc to ease access in other functions\r\n        probes.put(desc.getProbeId(), desc);\r\n        // send probe registered data object to blackboard\r\n        ProbeRegistered pr = new ProbeRegistered(desc, newBM, newTarget);\r\n        bb.process(pr);\r\n        return desc.getProbeId();\r\n    }\r\n\r\n    //this is the thread that runs checking when a keep-alive message is received and if the delay for a probe has\r\n    //surpassed the given threshold. if one gets lots, the set of available BM is updated accordingly.\r\n    public void run() {\r\n        while (shouldRun) {\r\n            try {\r\n                Thread.sleep(delayIncrement);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"sleep interrupted\", e);\r\n            }\r\n            synchronized (this) {\r\n                for (Iterator<Map.Entry<Long, ProbeDescription>> i = probes.entrySet().iterator(); i.hasNext(); ) {\r\n                    Map.Entry<Long, ProbeDescription> entry = i.next();\r\n                    ProbeDescription probe = entry.getValue();\r\n                    probe.increaseDelay(delayIncrement);\r\n                    //          log.debug(\"Increasing delay for \"+probe+\" by \"+delayIncrement);\r\n                    if (probe.getDelay() >= maxDelay) {\r\n                        //TODO: also check all BM if we need to remove one, etc.\r\n                        log.info(\"Lease terminated for:\" + probe);\r\n                        i.remove();\r\n                        //check if there are any BM for the target (device)\r\n                        boolean found = false;\r\n                        boolean targetDisabled = false;\r\n                        TargetDescription target = probe.getBm().getTarget();\r\n                        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n                            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n                            if (target == targetDesc) {\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            //there are no BM for the target so it can be removed\r\n                            log.debug(\"removing Target:\" + target);\r\n                            String key = target.getTargetType() + target.getTargetName();\r\n                            targets.remove(key);\r\n                            targetDisabled = true;\r\n                        }\r\n                        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n                        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n                        boolean bmDisabled = false;\r\n                        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n                            String measureURI = probe.getMeasureURI();\r\n                            BMDescription bmDesc = availableBM.remove(measureURI);\r\n                            log.debug(\"removind BM:\" + bmDesc);\r\n                            bmIds.remove(bmDesc.getBmId());\r\n                            bmDisabled = true;\r\n                        }\r\n                        // send probe disabled data object to blackboard\r\n                        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n                        bb.process(pd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setProbeDisabled(ProbeDescription probe) {\r\n        log.info(\"Disabling Probe:\" + probe);\r\n        probes.remove(probe.getProbeId());\r\n        //check if there are any BM for the target (device)\r\n        boolean found = false;\r\n        boolean targetDisabled = false;\r\n        TargetDescription target = probe.getBm().getTarget();\r\n        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n            if (target == targetDesc) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            //there are no BM for the target so it can be removed\r\n            log.debug(\"removing Target:\" + target);\r\n            String key = target.getTargetType() + target.getTargetName();\r\n            targets.remove(key);\r\n            targetDisabled = true;\r\n        }\r\n        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n        boolean bmDisabled = false;\r\n        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n            String measureURI = probe.getMeasureURI();\r\n            BMDescription bmDesc = availableBM.remove(measureURI);\r\n            log.debug(\"removind BM:\" + bmDesc);\r\n            bmIds.remove(bmDesc.getBmId());\r\n            bmDisabled = true;\r\n        }\r\n        // send probe disabled data object to blackboard\r\n        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n        bb.process(pd);\r\n    }\r\n\r\n    public ProbeDescription getProbeForSubscription(long subscriptionId) {\r\n        try {\r\n            long probeId = subscriptionRegistry.getSubscription(subscriptionId).getProbeId();\r\n            return getProbeFor(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get probe for subscription\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        String msg = \"New measurement subscription URI:\" + bm.getMeasureURI() + \" F:\" + frequency + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, frequency, probeId);\r\n    }\r\n\r\n    public long getSacIdForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getSacIdForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public long getFrequencyForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getFrequencyForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public void removeSubscription(long sacId, long subscriptionId) {\r\n        String msg = \"Removed measurement subscription id:\" + subscriptionId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.DELETE_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        subscriptionRegistry.removeSubscription(subscriptionId);\r\n    }\r\n\r\n    public long getIdForSubscription(long sacId, long bmId) {\r\n        return subscriptionRegistry.getIdForSubscription(sacId, bmId);\r\n    }\r\n\r\n    public long addMeasurementRequest(long sacId, BMDescription bm, long probeId) {\r\n        String msg = \"New measurement request URI:\" + bm.getMeasureURI() + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_MEASUREMENT_REQUEST, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, 0, probeId);\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        log.debug(\"checkSubscriptions (probeId:\" + probeId + \") - subscriptions:\" + subscriptionIds);\r\n        //check if some other probe is better for the bm\r\n        //should be done only once after probe registration?\r\n        //get the best available probe for bm\r\n        long bmId = probes.get(probeId).getBm().getBmId();\r\n        ProbeDescription probe = getProbeForBM(bmId);\r\n        List<MeasurementSubscription> subscriptions = subscriptionRegistry.getSubscriptionsForBM(bmId);\r\n        log.debug(\"Probe BM subscriptions:\" + subscriptions);\r\n        for (MeasurementSubscription subscription : subscriptions) {\r\n            if (subscription.getProbeId() != probe.getProbeId()) {\r\n                log.debug(\"Probe with higher precision found\");\r\n                subscriptionRegistry.setProbeForSubscription(subscription.getSubscriptionId(), probe.getProbeId());\r\n            }\r\n        }\r\n        subscriptions = subscriptionRegistry.getSubscriptionsForProbe(probeId);\r\n        log.debug(\"Subscriptions for probe:\" + subscriptions);\r\n        for (MeasurementSubscription ms : subscriptions) {\r\n            //log.debug(\"Subscription on server (ID:\"+ms.getSubscriptionId()+\")\");\r\n            //if there is a new subscription\r\n            if (!subscriptionIds.contains(ms.getSubscriptionId())) {\r\n                log.info(\"New subscription found (bmId:\" + ms.getBmId() + \") while checking existing ones\");\r\n                //send subscription request to probe\r\n                if (server != null) {\r\n                    server.subscribeToBM(ms.getBmId(), ms.getFrequency(), ms.getSubscriptionId());\r\n                } else {\r\n                    log.error(\"Could not request bm, server null\");\r\n                }\r\n            }\r\n        }\r\n        //if probes current subscription is not found on the server it should be removed from the probe\r\n        for (Long subscriptionId : subscriptionIds) {\r\n            //log.debug(\"Probes current subscription (ID:\"+subscriptionId+\")\");\r\n            boolean found = false;\r\n            for (MeasurementSubscription ms : subscriptions) {\r\n                if (ms.getSubscriptionId() == subscriptionId) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                log.debug(\"Probes (ID:\" + probeId + \") current subscription (ID:\" + subscriptionId + \") not found on server, sending unsubscription request to probe\");\r\n                server.unSubscribeToBM(getProbeFor(probeId), subscriptionId);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/RegistryPluginImpl_0Test.java",
		"test_prompt": "// RegistryPluginImpl_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistryPluginImpl}.\n* It contains ten unit test cases for the {@link RegistryPluginImpl#descriptionFor(String)} method.\n*/\nclass RegistryPluginImpl_0Test {"
	},
	{
		"original_code": "// RegistryPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RegistryPluginImpl extends BasePlugin implements RegistryPlugin, PersistenceUser, ServerUser, Runnable {\r\n\r\n    private final static Logger log = new Logger(RegistryPluginImpl.class);\r\n\r\n    //key = measureURI\r\n    private final Map<String, BMDescription> availableBM = new HashMap<String, BMDescription>();\r\n\r\n    //key = long bmid provided by sac\r\n    private final Map<Long, BMDescription> bmIds = new HashMap<Long, BMDescription>();\r\n\r\n    //key = targetType+targetName\r\n    private final Map<String, TargetDescription> targets = new HashMap<String, TargetDescription>();\r\n\r\n    //key = probeId, value = ProbeDescription\r\n    private final Map<Long, ProbeDescription> probes = new HashMap<Long, ProbeDescription>();\r\n\r\n    //all DM definitions created\r\n    private final Collection<DMDefinition> dms = new HashSet<DMDefinition>();\r\n\r\n    private int nextDmId = 1;\r\n\r\n    //maximum delay for receiving keep-alive messages before a probe-agent is reported as lost\r\n    private int maxDelay = DEFAULT_DELAY;\r\n\r\n    //how much time to wait between checking the keep-alive status of probe-agents\r\n    private int delayIncrement = DEFAULT_INCREMENT;\r\n\r\n    //default keep-alive threshold if nothing is configured\r\n    //10 seconds\r\n    private static final int DEFAULT_DELAY = 10 * 1000;\r\n\r\n    //default keep-alive wait time if nothing is configured\r\n    //1 second\r\n    private static final int DEFAULT_INCREMENT = 1000;\r\n\r\n    //should the registry keep running its threads or shut down?\r\n    private boolean shouldRun = true;\r\n\r\n    //access to the persistent state\r\n    private PersistencePlugin persistence = null;\r\n\r\n    private ServerPlugin server = null;\r\n\r\n    private SubscriptionRegistry subscriptionRegistry;\r\n\r\n    public RegistryPluginImpl(BundleContext bc, int maxDelay, int delayIncrement) {\r\n        super(bc, log);\r\n        if (maxDelay > 0) {\r\n            //assume that if one is set, both are set\r\n            this.maxDelay = maxDelay;\r\n            this.delayIncrement = delayIncrement;\r\n        } else {\r\n            try {\r\n                Properties props = readConfiguration();\r\n                this.maxDelay = Integer.parseInt(props.getProperty(Const.MAX_KEEPALIVE_DELAY));\r\n            } catch (IOException e) {\r\n                log.error(\"Error in reading configuration file. Using defaults.\", e);\r\n            }\r\n        }\r\n        //start a thread to monitor keep-alive messages\r\n        Thread t = new Thread(this);\r\n        t.setDaemon(true);\r\n        t.start();\r\n        //register a listener to capture the persistenceplugin when available\r\n        PersistenceServiceListener pl = new PersistenceServiceListener(bc, log, this);\r\n        pl.init();\r\n        //register a listener to capture the server-agent when available\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        subscriptionRegistry = new SubscriptionRegistry(bc);\r\n    }\r\n\r\n    public void stop() {\r\n        shouldRun = false;\r\n    }\r\n\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    //get the BMDescription for the given measureURI (measure identifier)\r\n    public BMDescription descriptionFor(String measureURI) {\r\n        return availableBM.get(measureURI);\r\n    }\r\n\r\n    //provides a list of all registered probes\r\n    public List<ProbeDescription> getProbes() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<ProbeDescription> result = new ArrayList<ProbeDescription>(probes.size());\r\n        result.addAll(probes.values());\r\n        return result;\r\n    }\r\n\r\n    //get current list of registered probes\r\n    public synchronized List<BMDescription> getAvailableBM() {\r\n        Collection<BMDescription> values = availableBM.values();\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<BMDescription> result = new ArrayList<BMDescription>(values.size());\r\n        result.addAll(values);\r\n        return result;\r\n    }\r\n\r\n    //list of all currently defined DM\r\n    public synchronized List<DMDefinition> getDerivedMeasures() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<DMDefinition> result = new ArrayList<DMDefinition>(dms.size());\r\n        result.addAll(dms);\r\n        return result;\r\n    }\r\n\r\n    //list of all active targets (with probes registered for them)\r\n    public Collection<TargetDescription> getTargets() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<TargetDescription> targets = new ArrayList<TargetDescription>();\r\n        targets.addAll(this.targets.values());\r\n        return targets;\r\n    }\r\n\r\n    //create a derived measure. currently not a core feature, not persisted, etc.\r\n    public void createDM(String name, String script) {\r\n        DMDefinition newDm = new DMDefinition(nextDmId++, name, script);\r\n        dms.add(newDm);\r\n        bb.process(newDm);\r\n        log.debug(\"Registered DM:\" + name);\r\n    }\r\n\r\n    //gives probe description for given probeid\r\n    public ProbeDescription getProbeFor(long probeId) {\r\n        return probes.get(probeId);\r\n    }\r\n\r\n    //give the best available probe for given BM (with highest precision)\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        BMDescription bm = bmIds.get(bmId);\r\n        String measureURI = bm.getMeasureURI();\r\n        ProbeDescription result = null;\r\n        for (ProbeDescription probe : probes.values()) {\r\n            if (!probe.getMeasureURI().equals(measureURI)) {\r\n                continue;\r\n            }\r\n            if (result != null) {\r\n                if (result.getPrecision() < probe.getPrecision()) {\r\n                    result = probe;\r\n                }\r\n            } else {\r\n                result = probe;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //find the target id for the given measureURI\r\n    public long targetIdFor(String measureURI) {\r\n        //parse type from uri\r\n        String targetType = parseTargetType(measureURI);\r\n        //parse name from uri\r\n        String targetName = parseTargetName(measureURI);\r\n        //get the name from the target map\r\n        TargetDescription target = targets.get(targetType + targetName);\r\n        if (target == null) {\r\n            throw new IllegalArgumentException(\"No target found for measureURI:\" + measureURI);\r\n        }\r\n        return target.getTargetId();\r\n    }\r\n\r\n    //parse target type from a measureURI\r\n    public String parseTargetType(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        return measureURI.substring(bounds[0], bounds[1]);\r\n    }\r\n\r\n    //get start and end index of target type inside given measureURI\r\n    private int[] getTargetTypeBounds(String measureURI) {\r\n        int si = measureURI.indexOf(\"//\");\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        si += 2;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return new int[] { si, ei };\r\n    }\r\n\r\n    //parse target name from given measureURI\r\n    public String parseTargetName(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        //end of type + \"/\"\r\n        int si = bounds[1] + 1;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return measureURI.substring(si, ei);\r\n    }\r\n\r\n    //when a probe sends a keep-alive message, this is invoked\r\n    public boolean processKeepAlive(long probeId) {\r\n        ProbeDescription probe = probes.get(probeId);\r\n        if (probe != null) {\r\n            probe.resetDelay();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a registration is received from a probe-agent.\r\n     *\r\n     * @param properties A set of key-value pairs describing the probe. For key and their description see.. what? :)\r\n     * @return The probe identifier for the registered probe.\r\n     */\r\n    public synchronized long registerProbe(Map<String, String> properties) {\r\n        log.debug(\"registering probe\");\r\n        BMDescription bm = null;\r\n        boolean newTarget = false;\r\n        boolean newBM = false;\r\n        try {\r\n            log.debug(\"creating target description\");\r\n            TargetDescription target = persistence.createTargetDescription(properties);\r\n            if (!targets.containsValue(target)) {\r\n                newTarget = true;\r\n            }\r\n            targets.put(target.getTargetType() + target.getTargetName(), target);\r\n            log.debug(\"creating bm description\");\r\n            bm = persistence.createBMDescription(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to create target/bm for probe description.\", e);\r\n            return Const.ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE;\r\n        }\r\n        if (!bmIds.containsKey(bm.getBmId())) {\r\n            newBM = true;\r\n        }\r\n        availableBM.put(bm.getMeasureURI(), bm);\r\n        bmIds.put(bm.getBmId(), bm);\r\n        //we use the database to manage the probe information\r\n        log.debug(\"creating probe description\");\r\n        ProbeDescription desc = persistence.createProbeDescription(properties);\r\n        //we keep a mapping from id to desc to ease access in other functions\r\n        probes.put(desc.getProbeId(), desc);\r\n        // send probe registered data object to blackboard\r\n        ProbeRegistered pr = new ProbeRegistered(desc, newBM, newTarget);\r\n        bb.process(pr);\r\n        return desc.getProbeId();\r\n    }\r\n\r\n    //this is the thread that runs checking when a keep-alive message is received and if the delay for a probe has\r\n    //surpassed the given threshold. if one gets lots, the set of available BM is updated accordingly.\r\n    public void run() {\r\n        while (shouldRun) {\r\n            try {\r\n                Thread.sleep(delayIncrement);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"sleep interrupted\", e);\r\n            }\r\n            synchronized (this) {\r\n                for (Iterator<Map.Entry<Long, ProbeDescription>> i = probes.entrySet().iterator(); i.hasNext(); ) {\r\n                    Map.Entry<Long, ProbeDescription> entry = i.next();\r\n                    ProbeDescription probe = entry.getValue();\r\n                    probe.increaseDelay(delayIncrement);\r\n                    //          log.debug(\"Increasing delay for \"+probe+\" by \"+delayIncrement);\r\n                    if (probe.getDelay() >= maxDelay) {\r\n                        //TODO: also check all BM if we need to remove one, etc.\r\n                        log.info(\"Lease terminated for:\" + probe);\r\n                        i.remove();\r\n                        //check if there are any BM for the target (device)\r\n                        boolean found = false;\r\n                        boolean targetDisabled = false;\r\n                        TargetDescription target = probe.getBm().getTarget();\r\n                        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n                            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n                            if (target == targetDesc) {\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            //there are no BM for the target so it can be removed\r\n                            log.debug(\"removing Target:\" + target);\r\n                            String key = target.getTargetType() + target.getTargetName();\r\n                            targets.remove(key);\r\n                            targetDisabled = true;\r\n                        }\r\n                        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n                        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n                        boolean bmDisabled = false;\r\n                        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n                            String measureURI = probe.getMeasureURI();\r\n                            BMDescription bmDesc = availableBM.remove(measureURI);\r\n                            log.debug(\"removind BM:\" + bmDesc);\r\n                            bmIds.remove(bmDesc.getBmId());\r\n                            bmDisabled = true;\r\n                        }\r\n                        // send probe disabled data object to blackboard\r\n                        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n                        bb.process(pd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setProbeDisabled(ProbeDescription probe) {\r\n        log.info(\"Disabling Probe:\" + probe);\r\n        probes.remove(probe.getProbeId());\r\n        //check if there are any BM for the target (device)\r\n        boolean found = false;\r\n        boolean targetDisabled = false;\r\n        TargetDescription target = probe.getBm().getTarget();\r\n        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n            if (target == targetDesc) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            //there are no BM for the target so it can be removed\r\n            log.debug(\"removing Target:\" + target);\r\n            String key = target.getTargetType() + target.getTargetName();\r\n            targets.remove(key);\r\n            targetDisabled = true;\r\n        }\r\n        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n        boolean bmDisabled = false;\r\n        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n            String measureURI = probe.getMeasureURI();\r\n            BMDescription bmDesc = availableBM.remove(measureURI);\r\n            log.debug(\"removind BM:\" + bmDesc);\r\n            bmIds.remove(bmDesc.getBmId());\r\n            bmDisabled = true;\r\n        }\r\n        // send probe disabled data object to blackboard\r\n        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n        bb.process(pd);\r\n    }\r\n\r\n    public ProbeDescription getProbeForSubscription(long subscriptionId) {\r\n        try {\r\n            long probeId = subscriptionRegistry.getSubscription(subscriptionId).getProbeId();\r\n            return getProbeFor(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get probe for subscription\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        String msg = \"New measurement subscription URI:\" + bm.getMeasureURI() + \" F:\" + frequency + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, frequency, probeId);\r\n    }\r\n\r\n    public long getSacIdForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getSacIdForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public long getFrequencyForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getFrequencyForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public void removeSubscription(long sacId, long subscriptionId) {\r\n        String msg = \"Removed measurement subscription id:\" + subscriptionId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.DELETE_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        subscriptionRegistry.removeSubscription(subscriptionId);\r\n    }\r\n\r\n    public long getIdForSubscription(long sacId, long bmId) {\r\n        return subscriptionRegistry.getIdForSubscription(sacId, bmId);\r\n    }\r\n\r\n    public long addMeasurementRequest(long sacId, BMDescription bm, long probeId) {\r\n        String msg = \"New measurement request URI:\" + bm.getMeasureURI() + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_MEASUREMENT_REQUEST, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, 0, probeId);\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        log.debug(\"checkSubscriptions (probeId:\" + probeId + \") - subscriptions:\" + subscriptionIds);\r\n        //check if some other probe is better for the bm\r\n        //should be done only once after probe registration?\r\n        //get the best available probe for bm\r\n        long bmId = probes.get(probeId).getBm().getBmId();\r\n        ProbeDescription probe = getProbeForBM(bmId);\r\n        List<MeasurementSubscription> subscriptions = subscriptionRegistry.getSubscriptionsForBM(bmId);\r\n        log.debug(\"Probe BM subscriptions:\" + subscriptions);\r\n        for (MeasurementSubscription subscription : subscriptions) {\r\n            if (subscription.getProbeId() != probe.getProbeId()) {\r\n                log.debug(\"Probe with higher precision found\");\r\n                subscriptionRegistry.setProbeForSubscription(subscription.getSubscriptionId(), probe.getProbeId());\r\n            }\r\n        }\r\n        subscriptions = subscriptionRegistry.getSubscriptionsForProbe(probeId);\r\n        log.debug(\"Subscriptions for probe:\" + subscriptions);\r\n        for (MeasurementSubscription ms : subscriptions) {\r\n            //log.debug(\"Subscription on server (ID:\"+ms.getSubscriptionId()+\")\");\r\n            //if there is a new subscription\r\n            if (!subscriptionIds.contains(ms.getSubscriptionId())) {\r\n                log.info(\"New subscription found (bmId:\" + ms.getBmId() + \") while checking existing ones\");\r\n                //send subscription request to probe\r\n                if (server != null) {\r\n                    server.subscribeToBM(ms.getBmId(), ms.getFrequency(), ms.getSubscriptionId());\r\n                } else {\r\n                    log.error(\"Could not request bm, server null\");\r\n                }\r\n            }\r\n        }\r\n        //if probes current subscription is not found on the server it should be removed from the probe\r\n        for (Long subscriptionId : subscriptionIds) {\r\n            //log.debug(\"Probes current subscription (ID:\"+subscriptionId+\")\");\r\n            boolean found = false;\r\n            for (MeasurementSubscription ms : subscriptions) {\r\n                if (ms.getSubscriptionId() == subscriptionId) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                log.debug(\"Probes (ID:\" + probeId + \") current subscription (ID:\" + subscriptionId + \") not found on server, sending unsubscription request to probe\");\r\n                server.unSubscribeToBM(getProbeFor(probeId), subscriptionId);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/RegistryPluginImpl_1Test.java",
		"test_prompt": "// RegistryPluginImpl_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistryPluginImpl}.\n* It contains ten unit test cases for the {@link RegistryPluginImpl#targetIdFor(String)} method.\n*/\nclass RegistryPluginImpl_1Test {"
	},
	{
		"original_code": "// RegistryPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RegistryPluginImpl extends BasePlugin implements RegistryPlugin, PersistenceUser, ServerUser, Runnable {\r\n\r\n    private final static Logger log = new Logger(RegistryPluginImpl.class);\r\n\r\n    //key = measureURI\r\n    private final Map<String, BMDescription> availableBM = new HashMap<String, BMDescription>();\r\n\r\n    //key = long bmid provided by sac\r\n    private final Map<Long, BMDescription> bmIds = new HashMap<Long, BMDescription>();\r\n\r\n    //key = targetType+targetName\r\n    private final Map<String, TargetDescription> targets = new HashMap<String, TargetDescription>();\r\n\r\n    //key = probeId, value = ProbeDescription\r\n    private final Map<Long, ProbeDescription> probes = new HashMap<Long, ProbeDescription>();\r\n\r\n    //all DM definitions created\r\n    private final Collection<DMDefinition> dms = new HashSet<DMDefinition>();\r\n\r\n    private int nextDmId = 1;\r\n\r\n    //maximum delay for receiving keep-alive messages before a probe-agent is reported as lost\r\n    private int maxDelay = DEFAULT_DELAY;\r\n\r\n    //how much time to wait between checking the keep-alive status of probe-agents\r\n    private int delayIncrement = DEFAULT_INCREMENT;\r\n\r\n    //default keep-alive threshold if nothing is configured\r\n    //10 seconds\r\n    private static final int DEFAULT_DELAY = 10 * 1000;\r\n\r\n    //default keep-alive wait time if nothing is configured\r\n    //1 second\r\n    private static final int DEFAULT_INCREMENT = 1000;\r\n\r\n    //should the registry keep running its threads or shut down?\r\n    private boolean shouldRun = true;\r\n\r\n    //access to the persistent state\r\n    private PersistencePlugin persistence = null;\r\n\r\n    private ServerPlugin server = null;\r\n\r\n    private SubscriptionRegistry subscriptionRegistry;\r\n\r\n    public RegistryPluginImpl(BundleContext bc, int maxDelay, int delayIncrement) {\r\n        super(bc, log);\r\n        if (maxDelay > 0) {\r\n            //assume that if one is set, both are set\r\n            this.maxDelay = maxDelay;\r\n            this.delayIncrement = delayIncrement;\r\n        } else {\r\n            try {\r\n                Properties props = readConfiguration();\r\n                this.maxDelay = Integer.parseInt(props.getProperty(Const.MAX_KEEPALIVE_DELAY));\r\n            } catch (IOException e) {\r\n                log.error(\"Error in reading configuration file. Using defaults.\", e);\r\n            }\r\n        }\r\n        //start a thread to monitor keep-alive messages\r\n        Thread t = new Thread(this);\r\n        t.setDaemon(true);\r\n        t.start();\r\n        //register a listener to capture the persistenceplugin when available\r\n        PersistenceServiceListener pl = new PersistenceServiceListener(bc, log, this);\r\n        pl.init();\r\n        //register a listener to capture the server-agent when available\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        subscriptionRegistry = new SubscriptionRegistry(bc);\r\n    }\r\n\r\n    public void stop() {\r\n        shouldRun = false;\r\n    }\r\n\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    //get the BMDescription for the given measureURI (measure identifier)\r\n    public BMDescription descriptionFor(String measureURI) {\r\n        return availableBM.get(measureURI);\r\n    }\r\n\r\n    //provides a list of all registered probes\r\n    public List<ProbeDescription> getProbes() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<ProbeDescription> result = new ArrayList<ProbeDescription>(probes.size());\r\n        result.addAll(probes.values());\r\n        return result;\r\n    }\r\n\r\n    //get current list of registered probes\r\n    public synchronized List<BMDescription> getAvailableBM() {\r\n        Collection<BMDescription> values = availableBM.values();\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<BMDescription> result = new ArrayList<BMDescription>(values.size());\r\n        result.addAll(values);\r\n        return result;\r\n    }\r\n\r\n    //list of all currently defined DM\r\n    public synchronized List<DMDefinition> getDerivedMeasures() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<DMDefinition> result = new ArrayList<DMDefinition>(dms.size());\r\n        result.addAll(dms);\r\n        return result;\r\n    }\r\n\r\n    //list of all active targets (with probes registered for them)\r\n    public Collection<TargetDescription> getTargets() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<TargetDescription> targets = new ArrayList<TargetDescription>();\r\n        targets.addAll(this.targets.values());\r\n        return targets;\r\n    }\r\n\r\n    //create a derived measure. currently not a core feature, not persisted, etc.\r\n    public void createDM(String name, String script) {\r\n        DMDefinition newDm = new DMDefinition(nextDmId++, name, script);\r\n        dms.add(newDm);\r\n        bb.process(newDm);\r\n        log.debug(\"Registered DM:\" + name);\r\n    }\r\n\r\n    //gives probe description for given probeid\r\n    public ProbeDescription getProbeFor(long probeId) {\r\n        return probes.get(probeId);\r\n    }\r\n\r\n    //give the best available probe for given BM (with highest precision)\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        BMDescription bm = bmIds.get(bmId);\r\n        String measureURI = bm.getMeasureURI();\r\n        ProbeDescription result = null;\r\n        for (ProbeDescription probe : probes.values()) {\r\n            if (!probe.getMeasureURI().equals(measureURI)) {\r\n                continue;\r\n            }\r\n            if (result != null) {\r\n                if (result.getPrecision() < probe.getPrecision()) {\r\n                    result = probe;\r\n                }\r\n            } else {\r\n                result = probe;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //find the target id for the given measureURI\r\n    public long targetIdFor(String measureURI) {\r\n        //parse type from uri\r\n        String targetType = parseTargetType(measureURI);\r\n        //parse name from uri\r\n        String targetName = parseTargetName(measureURI);\r\n        //get the name from the target map\r\n        TargetDescription target = targets.get(targetType + targetName);\r\n        if (target == null) {\r\n            throw new IllegalArgumentException(\"No target found for measureURI:\" + measureURI);\r\n        }\r\n        return target.getTargetId();\r\n    }\r\n\r\n    //parse target type from a measureURI\r\n    public String parseTargetType(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        return measureURI.substring(bounds[0], bounds[1]);\r\n    }\r\n\r\n    //get start and end index of target type inside given measureURI\r\n    private int[] getTargetTypeBounds(String measureURI) {\r\n        int si = measureURI.indexOf(\"//\");\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        si += 2;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return new int[] { si, ei };\r\n    }\r\n\r\n    //parse target name from given measureURI\r\n    public String parseTargetName(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        //end of type + \"/\"\r\n        int si = bounds[1] + 1;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return measureURI.substring(si, ei);\r\n    }\r\n\r\n    //when a probe sends a keep-alive message, this is invoked\r\n    public boolean processKeepAlive(long probeId) {\r\n        ProbeDescription probe = probes.get(probeId);\r\n        if (probe != null) {\r\n            probe.resetDelay();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a registration is received from a probe-agent.\r\n     *\r\n     * @param properties A set of key-value pairs describing the probe. For key and their description see.. what? :)\r\n     * @return The probe identifier for the registered probe.\r\n     */\r\n    public synchronized long registerProbe(Map<String, String> properties) {\r\n        log.debug(\"registering probe\");\r\n        BMDescription bm = null;\r\n        boolean newTarget = false;\r\n        boolean newBM = false;\r\n        try {\r\n            log.debug(\"creating target description\");\r\n            TargetDescription target = persistence.createTargetDescription(properties);\r\n            if (!targets.containsValue(target)) {\r\n                newTarget = true;\r\n            }\r\n            targets.put(target.getTargetType() + target.getTargetName(), target);\r\n            log.debug(\"creating bm description\");\r\n            bm = persistence.createBMDescription(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to create target/bm for probe description.\", e);\r\n            return Const.ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE;\r\n        }\r\n        if (!bmIds.containsKey(bm.getBmId())) {\r\n            newBM = true;\r\n        }\r\n        availableBM.put(bm.getMeasureURI(), bm);\r\n        bmIds.put(bm.getBmId(), bm);\r\n        //we use the database to manage the probe information\r\n        log.debug(\"creating probe description\");\r\n        ProbeDescription desc = persistence.createProbeDescription(properties);\r\n        //we keep a mapping from id to desc to ease access in other functions\r\n        probes.put(desc.getProbeId(), desc);\r\n        // send probe registered data object to blackboard\r\n        ProbeRegistered pr = new ProbeRegistered(desc, newBM, newTarget);\r\n        bb.process(pr);\r\n        return desc.getProbeId();\r\n    }\r\n\r\n    //this is the thread that runs checking when a keep-alive message is received and if the delay for a probe has\r\n    //surpassed the given threshold. if one gets lots, the set of available BM is updated accordingly.\r\n    public void run() {\r\n        while (shouldRun) {\r\n            try {\r\n                Thread.sleep(delayIncrement);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"sleep interrupted\", e);\r\n            }\r\n            synchronized (this) {\r\n                for (Iterator<Map.Entry<Long, ProbeDescription>> i = probes.entrySet().iterator(); i.hasNext(); ) {\r\n                    Map.Entry<Long, ProbeDescription> entry = i.next();\r\n                    ProbeDescription probe = entry.getValue();\r\n                    probe.increaseDelay(delayIncrement);\r\n                    //          log.debug(\"Increasing delay for \"+probe+\" by \"+delayIncrement);\r\n                    if (probe.getDelay() >= maxDelay) {\r\n                        //TODO: also check all BM if we need to remove one, etc.\r\n                        log.info(\"Lease terminated for:\" + probe);\r\n                        i.remove();\r\n                        //check if there are any BM for the target (device)\r\n                        boolean found = false;\r\n                        boolean targetDisabled = false;\r\n                        TargetDescription target = probe.getBm().getTarget();\r\n                        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n                            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n                            if (target == targetDesc) {\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            //there are no BM for the target so it can be removed\r\n                            log.debug(\"removing Target:\" + target);\r\n                            String key = target.getTargetType() + target.getTargetName();\r\n                            targets.remove(key);\r\n                            targetDisabled = true;\r\n                        }\r\n                        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n                        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n                        boolean bmDisabled = false;\r\n                        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n                            String measureURI = probe.getMeasureURI();\r\n                            BMDescription bmDesc = availableBM.remove(measureURI);\r\n                            log.debug(\"removind BM:\" + bmDesc);\r\n                            bmIds.remove(bmDesc.getBmId());\r\n                            bmDisabled = true;\r\n                        }\r\n                        // send probe disabled data object to blackboard\r\n                        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n                        bb.process(pd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setProbeDisabled(ProbeDescription probe) {\r\n        log.info(\"Disabling Probe:\" + probe);\r\n        probes.remove(probe.getProbeId());\r\n        //check if there are any BM for the target (device)\r\n        boolean found = false;\r\n        boolean targetDisabled = false;\r\n        TargetDescription target = probe.getBm().getTarget();\r\n        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n            if (target == targetDesc) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            //there are no BM for the target so it can be removed\r\n            log.debug(\"removing Target:\" + target);\r\n            String key = target.getTargetType() + target.getTargetName();\r\n            targets.remove(key);\r\n            targetDisabled = true;\r\n        }\r\n        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n        boolean bmDisabled = false;\r\n        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n            String measureURI = probe.getMeasureURI();\r\n            BMDescription bmDesc = availableBM.remove(measureURI);\r\n            log.debug(\"removind BM:\" + bmDesc);\r\n            bmIds.remove(bmDesc.getBmId());\r\n            bmDisabled = true;\r\n        }\r\n        // send probe disabled data object to blackboard\r\n        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n        bb.process(pd);\r\n    }\r\n\r\n    public ProbeDescription getProbeForSubscription(long subscriptionId) {\r\n        try {\r\n            long probeId = subscriptionRegistry.getSubscription(subscriptionId).getProbeId();\r\n            return getProbeFor(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get probe for subscription\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        String msg = \"New measurement subscription URI:\" + bm.getMeasureURI() + \" F:\" + frequency + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, frequency, probeId);\r\n    }\r\n\r\n    public long getSacIdForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getSacIdForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public long getFrequencyForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getFrequencyForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public void removeSubscription(long sacId, long subscriptionId) {\r\n        String msg = \"Removed measurement subscription id:\" + subscriptionId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.DELETE_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        subscriptionRegistry.removeSubscription(subscriptionId);\r\n    }\r\n\r\n    public long getIdForSubscription(long sacId, long bmId) {\r\n        return subscriptionRegistry.getIdForSubscription(sacId, bmId);\r\n    }\r\n\r\n    public long addMeasurementRequest(long sacId, BMDescription bm, long probeId) {\r\n        String msg = \"New measurement request URI:\" + bm.getMeasureURI() + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_MEASUREMENT_REQUEST, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, 0, probeId);\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        log.debug(\"checkSubscriptions (probeId:\" + probeId + \") - subscriptions:\" + subscriptionIds);\r\n        //check if some other probe is better for the bm\r\n        //should be done only once after probe registration?\r\n        //get the best available probe for bm\r\n        long bmId = probes.get(probeId).getBm().getBmId();\r\n        ProbeDescription probe = getProbeForBM(bmId);\r\n        List<MeasurementSubscription> subscriptions = subscriptionRegistry.getSubscriptionsForBM(bmId);\r\n        log.debug(\"Probe BM subscriptions:\" + subscriptions);\r\n        for (MeasurementSubscription subscription : subscriptions) {\r\n            if (subscription.getProbeId() != probe.getProbeId()) {\r\n                log.debug(\"Probe with higher precision found\");\r\n                subscriptionRegistry.setProbeForSubscription(subscription.getSubscriptionId(), probe.getProbeId());\r\n            }\r\n        }\r\n        subscriptions = subscriptionRegistry.getSubscriptionsForProbe(probeId);\r\n        log.debug(\"Subscriptions for probe:\" + subscriptions);\r\n        for (MeasurementSubscription ms : subscriptions) {\r\n            //log.debug(\"Subscription on server (ID:\"+ms.getSubscriptionId()+\")\");\r\n            //if there is a new subscription\r\n            if (!subscriptionIds.contains(ms.getSubscriptionId())) {\r\n                log.info(\"New subscription found (bmId:\" + ms.getBmId() + \") while checking existing ones\");\r\n                //send subscription request to probe\r\n                if (server != null) {\r\n                    server.subscribeToBM(ms.getBmId(), ms.getFrequency(), ms.getSubscriptionId());\r\n                } else {\r\n                    log.error(\"Could not request bm, server null\");\r\n                }\r\n            }\r\n        }\r\n        //if probes current subscription is not found on the server it should be removed from the probe\r\n        for (Long subscriptionId : subscriptionIds) {\r\n            //log.debug(\"Probes current subscription (ID:\"+subscriptionId+\")\");\r\n            boolean found = false;\r\n            for (MeasurementSubscription ms : subscriptions) {\r\n                if (ms.getSubscriptionId() == subscriptionId) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                log.debug(\"Probes (ID:\" + probeId + \") current subscription (ID:\" + subscriptionId + \") not found on server, sending unsubscription request to probe\");\r\n                server.unSubscribeToBM(getProbeFor(probeId), subscriptionId);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/RegistryPluginImpl_2Test.java",
		"test_prompt": "// RegistryPluginImpl_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistryPluginImpl}.\n* It contains ten unit test cases for the {@link RegistryPluginImpl#parseTargetType(String)} method.\n*/\nclass RegistryPluginImpl_2Test {"
	},
	{
		"original_code": "// RegistryPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RegistryPluginImpl extends BasePlugin implements RegistryPlugin, PersistenceUser, ServerUser, Runnable {\r\n\r\n    private final static Logger log = new Logger(RegistryPluginImpl.class);\r\n\r\n    //key = measureURI\r\n    private final Map<String, BMDescription> availableBM = new HashMap<String, BMDescription>();\r\n\r\n    //key = long bmid provided by sac\r\n    private final Map<Long, BMDescription> bmIds = new HashMap<Long, BMDescription>();\r\n\r\n    //key = targetType+targetName\r\n    private final Map<String, TargetDescription> targets = new HashMap<String, TargetDescription>();\r\n\r\n    //key = probeId, value = ProbeDescription\r\n    private final Map<Long, ProbeDescription> probes = new HashMap<Long, ProbeDescription>();\r\n\r\n    //all DM definitions created\r\n    private final Collection<DMDefinition> dms = new HashSet<DMDefinition>();\r\n\r\n    private int nextDmId = 1;\r\n\r\n    //maximum delay for receiving keep-alive messages before a probe-agent is reported as lost\r\n    private int maxDelay = DEFAULT_DELAY;\r\n\r\n    //how much time to wait between checking the keep-alive status of probe-agents\r\n    private int delayIncrement = DEFAULT_INCREMENT;\r\n\r\n    //default keep-alive threshold if nothing is configured\r\n    //10 seconds\r\n    private static final int DEFAULT_DELAY = 10 * 1000;\r\n\r\n    //default keep-alive wait time if nothing is configured\r\n    //1 second\r\n    private static final int DEFAULT_INCREMENT = 1000;\r\n\r\n    //should the registry keep running its threads or shut down?\r\n    private boolean shouldRun = true;\r\n\r\n    //access to the persistent state\r\n    private PersistencePlugin persistence = null;\r\n\r\n    private ServerPlugin server = null;\r\n\r\n    private SubscriptionRegistry subscriptionRegistry;\r\n\r\n    public RegistryPluginImpl(BundleContext bc, int maxDelay, int delayIncrement) {\r\n        super(bc, log);\r\n        if (maxDelay > 0) {\r\n            //assume that if one is set, both are set\r\n            this.maxDelay = maxDelay;\r\n            this.delayIncrement = delayIncrement;\r\n        } else {\r\n            try {\r\n                Properties props = readConfiguration();\r\n                this.maxDelay = Integer.parseInt(props.getProperty(Const.MAX_KEEPALIVE_DELAY));\r\n            } catch (IOException e) {\r\n                log.error(\"Error in reading configuration file. Using defaults.\", e);\r\n            }\r\n        }\r\n        //start a thread to monitor keep-alive messages\r\n        Thread t = new Thread(this);\r\n        t.setDaemon(true);\r\n        t.start();\r\n        //register a listener to capture the persistenceplugin when available\r\n        PersistenceServiceListener pl = new PersistenceServiceListener(bc, log, this);\r\n        pl.init();\r\n        //register a listener to capture the server-agent when available\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        subscriptionRegistry = new SubscriptionRegistry(bc);\r\n    }\r\n\r\n    public void stop() {\r\n        shouldRun = false;\r\n    }\r\n\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    //get the BMDescription for the given measureURI (measure identifier)\r\n    public BMDescription descriptionFor(String measureURI) {\r\n        return availableBM.get(measureURI);\r\n    }\r\n\r\n    //provides a list of all registered probes\r\n    public List<ProbeDescription> getProbes() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<ProbeDescription> result = new ArrayList<ProbeDescription>(probes.size());\r\n        result.addAll(probes.values());\r\n        return result;\r\n    }\r\n\r\n    //get current list of registered probes\r\n    public synchronized List<BMDescription> getAvailableBM() {\r\n        Collection<BMDescription> values = availableBM.values();\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<BMDescription> result = new ArrayList<BMDescription>(values.size());\r\n        result.addAll(values);\r\n        return result;\r\n    }\r\n\r\n    //list of all currently defined DM\r\n    public synchronized List<DMDefinition> getDerivedMeasures() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<DMDefinition> result = new ArrayList<DMDefinition>(dms.size());\r\n        result.addAll(dms);\r\n        return result;\r\n    }\r\n\r\n    //list of all active targets (with probes registered for them)\r\n    public Collection<TargetDescription> getTargets() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<TargetDescription> targets = new ArrayList<TargetDescription>();\r\n        targets.addAll(this.targets.values());\r\n        return targets;\r\n    }\r\n\r\n    //create a derived measure. currently not a core feature, not persisted, etc.\r\n    public void createDM(String name, String script) {\r\n        DMDefinition newDm = new DMDefinition(nextDmId++, name, script);\r\n        dms.add(newDm);\r\n        bb.process(newDm);\r\n        log.debug(\"Registered DM:\" + name);\r\n    }\r\n\r\n    //gives probe description for given probeid\r\n    public ProbeDescription getProbeFor(long probeId) {\r\n        return probes.get(probeId);\r\n    }\r\n\r\n    //give the best available probe for given BM (with highest precision)\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        BMDescription bm = bmIds.get(bmId);\r\n        String measureURI = bm.getMeasureURI();\r\n        ProbeDescription result = null;\r\n        for (ProbeDescription probe : probes.values()) {\r\n            if (!probe.getMeasureURI().equals(measureURI)) {\r\n                continue;\r\n            }\r\n            if (result != null) {\r\n                if (result.getPrecision() < probe.getPrecision()) {\r\n                    result = probe;\r\n                }\r\n            } else {\r\n                result = probe;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //find the target id for the given measureURI\r\n    public long targetIdFor(String measureURI) {\r\n        //parse type from uri\r\n        String targetType = parseTargetType(measureURI);\r\n        //parse name from uri\r\n        String targetName = parseTargetName(measureURI);\r\n        //get the name from the target map\r\n        TargetDescription target = targets.get(targetType + targetName);\r\n        if (target == null) {\r\n            throw new IllegalArgumentException(\"No target found for measureURI:\" + measureURI);\r\n        }\r\n        return target.getTargetId();\r\n    }\r\n\r\n    //parse target type from a measureURI\r\n    public String parseTargetType(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        return measureURI.substring(bounds[0], bounds[1]);\r\n    }\r\n\r\n    //get start and end index of target type inside given measureURI\r\n    private int[] getTargetTypeBounds(String measureURI) {\r\n        int si = measureURI.indexOf(\"//\");\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        si += 2;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return new int[] { si, ei };\r\n    }\r\n\r\n    //parse target name from given measureURI\r\n    public String parseTargetName(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        //end of type + \"/\"\r\n        int si = bounds[1] + 1;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return measureURI.substring(si, ei);\r\n    }\r\n\r\n    //when a probe sends a keep-alive message, this is invoked\r\n    public boolean processKeepAlive(long probeId) {\r\n        ProbeDescription probe = probes.get(probeId);\r\n        if (probe != null) {\r\n            probe.resetDelay();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a registration is received from a probe-agent.\r\n     *\r\n     * @param properties A set of key-value pairs describing the probe. For key and their description see.. what? :)\r\n     * @return The probe identifier for the registered probe.\r\n     */\r\n    public synchronized long registerProbe(Map<String, String> properties) {\r\n        log.debug(\"registering probe\");\r\n        BMDescription bm = null;\r\n        boolean newTarget = false;\r\n        boolean newBM = false;\r\n        try {\r\n            log.debug(\"creating target description\");\r\n            TargetDescription target = persistence.createTargetDescription(properties);\r\n            if (!targets.containsValue(target)) {\r\n                newTarget = true;\r\n            }\r\n            targets.put(target.getTargetType() + target.getTargetName(), target);\r\n            log.debug(\"creating bm description\");\r\n            bm = persistence.createBMDescription(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to create target/bm for probe description.\", e);\r\n            return Const.ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE;\r\n        }\r\n        if (!bmIds.containsKey(bm.getBmId())) {\r\n            newBM = true;\r\n        }\r\n        availableBM.put(bm.getMeasureURI(), bm);\r\n        bmIds.put(bm.getBmId(), bm);\r\n        //we use the database to manage the probe information\r\n        log.debug(\"creating probe description\");\r\n        ProbeDescription desc = persistence.createProbeDescription(properties);\r\n        //we keep a mapping from id to desc to ease access in other functions\r\n        probes.put(desc.getProbeId(), desc);\r\n        // send probe registered data object to blackboard\r\n        ProbeRegistered pr = new ProbeRegistered(desc, newBM, newTarget);\r\n        bb.process(pr);\r\n        return desc.getProbeId();\r\n    }\r\n\r\n    //this is the thread that runs checking when a keep-alive message is received and if the delay for a probe has\r\n    //surpassed the given threshold. if one gets lots, the set of available BM is updated accordingly.\r\n    public void run() {\r\n        while (shouldRun) {\r\n            try {\r\n                Thread.sleep(delayIncrement);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"sleep interrupted\", e);\r\n            }\r\n            synchronized (this) {\r\n                for (Iterator<Map.Entry<Long, ProbeDescription>> i = probes.entrySet().iterator(); i.hasNext(); ) {\r\n                    Map.Entry<Long, ProbeDescription> entry = i.next();\r\n                    ProbeDescription probe = entry.getValue();\r\n                    probe.increaseDelay(delayIncrement);\r\n                    //          log.debug(\"Increasing delay for \"+probe+\" by \"+delayIncrement);\r\n                    if (probe.getDelay() >= maxDelay) {\r\n                        //TODO: also check all BM if we need to remove one, etc.\r\n                        log.info(\"Lease terminated for:\" + probe);\r\n                        i.remove();\r\n                        //check if there are any BM for the target (device)\r\n                        boolean found = false;\r\n                        boolean targetDisabled = false;\r\n                        TargetDescription target = probe.getBm().getTarget();\r\n                        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n                            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n                            if (target == targetDesc) {\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            //there are no BM for the target so it can be removed\r\n                            log.debug(\"removing Target:\" + target);\r\n                            String key = target.getTargetType() + target.getTargetName();\r\n                            targets.remove(key);\r\n                            targetDisabled = true;\r\n                        }\r\n                        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n                        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n                        boolean bmDisabled = false;\r\n                        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n                            String measureURI = probe.getMeasureURI();\r\n                            BMDescription bmDesc = availableBM.remove(measureURI);\r\n                            log.debug(\"removind BM:\" + bmDesc);\r\n                            bmIds.remove(bmDesc.getBmId());\r\n                            bmDisabled = true;\r\n                        }\r\n                        // send probe disabled data object to blackboard\r\n                        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n                        bb.process(pd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setProbeDisabled(ProbeDescription probe) {\r\n        log.info(\"Disabling Probe:\" + probe);\r\n        probes.remove(probe.getProbeId());\r\n        //check if there are any BM for the target (device)\r\n        boolean found = false;\r\n        boolean targetDisabled = false;\r\n        TargetDescription target = probe.getBm().getTarget();\r\n        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n            if (target == targetDesc) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            //there are no BM for the target so it can be removed\r\n            log.debug(\"removing Target:\" + target);\r\n            String key = target.getTargetType() + target.getTargetName();\r\n            targets.remove(key);\r\n            targetDisabled = true;\r\n        }\r\n        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n        boolean bmDisabled = false;\r\n        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n            String measureURI = probe.getMeasureURI();\r\n            BMDescription bmDesc = availableBM.remove(measureURI);\r\n            log.debug(\"removind BM:\" + bmDesc);\r\n            bmIds.remove(bmDesc.getBmId());\r\n            bmDisabled = true;\r\n        }\r\n        // send probe disabled data object to blackboard\r\n        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n        bb.process(pd);\r\n    }\r\n\r\n    public ProbeDescription getProbeForSubscription(long subscriptionId) {\r\n        try {\r\n            long probeId = subscriptionRegistry.getSubscription(subscriptionId).getProbeId();\r\n            return getProbeFor(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get probe for subscription\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        String msg = \"New measurement subscription URI:\" + bm.getMeasureURI() + \" F:\" + frequency + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, frequency, probeId);\r\n    }\r\n\r\n    public long getSacIdForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getSacIdForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public long getFrequencyForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getFrequencyForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public void removeSubscription(long sacId, long subscriptionId) {\r\n        String msg = \"Removed measurement subscription id:\" + subscriptionId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.DELETE_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        subscriptionRegistry.removeSubscription(subscriptionId);\r\n    }\r\n\r\n    public long getIdForSubscription(long sacId, long bmId) {\r\n        return subscriptionRegistry.getIdForSubscription(sacId, bmId);\r\n    }\r\n\r\n    public long addMeasurementRequest(long sacId, BMDescription bm, long probeId) {\r\n        String msg = \"New measurement request URI:\" + bm.getMeasureURI() + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_MEASUREMENT_REQUEST, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, 0, probeId);\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        log.debug(\"checkSubscriptions (probeId:\" + probeId + \") - subscriptions:\" + subscriptionIds);\r\n        //check if some other probe is better for the bm\r\n        //should be done only once after probe registration?\r\n        //get the best available probe for bm\r\n        long bmId = probes.get(probeId).getBm().getBmId();\r\n        ProbeDescription probe = getProbeForBM(bmId);\r\n        List<MeasurementSubscription> subscriptions = subscriptionRegistry.getSubscriptionsForBM(bmId);\r\n        log.debug(\"Probe BM subscriptions:\" + subscriptions);\r\n        for (MeasurementSubscription subscription : subscriptions) {\r\n            if (subscription.getProbeId() != probe.getProbeId()) {\r\n                log.debug(\"Probe with higher precision found\");\r\n                subscriptionRegistry.setProbeForSubscription(subscription.getSubscriptionId(), probe.getProbeId());\r\n            }\r\n        }\r\n        subscriptions = subscriptionRegistry.getSubscriptionsForProbe(probeId);\r\n        log.debug(\"Subscriptions for probe:\" + subscriptions);\r\n        for (MeasurementSubscription ms : subscriptions) {\r\n            //log.debug(\"Subscription on server (ID:\"+ms.getSubscriptionId()+\")\");\r\n            //if there is a new subscription\r\n            if (!subscriptionIds.contains(ms.getSubscriptionId())) {\r\n                log.info(\"New subscription found (bmId:\" + ms.getBmId() + \") while checking existing ones\");\r\n                //send subscription request to probe\r\n                if (server != null) {\r\n                    server.subscribeToBM(ms.getBmId(), ms.getFrequency(), ms.getSubscriptionId());\r\n                } else {\r\n                    log.error(\"Could not request bm, server null\");\r\n                }\r\n            }\r\n        }\r\n        //if probes current subscription is not found on the server it should be removed from the probe\r\n        for (Long subscriptionId : subscriptionIds) {\r\n            //log.debug(\"Probes current subscription (ID:\"+subscriptionId+\")\");\r\n            boolean found = false;\r\n            for (MeasurementSubscription ms : subscriptions) {\r\n                if (ms.getSubscriptionId() == subscriptionId) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                log.debug(\"Probes (ID:\" + probeId + \") current subscription (ID:\" + subscriptionId + \") not found on server, sending unsubscription request to probe\");\r\n                server.unSubscribeToBM(getProbeFor(probeId), subscriptionId);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/RegistryPluginImpl_3Test.java",
		"test_prompt": "// RegistryPluginImpl_3Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistryPluginImpl}.\n* It contains ten unit test cases for the {@link RegistryPluginImpl#parseTargetName(String)} method.\n*/\nclass RegistryPluginImpl_3Test {"
	},
	{
		"original_code": "// RegistryPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RegistryPluginImpl extends BasePlugin implements RegistryPlugin, PersistenceUser, ServerUser, Runnable {\r\n\r\n    private final static Logger log = new Logger(RegistryPluginImpl.class);\r\n\r\n    //key = measureURI\r\n    private final Map<String, BMDescription> availableBM = new HashMap<String, BMDescription>();\r\n\r\n    //key = long bmid provided by sac\r\n    private final Map<Long, BMDescription> bmIds = new HashMap<Long, BMDescription>();\r\n\r\n    //key = targetType+targetName\r\n    private final Map<String, TargetDescription> targets = new HashMap<String, TargetDescription>();\r\n\r\n    //key = probeId, value = ProbeDescription\r\n    private final Map<Long, ProbeDescription> probes = new HashMap<Long, ProbeDescription>();\r\n\r\n    //all DM definitions created\r\n    private final Collection<DMDefinition> dms = new HashSet<DMDefinition>();\r\n\r\n    private int nextDmId = 1;\r\n\r\n    //maximum delay for receiving keep-alive messages before a probe-agent is reported as lost\r\n    private int maxDelay = DEFAULT_DELAY;\r\n\r\n    //how much time to wait between checking the keep-alive status of probe-agents\r\n    private int delayIncrement = DEFAULT_INCREMENT;\r\n\r\n    //default keep-alive threshold if nothing is configured\r\n    //10 seconds\r\n    private static final int DEFAULT_DELAY = 10 * 1000;\r\n\r\n    //default keep-alive wait time if nothing is configured\r\n    //1 second\r\n    private static final int DEFAULT_INCREMENT = 1000;\r\n\r\n    //should the registry keep running its threads or shut down?\r\n    private boolean shouldRun = true;\r\n\r\n    //access to the persistent state\r\n    private PersistencePlugin persistence = null;\r\n\r\n    private ServerPlugin server = null;\r\n\r\n    private SubscriptionRegistry subscriptionRegistry;\r\n\r\n    public RegistryPluginImpl(BundleContext bc, int maxDelay, int delayIncrement) {\r\n        super(bc, log);\r\n        if (maxDelay > 0) {\r\n            //assume that if one is set, both are set\r\n            this.maxDelay = maxDelay;\r\n            this.delayIncrement = delayIncrement;\r\n        } else {\r\n            try {\r\n                Properties props = readConfiguration();\r\n                this.maxDelay = Integer.parseInt(props.getProperty(Const.MAX_KEEPALIVE_DELAY));\r\n            } catch (IOException e) {\r\n                log.error(\"Error in reading configuration file. Using defaults.\", e);\r\n            }\r\n        }\r\n        //start a thread to monitor keep-alive messages\r\n        Thread t = new Thread(this);\r\n        t.setDaemon(true);\r\n        t.start();\r\n        //register a listener to capture the persistenceplugin when available\r\n        PersistenceServiceListener pl = new PersistenceServiceListener(bc, log, this);\r\n        pl.init();\r\n        //register a listener to capture the server-agent when available\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        subscriptionRegistry = new SubscriptionRegistry(bc);\r\n    }\r\n\r\n    public void stop() {\r\n        shouldRun = false;\r\n    }\r\n\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    //get the BMDescription for the given measureURI (measure identifier)\r\n    public BMDescription descriptionFor(String measureURI) {\r\n        return availableBM.get(measureURI);\r\n    }\r\n\r\n    //provides a list of all registered probes\r\n    public List<ProbeDescription> getProbes() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<ProbeDescription> result = new ArrayList<ProbeDescription>(probes.size());\r\n        result.addAll(probes.values());\r\n        return result;\r\n    }\r\n\r\n    //get current list of registered probes\r\n    public synchronized List<BMDescription> getAvailableBM() {\r\n        Collection<BMDescription> values = availableBM.values();\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<BMDescription> result = new ArrayList<BMDescription>(values.size());\r\n        result.addAll(values);\r\n        return result;\r\n    }\r\n\r\n    //list of all currently defined DM\r\n    public synchronized List<DMDefinition> getDerivedMeasures() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<DMDefinition> result = new ArrayList<DMDefinition>(dms.size());\r\n        result.addAll(dms);\r\n        return result;\r\n    }\r\n\r\n    //list of all active targets (with probes registered for them)\r\n    public Collection<TargetDescription> getTargets() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<TargetDescription> targets = new ArrayList<TargetDescription>();\r\n        targets.addAll(this.targets.values());\r\n        return targets;\r\n    }\r\n\r\n    //create a derived measure. currently not a core feature, not persisted, etc.\r\n    public void createDM(String name, String script) {\r\n        DMDefinition newDm = new DMDefinition(nextDmId++, name, script);\r\n        dms.add(newDm);\r\n        bb.process(newDm);\r\n        log.debug(\"Registered DM:\" + name);\r\n    }\r\n\r\n    //gives probe description for given probeid\r\n    public ProbeDescription getProbeFor(long probeId) {\r\n        return probes.get(probeId);\r\n    }\r\n\r\n    //give the best available probe for given BM (with highest precision)\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        BMDescription bm = bmIds.get(bmId);\r\n        String measureURI = bm.getMeasureURI();\r\n        ProbeDescription result = null;\r\n        for (ProbeDescription probe : probes.values()) {\r\n            if (!probe.getMeasureURI().equals(measureURI)) {\r\n                continue;\r\n            }\r\n            if (result != null) {\r\n                if (result.getPrecision() < probe.getPrecision()) {\r\n                    result = probe;\r\n                }\r\n            } else {\r\n                result = probe;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //find the target id for the given measureURI\r\n    public long targetIdFor(String measureURI) {\r\n        //parse type from uri\r\n        String targetType = parseTargetType(measureURI);\r\n        //parse name from uri\r\n        String targetName = parseTargetName(measureURI);\r\n        //get the name from the target map\r\n        TargetDescription target = targets.get(targetType + targetName);\r\n        if (target == null) {\r\n            throw new IllegalArgumentException(\"No target found for measureURI:\" + measureURI);\r\n        }\r\n        return target.getTargetId();\r\n    }\r\n\r\n    //parse target type from a measureURI\r\n    public String parseTargetType(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        return measureURI.substring(bounds[0], bounds[1]);\r\n    }\r\n\r\n    //get start and end index of target type inside given measureURI\r\n    private int[] getTargetTypeBounds(String measureURI) {\r\n        int si = measureURI.indexOf(\"//\");\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        si += 2;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return new int[] { si, ei };\r\n    }\r\n\r\n    //parse target name from given measureURI\r\n    public String parseTargetName(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        //end of type + \"/\"\r\n        int si = bounds[1] + 1;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return measureURI.substring(si, ei);\r\n    }\r\n\r\n    //when a probe sends a keep-alive message, this is invoked\r\n    public boolean processKeepAlive(long probeId) {\r\n        ProbeDescription probe = probes.get(probeId);\r\n        if (probe != null) {\r\n            probe.resetDelay();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a registration is received from a probe-agent.\r\n     *\r\n     * @param properties A set of key-value pairs describing the probe. For key and their description see.. what? :)\r\n     * @return The probe identifier for the registered probe.\r\n     */\r\n    public synchronized long registerProbe(Map<String, String> properties) {\r\n        log.debug(\"registering probe\");\r\n        BMDescription bm = null;\r\n        boolean newTarget = false;\r\n        boolean newBM = false;\r\n        try {\r\n            log.debug(\"creating target description\");\r\n            TargetDescription target = persistence.createTargetDescription(properties);\r\n            if (!targets.containsValue(target)) {\r\n                newTarget = true;\r\n            }\r\n            targets.put(target.getTargetType() + target.getTargetName(), target);\r\n            log.debug(\"creating bm description\");\r\n            bm = persistence.createBMDescription(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to create target/bm for probe description.\", e);\r\n            return Const.ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE;\r\n        }\r\n        if (!bmIds.containsKey(bm.getBmId())) {\r\n            newBM = true;\r\n        }\r\n        availableBM.put(bm.getMeasureURI(), bm);\r\n        bmIds.put(bm.getBmId(), bm);\r\n        //we use the database to manage the probe information\r\n        log.debug(\"creating probe description\");\r\n        ProbeDescription desc = persistence.createProbeDescription(properties);\r\n        //we keep a mapping from id to desc to ease access in other functions\r\n        probes.put(desc.getProbeId(), desc);\r\n        // send probe registered data object to blackboard\r\n        ProbeRegistered pr = new ProbeRegistered(desc, newBM, newTarget);\r\n        bb.process(pr);\r\n        return desc.getProbeId();\r\n    }\r\n\r\n    //this is the thread that runs checking when a keep-alive message is received and if the delay for a probe has\r\n    //surpassed the given threshold. if one gets lots, the set of available BM is updated accordingly.\r\n    public void run() {\r\n        while (shouldRun) {\r\n            try {\r\n                Thread.sleep(delayIncrement);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"sleep interrupted\", e);\r\n            }\r\n            synchronized (this) {\r\n                for (Iterator<Map.Entry<Long, ProbeDescription>> i = probes.entrySet().iterator(); i.hasNext(); ) {\r\n                    Map.Entry<Long, ProbeDescription> entry = i.next();\r\n                    ProbeDescription probe = entry.getValue();\r\n                    probe.increaseDelay(delayIncrement);\r\n                    //          log.debug(\"Increasing delay for \"+probe+\" by \"+delayIncrement);\r\n                    if (probe.getDelay() >= maxDelay) {\r\n                        //TODO: also check all BM if we need to remove one, etc.\r\n                        log.info(\"Lease terminated for:\" + probe);\r\n                        i.remove();\r\n                        //check if there are any BM for the target (device)\r\n                        boolean found = false;\r\n                        boolean targetDisabled = false;\r\n                        TargetDescription target = probe.getBm().getTarget();\r\n                        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n                            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n                            if (target == targetDesc) {\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            //there are no BM for the target so it can be removed\r\n                            log.debug(\"removing Target:\" + target);\r\n                            String key = target.getTargetType() + target.getTargetName();\r\n                            targets.remove(key);\r\n                            targetDisabled = true;\r\n                        }\r\n                        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n                        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n                        boolean bmDisabled = false;\r\n                        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n                            String measureURI = probe.getMeasureURI();\r\n                            BMDescription bmDesc = availableBM.remove(measureURI);\r\n                            log.debug(\"removind BM:\" + bmDesc);\r\n                            bmIds.remove(bmDesc.getBmId());\r\n                            bmDisabled = true;\r\n                        }\r\n                        // send probe disabled data object to blackboard\r\n                        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n                        bb.process(pd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setProbeDisabled(ProbeDescription probe) {\r\n        log.info(\"Disabling Probe:\" + probe);\r\n        probes.remove(probe.getProbeId());\r\n        //check if there are any BM for the target (device)\r\n        boolean found = false;\r\n        boolean targetDisabled = false;\r\n        TargetDescription target = probe.getBm().getTarget();\r\n        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n            if (target == targetDesc) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            //there are no BM for the target so it can be removed\r\n            log.debug(\"removing Target:\" + target);\r\n            String key = target.getTargetType() + target.getTargetName();\r\n            targets.remove(key);\r\n            targetDisabled = true;\r\n        }\r\n        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n        boolean bmDisabled = false;\r\n        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n            String measureURI = probe.getMeasureURI();\r\n            BMDescription bmDesc = availableBM.remove(measureURI);\r\n            log.debug(\"removind BM:\" + bmDesc);\r\n            bmIds.remove(bmDesc.getBmId());\r\n            bmDisabled = true;\r\n        }\r\n        // send probe disabled data object to blackboard\r\n        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n        bb.process(pd);\r\n    }\r\n\r\n    public ProbeDescription getProbeForSubscription(long subscriptionId) {\r\n        try {\r\n            long probeId = subscriptionRegistry.getSubscription(subscriptionId).getProbeId();\r\n            return getProbeFor(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get probe for subscription\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        String msg = \"New measurement subscription URI:\" + bm.getMeasureURI() + \" F:\" + frequency + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, frequency, probeId);\r\n    }\r\n\r\n    public long getSacIdForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getSacIdForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public long getFrequencyForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getFrequencyForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public void removeSubscription(long sacId, long subscriptionId) {\r\n        String msg = \"Removed measurement subscription id:\" + subscriptionId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.DELETE_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        subscriptionRegistry.removeSubscription(subscriptionId);\r\n    }\r\n\r\n    public long getIdForSubscription(long sacId, long bmId) {\r\n        return subscriptionRegistry.getIdForSubscription(sacId, bmId);\r\n    }\r\n\r\n    public long addMeasurementRequest(long sacId, BMDescription bm, long probeId) {\r\n        String msg = \"New measurement request URI:\" + bm.getMeasureURI() + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_MEASUREMENT_REQUEST, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, 0, probeId);\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        log.debug(\"checkSubscriptions (probeId:\" + probeId + \") - subscriptions:\" + subscriptionIds);\r\n        //check if some other probe is better for the bm\r\n        //should be done only once after probe registration?\r\n        //get the best available probe for bm\r\n        long bmId = probes.get(probeId).getBm().getBmId();\r\n        ProbeDescription probe = getProbeForBM(bmId);\r\n        List<MeasurementSubscription> subscriptions = subscriptionRegistry.getSubscriptionsForBM(bmId);\r\n        log.debug(\"Probe BM subscriptions:\" + subscriptions);\r\n        for (MeasurementSubscription subscription : subscriptions) {\r\n            if (subscription.getProbeId() != probe.getProbeId()) {\r\n                log.debug(\"Probe with higher precision found\");\r\n                subscriptionRegistry.setProbeForSubscription(subscription.getSubscriptionId(), probe.getProbeId());\r\n            }\r\n        }\r\n        subscriptions = subscriptionRegistry.getSubscriptionsForProbe(probeId);\r\n        log.debug(\"Subscriptions for probe:\" + subscriptions);\r\n        for (MeasurementSubscription ms : subscriptions) {\r\n            //log.debug(\"Subscription on server (ID:\"+ms.getSubscriptionId()+\")\");\r\n            //if there is a new subscription\r\n            if (!subscriptionIds.contains(ms.getSubscriptionId())) {\r\n                log.info(\"New subscription found (bmId:\" + ms.getBmId() + \") while checking existing ones\");\r\n                //send subscription request to probe\r\n                if (server != null) {\r\n                    server.subscribeToBM(ms.getBmId(), ms.getFrequency(), ms.getSubscriptionId());\r\n                } else {\r\n                    log.error(\"Could not request bm, server null\");\r\n                }\r\n            }\r\n        }\r\n        //if probes current subscription is not found on the server it should be removed from the probe\r\n        for (Long subscriptionId : subscriptionIds) {\r\n            //log.debug(\"Probes current subscription (ID:\"+subscriptionId+\")\");\r\n            boolean found = false;\r\n            for (MeasurementSubscription ms : subscriptions) {\r\n                if (ms.getSubscriptionId() == subscriptionId) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                log.debug(\"Probes (ID:\" + probeId + \") current subscription (ID:\" + subscriptionId + \") not found on server, sending unsubscription request to probe\");\r\n                server.unSubscribeToBM(getProbeFor(probeId), subscriptionId);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/RegistryPluginImpl_4Test.java",
		"test_prompt": "// RegistryPluginImpl_4Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistryPluginImpl}.\n* It contains ten unit test cases for the {@link RegistryPluginImpl#processKeepAlive(long)} method.\n*/\nclass RegistryPluginImpl_4Test {"
	},
	{
		"original_code": "// RegistryPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RegistryPluginImpl extends BasePlugin implements RegistryPlugin, PersistenceUser, ServerUser, Runnable {\r\n\r\n    private final static Logger log = new Logger(RegistryPluginImpl.class);\r\n\r\n    //key = measureURI\r\n    private final Map<String, BMDescription> availableBM = new HashMap<String, BMDescription>();\r\n\r\n    //key = long bmid provided by sac\r\n    private final Map<Long, BMDescription> bmIds = new HashMap<Long, BMDescription>();\r\n\r\n    //key = targetType+targetName\r\n    private final Map<String, TargetDescription> targets = new HashMap<String, TargetDescription>();\r\n\r\n    //key = probeId, value = ProbeDescription\r\n    private final Map<Long, ProbeDescription> probes = new HashMap<Long, ProbeDescription>();\r\n\r\n    //all DM definitions created\r\n    private final Collection<DMDefinition> dms = new HashSet<DMDefinition>();\r\n\r\n    private int nextDmId = 1;\r\n\r\n    //maximum delay for receiving keep-alive messages before a probe-agent is reported as lost\r\n    private int maxDelay = DEFAULT_DELAY;\r\n\r\n    //how much time to wait between checking the keep-alive status of probe-agents\r\n    private int delayIncrement = DEFAULT_INCREMENT;\r\n\r\n    //default keep-alive threshold if nothing is configured\r\n    //10 seconds\r\n    private static final int DEFAULT_DELAY = 10 * 1000;\r\n\r\n    //default keep-alive wait time if nothing is configured\r\n    //1 second\r\n    private static final int DEFAULT_INCREMENT = 1000;\r\n\r\n    //should the registry keep running its threads or shut down?\r\n    private boolean shouldRun = true;\r\n\r\n    //access to the persistent state\r\n    private PersistencePlugin persistence = null;\r\n\r\n    private ServerPlugin server = null;\r\n\r\n    private SubscriptionRegistry subscriptionRegistry;\r\n\r\n    public RegistryPluginImpl(BundleContext bc, int maxDelay, int delayIncrement) {\r\n        super(bc, log);\r\n        if (maxDelay > 0) {\r\n            //assume that if one is set, both are set\r\n            this.maxDelay = maxDelay;\r\n            this.delayIncrement = delayIncrement;\r\n        } else {\r\n            try {\r\n                Properties props = readConfiguration();\r\n                this.maxDelay = Integer.parseInt(props.getProperty(Const.MAX_KEEPALIVE_DELAY));\r\n            } catch (IOException e) {\r\n                log.error(\"Error in reading configuration file. Using defaults.\", e);\r\n            }\r\n        }\r\n        //start a thread to monitor keep-alive messages\r\n        Thread t = new Thread(this);\r\n        t.setDaemon(true);\r\n        t.start();\r\n        //register a listener to capture the persistenceplugin when available\r\n        PersistenceServiceListener pl = new PersistenceServiceListener(bc, log, this);\r\n        pl.init();\r\n        //register a listener to capture the server-agent when available\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        subscriptionRegistry = new SubscriptionRegistry(bc);\r\n    }\r\n\r\n    public void stop() {\r\n        shouldRun = false;\r\n    }\r\n\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    //get the BMDescription for the given measureURI (measure identifier)\r\n    public BMDescription descriptionFor(String measureURI) {\r\n        return availableBM.get(measureURI);\r\n    }\r\n\r\n    //provides a list of all registered probes\r\n    public List<ProbeDescription> getProbes() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<ProbeDescription> result = new ArrayList<ProbeDescription>(probes.size());\r\n        result.addAll(probes.values());\r\n        return result;\r\n    }\r\n\r\n    //get current list of registered probes\r\n    public synchronized List<BMDescription> getAvailableBM() {\r\n        Collection<BMDescription> values = availableBM.values();\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<BMDescription> result = new ArrayList<BMDescription>(values.size());\r\n        result.addAll(values);\r\n        return result;\r\n    }\r\n\r\n    //list of all currently defined DM\r\n    public synchronized List<DMDefinition> getDerivedMeasures() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<DMDefinition> result = new ArrayList<DMDefinition>(dms.size());\r\n        result.addAll(dms);\r\n        return result;\r\n    }\r\n\r\n    //list of all active targets (with probes registered for them)\r\n    public Collection<TargetDescription> getTargets() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<TargetDescription> targets = new ArrayList<TargetDescription>();\r\n        targets.addAll(this.targets.values());\r\n        return targets;\r\n    }\r\n\r\n    //create a derived measure. currently not a core feature, not persisted, etc.\r\n    public void createDM(String name, String script) {\r\n        DMDefinition newDm = new DMDefinition(nextDmId++, name, script);\r\n        dms.add(newDm);\r\n        bb.process(newDm);\r\n        log.debug(\"Registered DM:\" + name);\r\n    }\r\n\r\n    //gives probe description for given probeid\r\n    public ProbeDescription getProbeFor(long probeId) {\r\n        return probes.get(probeId);\r\n    }\r\n\r\n    //give the best available probe for given BM (with highest precision)\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        BMDescription bm = bmIds.get(bmId);\r\n        String measureURI = bm.getMeasureURI();\r\n        ProbeDescription result = null;\r\n        for (ProbeDescription probe : probes.values()) {\r\n            if (!probe.getMeasureURI().equals(measureURI)) {\r\n                continue;\r\n            }\r\n            if (result != null) {\r\n                if (result.getPrecision() < probe.getPrecision()) {\r\n                    result = probe;\r\n                }\r\n            } else {\r\n                result = probe;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //find the target id for the given measureURI\r\n    public long targetIdFor(String measureURI) {\r\n        //parse type from uri\r\n        String targetType = parseTargetType(measureURI);\r\n        //parse name from uri\r\n        String targetName = parseTargetName(measureURI);\r\n        //get the name from the target map\r\n        TargetDescription target = targets.get(targetType + targetName);\r\n        if (target == null) {\r\n            throw new IllegalArgumentException(\"No target found for measureURI:\" + measureURI);\r\n        }\r\n        return target.getTargetId();\r\n    }\r\n\r\n    //parse target type from a measureURI\r\n    public String parseTargetType(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        return measureURI.substring(bounds[0], bounds[1]);\r\n    }\r\n\r\n    //get start and end index of target type inside given measureURI\r\n    private int[] getTargetTypeBounds(String measureURI) {\r\n        int si = measureURI.indexOf(\"//\");\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        si += 2;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return new int[] { si, ei };\r\n    }\r\n\r\n    //parse target name from given measureURI\r\n    public String parseTargetName(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        //end of type + \"/\"\r\n        int si = bounds[1] + 1;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return measureURI.substring(si, ei);\r\n    }\r\n\r\n    //when a probe sends a keep-alive message, this is invoked\r\n    public boolean processKeepAlive(long probeId) {\r\n        ProbeDescription probe = probes.get(probeId);\r\n        if (probe != null) {\r\n            probe.resetDelay();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a registration is received from a probe-agent.\r\n     *\r\n     * @param properties A set of key-value pairs describing the probe. For key and their description see.. what? :)\r\n     * @return The probe identifier for the registered probe.\r\n     */\r\n    public synchronized long registerProbe(Map<String, String> properties) {\r\n        log.debug(\"registering probe\");\r\n        BMDescription bm = null;\r\n        boolean newTarget = false;\r\n        boolean newBM = false;\r\n        try {\r\n            log.debug(\"creating target description\");\r\n            TargetDescription target = persistence.createTargetDescription(properties);\r\n            if (!targets.containsValue(target)) {\r\n                newTarget = true;\r\n            }\r\n            targets.put(target.getTargetType() + target.getTargetName(), target);\r\n            log.debug(\"creating bm description\");\r\n            bm = persistence.createBMDescription(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to create target/bm for probe description.\", e);\r\n            return Const.ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE;\r\n        }\r\n        if (!bmIds.containsKey(bm.getBmId())) {\r\n            newBM = true;\r\n        }\r\n        availableBM.put(bm.getMeasureURI(), bm);\r\n        bmIds.put(bm.getBmId(), bm);\r\n        //we use the database to manage the probe information\r\n        log.debug(\"creating probe description\");\r\n        ProbeDescription desc = persistence.createProbeDescription(properties);\r\n        //we keep a mapping from id to desc to ease access in other functions\r\n        probes.put(desc.getProbeId(), desc);\r\n        // send probe registered data object to blackboard\r\n        ProbeRegistered pr = new ProbeRegistered(desc, newBM, newTarget);\r\n        bb.process(pr);\r\n        return desc.getProbeId();\r\n    }\r\n\r\n    //this is the thread that runs checking when a keep-alive message is received and if the delay for a probe has\r\n    //surpassed the given threshold. if one gets lots, the set of available BM is updated accordingly.\r\n    public void run() {\r\n        while (shouldRun) {\r\n            try {\r\n                Thread.sleep(delayIncrement);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"sleep interrupted\", e);\r\n            }\r\n            synchronized (this) {\r\n                for (Iterator<Map.Entry<Long, ProbeDescription>> i = probes.entrySet().iterator(); i.hasNext(); ) {\r\n                    Map.Entry<Long, ProbeDescription> entry = i.next();\r\n                    ProbeDescription probe = entry.getValue();\r\n                    probe.increaseDelay(delayIncrement);\r\n                    //          log.debug(\"Increasing delay for \"+probe+\" by \"+delayIncrement);\r\n                    if (probe.getDelay() >= maxDelay) {\r\n                        //TODO: also check all BM if we need to remove one, etc.\r\n                        log.info(\"Lease terminated for:\" + probe);\r\n                        i.remove();\r\n                        //check if there are any BM for the target (device)\r\n                        boolean found = false;\r\n                        boolean targetDisabled = false;\r\n                        TargetDescription target = probe.getBm().getTarget();\r\n                        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n                            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n                            if (target == targetDesc) {\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            //there are no BM for the target so it can be removed\r\n                            log.debug(\"removing Target:\" + target);\r\n                            String key = target.getTargetType() + target.getTargetName();\r\n                            targets.remove(key);\r\n                            targetDisabled = true;\r\n                        }\r\n                        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n                        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n                        boolean bmDisabled = false;\r\n                        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n                            String measureURI = probe.getMeasureURI();\r\n                            BMDescription bmDesc = availableBM.remove(measureURI);\r\n                            log.debug(\"removind BM:\" + bmDesc);\r\n                            bmIds.remove(bmDesc.getBmId());\r\n                            bmDisabled = true;\r\n                        }\r\n                        // send probe disabled data object to blackboard\r\n                        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n                        bb.process(pd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setProbeDisabled(ProbeDescription probe) {\r\n        log.info(\"Disabling Probe:\" + probe);\r\n        probes.remove(probe.getProbeId());\r\n        //check if there are any BM for the target (device)\r\n        boolean found = false;\r\n        boolean targetDisabled = false;\r\n        TargetDescription target = probe.getBm().getTarget();\r\n        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n            if (target == targetDesc) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            //there are no BM for the target so it can be removed\r\n            log.debug(\"removing Target:\" + target);\r\n            String key = target.getTargetType() + target.getTargetName();\r\n            targets.remove(key);\r\n            targetDisabled = true;\r\n        }\r\n        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n        boolean bmDisabled = false;\r\n        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n            String measureURI = probe.getMeasureURI();\r\n            BMDescription bmDesc = availableBM.remove(measureURI);\r\n            log.debug(\"removind BM:\" + bmDesc);\r\n            bmIds.remove(bmDesc.getBmId());\r\n            bmDisabled = true;\r\n        }\r\n        // send probe disabled data object to blackboard\r\n        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n        bb.process(pd);\r\n    }\r\n\r\n    public ProbeDescription getProbeForSubscription(long subscriptionId) {\r\n        try {\r\n            long probeId = subscriptionRegistry.getSubscription(subscriptionId).getProbeId();\r\n            return getProbeFor(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get probe for subscription\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        String msg = \"New measurement subscription URI:\" + bm.getMeasureURI() + \" F:\" + frequency + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, frequency, probeId);\r\n    }\r\n\r\n    public long getSacIdForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getSacIdForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public long getFrequencyForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getFrequencyForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public void removeSubscription(long sacId, long subscriptionId) {\r\n        String msg = \"Removed measurement subscription id:\" + subscriptionId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.DELETE_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        subscriptionRegistry.removeSubscription(subscriptionId);\r\n    }\r\n\r\n    public long getIdForSubscription(long sacId, long bmId) {\r\n        return subscriptionRegistry.getIdForSubscription(sacId, bmId);\r\n    }\r\n\r\n    public long addMeasurementRequest(long sacId, BMDescription bm, long probeId) {\r\n        String msg = \"New measurement request URI:\" + bm.getMeasureURI() + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_MEASUREMENT_REQUEST, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, 0, probeId);\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        log.debug(\"checkSubscriptions (probeId:\" + probeId + \") - subscriptions:\" + subscriptionIds);\r\n        //check if some other probe is better for the bm\r\n        //should be done only once after probe registration?\r\n        //get the best available probe for bm\r\n        long bmId = probes.get(probeId).getBm().getBmId();\r\n        ProbeDescription probe = getProbeForBM(bmId);\r\n        List<MeasurementSubscription> subscriptions = subscriptionRegistry.getSubscriptionsForBM(bmId);\r\n        log.debug(\"Probe BM subscriptions:\" + subscriptions);\r\n        for (MeasurementSubscription subscription : subscriptions) {\r\n            if (subscription.getProbeId() != probe.getProbeId()) {\r\n                log.debug(\"Probe with higher precision found\");\r\n                subscriptionRegistry.setProbeForSubscription(subscription.getSubscriptionId(), probe.getProbeId());\r\n            }\r\n        }\r\n        subscriptions = subscriptionRegistry.getSubscriptionsForProbe(probeId);\r\n        log.debug(\"Subscriptions for probe:\" + subscriptions);\r\n        for (MeasurementSubscription ms : subscriptions) {\r\n            //log.debug(\"Subscription on server (ID:\"+ms.getSubscriptionId()+\")\");\r\n            //if there is a new subscription\r\n            if (!subscriptionIds.contains(ms.getSubscriptionId())) {\r\n                log.info(\"New subscription found (bmId:\" + ms.getBmId() + \") while checking existing ones\");\r\n                //send subscription request to probe\r\n                if (server != null) {\r\n                    server.subscribeToBM(ms.getBmId(), ms.getFrequency(), ms.getSubscriptionId());\r\n                } else {\r\n                    log.error(\"Could not request bm, server null\");\r\n                }\r\n            }\r\n        }\r\n        //if probes current subscription is not found on the server it should be removed from the probe\r\n        for (Long subscriptionId : subscriptionIds) {\r\n            //log.debug(\"Probes current subscription (ID:\"+subscriptionId+\")\");\r\n            boolean found = false;\r\n            for (MeasurementSubscription ms : subscriptions) {\r\n                if (ms.getSubscriptionId() == subscriptionId) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                log.debug(\"Probes (ID:\" + probeId + \") current subscription (ID:\" + subscriptionId + \") not found on server, sending unsubscription request to probe\");\r\n                server.unSubscribeToBM(getProbeFor(probeId), subscriptionId);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/RegistryPluginImpl_5Test.java",
		"test_prompt": "// RegistryPluginImpl_5Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistryPluginImpl}.\n* It contains ten unit test cases for the {@link RegistryPluginImpl#registerProbe(Map)} method.\n*/\nclass RegistryPluginImpl_5Test {"
	},
	{
		"original_code": "// RegistryPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RegistryPluginImpl extends BasePlugin implements RegistryPlugin, PersistenceUser, ServerUser, Runnable {\r\n\r\n    private final static Logger log = new Logger(RegistryPluginImpl.class);\r\n\r\n    //key = measureURI\r\n    private final Map<String, BMDescription> availableBM = new HashMap<String, BMDescription>();\r\n\r\n    //key = long bmid provided by sac\r\n    private final Map<Long, BMDescription> bmIds = new HashMap<Long, BMDescription>();\r\n\r\n    //key = targetType+targetName\r\n    private final Map<String, TargetDescription> targets = new HashMap<String, TargetDescription>();\r\n\r\n    //key = probeId, value = ProbeDescription\r\n    private final Map<Long, ProbeDescription> probes = new HashMap<Long, ProbeDescription>();\r\n\r\n    //all DM definitions created\r\n    private final Collection<DMDefinition> dms = new HashSet<DMDefinition>();\r\n\r\n    private int nextDmId = 1;\r\n\r\n    //maximum delay for receiving keep-alive messages before a probe-agent is reported as lost\r\n    private int maxDelay = DEFAULT_DELAY;\r\n\r\n    //how much time to wait between checking the keep-alive status of probe-agents\r\n    private int delayIncrement = DEFAULT_INCREMENT;\r\n\r\n    //default keep-alive threshold if nothing is configured\r\n    //10 seconds\r\n    private static final int DEFAULT_DELAY = 10 * 1000;\r\n\r\n    //default keep-alive wait time if nothing is configured\r\n    //1 second\r\n    private static final int DEFAULT_INCREMENT = 1000;\r\n\r\n    //should the registry keep running its threads or shut down?\r\n    private boolean shouldRun = true;\r\n\r\n    //access to the persistent state\r\n    private PersistencePlugin persistence = null;\r\n\r\n    private ServerPlugin server = null;\r\n\r\n    private SubscriptionRegistry subscriptionRegistry;\r\n\r\n    public RegistryPluginImpl(BundleContext bc, int maxDelay, int delayIncrement) {\r\n        super(bc, log);\r\n        if (maxDelay > 0) {\r\n            //assume that if one is set, both are set\r\n            this.maxDelay = maxDelay;\r\n            this.delayIncrement = delayIncrement;\r\n        } else {\r\n            try {\r\n                Properties props = readConfiguration();\r\n                this.maxDelay = Integer.parseInt(props.getProperty(Const.MAX_KEEPALIVE_DELAY));\r\n            } catch (IOException e) {\r\n                log.error(\"Error in reading configuration file. Using defaults.\", e);\r\n            }\r\n        }\r\n        //start a thread to monitor keep-alive messages\r\n        Thread t = new Thread(this);\r\n        t.setDaemon(true);\r\n        t.start();\r\n        //register a listener to capture the persistenceplugin when available\r\n        PersistenceServiceListener pl = new PersistenceServiceListener(bc, log, this);\r\n        pl.init();\r\n        //register a listener to capture the server-agent when available\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        subscriptionRegistry = new SubscriptionRegistry(bc);\r\n    }\r\n\r\n    public void stop() {\r\n        shouldRun = false;\r\n    }\r\n\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    //get the BMDescription for the given measureURI (measure identifier)\r\n    public BMDescription descriptionFor(String measureURI) {\r\n        return availableBM.get(measureURI);\r\n    }\r\n\r\n    //provides a list of all registered probes\r\n    public List<ProbeDescription> getProbes() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<ProbeDescription> result = new ArrayList<ProbeDescription>(probes.size());\r\n        result.addAll(probes.values());\r\n        return result;\r\n    }\r\n\r\n    //get current list of registered probes\r\n    public synchronized List<BMDescription> getAvailableBM() {\r\n        Collection<BMDescription> values = availableBM.values();\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<BMDescription> result = new ArrayList<BMDescription>(values.size());\r\n        result.addAll(values);\r\n        return result;\r\n    }\r\n\r\n    //list of all currently defined DM\r\n    public synchronized List<DMDefinition> getDerivedMeasures() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<DMDefinition> result = new ArrayList<DMDefinition>(dms.size());\r\n        result.addAll(dms);\r\n        return result;\r\n    }\r\n\r\n    //list of all active targets (with probes registered for them)\r\n    public Collection<TargetDescription> getTargets() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<TargetDescription> targets = new ArrayList<TargetDescription>();\r\n        targets.addAll(this.targets.values());\r\n        return targets;\r\n    }\r\n\r\n    //create a derived measure. currently not a core feature, not persisted, etc.\r\n    public void createDM(String name, String script) {\r\n        DMDefinition newDm = new DMDefinition(nextDmId++, name, script);\r\n        dms.add(newDm);\r\n        bb.process(newDm);\r\n        log.debug(\"Registered DM:\" + name);\r\n    }\r\n\r\n    //gives probe description for given probeid\r\n    public ProbeDescription getProbeFor(long probeId) {\r\n        return probes.get(probeId);\r\n    }\r\n\r\n    //give the best available probe for given BM (with highest precision)\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        BMDescription bm = bmIds.get(bmId);\r\n        String measureURI = bm.getMeasureURI();\r\n        ProbeDescription result = null;\r\n        for (ProbeDescription probe : probes.values()) {\r\n            if (!probe.getMeasureURI().equals(measureURI)) {\r\n                continue;\r\n            }\r\n            if (result != null) {\r\n                if (result.getPrecision() < probe.getPrecision()) {\r\n                    result = probe;\r\n                }\r\n            } else {\r\n                result = probe;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //find the target id for the given measureURI\r\n    public long targetIdFor(String measureURI) {\r\n        //parse type from uri\r\n        String targetType = parseTargetType(measureURI);\r\n        //parse name from uri\r\n        String targetName = parseTargetName(measureURI);\r\n        //get the name from the target map\r\n        TargetDescription target = targets.get(targetType + targetName);\r\n        if (target == null) {\r\n            throw new IllegalArgumentException(\"No target found for measureURI:\" + measureURI);\r\n        }\r\n        return target.getTargetId();\r\n    }\r\n\r\n    //parse target type from a measureURI\r\n    public String parseTargetType(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        return measureURI.substring(bounds[0], bounds[1]);\r\n    }\r\n\r\n    //get start and end index of target type inside given measureURI\r\n    private int[] getTargetTypeBounds(String measureURI) {\r\n        int si = measureURI.indexOf(\"//\");\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        si += 2;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return new int[] { si, ei };\r\n    }\r\n\r\n    //parse target name from given measureURI\r\n    public String parseTargetName(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        //end of type + \"/\"\r\n        int si = bounds[1] + 1;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return measureURI.substring(si, ei);\r\n    }\r\n\r\n    //when a probe sends a keep-alive message, this is invoked\r\n    public boolean processKeepAlive(long probeId) {\r\n        ProbeDescription probe = probes.get(probeId);\r\n        if (probe != null) {\r\n            probe.resetDelay();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a registration is received from a probe-agent.\r\n     *\r\n     * @param properties A set of key-value pairs describing the probe. For key and their description see.. what? :)\r\n     * @return The probe identifier for the registered probe.\r\n     */\r\n    public synchronized long registerProbe(Map<String, String> properties) {\r\n        log.debug(\"registering probe\");\r\n        BMDescription bm = null;\r\n        boolean newTarget = false;\r\n        boolean newBM = false;\r\n        try {\r\n            log.debug(\"creating target description\");\r\n            TargetDescription target = persistence.createTargetDescription(properties);\r\n            if (!targets.containsValue(target)) {\r\n                newTarget = true;\r\n            }\r\n            targets.put(target.getTargetType() + target.getTargetName(), target);\r\n            log.debug(\"creating bm description\");\r\n            bm = persistence.createBMDescription(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to create target/bm for probe description.\", e);\r\n            return Const.ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE;\r\n        }\r\n        if (!bmIds.containsKey(bm.getBmId())) {\r\n            newBM = true;\r\n        }\r\n        availableBM.put(bm.getMeasureURI(), bm);\r\n        bmIds.put(bm.getBmId(), bm);\r\n        //we use the database to manage the probe information\r\n        log.debug(\"creating probe description\");\r\n        ProbeDescription desc = persistence.createProbeDescription(properties);\r\n        //we keep a mapping from id to desc to ease access in other functions\r\n        probes.put(desc.getProbeId(), desc);\r\n        // send probe registered data object to blackboard\r\n        ProbeRegistered pr = new ProbeRegistered(desc, newBM, newTarget);\r\n        bb.process(pr);\r\n        return desc.getProbeId();\r\n    }\r\n\r\n    //this is the thread that runs checking when a keep-alive message is received and if the delay for a probe has\r\n    //surpassed the given threshold. if one gets lots, the set of available BM is updated accordingly.\r\n    public void run() {\r\n        while (shouldRun) {\r\n            try {\r\n                Thread.sleep(delayIncrement);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"sleep interrupted\", e);\r\n            }\r\n            synchronized (this) {\r\n                for (Iterator<Map.Entry<Long, ProbeDescription>> i = probes.entrySet().iterator(); i.hasNext(); ) {\r\n                    Map.Entry<Long, ProbeDescription> entry = i.next();\r\n                    ProbeDescription probe = entry.getValue();\r\n                    probe.increaseDelay(delayIncrement);\r\n                    //          log.debug(\"Increasing delay for \"+probe+\" by \"+delayIncrement);\r\n                    if (probe.getDelay() >= maxDelay) {\r\n                        //TODO: also check all BM if we need to remove one, etc.\r\n                        log.info(\"Lease terminated for:\" + probe);\r\n                        i.remove();\r\n                        //check if there are any BM for the target (device)\r\n                        boolean found = false;\r\n                        boolean targetDisabled = false;\r\n                        TargetDescription target = probe.getBm().getTarget();\r\n                        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n                            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n                            if (target == targetDesc) {\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            //there are no BM for the target so it can be removed\r\n                            log.debug(\"removing Target:\" + target);\r\n                            String key = target.getTargetType() + target.getTargetName();\r\n                            targets.remove(key);\r\n                            targetDisabled = true;\r\n                        }\r\n                        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n                        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n                        boolean bmDisabled = false;\r\n                        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n                            String measureURI = probe.getMeasureURI();\r\n                            BMDescription bmDesc = availableBM.remove(measureURI);\r\n                            log.debug(\"removind BM:\" + bmDesc);\r\n                            bmIds.remove(bmDesc.getBmId());\r\n                            bmDisabled = true;\r\n                        }\r\n                        // send probe disabled data object to blackboard\r\n                        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n                        bb.process(pd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setProbeDisabled(ProbeDescription probe) {\r\n        log.info(\"Disabling Probe:\" + probe);\r\n        probes.remove(probe.getProbeId());\r\n        //check if there are any BM for the target (device)\r\n        boolean found = false;\r\n        boolean targetDisabled = false;\r\n        TargetDescription target = probe.getBm().getTarget();\r\n        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n            if (target == targetDesc) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            //there are no BM for the target so it can be removed\r\n            log.debug(\"removing Target:\" + target);\r\n            String key = target.getTargetType() + target.getTargetName();\r\n            targets.remove(key);\r\n            targetDisabled = true;\r\n        }\r\n        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n        boolean bmDisabled = false;\r\n        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n            String measureURI = probe.getMeasureURI();\r\n            BMDescription bmDesc = availableBM.remove(measureURI);\r\n            log.debug(\"removind BM:\" + bmDesc);\r\n            bmIds.remove(bmDesc.getBmId());\r\n            bmDisabled = true;\r\n        }\r\n        // send probe disabled data object to blackboard\r\n        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n        bb.process(pd);\r\n    }\r\n\r\n    public ProbeDescription getProbeForSubscription(long subscriptionId) {\r\n        try {\r\n            long probeId = subscriptionRegistry.getSubscription(subscriptionId).getProbeId();\r\n            return getProbeFor(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get probe for subscription\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        String msg = \"New measurement subscription URI:\" + bm.getMeasureURI() + \" F:\" + frequency + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, frequency, probeId);\r\n    }\r\n\r\n    public long getSacIdForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getSacIdForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public long getFrequencyForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getFrequencyForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public void removeSubscription(long sacId, long subscriptionId) {\r\n        String msg = \"Removed measurement subscription id:\" + subscriptionId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.DELETE_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        subscriptionRegistry.removeSubscription(subscriptionId);\r\n    }\r\n\r\n    public long getIdForSubscription(long sacId, long bmId) {\r\n        return subscriptionRegistry.getIdForSubscription(sacId, bmId);\r\n    }\r\n\r\n    public long addMeasurementRequest(long sacId, BMDescription bm, long probeId) {\r\n        String msg = \"New measurement request URI:\" + bm.getMeasureURI() + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_MEASUREMENT_REQUEST, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, 0, probeId);\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        log.debug(\"checkSubscriptions (probeId:\" + probeId + \") - subscriptions:\" + subscriptionIds);\r\n        //check if some other probe is better for the bm\r\n        //should be done only once after probe registration?\r\n        //get the best available probe for bm\r\n        long bmId = probes.get(probeId).getBm().getBmId();\r\n        ProbeDescription probe = getProbeForBM(bmId);\r\n        List<MeasurementSubscription> subscriptions = subscriptionRegistry.getSubscriptionsForBM(bmId);\r\n        log.debug(\"Probe BM subscriptions:\" + subscriptions);\r\n        for (MeasurementSubscription subscription : subscriptions) {\r\n            if (subscription.getProbeId() != probe.getProbeId()) {\r\n                log.debug(\"Probe with higher precision found\");\r\n                subscriptionRegistry.setProbeForSubscription(subscription.getSubscriptionId(), probe.getProbeId());\r\n            }\r\n        }\r\n        subscriptions = subscriptionRegistry.getSubscriptionsForProbe(probeId);\r\n        log.debug(\"Subscriptions for probe:\" + subscriptions);\r\n        for (MeasurementSubscription ms : subscriptions) {\r\n            //log.debug(\"Subscription on server (ID:\"+ms.getSubscriptionId()+\")\");\r\n            //if there is a new subscription\r\n            if (!subscriptionIds.contains(ms.getSubscriptionId())) {\r\n                log.info(\"New subscription found (bmId:\" + ms.getBmId() + \") while checking existing ones\");\r\n                //send subscription request to probe\r\n                if (server != null) {\r\n                    server.subscribeToBM(ms.getBmId(), ms.getFrequency(), ms.getSubscriptionId());\r\n                } else {\r\n                    log.error(\"Could not request bm, server null\");\r\n                }\r\n            }\r\n        }\r\n        //if probes current subscription is not found on the server it should be removed from the probe\r\n        for (Long subscriptionId : subscriptionIds) {\r\n            //log.debug(\"Probes current subscription (ID:\"+subscriptionId+\")\");\r\n            boolean found = false;\r\n            for (MeasurementSubscription ms : subscriptions) {\r\n                if (ms.getSubscriptionId() == subscriptionId) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                log.debug(\"Probes (ID:\" + probeId + \") current subscription (ID:\" + subscriptionId + \") not found on server, sending unsubscription request to probe\");\r\n                server.unSubscribeToBM(getProbeFor(probeId), subscriptionId);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/RegistryPluginImpl_6Test.java",
		"test_prompt": "// RegistryPluginImpl_6Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistryPluginImpl}.\n* It contains ten unit test cases for the {@link RegistryPluginImpl#addSubscription(long, BMDescription, long, long)} method.\n*/\nclass RegistryPluginImpl_6Test {"
	},
	{
		"original_code": "// RegistryPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RegistryPluginImpl extends BasePlugin implements RegistryPlugin, PersistenceUser, ServerUser, Runnable {\r\n\r\n    private final static Logger log = new Logger(RegistryPluginImpl.class);\r\n\r\n    //key = measureURI\r\n    private final Map<String, BMDescription> availableBM = new HashMap<String, BMDescription>();\r\n\r\n    //key = long bmid provided by sac\r\n    private final Map<Long, BMDescription> bmIds = new HashMap<Long, BMDescription>();\r\n\r\n    //key = targetType+targetName\r\n    private final Map<String, TargetDescription> targets = new HashMap<String, TargetDescription>();\r\n\r\n    //key = probeId, value = ProbeDescription\r\n    private final Map<Long, ProbeDescription> probes = new HashMap<Long, ProbeDescription>();\r\n\r\n    //all DM definitions created\r\n    private final Collection<DMDefinition> dms = new HashSet<DMDefinition>();\r\n\r\n    private int nextDmId = 1;\r\n\r\n    //maximum delay for receiving keep-alive messages before a probe-agent is reported as lost\r\n    private int maxDelay = DEFAULT_DELAY;\r\n\r\n    //how much time to wait between checking the keep-alive status of probe-agents\r\n    private int delayIncrement = DEFAULT_INCREMENT;\r\n\r\n    //default keep-alive threshold if nothing is configured\r\n    //10 seconds\r\n    private static final int DEFAULT_DELAY = 10 * 1000;\r\n\r\n    //default keep-alive wait time if nothing is configured\r\n    //1 second\r\n    private static final int DEFAULT_INCREMENT = 1000;\r\n\r\n    //should the registry keep running its threads or shut down?\r\n    private boolean shouldRun = true;\r\n\r\n    //access to the persistent state\r\n    private PersistencePlugin persistence = null;\r\n\r\n    private ServerPlugin server = null;\r\n\r\n    private SubscriptionRegistry subscriptionRegistry;\r\n\r\n    public RegistryPluginImpl(BundleContext bc, int maxDelay, int delayIncrement) {\r\n        super(bc, log);\r\n        if (maxDelay > 0) {\r\n            //assume that if one is set, both are set\r\n            this.maxDelay = maxDelay;\r\n            this.delayIncrement = delayIncrement;\r\n        } else {\r\n            try {\r\n                Properties props = readConfiguration();\r\n                this.maxDelay = Integer.parseInt(props.getProperty(Const.MAX_KEEPALIVE_DELAY));\r\n            } catch (IOException e) {\r\n                log.error(\"Error in reading configuration file. Using defaults.\", e);\r\n            }\r\n        }\r\n        //start a thread to monitor keep-alive messages\r\n        Thread t = new Thread(this);\r\n        t.setDaemon(true);\r\n        t.start();\r\n        //register a listener to capture the persistenceplugin when available\r\n        PersistenceServiceListener pl = new PersistenceServiceListener(bc, log, this);\r\n        pl.init();\r\n        //register a listener to capture the server-agent when available\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        subscriptionRegistry = new SubscriptionRegistry(bc);\r\n    }\r\n\r\n    public void stop() {\r\n        shouldRun = false;\r\n    }\r\n\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    //get the BMDescription for the given measureURI (measure identifier)\r\n    public BMDescription descriptionFor(String measureURI) {\r\n        return availableBM.get(measureURI);\r\n    }\r\n\r\n    //provides a list of all registered probes\r\n    public List<ProbeDescription> getProbes() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<ProbeDescription> result = new ArrayList<ProbeDescription>(probes.size());\r\n        result.addAll(probes.values());\r\n        return result;\r\n    }\r\n\r\n    //get current list of registered probes\r\n    public synchronized List<BMDescription> getAvailableBM() {\r\n        Collection<BMDescription> values = availableBM.values();\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<BMDescription> result = new ArrayList<BMDescription>(values.size());\r\n        result.addAll(values);\r\n        return result;\r\n    }\r\n\r\n    //list of all currently defined DM\r\n    public synchronized List<DMDefinition> getDerivedMeasures() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<DMDefinition> result = new ArrayList<DMDefinition>(dms.size());\r\n        result.addAll(dms);\r\n        return result;\r\n    }\r\n\r\n    //list of all active targets (with probes registered for them)\r\n    public Collection<TargetDescription> getTargets() {\r\n        //create copy of current state to avoid breaking on concurrent access etc.\r\n        List<TargetDescription> targets = new ArrayList<TargetDescription>();\r\n        targets.addAll(this.targets.values());\r\n        return targets;\r\n    }\r\n\r\n    //create a derived measure. currently not a core feature, not persisted, etc.\r\n    public void createDM(String name, String script) {\r\n        DMDefinition newDm = new DMDefinition(nextDmId++, name, script);\r\n        dms.add(newDm);\r\n        bb.process(newDm);\r\n        log.debug(\"Registered DM:\" + name);\r\n    }\r\n\r\n    //gives probe description for given probeid\r\n    public ProbeDescription getProbeFor(long probeId) {\r\n        return probes.get(probeId);\r\n    }\r\n\r\n    //give the best available probe for given BM (with highest precision)\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        BMDescription bm = bmIds.get(bmId);\r\n        String measureURI = bm.getMeasureURI();\r\n        ProbeDescription result = null;\r\n        for (ProbeDescription probe : probes.values()) {\r\n            if (!probe.getMeasureURI().equals(measureURI)) {\r\n                continue;\r\n            }\r\n            if (result != null) {\r\n                if (result.getPrecision() < probe.getPrecision()) {\r\n                    result = probe;\r\n                }\r\n            } else {\r\n                result = probe;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    //find the target id for the given measureURI\r\n    public long targetIdFor(String measureURI) {\r\n        //parse type from uri\r\n        String targetType = parseTargetType(measureURI);\r\n        //parse name from uri\r\n        String targetName = parseTargetName(measureURI);\r\n        //get the name from the target map\r\n        TargetDescription target = targets.get(targetType + targetName);\r\n        if (target == null) {\r\n            throw new IllegalArgumentException(\"No target found for measureURI:\" + measureURI);\r\n        }\r\n        return target.getTargetId();\r\n    }\r\n\r\n    //parse target type from a measureURI\r\n    public String parseTargetType(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        return measureURI.substring(bounds[0], bounds[1]);\r\n    }\r\n\r\n    //get start and end index of target type inside given measureURI\r\n    private int[] getTargetTypeBounds(String measureURI) {\r\n        int si = measureURI.indexOf(\"//\");\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        si += 2;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return new int[] { si, ei };\r\n    }\r\n\r\n    //parse target name from given measureURI\r\n    public String parseTargetName(String measureURI) {\r\n        int[] bounds = getTargetTypeBounds(measureURI);\r\n        //end of type + \"/\"\r\n        int si = bounds[1] + 1;\r\n        int ei = measureURI.indexOf(\"/\", si);\r\n        if (si <= 0) {\r\n            throw new IllegalArgumentException(\"Invalid measure URI:\" + measureURI);\r\n        }\r\n        return measureURI.substring(si, ei);\r\n    }\r\n\r\n    //when a probe sends a keep-alive message, this is invoked\r\n    public boolean processKeepAlive(long probeId) {\r\n        ProbeDescription probe = probes.get(probeId);\r\n        if (probe != null) {\r\n            probe.resetDelay();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Called when a registration is received from a probe-agent.\r\n     *\r\n     * @param properties A set of key-value pairs describing the probe. For key and their description see.. what? :)\r\n     * @return The probe identifier for the registered probe.\r\n     */\r\n    public synchronized long registerProbe(Map<String, String> properties) {\r\n        log.debug(\"registering probe\");\r\n        BMDescription bm = null;\r\n        boolean newTarget = false;\r\n        boolean newBM = false;\r\n        try {\r\n            log.debug(\"creating target description\");\r\n            TargetDescription target = persistence.createTargetDescription(properties);\r\n            if (!targets.containsValue(target)) {\r\n                newTarget = true;\r\n            }\r\n            targets.put(target.getTargetType() + target.getTargetName(), target);\r\n            log.debug(\"creating bm description\");\r\n            bm = persistence.createBMDescription(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to create target/bm for probe description.\", e);\r\n            return Const.ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE;\r\n        }\r\n        if (!bmIds.containsKey(bm.getBmId())) {\r\n            newBM = true;\r\n        }\r\n        availableBM.put(bm.getMeasureURI(), bm);\r\n        bmIds.put(bm.getBmId(), bm);\r\n        //we use the database to manage the probe information\r\n        log.debug(\"creating probe description\");\r\n        ProbeDescription desc = persistence.createProbeDescription(properties);\r\n        //we keep a mapping from id to desc to ease access in other functions\r\n        probes.put(desc.getProbeId(), desc);\r\n        // send probe registered data object to blackboard\r\n        ProbeRegistered pr = new ProbeRegistered(desc, newBM, newTarget);\r\n        bb.process(pr);\r\n        return desc.getProbeId();\r\n    }\r\n\r\n    //this is the thread that runs checking when a keep-alive message is received and if the delay for a probe has\r\n    //surpassed the given threshold. if one gets lots, the set of available BM is updated accordingly.\r\n    public void run() {\r\n        while (shouldRun) {\r\n            try {\r\n                Thread.sleep(delayIncrement);\r\n            } catch (InterruptedException e) {\r\n                log.error(\"sleep interrupted\", e);\r\n            }\r\n            synchronized (this) {\r\n                for (Iterator<Map.Entry<Long, ProbeDescription>> i = probes.entrySet().iterator(); i.hasNext(); ) {\r\n                    Map.Entry<Long, ProbeDescription> entry = i.next();\r\n                    ProbeDescription probe = entry.getValue();\r\n                    probe.increaseDelay(delayIncrement);\r\n                    //          log.debug(\"Increasing delay for \"+probe+\" by \"+delayIncrement);\r\n                    if (probe.getDelay() >= maxDelay) {\r\n                        //TODO: also check all BM if we need to remove one, etc.\r\n                        log.info(\"Lease terminated for:\" + probe);\r\n                        i.remove();\r\n                        //check if there are any BM for the target (device)\r\n                        boolean found = false;\r\n                        boolean targetDisabled = false;\r\n                        TargetDescription target = probe.getBm().getTarget();\r\n                        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n                            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n                            if (target == targetDesc) {\r\n                                found = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!found) {\r\n                            //there are no BM for the target so it can be removed\r\n                            log.debug(\"removing Target:\" + target);\r\n                            String key = target.getTargetType() + target.getTargetName();\r\n                            targets.remove(key);\r\n                            targetDisabled = true;\r\n                        }\r\n                        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n                        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n                        boolean bmDisabled = false;\r\n                        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n                            String measureURI = probe.getMeasureURI();\r\n                            BMDescription bmDesc = availableBM.remove(measureURI);\r\n                            log.debug(\"removind BM:\" + bmDesc);\r\n                            bmIds.remove(bmDesc.getBmId());\r\n                            bmDisabled = true;\r\n                        }\r\n                        // send probe disabled data object to blackboard\r\n                        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n                        bb.process(pd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setProbeDisabled(ProbeDescription probe) {\r\n        log.info(\"Disabling Probe:\" + probe);\r\n        probes.remove(probe.getProbeId());\r\n        //check if there are any BM for the target (device)\r\n        boolean found = false;\r\n        boolean targetDisabled = false;\r\n        TargetDescription target = probe.getBm().getTarget();\r\n        for (Map.Entry<Long, BMDescription> bmEntry : bmIds.entrySet()) {\r\n            TargetDescription targetDesc = bmEntry.getValue().getTarget();\r\n            if (target == targetDesc) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            //there are no BM for the target so it can be removed\r\n            log.debug(\"removing Target:\" + target);\r\n            String key = target.getTargetType() + target.getTargetName();\r\n            targets.remove(key);\r\n            targetDisabled = true;\r\n        }\r\n        // here can be several probes for the same BM so we can only remove the BM if no other probe is present\r\n        //note that above we removed this probe from the list of probes so it is no longer found by getForBM()\r\n        boolean bmDisabled = false;\r\n        if (getProbeForBM(probe.getBm().getBmId()) == null) {\r\n            String measureURI = probe.getMeasureURI();\r\n            BMDescription bmDesc = availableBM.remove(measureURI);\r\n            log.debug(\"removind BM:\" + bmDesc);\r\n            bmIds.remove(bmDesc.getBmId());\r\n            bmDisabled = true;\r\n        }\r\n        // send probe disabled data object to blackboard\r\n        ProbeDisabled pd = new ProbeDisabled(probe, bmDisabled, targetDisabled);\r\n        bb.process(pd);\r\n    }\r\n\r\n    public ProbeDescription getProbeForSubscription(long subscriptionId) {\r\n        try {\r\n            long probeId = subscriptionRegistry.getSubscription(subscriptionId).getProbeId();\r\n            return getProbeFor(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to get probe for subscription\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        String msg = \"New measurement subscription URI:\" + bm.getMeasureURI() + \" F:\" + frequency + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, frequency, probeId);\r\n    }\r\n\r\n    public long getSacIdForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getSacIdForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public long getFrequencyForSubscription(long subscriptionId) {\r\n        return subscriptionRegistry.getFrequencyForSubscriptionId(subscriptionId);\r\n    }\r\n\r\n    public void removeSubscription(long sacId, long subscriptionId) {\r\n        String msg = \"Removed measurement subscription id:\" + subscriptionId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.DELETE_SUBSCRIPTION, \"SAC \" + sacId, msg));\r\n        subscriptionRegistry.removeSubscription(subscriptionId);\r\n    }\r\n\r\n    public long getIdForSubscription(long sacId, long bmId) {\r\n        return subscriptionRegistry.getIdForSubscription(sacId, bmId);\r\n    }\r\n\r\n    public long addMeasurementRequest(long sacId, BMDescription bm, long probeId) {\r\n        String msg = \"New measurement request URI:\" + bm.getMeasureURI() + \" PID:\" + probeId;\r\n        bb.process(new ServerEvent(System.currentTimeMillis(), EventType.NEW_MEASUREMENT_REQUEST, \"SAC \" + sacId, msg));\r\n        return subscriptionRegistry.addSubscription(sacId, bm, 0, probeId);\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        log.debug(\"checkSubscriptions (probeId:\" + probeId + \") - subscriptions:\" + subscriptionIds);\r\n        //check if some other probe is better for the bm\r\n        //should be done only once after probe registration?\r\n        //get the best available probe for bm\r\n        long bmId = probes.get(probeId).getBm().getBmId();\r\n        ProbeDescription probe = getProbeForBM(bmId);\r\n        List<MeasurementSubscription> subscriptions = subscriptionRegistry.getSubscriptionsForBM(bmId);\r\n        log.debug(\"Probe BM subscriptions:\" + subscriptions);\r\n        for (MeasurementSubscription subscription : subscriptions) {\r\n            if (subscription.getProbeId() != probe.getProbeId()) {\r\n                log.debug(\"Probe with higher precision found\");\r\n                subscriptionRegistry.setProbeForSubscription(subscription.getSubscriptionId(), probe.getProbeId());\r\n            }\r\n        }\r\n        subscriptions = subscriptionRegistry.getSubscriptionsForProbe(probeId);\r\n        log.debug(\"Subscriptions for probe:\" + subscriptions);\r\n        for (MeasurementSubscription ms : subscriptions) {\r\n            //log.debug(\"Subscription on server (ID:\"+ms.getSubscriptionId()+\")\");\r\n            //if there is a new subscription\r\n            if (!subscriptionIds.contains(ms.getSubscriptionId())) {\r\n                log.info(\"New subscription found (bmId:\" + ms.getBmId() + \") while checking existing ones\");\r\n                //send subscription request to probe\r\n                if (server != null) {\r\n                    server.subscribeToBM(ms.getBmId(), ms.getFrequency(), ms.getSubscriptionId());\r\n                } else {\r\n                    log.error(\"Could not request bm, server null\");\r\n                }\r\n            }\r\n        }\r\n        //if probes current subscription is not found on the server it should be removed from the probe\r\n        for (Long subscriptionId : subscriptionIds) {\r\n            //log.debug(\"Probes current subscription (ID:\"+subscriptionId+\")\");\r\n            boolean found = false;\r\n            for (MeasurementSubscription ms : subscriptions) {\r\n                if (ms.getSubscriptionId() == subscriptionId) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                log.debug(\"Probes (ID:\" + probeId + \") current subscription (ID:\" + subscriptionId + \") not found on server, sending unsubscription request to probe\");\r\n                server.unSubscribeToBM(getProbeFor(probeId), subscriptionId);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/RegistryPluginImpl_7Test.java",
		"test_prompt": "// RegistryPluginImpl_7Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegistryPluginImpl}.\n* It contains ten unit test cases for the {@link RegistryPluginImpl#addMeasurementRequest(long, BMDescription, long)} method.\n*/\nclass RegistryPluginImpl_7Test {"
	},
	{
		"original_code": "// SubscriptionRegistry.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\r\n\r\n//import java.util.Iterator;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n//import java.util.Collection;\r\n//import java.util.Vector;\r\npublic class SubscriptionRegistry {\r\n\r\n    private final static Logger log = new Logger(SubscriptionRegistry.class);\r\n\r\n    private Map<Long, MeasurementSubscription> subscriptions = new HashMap<Long, MeasurementSubscription>();\r\n\r\n    private long nextId = 1;\r\n\r\n    public SubscriptionRegistry(BundleContext bc) {\r\n    }\r\n\r\n    public synchronized long addSubscription(long sacId, BMDescription bm, long frequency, long probeId) {\r\n        if (frequency > 0) {\r\n            for (MeasurementSubscription subscription : subscriptions.values()) {\r\n                if ((subscription.getSacId() == sacId) && (subscription.getBmId() == bm.getBmId())) {\r\n                    //if measurement subscription exists for sacId/bmId change new frequency for the subscription\r\n                    subscription.setFrequency(frequency);\r\n                    return subscription.getSubscriptionId();\r\n                }\r\n            }\r\n        }\r\n        //create and add new subscription\r\n        long subscriptionId = nextId++;\r\n        MeasurementSubscription subscription = new MeasurementSubscription(subscriptionId, bm, sacId, frequency, probeId);\r\n        subscriptions.put(subscriptionId, subscription);\r\n        return subscriptionId;\r\n    }\r\n\r\n    public synchronized long getSacIdForSubscriptionId(long subscriptionId) {\r\n        MeasurementSubscription subscription = subscriptions.get(subscriptionId);\r\n        if (subscription != null) {\r\n            return subscription.getSacId();\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    public synchronized long getFrequencyForSubscriptionId(long subscriptionId) {\r\n        MeasurementSubscription subscription = subscriptions.get(subscriptionId);\r\n        if (subscription != null) {\r\n            return subscription.getFrequency();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public synchronized void removeSubscription(long subscriptionId) {\r\n        log.debug(\"removing\");\r\n        subscriptions.remove(subscriptionId);\r\n        log.debug(\"removing done\");\r\n    }\r\n\r\n    public synchronized MeasurementSubscription getSubscription(long subscriptionId) {\r\n        return subscriptions.get(subscriptionId);\r\n    }\r\n\r\n    public synchronized long getIdForSubscription(long sacId, long bmId) {\r\n        long result = 0;\r\n        //search existing subscription for sacId/bmId\r\n        for (MeasurementSubscription ms : subscriptions.values()) {\r\n            if ((ms.getSacId() == sacId) && (ms.getBmId() == bmId)) {\r\n                //ignore one time requests\r\n                if (ms.getFrequency() > 0) {\r\n                    result = ms.getSubscriptionId();\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public synchronized List<MeasurementSubscription> getSubscriptionsForBM(long bmId) {\r\n        List<MeasurementSubscription> result = new ArrayList<MeasurementSubscription>();\r\n        for (MeasurementSubscription ms : subscriptions.values()) {\r\n            if (ms.getBmId() == bmId) {\r\n                result.add(ms);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public synchronized List<MeasurementSubscription> getSubscriptionsForProbe(long probeId) {\r\n        List<MeasurementSubscription> result = new ArrayList<MeasurementSubscription>();\r\n        for (MeasurementSubscription ms : subscriptions.values()) {\r\n            if (ms.getProbeId() == probeId) {\r\n                result.add(ms);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public synchronized void setProbeForSubscription(long subscriptionId, long probeId) {\r\n        subscriptions.get(subscriptionId).setProbeId(probeId);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/registry/SubscriptionRegistry.java",
		"test_prompt": "// SubscriptionRegistryTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.registry;\n\n//import java.util.Iterator;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.MeasurementSubscription;\nimport org.osgi.framework.BundleContext;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SubscriptionRegistry}.\n* It contains ten unit test cases for the {@link SubscriptionRegistry#addSubscription(long, BMDescription, long, long)} method.\n*/\nclass SubscriptionRegistryTest {"
	},
	{
		"original_code": "// ProbeDesc.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\r\n\r\npublic class ProbeDesc {\r\n\r\n    private final long probeId;\r\n\r\n    private final long bmId;\r\n\r\n    private final String name;\r\n\r\n    private final boolean disabled;\r\n\r\n    public ProbeDesc(long probeId, long bmId, String name, boolean disabled) {\r\n        super();\r\n        this.probeId = probeId;\r\n        this.bmId = bmId;\r\n        this.name = name;\r\n        this.disabled = disabled;\r\n    }\r\n\r\n    public long getProbeId() {\r\n        return probeId;\r\n    }\r\n\r\n    public long getBmId() {\r\n        return bmId;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probeparameterpage/ProbeDesc.java",
		"test_prompt": "// ProbeDescTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeDesc}.\n* It contains ten unit test cases for the {@link ProbeDesc#isDisabled()} method.\n*/\nclass ProbeDescTest {"
	},
	{
		"original_code": "// ParameterListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class ParameterListDataProvider extends SortableDataProvider<ProbeParameter> {\r\n\r\n    private final static Logger log = new Logger(ParameterListDataProvider.class);\r\n\r\n    private final List<ProbeParameter> params;\r\n\r\n    public ParameterListDataProvider(List<ProbeParameter> params) {\r\n        this.params = params;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<ProbeParameter> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(params, new ParameterComparator(key, true));\r\n        } else {\r\n            Collections.sort(params, new ParameterComparator(key, false));\r\n        }\r\n        return params.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return params.size();\r\n    }\r\n\r\n    public IModel<ProbeParameter> model(ProbeParameter param) {\r\n        return new DetachableParameterModel(param);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probeparameterpage/ParameterListDataProvider_0Test.java",
		"test_prompt": "// ParameterListDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterListDataProvider}.\n* It contains ten unit test cases for the {@link ParameterListDataProvider#iterator(int, int)} method.\n*/\nclass ParameterListDataProvider_0Test {"
	},
	{
		"original_code": "// ParameterListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class ParameterListDataProvider extends SortableDataProvider<ProbeParameter> {\r\n\r\n    private final static Logger log = new Logger(ParameterListDataProvider.class);\r\n\r\n    private final List<ProbeParameter> params;\r\n\r\n    public ParameterListDataProvider(List<ProbeParameter> params) {\r\n        this.params = params;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<ProbeParameter> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(params, new ParameterComparator(key, true));\r\n        } else {\r\n            Collections.sort(params, new ParameterComparator(key, false));\r\n        }\r\n        return params.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return params.size();\r\n    }\r\n\r\n    public IModel<ProbeParameter> model(ProbeParameter param) {\r\n        return new DetachableParameterModel(param);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probeparameterpage/ParameterListDataProvider_1Test.java",
		"test_prompt": "// ParameterListDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterListDataProvider}.\n* It contains ten unit test cases for the {@link ParameterListDataProvider#size()} method.\n*/\nclass ParameterListDataProvider_1Test {"
	},
	{
		"original_code": "// ParameterListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class ParameterListDataProvider extends SortableDataProvider<ProbeParameter> {\r\n\r\n    private final static Logger log = new Logger(ParameterListDataProvider.class);\r\n\r\n    private final List<ProbeParameter> params;\r\n\r\n    public ParameterListDataProvider(List<ProbeParameter> params) {\r\n        this.params = params;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<ProbeParameter> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(params, new ParameterComparator(key, true));\r\n        } else {\r\n            Collections.sort(params, new ParameterComparator(key, false));\r\n        }\r\n        return params.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return params.size();\r\n    }\r\n\r\n    public IModel<ProbeParameter> model(ProbeParameter param) {\r\n        return new DetachableParameterModel(param);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probeparameterpage/ParameterListDataProvider_2Test.java",
		"test_prompt": "// ParameterListDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterListDataProvider}.\n* It contains ten unit test cases for the {@link ParameterListDataProvider#model(ProbeParameter)} method.\n*/\nclass ParameterListDataProvider_2Test {"
	},
	{
		"original_code": "// ParameterComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\r\nimport java.util.Comparator;\r\n\r\npublic class ParameterComparator implements Comparator<ProbeParameter> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public ParameterComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(ProbeParameter a1, ProbeParameter a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"name\")) {\r\n            result = a1.getName().compareTo(a2.getName());\r\n        }\r\n        if (sortKey.equals(\"description\")) {\r\n            result = a1.getDescription().compareTo(a2.getDescription());\r\n        }\r\n        if (sortKey.equals(\"value\")) {\r\n            result = a1.getValue().compareTo(a2.getValue());\r\n        }\r\n        if (sortKey.equals(\"mandatory\")) {\r\n            result = new Boolean(a1.isMandatory()).compareTo(a2.isMandatory());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probeparameterpage/ParameterComparator.java",
		"test_prompt": "// ParameterComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage;\n\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterComparator}.\n* It contains ten unit test cases for the {@link ParameterComparator#compare(ProbeParameter, ProbeParameter)} method.\n*/\nclass ParameterComparatorTest {"
	},
	{
		"original_code": "// BMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.BMComparator;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMListDataProvider extends SortableDataProvider<BMListItem> {\r\n\r\n    private final static Logger log = new Logger(BMListDataProvider.class);\r\n\r\n    private final RegistryPlugin registry;\r\n\r\n    private final Map<String, String> latestValues;\r\n\r\n    public BMListDataProvider(RegistryPlugin registry, Map<String, String> latestValues) {\r\n        this.registry = registry;\r\n        this.latestValues = latestValues;\r\n        setSort(\"targetId\", true);\r\n    }\r\n\r\n    public Iterator<BMListItem> iterator(int i, int i1) {\r\n        List<BMDescription> bms = registry.getAvailableBM();\r\n        bms = bms.subList(i, i + i1);\r\n        List<BMListItem> list = new ArrayList<BMListItem>();\r\n        for (BMDescription bm : bms) {\r\n            String value = latestValues.get(bm.getMeasureURI());\r\n            BMListItem listItem = new BMListItem(bm, value);\r\n            list.add(listItem);\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(list, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(list, new BMComparator(key, false));\r\n        }\r\n        return list.iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return registry.getAvailableBM().size();\r\n    }\r\n\r\n    public IModel<BMListItem> model(BMListItem bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmlistpage/BMListDataProvider_0Test.java",
		"test_prompt": "// BMListDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.BMComparator;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMListDataProvider}.\n* It contains ten unit test cases for the {@link BMListDataProvider#iterator(int, int)} method.\n*/\nclass BMListDataProvider_0Test {"
	},
	{
		"original_code": "// BMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.BMComparator;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMListDataProvider extends SortableDataProvider<BMListItem> {\r\n\r\n    private final static Logger log = new Logger(BMListDataProvider.class);\r\n\r\n    private final RegistryPlugin registry;\r\n\r\n    private final Map<String, String> latestValues;\r\n\r\n    public BMListDataProvider(RegistryPlugin registry, Map<String, String> latestValues) {\r\n        this.registry = registry;\r\n        this.latestValues = latestValues;\r\n        setSort(\"targetId\", true);\r\n    }\r\n\r\n    public Iterator<BMListItem> iterator(int i, int i1) {\r\n        List<BMDescription> bms = registry.getAvailableBM();\r\n        bms = bms.subList(i, i + i1);\r\n        List<BMListItem> list = new ArrayList<BMListItem>();\r\n        for (BMDescription bm : bms) {\r\n            String value = latestValues.get(bm.getMeasureURI());\r\n            BMListItem listItem = new BMListItem(bm, value);\r\n            list.add(listItem);\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(list, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(list, new BMComparator(key, false));\r\n        }\r\n        return list.iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return registry.getAvailableBM().size();\r\n    }\r\n\r\n    public IModel<BMListItem> model(BMListItem bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmlistpage/BMListDataProvider_1Test.java",
		"test_prompt": "// BMListDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.BMComparator;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMListDataProvider}.\n* It contains ten unit test cases for the {@link BMListDataProvider#size()} method.\n*/\nclass BMListDataProvider_1Test {"
	},
	{
		"original_code": "// BMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.BMComparator;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMListDataProvider extends SortableDataProvider<BMListItem> {\r\n\r\n    private final static Logger log = new Logger(BMListDataProvider.class);\r\n\r\n    private final RegistryPlugin registry;\r\n\r\n    private final Map<String, String> latestValues;\r\n\r\n    public BMListDataProvider(RegistryPlugin registry, Map<String, String> latestValues) {\r\n        this.registry = registry;\r\n        this.latestValues = latestValues;\r\n        setSort(\"targetId\", true);\r\n    }\r\n\r\n    public Iterator<BMListItem> iterator(int i, int i1) {\r\n        List<BMDescription> bms = registry.getAvailableBM();\r\n        bms = bms.subList(i, i + i1);\r\n        List<BMListItem> list = new ArrayList<BMListItem>();\r\n        for (BMDescription bm : bms) {\r\n            String value = latestValues.get(bm.getMeasureURI());\r\n            BMListItem listItem = new BMListItem(bm, value);\r\n            list.add(listItem);\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(list, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(list, new BMComparator(key, false));\r\n        }\r\n        return list.iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return registry.getAvailableBM().size();\r\n    }\r\n\r\n    public IModel<BMListItem> model(BMListItem bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmlistpage/BMListDataProvider_2Test.java",
		"test_prompt": "// BMListDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.BMComparator;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMListDataProvider}.\n* It contains ten unit test cases for the {@link BMListDataProvider#model(BMListItem)} method.\n*/\nclass BMListDataProvider_2Test {"
	},
	{
		"original_code": "// DeviceListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class DeviceListDataProvider extends SortableDataProvider<DeviceDesc> {\r\n\r\n    private final static Logger log = new Logger(DeviceListDataProvider.class);\r\n\r\n    private final List<DeviceDesc> devices;\r\n\r\n    public DeviceListDataProvider(List<DeviceDesc> devices) {\r\n        this.devices = devices;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DeviceDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(devices, new DeviceComparator(key, true));\r\n        } else {\r\n            Collections.sort(devices, new DeviceComparator(key, false));\r\n        }\r\n        return devices.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return devices.size();\r\n    }\r\n\r\n    public IModel<DeviceDesc> model(DeviceDesc deviceDesc) {\r\n        return new DetachableDeviceModel(deviceDesc);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/DeviceListDataProvider_0Test.java",
		"test_prompt": "// DeviceListDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeviceListDataProvider}.\n* It contains ten unit test cases for the {@link DeviceListDataProvider#iterator(int, int)} method.\n*/\nclass DeviceListDataProvider_0Test {"
	},
	{
		"original_code": "// DeviceListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class DeviceListDataProvider extends SortableDataProvider<DeviceDesc> {\r\n\r\n    private final static Logger log = new Logger(DeviceListDataProvider.class);\r\n\r\n    private final List<DeviceDesc> devices;\r\n\r\n    public DeviceListDataProvider(List<DeviceDesc> devices) {\r\n        this.devices = devices;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DeviceDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(devices, new DeviceComparator(key, true));\r\n        } else {\r\n            Collections.sort(devices, new DeviceComparator(key, false));\r\n        }\r\n        return devices.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return devices.size();\r\n    }\r\n\r\n    public IModel<DeviceDesc> model(DeviceDesc deviceDesc) {\r\n        return new DetachableDeviceModel(deviceDesc);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/DeviceListDataProvider_1Test.java",
		"test_prompt": "// DeviceListDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeviceListDataProvider}.\n* It contains ten unit test cases for the {@link DeviceListDataProvider#size()} method.\n*/\nclass DeviceListDataProvider_1Test {"
	},
	{
		"original_code": "// DeviceListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class DeviceListDataProvider extends SortableDataProvider<DeviceDesc> {\r\n\r\n    private final static Logger log = new Logger(DeviceListDataProvider.class);\r\n\r\n    private final List<DeviceDesc> devices;\r\n\r\n    public DeviceListDataProvider(List<DeviceDesc> devices) {\r\n        this.devices = devices;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DeviceDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(devices, new DeviceComparator(key, true));\r\n        } else {\r\n            Collections.sort(devices, new DeviceComparator(key, false));\r\n        }\r\n        return devices.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return devices.size();\r\n    }\r\n\r\n    public IModel<DeviceDesc> model(DeviceDesc deviceDesc) {\r\n        return new DetachableDeviceModel(deviceDesc);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/DeviceListDataProvider_2Test.java",
		"test_prompt": "// DeviceListDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeviceListDataProvider}.\n* It contains ten unit test cases for the {@link DeviceListDataProvider#model(DeviceDesc)} method.\n*/\nclass DeviceListDataProvider_2Test {"
	},
	{
		"original_code": "// BMComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport java.util.Comparator;\r\n\r\npublic class BMComparator implements Comparator<BMDesc> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public BMComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(BMDesc a1, BMDesc a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"bmId\")) {\r\n            result = (int) (a1.getBmId() - a2.getBmId());\r\n        }\r\n        if (sortKey.equals(\"deviceId\")) {\r\n            result = (int) (a1.getDeviceId() - a2.getDeviceId());\r\n        }\r\n        if (sortKey.equals(\"clazz\")) {\r\n            result = a1.getClazz().compareTo(a2.getClazz());\r\n        }\r\n        if (sortKey.equals(\"name\")) {\r\n            result = a1.getName().compareTo(a2.getName());\r\n        }\r\n        if (sortKey.equals(\"description\")) {\r\n            result = a1.getDescription().compareTo(a2.getDescription());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/BMComparator.java",
		"test_prompt": "// BMComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMComparator}.\n* It contains ten unit test cases for the {@link BMComparator#compare(BMDesc, BMDesc)} method.\n*/\nclass BMComparatorTest {"
	},
	{
		"original_code": "// DeviceComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport java.util.Comparator;\r\n\r\npublic class DeviceComparator implements Comparator<DeviceDesc> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public DeviceComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(DeviceDesc a1, DeviceDesc a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"deviceId\")) {\r\n            result = (int) (a1.getDeviceId() - a2.getDeviceId());\r\n        }\r\n        if (sortKey.equals(\"name\")) {\r\n            result = a1.getName().compareTo(a2.getName());\r\n        }\r\n        if (sortKey.equals(\"type\")) {\r\n            result = a1.getType().compareTo(a2.getType());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/DeviceComparator.java",
		"test_prompt": "// DeviceComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeviceComparator}.\n* It contains ten unit test cases for the {@link DeviceComparator#compare(DeviceDesc, DeviceDesc)} method.\n*/\nclass DeviceComparatorTest {"
	},
	{
		"original_code": "// ProbeDesc.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\npublic class ProbeDesc {\r\n\r\n    private final long probeId;\r\n\r\n    private final long bmId;\r\n\r\n    private final String name;\r\n\r\n    private final boolean disabled;\r\n\r\n    public ProbeDesc(long probeId, long bmId, String name, boolean disabled) {\r\n        super();\r\n        this.probeId = probeId;\r\n        this.bmId = bmId;\r\n        this.name = name;\r\n        this.disabled = disabled;\r\n    }\r\n\r\n    public long getProbeId() {\r\n        return probeId;\r\n    }\r\n\r\n    public long getBmId() {\r\n        return bmId;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/ProbeDesc.java",
		"test_prompt": "// ProbeDescTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeDesc}.\n* It contains ten unit test cases for the {@link ProbeDesc#isDisabled()} method.\n*/\nclass ProbeDescTest {"
	},
	{
		"original_code": "// BMDesc.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\npublic class BMDesc {\r\n\r\n    private final long bmId;\r\n\r\n    private final long deviceId;\r\n\r\n    private final String clazz;\r\n\r\n    private final String name;\r\n\r\n    private final String description;\r\n\r\n    private final boolean disabled;\r\n\r\n    public BMDesc(long bmId, long deviceId, String clazz, String name, String description, boolean disabled) {\r\n        super();\r\n        this.bmId = bmId;\r\n        this.deviceId = deviceId;\r\n        this.clazz = clazz;\r\n        this.name = name;\r\n        this.description = description;\r\n        this.disabled = disabled;\r\n    }\r\n\r\n    public long getBmId() {\r\n        return bmId;\r\n    }\r\n\r\n    public long getDeviceId() {\r\n        return deviceId;\r\n    }\r\n\r\n    public String getClazz() {\r\n        return clazz;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    public boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/BMDesc.java",
		"test_prompt": "// BMDescTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMDesc}.\n* It contains ten unit test cases for the {@link BMDesc#isDisabled()} method.\n*/\nclass BMDescTest {"
	},
	{
		"original_code": "// DeviceDesc.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\npublic class DeviceDesc {\r\n\r\n    private final long deviceId;\r\n\r\n    private final String name;\r\n\r\n    private final String type;\r\n\r\n    private final boolean disabled;\r\n\r\n    public DeviceDesc(long deviceId, String name, String type, boolean disabled) {\r\n        super();\r\n        this.deviceId = deviceId;\r\n        this.name = name;\r\n        this.type = type;\r\n        this.disabled = disabled;\r\n    }\r\n\r\n    public long getDeviceId() {\r\n        return deviceId;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    public boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/DeviceDesc.java",
		"test_prompt": "// DeviceDescTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeviceDesc}.\n* It contains ten unit test cases for the {@link DeviceDesc#isDisabled()} method.\n*/\nclass DeviceDescTest {"
	},
	{
		"original_code": "// ProbeComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport java.util.Comparator;\r\n\r\npublic class ProbeComparator implements Comparator<ProbeDesc> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public ProbeComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(ProbeDesc a1, ProbeDesc a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"probeId\")) {\r\n            result = (int) (a1.getProbeId() - a2.getProbeId());\r\n        }\r\n        if (sortKey.equals(\"bmId\")) {\r\n            result = (int) (a1.getBmId() - a2.getBmId());\r\n        }\r\n        if (sortKey.equals(\"name\")) {\r\n            result = a1.getName().compareTo(a2.getName());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/ProbeComparator.java",
		"test_prompt": "// ProbeComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeComparator}.\n* It contains ten unit test cases for the {@link ProbeComparator#compare(ProbeDesc, ProbeDesc)} method.\n*/\nclass ProbeComparatorTest {"
	},
	{
		"original_code": "// BMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class BMListDataProvider extends SortableDataProvider<BMDesc> {\r\n\r\n    private final static Logger log = new Logger(BMListDataProvider.class);\r\n\r\n    private final List<BMDesc> bms;\r\n\r\n    public BMListDataProvider(List<BMDesc> bms) {\r\n        this.bms = bms;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<BMDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bms, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(bms, new BMComparator(key, false));\r\n        }\r\n        return bms.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return bms.size();\r\n    }\r\n\r\n    public IModel<BMDesc> model(BMDesc bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/BMListDataProvider_0Test.java",
		"test_prompt": "// BMListDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMListDataProvider}.\n* It contains ten unit test cases for the {@link BMListDataProvider#iterator(int, int)} method.\n*/\nclass BMListDataProvider_0Test {"
	},
	{
		"original_code": "// BMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class BMListDataProvider extends SortableDataProvider<BMDesc> {\r\n\r\n    private final static Logger log = new Logger(BMListDataProvider.class);\r\n\r\n    private final List<BMDesc> bms;\r\n\r\n    public BMListDataProvider(List<BMDesc> bms) {\r\n        this.bms = bms;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<BMDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bms, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(bms, new BMComparator(key, false));\r\n        }\r\n        return bms.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return bms.size();\r\n    }\r\n\r\n    public IModel<BMDesc> model(BMDesc bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/BMListDataProvider_1Test.java",
		"test_prompt": "// BMListDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMListDataProvider}.\n* It contains ten unit test cases for the {@link BMListDataProvider#size()} method.\n*/\nclass BMListDataProvider_1Test {"
	},
	{
		"original_code": "// BMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\npublic class BMListDataProvider extends SortableDataProvider<BMDesc> {\r\n\r\n    private final static Logger log = new Logger(BMListDataProvider.class);\r\n\r\n    private final List<BMDesc> bms;\r\n\r\n    public BMListDataProvider(List<BMDesc> bms) {\r\n        this.bms = bms;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<BMDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bms, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(bms, new BMComparator(key, false));\r\n        }\r\n        return bms.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return bms.size();\r\n    }\r\n\r\n    public IModel<BMDesc> model(BMDesc bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/BMListDataProvider_2Test.java",
		"test_prompt": "// BMListDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMListDataProvider}.\n* It contains ten unit test cases for the {@link BMListDataProvider#model(BMDesc)} method.\n*/\nclass BMListDataProvider_2Test {"
	},
	{
		"original_code": "// ProbeListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n//import fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\npublic class ProbeListDataProvider extends SortableDataProvider<ProbeDesc> {\r\n\r\n    private final static Logger log = new Logger(ProbeListDataProvider.class);\r\n\r\n    private final List<ProbeDesc> probes;\r\n\r\n    public ProbeListDataProvider(List<ProbeDesc> probes) {\r\n        this.probes = probes;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<ProbeDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(probes, new ProbeComparator(key, true));\r\n        } else {\r\n            Collections.sort(probes, new ProbeComparator(key, false));\r\n        }\r\n        return probes.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return probes.size();\r\n    }\r\n\r\n    public IModel<ProbeDesc> model(ProbeDesc probeDesc) {\r\n        return new DetachableProbeModel(probeDesc);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/ProbeListDataProvider_0Test.java",
		"test_prompt": "// ProbeListDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeListDataProvider}.\n* It contains ten unit test cases for the {@link ProbeListDataProvider#iterator(int, int)} method.\n*/\nclass ProbeListDataProvider_0Test {"
	},
	{
		"original_code": "// ProbeListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n//import fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\npublic class ProbeListDataProvider extends SortableDataProvider<ProbeDesc> {\r\n\r\n    private final static Logger log = new Logger(ProbeListDataProvider.class);\r\n\r\n    private final List<ProbeDesc> probes;\r\n\r\n    public ProbeListDataProvider(List<ProbeDesc> probes) {\r\n        this.probes = probes;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<ProbeDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(probes, new ProbeComparator(key, true));\r\n        } else {\r\n            Collections.sort(probes, new ProbeComparator(key, false));\r\n        }\r\n        return probes.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return probes.size();\r\n    }\r\n\r\n    public IModel<ProbeDesc> model(ProbeDesc probeDesc) {\r\n        return new DetachableProbeModel(probeDesc);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/ProbeListDataProvider_1Test.java",
		"test_prompt": "// ProbeListDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeListDataProvider}.\n* It contains ten unit test cases for the {@link ProbeListDataProvider#size()} method.\n*/\nclass ProbeListDataProvider_1Test {"
	},
	{
		"original_code": "// ProbeListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n//import fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\npublic class ProbeListDataProvider extends SortableDataProvider<ProbeDesc> {\r\n\r\n    private final static Logger log = new Logger(ProbeListDataProvider.class);\r\n\r\n    private final List<ProbeDesc> probes;\r\n\r\n    public ProbeListDataProvider(List<ProbeDesc> probes) {\r\n        this.probes = probes;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<ProbeDesc> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(probes, new ProbeComparator(key, true));\r\n        } else {\r\n            Collections.sort(probes, new ProbeComparator(key, false));\r\n        }\r\n        return probes.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return probes.size();\r\n    }\r\n\r\n    public IModel<ProbeDesc> model(ProbeDesc probeDesc) {\r\n        return new DetachableProbeModel(probeDesc);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/availabilitypage/ProbeListDataProvider_2Test.java",
		"test_prompt": "// ProbeListDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeListDataProvider}.\n* It contains ten unit test cases for the {@link ProbeListDataProvider#model(ProbeDesc)} method.\n*/\nclass ProbeListDataProvider_2Test {"
	},
	{
		"original_code": "// BM.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element name=\"device_id\" type=\"{http://www.w3.org/2001/XMLSchema}long\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"class\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"description\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\", propOrder = { \"deviceId\" })\r\n@XmlRootElement(name = \"BM\")\r\npublic class BM {\r\n\r\n    @XmlElement(name = \"device_id\", namespace = \"\", type = Long.class)\r\n    protected List<Long> deviceId;\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"class\")\r\n    protected String clazz;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"description\")\r\n    protected String description;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the deviceId property.\r\n     *\r\n     * <p>\r\n     * This accessor method returns a reference to the live list,\r\n     * not a snapshot. Therefore any modification you make to the\r\n     * returned list will be present inside the JAXB object.\r\n     * This is why there is not a <CODE>set</CODE> method for the deviceId property.\r\n     *\r\n     * <p>\r\n     * For example, to add a new item, do as follows:\r\n     * <pre>\r\n     *    getDeviceId().add(newItem);\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Objects of the following type(s) are allowed in the list\r\n     * {@link Long }\r\n     */\r\n    public List<Long> getDeviceId() {\r\n        if (deviceId == null) {\r\n            deviceId = new ArrayList<Long>();\r\n        }\r\n        return this.deviceId;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the clazz property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getClazz() {\r\n        return clazz;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the clazz property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setClazz(String value) {\r\n        this.clazz = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the description property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the description property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setDescription(String value) {\r\n        this.description = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/BM.java",
		"test_prompt": "// BMTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BM}.\n* It contains ten unit test cases for the {@link BM#isDisabled()} method.\n*/\nclass BMTest {"
	},
	{
		"original_code": "// BMResult.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlSchemaType;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"error\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *       &lt;attribute name=\"value\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"timeStamp\" type=\"{http://www.w3.org/2001/XMLSchema}dateTime\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"BMResult\")\r\npublic class BMResult {\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"error\")\r\n    protected Boolean error;\r\n\r\n    @XmlAttribute(name = \"value\")\r\n    protected String value;\r\n\r\n    @XmlAttribute(name = \"timeStamp\")\r\n    @XmlSchemaType(name = \"dateTime\")\r\n    protected XMLGregorianCalendar timeStamp;\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the error property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the error property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setError(Boolean value) {\r\n        this.error = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the value property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the value property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the timeStamp property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link XMLGregorianCalendar }\r\n     */\r\n    public XMLGregorianCalendar getTimeStamp() {\r\n        return timeStamp;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the timeStamp property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link XMLGregorianCalendar }\r\n     */\r\n    public void setTimeStamp(XMLGregorianCalendar value) {\r\n        this.timeStamp = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/BMResult.java",
		"test_prompt": "// BMResultTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlSchemaType;\nimport javax.xml.bind.annotation.XmlType;\nimport javax.xml.datatype.XMLGregorianCalendar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMResult}.\n* It contains ten unit test cases for the {@link BMResult#isError()} method.\n*/\nclass BMResultTest {"
	},
	{
		"original_code": "// Probe.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element name=\"bm_id\" type=\"{http://www.w3.org/2001/XMLSchema}long\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\", propOrder = { \"bmId\" })\r\n@XmlRootElement(name = \"Probe\")\r\npublic class Probe {\r\n\r\n    @XmlElement(name = \"bm_id\", namespace = \"\", type = Long.class)\r\n    protected List<Long> bmId;\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the bmId property.\r\n     *\r\n     * <p>\r\n     * This accessor method returns a reference to the live list,\r\n     * not a snapshot. Therefore any modification you make to the\r\n     * returned list will be present inside the JAXB object.\r\n     * This is why there is not a <CODE>set</CODE> method for the bmId property.\r\n     *\r\n     * <p>\r\n     * For example, to add a new item, do as follows:\r\n     * <pre>\r\n     *    getBmId().add(newItem);\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Objects of the following type(s) are allowed in the list\r\n     * {@link Long }\r\n     */\r\n    public List<Long> getBmId() {\r\n        if (bmId == null) {\r\n            bmId = new ArrayList<Long>();\r\n        }\r\n        return this.bmId;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/Probe.java",
		"test_prompt": "// ProbeTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Probe}.\n* It contains ten unit test cases for the {@link Probe#isDisabled()} method.\n*/\nclass ProbeTest {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_0Test.java",
		"test_prompt": "// ObjectFactory_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResults()} method.\n*/\nclass ObjectFactory_0Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_1Test.java",
		"test_prompt": "// ObjectFactory_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createOperationResult()} method.\n*/\nclass ObjectFactory_1Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_2Test.java",
		"test_prompt": "// ObjectFactory_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createGetSAC()} method.\n*/\nclass ObjectFactory_2Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_3Test.java",
		"test_prompt": "// ObjectFactory_3Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createSAC()} method.\n*/\nclass ObjectFactory_3Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_4Test.java",
		"test_prompt": "// ObjectFactory_4Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createDevice()} method.\n*/\nclass ObjectFactory_4Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_5Test.java",
		"test_prompt": "// ObjectFactory_5Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createAvailability()} method.\n*/\nclass ObjectFactory_5Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_6Test.java",
		"test_prompt": "// ObjectFactory_6Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBM()} method.\n*/\nclass ObjectFactory_6Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_7Test.java",
		"test_prompt": "// ObjectFactory_7Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbe()} method.\n*/\nclass ObjectFactory_7Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_8Test.java",
		"test_prompt": "// ObjectFactory_8Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResult()} method.\n*/\nclass ObjectFactory_8Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.sacservice\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults }\r\n     */\r\n    public BMResults createBMResults() {\r\n        return new BMResults();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetSAC }\r\n     */\r\n    public GetSAC createGetSAC() {\r\n        return new GetSAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link SAC }\r\n     */\r\n    public SAC createSAC() {\r\n        return new SAC();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResult }\r\n     */\r\n    public BMResult createBMResult() {\r\n        return new BMResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResults.PerDevice }\r\n     */\r\n    public BMResults.PerDevice createBMResultsPerDevice() {\r\n        return new BMResults.PerDevice();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/ObjectFactory_9Test.java",
		"test_prompt": "// ObjectFactory_9Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResultsPerDevice()} method.\n*/\nclass ObjectFactory_9Test {"
	},
	{
		"original_code": "// Device.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"type\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"Device\")\r\npublic class Device {\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"type\")\r\n    protected String type;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the type property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the type property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setType(String value) {\r\n        this.type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/Device.java",
		"test_prompt": "// DeviceTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Device}.\n* It contains ten unit test cases for the {@link Device#isDisabled()} method.\n*/\nclass DeviceTest {"
	},
	{
		"original_code": "// OperationResult.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"error\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"OperationResult\")\r\npublic class OperationResult {\r\n\r\n    @XmlAttribute(name = \"error\", required = true)\r\n    protected boolean error;\r\n\r\n    /**\r\n     * Gets the value of the error property.\r\n     */\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the error property.\r\n     */\r\n    public void setError(boolean value) {\r\n        this.error = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/sacservice/OperationResult.java",
		"test_prompt": "// OperationResultTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.sacservice;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OperationResult}.\n* It contains ten unit test cases for the {@link OperationResult#isError()} method.\n*/\nclass OperationResultTest {"
	},
	{
		"original_code": "// BodyFrame.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.frameset;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage.HistoryPage;\r\nimport org.apache.wicket.AttributeModifier;\r\nimport org.apache.wicket.PageMap;\r\nimport org.apache.wicket.RequestCycle;\r\nimport org.apache.wicket.markup.html.WebComponent;\r\nimport org.apache.wicket.markup.html.WebPage;\r\nimport org.apache.wicket.model.IModel;\r\nimport org.apache.wicket.model.Model;\r\n\r\n/**\r\n * Second frame that splits the bottom frame into two horizontally\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class BodyFrame extends WebPage {\r\n\r\n    /**\r\n     * Model that returns the url to the bookmarkable page that is set in the current frame target.\r\n     */\r\n    private final class FrameModel implements IModel<CharSequence> {\r\n\r\n        public CharSequence getObject() {\r\n            return RequestCycle.get().urlFor(PageMap.forName(RIGHT_FRAME_NAME), frameTarget.getFrameClass(), null);\r\n        }\r\n\r\n        public void setObject(final CharSequence object) {\r\n        }\r\n\r\n        /**\r\n         * @see org.apache.wicket.model.IDetachable#detach()\r\n         */\r\n        public void detach() {\r\n        }\r\n    }\r\n\r\n    /**\r\n     * name for page map etc.\r\n     */\r\n    public static final String RIGHT_FRAME_NAME = \"right\";\r\n\r\n    private final FrameTarget frameTarget = new FrameTarget(HistoryPage.class);\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public BodyFrame() {\r\n        // create a new page instance, passing this 'master page' as an argument\r\n        LeftFrame leftFrame = new LeftFrame(this);\r\n        // get the url to that page\r\n        String leftFrameSrc = RequestCycle.get().urlFor(leftFrame).toString();\r\n        // and create a simple component that modifies it's src attribute to\r\n        // hold the url to that frame\r\n        WebComponent leftFrameTag = new WebComponent(\"leftFrame\");\r\n        leftFrameTag.add(new AttributeModifier(\"src\", new Model<String>(leftFrameSrc)));\r\n        add(leftFrameTag);\r\n        // make a simple component for the right frame tag\r\n        WebComponent rightFrameTag = new WebComponent(\"rightFrame\");\r\n        // and this time, set a model which retrieves the url to the currently\r\n        // set frame class in the frame target\r\n        rightFrameTag.add(new AttributeModifier(\"src\", new FrameModel()));\r\n        add(rightFrameTag);\r\n    }\r\n\r\n    /**\r\n     * Gets frameTarget.\r\n     *\r\n     * @return frameTarget\r\n     */\r\n    public FrameTarget getFrameTarget() {\r\n        return frameTarget;\r\n    }\r\n\r\n    /**\r\n     * @see org.apache.wicket.Component#isVersioned()\r\n     */\r\n    @Override\r\n    public boolean isVersioned() {\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/frameset/BodyFrame.java",
		"test_prompt": "// BodyFrameTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.frameset;\n\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage.HistoryPage;\nimport org.apache.wicket.AttributeModifier;\nimport org.apache.wicket.PageMap;\nimport org.apache.wicket.RequestCycle;\nimport org.apache.wicket.markup.html.WebComponent;\nimport org.apache.wicket.markup.html.WebPage;\nimport org.apache.wicket.model.IModel;\nimport org.apache.wicket.model.Model;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BodyFrame}.\n* It contains ten unit test cases for the {@link BodyFrame#isVersioned()} method.\n*/\nclass BodyFrameTest {"
	},
	{
		"original_code": "// LeftFrame.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.frameset;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage.AvailabilityPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage.BMReportsPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResultsPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage.EventListPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage.HistoryPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwinformationpage.MFWInformationPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage.ProbeListPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage.ProbeParameterPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.subscribetobmpage.SubscribeToBMPage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.updatepage.UpdatePage;\r\nimport org.apache.wicket.Page;\r\nimport org.apache.wicket.markup.html.WebPage;\r\nimport org.apache.wicket.markup.html.link.Link;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class LeftFrame extends WebPage {\r\n\r\n    private final static Logger log = new Logger(LeftFrame.class);\r\n\r\n    /**\r\n     * Link that, when clicked, changes the frame target's frame class (and as that is a shared\r\n     * model which is also being used by the 'master page' {@link BodyFrame}, changes are\r\n     * immediately reflected) and set the response page to the top level page {@link BodyFrame}.\r\n     * Tags that use this link should have a <code>target=\"_parent\"</code> attribute, so that the\r\n     * top frame will be refreshed.\r\n     */\r\n    private static final class ChangeFramePageLink extends Link {\r\n\r\n        private static final long serialVersionUID = 1L;\r\n\r\n        /**\r\n         * parent frame class.\r\n         */\r\n        private final BodyFrame bodyFrame;\r\n\r\n        /**\r\n         * this link's target.\r\n         */\r\n        private final Class<? extends Page> pageClass;\r\n\r\n        /**\r\n         * Construct.\r\n         *\r\n         * @param <C>\r\n         * @param id\r\n         * @param bodyFrame\r\n         * @param pageClass\r\n         */\r\n        public <C extends Page> ChangeFramePageLink(String id, BodyFrame bodyFrame, Class<C> pageClass) {\r\n            super(id);\r\n            this.bodyFrame = bodyFrame;\r\n            this.pageClass = pageClass;\r\n        }\r\n\r\n        /**\r\n         * @see org.apache.wicket.markup.html.link.Link#onClick()\r\n         */\r\n        @Override\r\n        public void onClick() {\r\n            // change frame class\r\n            bodyFrame.getFrameTarget().setFrameClass(pageClass);\r\n            // trigger re-rendering of the page\r\n            setResponsePage(bodyFrame);\r\n        }\r\n    }\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    /**\r\n     * Constructor\r\n     *\r\n     * @param index parent frame class\r\n     */\r\n    public LeftFrame(BodyFrame index) {\r\n        add(new ChangeFramePageLink(\"linkToHistoryPage\", index, HistoryPage.class));\r\n        add(new ChangeFramePageLink(\"linkToProbesPage\", index, ProbeListPage.class));\r\n        add(new ChangeFramePageLink(\"linkToBMPage\", index, BMListPage.class));\r\n        add(new ChangeFramePageLink(\"linkToEventsPage\", index, EventListPage.class));\r\n        //    add(new ChangeFramePageLink(\"linkToDMPage\", index, DerivedMeasuresPage.class));\r\n        //    add(new ChangeFramePageLink(\"linkToUpdatePage\", index, UpdatePage.class));\r\n        //    add(new ChangeFramePageLink(\"linkToMFWInformationPage\", index, MFWInformationPage.class));\r\n        //    add(new ChangeFramePageLink(\"linkToAvailabilityPage\", index, AvailabilityPage.class));\r\n        //    add(new ChangeFramePageLink(\"linkToProbeParameterPage\", index, ProbeParameterPage.class));\r\n        //    add(new ChangeFramePageLink(\"linkToSubscribeToBMPage\", index, SubscribeToBMPage.class));\r\n        //    add(new ChangeFramePageLink(\"linkToBMResultsPage\", index, BMResultsPage.class));\r\n        //    add(new ChangeFramePageLink(\"linkToBMReportsPage\", index, BMReportsPage.class));\r\n    }\r\n\r\n    /**\r\n     * No need for versioning this frame.\r\n     *\r\n     * @see org.apache.wicket.Component#isVersioned()\r\n     */\r\n    @Override\r\n    public boolean isVersioned() {\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/frameset/LeftFrame.java",
		"test_prompt": "// LeftFrameTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.frameset;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.availabilitypage.AvailabilityPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage.BMReportsPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResultsPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage.EventListPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage.HistoryPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwinformationpage.MFWInformationPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage.ProbeListPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.probeparameterpage.ProbeParameterPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.subscribetobmpage.SubscribeToBMPage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.updatepage.UpdatePage;\nimport org.apache.wicket.Page;\nimport org.apache.wicket.markup.html.WebPage;\nimport org.apache.wicket.markup.html.link.Link;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LeftFrame}.\n* It contains ten unit test cases for the {@link LeftFrame#isVersioned()} method.\n*/\nclass LeftFrameTest {"
	},
	{
		"original_code": "// WebUIWicketApplication.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.frameset.BodyFrame;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.frameset.Home;\r\nimport org.apache.wicket.Page;\r\nimport org.apache.wicket.Request;\r\nimport org.apache.wicket.Response;\r\nimport org.apache.wicket.Session;\r\nimport org.apache.wicket.protocol.http.WebApplication;\r\nimport org.apache.wicket.util.file.Folder;\r\n\r\n/**\r\n * The main Application used by Wicket to create the web ui.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class WebUIWicketApplication extends WebApplication {\r\n\r\n    private Folder uploadFolder = null;\r\n\r\n    public Class<? extends Page> getHomePage() {\r\n        return BodyFrame.class;\r\n        //    return ProbeListPage.class;\r\n    }\r\n\r\n    @Override\r\n    public Session newSession(Request request, Response response) {\r\n        return new WebUISession(request);\r\n    }\r\n\r\n    @Override\r\n    protected void init() {\r\n        super.init();\r\n        getResourceSettings().setThrowExceptionOnMissingResource(false);\r\n        uploadFolder = new Folder(System.getProperty(\"java.io.tmpdir\"), \"wicket-uploads\");\r\n        // Ensure folder exists\r\n        uploadFolder.mkdirs();\r\n        //    mountBookmarkablePage(\"/multi\", MultiUploadPage.class);\r\n        //    mountBookmarkablePage(\"/single\", UploadPage.class);\r\n    }\r\n\r\n    public Folder getUploadFolder() {\r\n        return uploadFolder;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/WebUIWicketApplication.java",
		"test_prompt": "// WebUIWicketApplicationTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui;\n\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.frameset.BodyFrame;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.frameset.Home;\nimport org.apache.wicket.Page;\nimport org.apache.wicket.Request;\nimport org.apache.wicket.Response;\nimport org.apache.wicket.Session;\nimport org.apache.wicket.protocol.http.WebApplication;\nimport org.apache.wicket.util.file.Folder;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUIWicketApplication}.\n* It contains ten unit test cases for the {@link WebUIWicketApplication#newSession(Request, Response)} method.\n*/\nclass WebUIWicketApplicationTest {"
	},
	{
		"original_code": "// WebUIWicketFilter.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.protocol.http.WicketFilter;\r\nimport javax.servlet.FilterChain;\r\nimport javax.servlet.FilterConfig;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.ServletRequest;\r\nimport javax.servlet.ServletResponse;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * Used to hack around the classloader constraints in OSGI and Wicket.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class WebUIWicketFilter extends WicketFilter {\r\n\r\n    private final static Logger log = new Logger(WebUIWicketFilter.class);\r\n\r\n    @Override\r\n    public void init(FilterConfig config) throws ServletException {\r\n        log.debug(\"initializing filter:\" + config);\r\n        try {\r\n            super.init(config);\r\n        } catch (ServletException e) {\r\n            e.printStackTrace();\r\n        }\r\n        log.debug(\"initialized\");\r\n    }\r\n\r\n    //this provides Wicket with a working classloader to create the web page objects via reflection, and while still\r\n    //running inside OSGI.\r\n    @Override\r\n    protected ClassLoader getClassLoader() {\r\n        //    log.debug(\"getting classloader:\"+this.getClass().getClassLoader());\r\n        try {\r\n            return this.getClass().getClassLoader();\r\n        } catch (RuntimeException e) {\r\n            e.printStackTrace();\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /*\r\n  @Override\r\n  protected String getFilterPath(HttpServletRequest request) {\r\n    return \"/ui/\";\r\n  }\r\n*/\r\n    @Override\r\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\r\n        //    log.debug(\"filter request\");\r\n        HttpServletRequest httpReq = null;\r\n        try {\r\n            httpReq = (HttpServletRequest) request;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        //    log.debug(\"filtering:\"+httpReq.getPathInfo());\r\n        super.doFilter(request, response, chain);\r\n    }\r\n\r\n    @Override\r\n    public boolean doGet(HttpServletRequest servletRequest, HttpServletResponse servletResponse) throws ServletException, IOException {\r\n        //    log.debug(\"getting\");\r\n        try {\r\n            return super.doGet(servletRequest, servletResponse);\r\n        } catch (ServletException e) {\r\n            e.printStackTrace();\r\n            throw e;\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/WebUIWicketFilter.java",
		"test_prompt": "// WebUIWicketFilterTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.protocol.http.WicketFilter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUIWicketFilter}.\n* It contains ten unit test cases for the {@link WebUIWicketFilter#doGet(HttpServletRequest, HttpServletResponse)} method.\n*/\nclass WebUIWicketFilterTest {"
	},
	{
		"original_code": "// DMComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DMComparator implements Comparator<DMDefinition> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public DMComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(DMDefinition a1, DMDefinition a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"id\")) {\r\n            result = a1.getId() - a2.getId();\r\n        }\r\n        if (sortKey.equals(\"name\")) {\r\n            result = a1.getName().compareTo(a2.getName());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMComparator.java",
		"test_prompt": "// DMComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMComparator}.\n* It contains ten unit test cases for the {@link DMComparator#compare(DMDefinition, DMDefinition)} method.\n*/\nclass DMComparatorTest {"
	},
	{
		"original_code": "// BMComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListItem;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class BMComparator implements Comparator<BMListItem> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public BMComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(BMListItem a1, BMListItem a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"bmId\")) {\r\n            result = (int) (a1.getBmId() - a2.getBmId());\r\n        }\r\n        if (sortKey.equals(\"measureURI\")) {\r\n            result = a1.getMeasureURI().compareTo(a2.getMeasureURI());\r\n        }\r\n        if (sortKey.equals(\"bmDescription\")) {\r\n            result = a1.getBmDescription().compareTo(a2.getBmDescription());\r\n        }\r\n        if (sortKey.equals(\"value\")) {\r\n            result = a1.getValue().compareTo(a2.getValue());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/BMComparator.java",
		"test_prompt": "// BMComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListItem;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMComparator}.\n* It contains ten unit test cases for the {@link BMComparator#compare(BMListItem, BMListItem)} method.\n*/\nclass BMComparatorTest {"
	},
	{
		"original_code": "// DMValueListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMValueListDataProvider extends SortableDataProvider<DMValue> {\r\n\r\n    private final static Logger log = new Logger(DMValueListDataProvider.class);\r\n\r\n    private final List<DMValue> dmValues;\r\n\r\n    public DMValueListDataProvider(List<DMValue> dmValues) {\r\n        this.dmValues = dmValues;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DMValue> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(dmValues, new DMValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(dmValues, new DMValueComparator(key, false));\r\n        }\r\n        return dmValues.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return dmValues.size();\r\n    }\r\n\r\n    public IModel<DMValue> model(DMValue dm) {\r\n        return new DetachableDMValueModel(dm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMValueListDataProvider_0Test.java",
		"test_prompt": "// DMValueListDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMValueListDataProvider}.\n* It contains ten unit test cases for the {@link DMValueListDataProvider#iterator(int, int)} method.\n*/\nclass DMValueListDataProvider_0Test {"
	},
	{
		"original_code": "// DMValueListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMValueListDataProvider extends SortableDataProvider<DMValue> {\r\n\r\n    private final static Logger log = new Logger(DMValueListDataProvider.class);\r\n\r\n    private final List<DMValue> dmValues;\r\n\r\n    public DMValueListDataProvider(List<DMValue> dmValues) {\r\n        this.dmValues = dmValues;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DMValue> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(dmValues, new DMValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(dmValues, new DMValueComparator(key, false));\r\n        }\r\n        return dmValues.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return dmValues.size();\r\n    }\r\n\r\n    public IModel<DMValue> model(DMValue dm) {\r\n        return new DetachableDMValueModel(dm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMValueListDataProvider_1Test.java",
		"test_prompt": "// DMValueListDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMValueListDataProvider}.\n* It contains ten unit test cases for the {@link DMValueListDataProvider#size()} method.\n*/\nclass DMValueListDataProvider_1Test {"
	},
	{
		"original_code": "// DMValueListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMValueListDataProvider extends SortableDataProvider<DMValue> {\r\n\r\n    private final static Logger log = new Logger(DMValueListDataProvider.class);\r\n\r\n    private final List<DMValue> dmValues;\r\n\r\n    public DMValueListDataProvider(List<DMValue> dmValues) {\r\n        this.dmValues = dmValues;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DMValue> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(dmValues, new DMValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(dmValues, new DMValueComparator(key, false));\r\n        }\r\n        return dmValues.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return dmValues.size();\r\n    }\r\n\r\n    public IModel<DMValue> model(DMValue dm) {\r\n        return new DetachableDMValueModel(dm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMValueListDataProvider_2Test.java",
		"test_prompt": "// DMValueListDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMValueListDataProvider}.\n* It contains ten unit test cases for the {@link DMValueListDataProvider#model(DMValue)} method.\n*/\nclass DMValueListDataProvider_2Test {"
	},
	{
		"original_code": "// DMInformationDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListItem;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.DetachableBMModel;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMInformationDataProvider extends SortableDataProvider<BMListItem> {\r\n\r\n    private final static Logger log = new Logger(DMInformationDataProvider.class);\r\n\r\n    private List<BMListItem> rows;\r\n\r\n    private Collection<BMDescription> requiredMeasures;\r\n\r\n    private DMDefinition dm;\r\n\r\n    private final RegistryPlugin registry;\r\n\r\n    public DMInformationDataProvider(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n        rows = new ArrayList<BMListItem>();\r\n        setSort(\"id\", true);\r\n    }\r\n\r\n    public void setDM(DMDefinition dm) {\r\n        this.dm = dm;\r\n        rows.clear();\r\n        if (dm == null) {\r\n            return;\r\n        }\r\n        requiredMeasures = dm.getRequiredBM();\r\n        List<BMDescription> actual = registry.getAvailableBM();\r\n        for (BMDescription bm : requiredMeasures) {\r\n            for (BMDescription ap : actual) {\r\n                if (bm.matches(ap)) {\r\n                    bm = ap;\r\n                }\r\n            }\r\n            rows.add(new BMListItem(bm, null));\r\n        }\r\n    }\r\n\r\n    public Iterator<BMListItem> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        log.debug(\"sort:\" + sp);\r\n        String key = sp.getProperty();\r\n        log.debug(\"xx sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(rows, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(rows, new BMComparator(key, false));\r\n        }\r\n        return rows.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return rows.size();\r\n    }\r\n\r\n    public IModel<BMListItem> model(BMListItem bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMInformationDataProvider_0Test.java",
		"test_prompt": "// DMInformationDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListItem;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.DetachableBMModel;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMInformationDataProvider}.\n* It contains ten unit test cases for the {@link DMInformationDataProvider#iterator(int, int)} method.\n*/\nclass DMInformationDataProvider_0Test {"
	},
	{
		"original_code": "// DMInformationDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListItem;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.DetachableBMModel;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMInformationDataProvider extends SortableDataProvider<BMListItem> {\r\n\r\n    private final static Logger log = new Logger(DMInformationDataProvider.class);\r\n\r\n    private List<BMListItem> rows;\r\n\r\n    private Collection<BMDescription> requiredMeasures;\r\n\r\n    private DMDefinition dm;\r\n\r\n    private final RegistryPlugin registry;\r\n\r\n    public DMInformationDataProvider(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n        rows = new ArrayList<BMListItem>();\r\n        setSort(\"id\", true);\r\n    }\r\n\r\n    public void setDM(DMDefinition dm) {\r\n        this.dm = dm;\r\n        rows.clear();\r\n        if (dm == null) {\r\n            return;\r\n        }\r\n        requiredMeasures = dm.getRequiredBM();\r\n        List<BMDescription> actual = registry.getAvailableBM();\r\n        for (BMDescription bm : requiredMeasures) {\r\n            for (BMDescription ap : actual) {\r\n                if (bm.matches(ap)) {\r\n                    bm = ap;\r\n                }\r\n            }\r\n            rows.add(new BMListItem(bm, null));\r\n        }\r\n    }\r\n\r\n    public Iterator<BMListItem> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        log.debug(\"sort:\" + sp);\r\n        String key = sp.getProperty();\r\n        log.debug(\"xx sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(rows, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(rows, new BMComparator(key, false));\r\n        }\r\n        return rows.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return rows.size();\r\n    }\r\n\r\n    public IModel<BMListItem> model(BMListItem bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMInformationDataProvider_1Test.java",
		"test_prompt": "// DMInformationDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListItem;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.DetachableBMModel;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMInformationDataProvider}.\n* It contains ten unit test cases for the {@link DMInformationDataProvider#size()} method.\n*/\nclass DMInformationDataProvider_1Test {"
	},
	{
		"original_code": "// DMInformationDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListItem;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.DetachableBMModel;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMInformationDataProvider extends SortableDataProvider<BMListItem> {\r\n\r\n    private final static Logger log = new Logger(DMInformationDataProvider.class);\r\n\r\n    private List<BMListItem> rows;\r\n\r\n    private Collection<BMDescription> requiredMeasures;\r\n\r\n    private DMDefinition dm;\r\n\r\n    private final RegistryPlugin registry;\r\n\r\n    public DMInformationDataProvider(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n        rows = new ArrayList<BMListItem>();\r\n        setSort(\"id\", true);\r\n    }\r\n\r\n    public void setDM(DMDefinition dm) {\r\n        this.dm = dm;\r\n        rows.clear();\r\n        if (dm == null) {\r\n            return;\r\n        }\r\n        requiredMeasures = dm.getRequiredBM();\r\n        List<BMDescription> actual = registry.getAvailableBM();\r\n        for (BMDescription bm : requiredMeasures) {\r\n            for (BMDescription ap : actual) {\r\n                if (bm.matches(ap)) {\r\n                    bm = ap;\r\n                }\r\n            }\r\n            rows.add(new BMListItem(bm, null));\r\n        }\r\n    }\r\n\r\n    public Iterator<BMListItem> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        log.debug(\"sort:\" + sp);\r\n        String key = sp.getProperty();\r\n        log.debug(\"xx sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(rows, new BMComparator(key, true));\r\n        } else {\r\n            Collections.sort(rows, new BMComparator(key, false));\r\n        }\r\n        return rows.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return rows.size();\r\n    }\r\n\r\n    public IModel<BMListItem> model(BMListItem bm) {\r\n        return new DetachableBMModel(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMInformationDataProvider_2Test.java",
		"test_prompt": "// DMInformationDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.BMListItem;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmlistpage.DetachableBMModel;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMInformationDataProvider}.\n* It contains ten unit test cases for the {@link DMInformationDataProvider#model(BMListItem)} method.\n*/\nclass DMInformationDataProvider_2Test {"
	},
	{
		"original_code": "// DMValueComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class DMValueComparator implements Comparator<DMValue> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public DMValueComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(DMValue a1, DMValue a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"id\")) {\r\n            result = a1.getId() - a2.getId();\r\n        }\r\n        if (sortKey.equals(\"name\")) {\r\n            result = a1.getName().compareTo(a2.getName());\r\n        }\r\n        if (sortKey.equals(\"value\")) {\r\n            result = a1.getValue().compareTo(a2.getValue());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMValueComparator.java",
		"test_prompt": "// DMValueComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMValue;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMValueComparator}.\n* It contains ten unit test cases for the {@link DMValueComparator#compare(DMValue, DMValue)} method.\n*/\nclass DMValueComparatorTest {"
	},
	{
		"original_code": "// DMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMListDataProvider extends SortableDataProvider<DMDefinition> {\r\n\r\n    private final static Logger log = new Logger(DMListDataProvider.class);\r\n\r\n    private final List<DMDefinition> dms;\r\n\r\n    public DMListDataProvider(List<DMDefinition> dms) {\r\n        this.dms = dms;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DMDefinition> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(dms, new DMComparator(key, true));\r\n        } else {\r\n            Collections.sort(dms, new DMComparator(key, false));\r\n        }\r\n        return dms.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return dms.size();\r\n    }\r\n\r\n    public IModel<DMDefinition> model(DMDefinition dmDescription) {\r\n        return new DetachableDMModel(dmDescription);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMListDataProvider_0Test.java",
		"test_prompt": "// DMListDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMListDataProvider}.\n* It contains ten unit test cases for the {@link DMListDataProvider#iterator(int, int)} method.\n*/\nclass DMListDataProvider_0Test {"
	},
	{
		"original_code": "// DMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMListDataProvider extends SortableDataProvider<DMDefinition> {\r\n\r\n    private final static Logger log = new Logger(DMListDataProvider.class);\r\n\r\n    private final List<DMDefinition> dms;\r\n\r\n    public DMListDataProvider(List<DMDefinition> dms) {\r\n        this.dms = dms;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DMDefinition> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(dms, new DMComparator(key, true));\r\n        } else {\r\n            Collections.sort(dms, new DMComparator(key, false));\r\n        }\r\n        return dms.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return dms.size();\r\n    }\r\n\r\n    public IModel<DMDefinition> model(DMDefinition dmDescription) {\r\n        return new DetachableDMModel(dmDescription);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMListDataProvider_1Test.java",
		"test_prompt": "// DMListDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMListDataProvider}.\n* It contains ten unit test cases for the {@link DMListDataProvider#size()} method.\n*/\nclass DMListDataProvider_1Test {"
	},
	{
		"original_code": "// DMListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class DMListDataProvider extends SortableDataProvider<DMDefinition> {\r\n\r\n    private final static Logger log = new Logger(DMListDataProvider.class);\r\n\r\n    private final List<DMDefinition> dms;\r\n\r\n    public DMListDataProvider(List<DMDefinition> dms) {\r\n        this.dms = dms;\r\n        setSort(\"name\", true);\r\n    }\r\n\r\n    public Iterator<DMDefinition> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(dms, new DMComparator(key, true));\r\n        } else {\r\n            Collections.sort(dms, new DMComparator(key, false));\r\n        }\r\n        return dms.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return dms.size();\r\n    }\r\n\r\n    public IModel<DMDefinition> model(DMDefinition dmDescription) {\r\n        return new DetachableDMModel(dmDescription);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/derivedmeasurepage/DMListDataProvider_2Test.java",
		"test_prompt": "// DMListDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.DMDefinition;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DMListDataProvider}.\n* It contains ten unit test cases for the {@link DMListDataProvider#model(DMDefinition)} method.\n*/\nclass DMListDataProvider_2Test {"
	},
	{
		"original_code": "// ValueComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\r\n\r\n//import fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ValueComparator implements Comparator<BMResult> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public ValueComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(BMResult result1, BMResult result2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"bm_id\")) {\r\n            result = (int) (result1.getBm_id() - result2.getBm_id());\r\n        }\r\n        if (sortKey.equals(\"device_id\")) {\r\n            result = (int) (result1.getDevice_id() - result2.getDevice_id());\r\n        }\r\n        if (sortKey.equals(\"value\")) {\r\n            result = result1.getValue().compareTo(result2.getValue());\r\n        }\r\n        if (sortKey.equals(\"time\")) {\r\n            result = result1.getTime().compare(result2.getTime());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmresultspage/ValueComparator.java",
		"test_prompt": "// ValueComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\n\n//import fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ValueComparator}.\n* It contains ten unit test cases for the {@link ValueComparator#compare(BMResult, BMResult)} method.\n*/\nclass ValueComparatorTest {"
	},
	{
		"original_code": "// BMResult.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\r\n\r\nimport javax.xml.datatype.XMLGregorianCalendar;\r\n\r\npublic class BMResult {\r\n\r\n    private final long bm_id;\r\n\r\n    private final long device_id;\r\n\r\n    private final String value;\r\n\r\n    private final XMLGregorianCalendar time;\r\n\r\n    private final boolean error;\r\n\r\n    public BMResult(long bmId, long deviceId, String value, XMLGregorianCalendar time, boolean error) {\r\n        super();\r\n        this.bm_id = bmId;\r\n        this.device_id = deviceId;\r\n        this.value = value;\r\n        this.time = time;\r\n        this.error = error;\r\n    }\r\n\r\n    public long getBm_id() {\r\n        return bm_id;\r\n    }\r\n\r\n    public long getDevice_id() {\r\n        return device_id;\r\n    }\r\n\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    public XMLGregorianCalendar getTime() {\r\n        return time;\r\n    }\r\n\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmresultspage/BMResult.java",
		"test_prompt": "// BMResultTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\n\nimport javax.xml.datatype.XMLGregorianCalendar;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMResult}.\n* It contains ten unit test cases for the {@link BMResult#isError()} method.\n*/\nclass BMResultTest {"
	},
	{
		"original_code": "// BMResultDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMResultDataProvider extends SortableDataProvider<BMResult> {\r\n\r\n    private final static Logger log = new Logger(BMResultDataProvider.class);\r\n\r\n    private final List<BMResult> bmResults;\r\n\r\n    public BMResultDataProvider(List<BMResult> bmResults) {\r\n        this.bmResults = bmResults;\r\n        setSort(\"bm_id\", true);\r\n    }\r\n\r\n    public Iterator<BMResult> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bmResults, new ValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(bmResults, new ValueComparator(key, false));\r\n        }\r\n        return bmResults.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return bmResults.size();\r\n    }\r\n\r\n    public IModel<BMResult> model(BMResult bmResult) {\r\n        return new DetachableBMResultModel(bmResult);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmresultspage/BMResultDataProvider_0Test.java",
		"test_prompt": "// BMResultDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMResultDataProvider}.\n* It contains ten unit test cases for the {@link BMResultDataProvider#iterator(int, int)} method.\n*/\nclass BMResultDataProvider_0Test {"
	},
	{
		"original_code": "// BMResultDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMResultDataProvider extends SortableDataProvider<BMResult> {\r\n\r\n    private final static Logger log = new Logger(BMResultDataProvider.class);\r\n\r\n    private final List<BMResult> bmResults;\r\n\r\n    public BMResultDataProvider(List<BMResult> bmResults) {\r\n        this.bmResults = bmResults;\r\n        setSort(\"bm_id\", true);\r\n    }\r\n\r\n    public Iterator<BMResult> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bmResults, new ValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(bmResults, new ValueComparator(key, false));\r\n        }\r\n        return bmResults.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return bmResults.size();\r\n    }\r\n\r\n    public IModel<BMResult> model(BMResult bmResult) {\r\n        return new DetachableBMResultModel(bmResult);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmresultspage/BMResultDataProvider_1Test.java",
		"test_prompt": "// BMResultDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMResultDataProvider}.\n* It contains ten unit test cases for the {@link BMResultDataProvider#size()} method.\n*/\nclass BMResultDataProvider_1Test {"
	},
	{
		"original_code": "// BMResultDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMResultDataProvider extends SortableDataProvider<BMResult> {\r\n\r\n    private final static Logger log = new Logger(BMResultDataProvider.class);\r\n\r\n    private final List<BMResult> bmResults;\r\n\r\n    public BMResultDataProvider(List<BMResult> bmResults) {\r\n        this.bmResults = bmResults;\r\n        setSort(\"bm_id\", true);\r\n    }\r\n\r\n    public Iterator<BMResult> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bmResults, new ValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(bmResults, new ValueComparator(key, false));\r\n        }\r\n        return bmResults.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return bmResults.size();\r\n    }\r\n\r\n    public IModel<BMResult> model(BMResult bmResult) {\r\n        return new DetachableBMResultModel(bmResult);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmresultspage/BMResultDataProvider_2Test.java",
		"test_prompt": "// BMResultDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMResultDataProvider}.\n* It contains ten unit test cases for the {@link BMResultDataProvider#model(BMResult)} method.\n*/\nclass BMResultDataProvider_2Test {"
	},
	{
		"original_code": "// ValueComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ValueComparator implements Comparator<BMReport> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public ValueComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(BMReport result1, BMReport result2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"measure_uri\")) {\r\n            result = result1.getMeasureURI().compareTo(result2.getMeasureURI());\r\n        }\r\n        if (sortKey.equals(\"time\")) {\r\n            result = result1.getMeasureTime().compareTo(result2.getMeasureTime());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmreportspage/ValueComparator.java",
		"test_prompt": "// ValueComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage;\n\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ValueComparator}.\n* It contains ten unit test cases for the {@link ValueComparator#compare(BMReport, BMReport)} method.\n*/\nclass ValueComparatorTest {"
	},
	{
		"original_code": "// BMReportDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.WebUIPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMReportDataProvider extends SortableDataProvider<BMReport> {\r\n\r\n    private final static Logger log = new Logger(BMReportDataProvider.class);\r\n\r\n    private WebUIPlugin webUi;\r\n\r\n    private boolean matchReference;\r\n\r\n    List<BMReport> bmReportsFiltered;\r\n\r\n    public BMReportDataProvider(WebUIPlugin webUi, boolean matchReference) {\r\n        this.webUi = webUi;\r\n        this.matchReference = matchReference;\r\n        setSort(\"measure_uri\", true);\r\n    }\r\n\r\n    public Iterator<BMReport> iterator(int i, int i1) {\r\n        List<BMReport> bmReports = webUi.getBMReports();\r\n        bmReportsFiltered = new ArrayList<BMReport>();\r\n        if (matchReference) {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        } else {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (!bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bmReportsFiltered, new ValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(bmReportsFiltered, new ValueComparator(key, false));\r\n        }\r\n        return bmReportsFiltered.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        List<BMReport> bmReports = webUi.getBMReports();\r\n        bmReportsFiltered = new ArrayList<BMReport>();\r\n        if (matchReference) {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        } else {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (!bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        }\r\n        return bmReportsFiltered.size();\r\n    }\r\n\r\n    public IModel<BMReport> model(BMReport bmReport) {\r\n        return new DetachableBMReportModel(bmReport);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmreportspage/BMReportDataProvider_0Test.java",
		"test_prompt": "// BMReportDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.WebUIPlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMReportDataProvider}.\n* It contains ten unit test cases for the {@link BMReportDataProvider#iterator(int, int)} method.\n*/\nclass BMReportDataProvider_0Test {"
	},
	{
		"original_code": "// BMReportDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.WebUIPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMReportDataProvider extends SortableDataProvider<BMReport> {\r\n\r\n    private final static Logger log = new Logger(BMReportDataProvider.class);\r\n\r\n    private WebUIPlugin webUi;\r\n\r\n    private boolean matchReference;\r\n\r\n    List<BMReport> bmReportsFiltered;\r\n\r\n    public BMReportDataProvider(WebUIPlugin webUi, boolean matchReference) {\r\n        this.webUi = webUi;\r\n        this.matchReference = matchReference;\r\n        setSort(\"measure_uri\", true);\r\n    }\r\n\r\n    public Iterator<BMReport> iterator(int i, int i1) {\r\n        List<BMReport> bmReports = webUi.getBMReports();\r\n        bmReportsFiltered = new ArrayList<BMReport>();\r\n        if (matchReference) {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        } else {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (!bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bmReportsFiltered, new ValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(bmReportsFiltered, new ValueComparator(key, false));\r\n        }\r\n        return bmReportsFiltered.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        List<BMReport> bmReports = webUi.getBMReports();\r\n        bmReportsFiltered = new ArrayList<BMReport>();\r\n        if (matchReference) {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        } else {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (!bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        }\r\n        return bmReportsFiltered.size();\r\n    }\r\n\r\n    public IModel<BMReport> model(BMReport bmReport) {\r\n        return new DetachableBMReportModel(bmReport);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmreportspage/BMReportDataProvider_1Test.java",
		"test_prompt": "// BMReportDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.WebUIPlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMReportDataProvider}.\n* It contains ten unit test cases for the {@link BMReportDataProvider#size()} method.\n*/\nclass BMReportDataProvider_1Test {"
	},
	{
		"original_code": "// BMReportDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.WebUIPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class BMReportDataProvider extends SortableDataProvider<BMReport> {\r\n\r\n    private final static Logger log = new Logger(BMReportDataProvider.class);\r\n\r\n    private WebUIPlugin webUi;\r\n\r\n    private boolean matchReference;\r\n\r\n    List<BMReport> bmReportsFiltered;\r\n\r\n    public BMReportDataProvider(WebUIPlugin webUi, boolean matchReference) {\r\n        this.webUi = webUi;\r\n        this.matchReference = matchReference;\r\n        setSort(\"measure_uri\", true);\r\n    }\r\n\r\n    public Iterator<BMReport> iterator(int i, int i1) {\r\n        List<BMReport> bmReports = webUi.getBMReports();\r\n        bmReportsFiltered = new ArrayList<BMReport>();\r\n        if (matchReference) {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        } else {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (!bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(bmReportsFiltered, new ValueComparator(key, true));\r\n        } else {\r\n            Collections.sort(bmReportsFiltered, new ValueComparator(key, false));\r\n        }\r\n        return bmReportsFiltered.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        List<BMReport> bmReports = webUi.getBMReports();\r\n        bmReportsFiltered = new ArrayList<BMReport>();\r\n        if (matchReference) {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        } else {\r\n            for (BMReport bmReport : bmReports) {\r\n                if (!bmReport.isMatchReference()) {\r\n                    bmReportsFiltered.add(bmReport);\r\n                }\r\n            }\r\n        }\r\n        return bmReportsFiltered.size();\r\n    }\r\n\r\n    public IModel<BMReport> model(BMReport bmReport) {\r\n        return new DetachableBMReportModel(bmReport);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/bmreportspage/BMReportDataProvider_2Test.java",
		"test_prompt": "// BMReportDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.WebUIPlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMReportDataProvider}.\n* It contains ten unit test cases for the {@link BMReportDataProvider#model(BMReport)} method.\n*/\nclass BMReportDataProvider_2Test {"
	},
	{
		"original_code": "// ValueComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ValueComparator implements Comparator<Value> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public ValueComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(Value v1, Value v2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"measureURI\")) {\r\n            result = v1.getMeasureURI().compareTo(v2.getMeasureURI());\r\n        }\r\n        if (sortKey.equals(\"precision\")) {\r\n            result = v1.getPrecision() - (v2.getPrecision());\r\n        }\r\n        if (sortKey.equals(\"value\")) {\r\n            result = v1.getString().compareTo(v2.getString());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/historypage/ValueComparator.java",
		"test_prompt": "// ValueComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage;\n\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ValueComparator}.\n* It contains ten unit test cases for the {@link ValueComparator#compare(Value, Value)} method.\n*/\nclass ValueComparatorTest {"
	},
	{
		"original_code": "// MeasurementHistoryDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementHistoryDataProvider extends SortableDataProvider<Value> {\r\n\r\n    private transient final static Logger log = new Logger(MeasurementHistoryDataProvider.class);\r\n\r\n    private transient PersistencePlugin persistence;\r\n\r\n    public MeasurementHistoryDataProvider(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n        setSort(Value.SortKey.MEASUREURI.toString(), true);\r\n    }\r\n\r\n    public Iterator<Value> iterator(int first, int count) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        List<Value> values = persistence.getValues(first, count, Value.SortKey.valueOf(key), sp.isAscending());\r\n        //log.debug(\"values:\"+values);\r\n        return values.iterator();\r\n        /*    if (sp.isAscending()) {\r\n      Collections.sort(measures, new ValueComparator(key, true));\r\n    } else {\r\n      Collections.sort(measures, new ValueComparator(key, false));\r\n    }\r\n    return measures.subList(i, i + i1).iterator();*/\r\n    }\r\n\r\n    public int size() {\r\n        int valueCount = persistence.getValueCount();\r\n        log.debug(\"valuecount:\" + valueCount);\r\n        return valueCount;\r\n    }\r\n\r\n    public IModel<Value> model(Value measure) {\r\n        return new DetachableValueModel(measure);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/historypage/MeasurementHistoryDataProvider_0Test.java",
		"test_prompt": "// MeasurementHistoryDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementHistoryDataProvider}.\n* It contains ten unit test cases for the {@link MeasurementHistoryDataProvider#iterator(int, int)} method.\n*/\nclass MeasurementHistoryDataProvider_0Test {"
	},
	{
		"original_code": "// MeasurementHistoryDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementHistoryDataProvider extends SortableDataProvider<Value> {\r\n\r\n    private transient final static Logger log = new Logger(MeasurementHistoryDataProvider.class);\r\n\r\n    private transient PersistencePlugin persistence;\r\n\r\n    public MeasurementHistoryDataProvider(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n        setSort(Value.SortKey.MEASUREURI.toString(), true);\r\n    }\r\n\r\n    public Iterator<Value> iterator(int first, int count) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        List<Value> values = persistence.getValues(first, count, Value.SortKey.valueOf(key), sp.isAscending());\r\n        //log.debug(\"values:\"+values);\r\n        return values.iterator();\r\n        /*    if (sp.isAscending()) {\r\n      Collections.sort(measures, new ValueComparator(key, true));\r\n    } else {\r\n      Collections.sort(measures, new ValueComparator(key, false));\r\n    }\r\n    return measures.subList(i, i + i1).iterator();*/\r\n    }\r\n\r\n    public int size() {\r\n        int valueCount = persistence.getValueCount();\r\n        log.debug(\"valuecount:\" + valueCount);\r\n        return valueCount;\r\n    }\r\n\r\n    public IModel<Value> model(Value measure) {\r\n        return new DetachableValueModel(measure);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/historypage/MeasurementHistoryDataProvider_1Test.java",
		"test_prompt": "// MeasurementHistoryDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementHistoryDataProvider}.\n* It contains ten unit test cases for the {@link MeasurementHistoryDataProvider#size()} method.\n*/\nclass MeasurementHistoryDataProvider_1Test {"
	},
	{
		"original_code": "// MeasurementHistoryDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementHistoryDataProvider extends SortableDataProvider<Value> {\r\n\r\n    private transient final static Logger log = new Logger(MeasurementHistoryDataProvider.class);\r\n\r\n    private transient PersistencePlugin persistence;\r\n\r\n    public MeasurementHistoryDataProvider(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n        setSort(Value.SortKey.MEASUREURI.toString(), true);\r\n    }\r\n\r\n    public Iterator<Value> iterator(int first, int count) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        List<Value> values = persistence.getValues(first, count, Value.SortKey.valueOf(key), sp.isAscending());\r\n        //log.debug(\"values:\"+values);\r\n        return values.iterator();\r\n        /*    if (sp.isAscending()) {\r\n      Collections.sort(measures, new ValueComparator(key, true));\r\n    } else {\r\n      Collections.sort(measures, new ValueComparator(key, false));\r\n    }\r\n    return measures.subList(i, i + i1).iterator();*/\r\n    }\r\n\r\n    public int size() {\r\n        int valueCount = persistence.getValueCount();\r\n        log.debug(\"valuecount:\" + valueCount);\r\n        return valueCount;\r\n    }\r\n\r\n    public IModel<Value> model(Value measure) {\r\n        return new DetachableValueModel(measure);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/historypage/MeasurementHistoryDataProvider_2Test.java",
		"test_prompt": "// MeasurementHistoryDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.historypage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementHistoryDataProvider}.\n* It contains ten unit test cases for the {@link MeasurementHistoryDataProvider#model(Value)} method.\n*/\nclass MeasurementHistoryDataProvider_2Test {"
	},
	{
		"original_code": "// ProbeInformationDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ProbeInformationDataProvider extends SortableDataProvider<WicketValuePair> {\r\n\r\n    private final static Logger log = new Logger(ProbeInformationDataProvider.class);\r\n\r\n    private List<WicketValuePair> rows;\r\n\r\n    public ProbeInformationDataProvider() {\r\n        rows = new ArrayList<WicketValuePair>();\r\n        setSort(\"key\", true);\r\n    }\r\n\r\n    public void setProbe(ProbeListItem probe) {\r\n        rows.clear();\r\n        addRow(\"endpoint\", probe.getEndpoint());\r\n        addRow(\"measureURI\", probe.getMeasureURI());\r\n        addRow(\"probeName\", probe.getProbeName());\r\n        addRow(\"precision\", \"\" + probe.getPrecision());\r\n    }\r\n\r\n    private void addRow(String key, String value) {\r\n        WicketValuePair pair = new WicketValuePair(key, value);\r\n        rows.add(pair);\r\n    }\r\n\r\n    public Iterator<? extends WicketValuePair> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        log.debug(\"sort:\" + sp);\r\n        String key = sp.getProperty();\r\n        log.debug(\"xx sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(rows, new ValuePairComparator(key, true));\r\n        } else {\r\n            Collections.sort(rows, new ValuePairComparator(key, false));\r\n        }\r\n        return rows.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return rows.size();\r\n    }\r\n\r\n    public IModel<WicketValuePair> model(WicketValuePair valuePair) {\r\n        return new DetachableValuePairModel(valuePair);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probelistpage/ProbeInformationDataProvider_0Test.java",
		"test_prompt": "// ProbeInformationDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeInformationDataProvider}.\n* It contains ten unit test cases for the {@link ProbeInformationDataProvider#iterator(int, int)} method.\n*/\nclass ProbeInformationDataProvider_0Test {"
	},
	{
		"original_code": "// ProbeInformationDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ProbeInformationDataProvider extends SortableDataProvider<WicketValuePair> {\r\n\r\n    private final static Logger log = new Logger(ProbeInformationDataProvider.class);\r\n\r\n    private List<WicketValuePair> rows;\r\n\r\n    public ProbeInformationDataProvider() {\r\n        rows = new ArrayList<WicketValuePair>();\r\n        setSort(\"key\", true);\r\n    }\r\n\r\n    public void setProbe(ProbeListItem probe) {\r\n        rows.clear();\r\n        addRow(\"endpoint\", probe.getEndpoint());\r\n        addRow(\"measureURI\", probe.getMeasureURI());\r\n        addRow(\"probeName\", probe.getProbeName());\r\n        addRow(\"precision\", \"\" + probe.getPrecision());\r\n    }\r\n\r\n    private void addRow(String key, String value) {\r\n        WicketValuePair pair = new WicketValuePair(key, value);\r\n        rows.add(pair);\r\n    }\r\n\r\n    public Iterator<? extends WicketValuePair> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        log.debug(\"sort:\" + sp);\r\n        String key = sp.getProperty();\r\n        log.debug(\"xx sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(rows, new ValuePairComparator(key, true));\r\n        } else {\r\n            Collections.sort(rows, new ValuePairComparator(key, false));\r\n        }\r\n        return rows.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return rows.size();\r\n    }\r\n\r\n    public IModel<WicketValuePair> model(WicketValuePair valuePair) {\r\n        return new DetachableValuePairModel(valuePair);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probelistpage/ProbeInformationDataProvider_1Test.java",
		"test_prompt": "// ProbeInformationDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeInformationDataProvider}.\n* It contains ten unit test cases for the {@link ProbeInformationDataProvider#size()} method.\n*/\nclass ProbeInformationDataProvider_1Test {"
	},
	{
		"original_code": "// ProbeInformationDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ProbeInformationDataProvider extends SortableDataProvider<WicketValuePair> {\r\n\r\n    private final static Logger log = new Logger(ProbeInformationDataProvider.class);\r\n\r\n    private List<WicketValuePair> rows;\r\n\r\n    public ProbeInformationDataProvider() {\r\n        rows = new ArrayList<WicketValuePair>();\r\n        setSort(\"key\", true);\r\n    }\r\n\r\n    public void setProbe(ProbeListItem probe) {\r\n        rows.clear();\r\n        addRow(\"endpoint\", probe.getEndpoint());\r\n        addRow(\"measureURI\", probe.getMeasureURI());\r\n        addRow(\"probeName\", probe.getProbeName());\r\n        addRow(\"precision\", \"\" + probe.getPrecision());\r\n    }\r\n\r\n    private void addRow(String key, String value) {\r\n        WicketValuePair pair = new WicketValuePair(key, value);\r\n        rows.add(pair);\r\n    }\r\n\r\n    public Iterator<? extends WicketValuePair> iterator(int i, int i1) {\r\n        SortParam sp = getSort();\r\n        log.debug(\"sort:\" + sp);\r\n        String key = sp.getProperty();\r\n        log.debug(\"xx sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(rows, new ValuePairComparator(key, true));\r\n        } else {\r\n            Collections.sort(rows, new ValuePairComparator(key, false));\r\n        }\r\n        return rows.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return rows.size();\r\n    }\r\n\r\n    public IModel<WicketValuePair> model(WicketValuePair valuePair) {\r\n        return new DetachableValuePairModel(valuePair);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probelistpage/ProbeInformationDataProvider_2Test.java",
		"test_prompt": "// ProbeInformationDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeInformationDataProvider}.\n* It contains ten unit test cases for the {@link ProbeInformationDataProvider#model(WicketValuePair)} method.\n*/\nclass ProbeInformationDataProvider_2Test {"
	},
	{
		"original_code": "// ValuePairComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\r\n\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ValuePairComparator implements Comparator<WicketValuePair> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public ValuePairComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(WicketValuePair vp, WicketValuePair vp2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"key\")) {\r\n            result = vp.getKey().compareTo(vp2.getKey());\r\n        }\r\n        if (sortKey.equals(\"value\")) {\r\n            result = vp.getValue().compareTo(vp2.getValue());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probelistpage/ValuePairComparator.java",
		"test_prompt": "// ValuePairComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\n\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ValuePairComparator}.\n* It contains ten unit test cases for the {@link ValuePairComparator#compare(WicketValuePair, WicketValuePair)} method.\n*/\nclass ValuePairComparatorTest {"
	},
	{
		"original_code": "// ProbeComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\r\n\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstr�n\r\n */\r\npublic class ProbeComparator implements Comparator<ProbeListItem> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public ProbeComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(ProbeListItem a1, ProbeListItem a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"probeId\")) {\r\n            result = (int) (a1.getProbeId() - (a2.getProbeId()));\r\n        }\r\n        if (sortKey.equals(\"bmName\")) {\r\n            result = a1.getBmName().compareTo(a2.getBmName());\r\n        }\r\n        if (sortKey.equals(\"measureURI\")) {\r\n            result = a1.getMeasureURI().compareTo(a2.getMeasureURI());\r\n        }\r\n        if (sortKey.equals(\"delay\")) {\r\n            result = a1.getDelay() - (a2.getDelay());\r\n        }\r\n        if (sortKey.equals(\"probeName\")) {\r\n            result = a1.getProbeName().compareTo(a2.getProbeName());\r\n        }\r\n        if (sortKey.equals(\"precision\")) {\r\n            result = a1.getPrecision() - (a2.getPrecision());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probelistpage/ProbeComparator.java",
		"test_prompt": "// ProbeComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\n\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeComparator}.\n* It contains ten unit test cases for the {@link ProbeComparator#compare(ProbeListItem, ProbeListItem)} method.\n*/\nclass ProbeComparatorTest {"
	},
	{
		"original_code": "// ProbeListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ProbeListDataProvider extends SortableDataProvider<ProbeListItem> {\r\n\r\n    private final static Logger log = new Logger(ProbeListDataProvider.class);\r\n\r\n    private RegistryPlugin registry;\r\n\r\n    public ProbeListDataProvider(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n        setSort(\"endpoint\", true);\r\n    }\r\n\r\n    public Iterator<ProbeListItem> iterator(int i, int i1) {\r\n        List<ProbeDescription> registeredProbes = registry.getProbes();\r\n        List<ProbeListItem> probes = new ArrayList<ProbeListItem>(registeredProbes.size());\r\n        for (ProbeDescription probe : registeredProbes) {\r\n            probes.add(new ProbeListItem(probe));\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(probes, new ProbeComparator(key, true));\r\n        } else {\r\n            Collections.sort(probes, new ProbeComparator(key, false));\r\n        }\r\n        return probes.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return registry.getProbes().size();\r\n    }\r\n\r\n    public IModel<ProbeListItem> model(ProbeListItem probe) {\r\n        return new DetachableProbeModel(probe);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probelistpage/ProbeListDataProvider_0Test.java",
		"test_prompt": "// ProbeListDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeListDataProvider}.\n* It contains ten unit test cases for the {@link ProbeListDataProvider#iterator(int, int)} method.\n*/\nclass ProbeListDataProvider_0Test {"
	},
	{
		"original_code": "// ProbeListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ProbeListDataProvider extends SortableDataProvider<ProbeListItem> {\r\n\r\n    private final static Logger log = new Logger(ProbeListDataProvider.class);\r\n\r\n    private RegistryPlugin registry;\r\n\r\n    public ProbeListDataProvider(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n        setSort(\"endpoint\", true);\r\n    }\r\n\r\n    public Iterator<ProbeListItem> iterator(int i, int i1) {\r\n        List<ProbeDescription> registeredProbes = registry.getProbes();\r\n        List<ProbeListItem> probes = new ArrayList<ProbeListItem>(registeredProbes.size());\r\n        for (ProbeDescription probe : registeredProbes) {\r\n            probes.add(new ProbeListItem(probe));\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(probes, new ProbeComparator(key, true));\r\n        } else {\r\n            Collections.sort(probes, new ProbeComparator(key, false));\r\n        }\r\n        return probes.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return registry.getProbes().size();\r\n    }\r\n\r\n    public IModel<ProbeListItem> model(ProbeListItem probe) {\r\n        return new DetachableProbeModel(probe);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probelistpage/ProbeListDataProvider_1Test.java",
		"test_prompt": "// ProbeListDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeListDataProvider}.\n* It contains ten unit test cases for the {@link ProbeListDataProvider#size()} method.\n*/\nclass ProbeListDataProvider_1Test {"
	},
	{
		"original_code": "// ProbeListDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Iterator;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class ProbeListDataProvider extends SortableDataProvider<ProbeListItem> {\r\n\r\n    private final static Logger log = new Logger(ProbeListDataProvider.class);\r\n\r\n    private RegistryPlugin registry;\r\n\r\n    public ProbeListDataProvider(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n        setSort(\"endpoint\", true);\r\n    }\r\n\r\n    public Iterator<ProbeListItem> iterator(int i, int i1) {\r\n        List<ProbeDescription> registeredProbes = registry.getProbes();\r\n        List<ProbeListItem> probes = new ArrayList<ProbeListItem>(registeredProbes.size());\r\n        for (ProbeDescription probe : registeredProbes) {\r\n            probes.add(new ProbeListItem(probe));\r\n        }\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        if (sp.isAscending()) {\r\n            Collections.sort(probes, new ProbeComparator(key, true));\r\n        } else {\r\n            Collections.sort(probes, new ProbeComparator(key, false));\r\n        }\r\n        return probes.subList(i, i + i1).iterator();\r\n    }\r\n\r\n    public int size() {\r\n        return registry.getProbes().size();\r\n    }\r\n\r\n    public IModel<ProbeListItem> model(ProbeListItem probe) {\r\n        return new DetachableProbeModel(probe);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/probelistpage/ProbeListDataProvider_2Test.java",
		"test_prompt": "// ProbeListDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.probelistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeListDataProvider}.\n* It contains ten unit test cases for the {@link ProbeListDataProvider#model(ProbeListItem)} method.\n*/\nclass ProbeListDataProvider_2Test {"
	},
	{
		"original_code": "// WebUIPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui;\r\n\r\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage.BMReportsStorage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResult;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResultsStorage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.DMMonitorPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.Availability;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.MFW;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.MFWClient;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameters;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.apache.felix.http.api.ExtHttpService;\r\nimport org.osgi.framework.BundleContext;\r\nimport org.osgi.framework.Constants;\r\nimport org.osgi.framework.InvalidSyntaxException;\r\nimport org.osgi.framework.ServiceReference;\r\nimport org.osgi.service.http.HttpService;\r\nimport javax.servlet.ServletException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Hashtable;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Provides a browser-based UI to see and manage information about the MFW operation. Uses the OSGI HTTP service\r\n * as the web-server.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class WebUIPlugin extends BasePlugin implements ServerUser, RegistryUser {\r\n\r\n    private final static Logger log = new Logger(WebUIPlugin.class);\r\n\r\n    //service itself..\r\n    private static WebUIPlugin webui = null;\r\n\r\n    //stores dm values and provides access to them on the DM page\r\n    private DMMonitorPlugin dmMonitor = null;\r\n\r\n    //  private AlertLabel alert = null;\r\n    private boolean initialized = false;\r\n\r\n    private BMResultsStorage bmresults;\r\n\r\n    private MFWClient mfwClient;\r\n\r\n    private ServerPlugin server;\r\n\r\n    private BMReportsStorage bmreports;\r\n\r\n    private Map<String, String> latestValues = new HashMap<String, String>();\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        //    this.registry = registry;\r\n    }\r\n\r\n    public static WebUIPlugin getInstance() {\r\n        return webui;\r\n    }\r\n\r\n    public BundleContext getBundleContext() {\r\n        return bc;\r\n    }\r\n\r\n    public WebUIPlugin(BundleContext bc) {\r\n        super(bc, log);\r\n        webui = this;\r\n        //we add listener here since init() can be called multiple times\r\n        HttpServiceListener listener = new HttpServiceListener(bc, this);\r\n        bc.addServiceListener(listener);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener registryListener = new RegistryServiceListener(bc, log, this);\r\n        registryListener.init();\r\n        bmresults = new BMResultsStorage();\r\n        bmreports = new BMReportsStorage();\r\n    }\r\n\r\n    public Set getCommands() {\r\n        return createCommandSet(BMReport.class, Value.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof BMReport) {\r\n            BMReport bmReport = (BMReport) data;\r\n            log.debug(\"received bm report:\" + bmReport);\r\n            bmreports.addBMReport(bmReport);\r\n        }\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            String uri = value.getMeasureURI();\r\n            latestValues.put(uri, value.getString());\r\n        }\r\n    }\r\n\r\n    public void terminate() {\r\n        //here we should put any code needed to remove something that was done in the \"init\" method.\r\n        //this happens when the httpservice is de-registered and later re-registered (new init() call)\r\n        initialized = false;\r\n    }\r\n\r\n    public void init() {\r\n        if (initialized) {\r\n            return;\r\n        }\r\n        try {\r\n            ServiceReference[] srs = bc.getAllServiceReferences(null, null);\r\n            log.debug(\"HTTP NAME:\" + HttpService.class.getName());\r\n            for (ServiceReference sr : srs) {\r\n                String[] names = (String[]) sr.getProperty(Constants.OBJECTCLASS);\r\n                for (String name : names) {\r\n                    log.debug(\"Service:\" + name);\r\n                }\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            log.error(\"Failed to read service names\", e);\r\n        }\r\n        ServiceReference sRef = bc.getServiceReference(HttpService.class.getName());\r\n        if (sRef != null) {\r\n            log.debug(\"Starting servlet\");\r\n            ExtHttpService service = (ExtHttpService) bc.getService(sRef);\r\n            /*\r\n      try {\r\n        service.registerServlet(\"/hello\", new WebUIServlet(), null, null);\r\n      } catch (Exception e) {\r\n        e.printStackTrace();\r\n      }*/\r\n            Hashtable<String, String> props = new Hashtable<String, String>();\r\n            props.put(\"applicationClassName\", WebUIWicketApplication.class.getName());\r\n            //      props.put(\"filterMappingUrlPattern\", \"/ui/*\");\r\n            try {\r\n                //grab all requests for any URL and pass them to Wicket\r\n                //        service.registerFilter(new WebUIWicketFilter(), \"/ui/.*\", props, 0, null);\r\n                service.registerFilter(new WebUIWicketFilter(), \"/.*\", props, 0, null);\r\n            } catch (ServletException e) {\r\n                log.error(\"Failed to register Wicket filter and start WebUI\", e);\r\n            }\r\n            initialized = true;\r\n            log.debug(\"wicket started\");\r\n        } else {\r\n            log.debug(\"Failed to start Wicket: No HTTP service found\");\r\n        }\r\n    }\r\n\r\n    public Blackboard locateBlackboard() {\r\n        return bb;\r\n    }\r\n\r\n    public DMMonitorPlugin getDMMonitor() {\r\n        return dmMonitor;\r\n    }\r\n\r\n    public void setDMMonitor(DMMonitorPlugin dmMonitor) {\r\n        this.dmMonitor = dmMonitor;\r\n    }\r\n\r\n    public List<BMResult> getBMResults() {\r\n        return bmresults.getBmResults();\r\n    }\r\n\r\n    public void addBMResult(BMResult bm) {\r\n        bmresults.addBMResult(bm);\r\n    }\r\n\r\n    public List<ProbeParameter> getProbeParameters(long probeId) {\r\n        List<ProbeParameter> params = new ArrayList<ProbeParameter>();\r\n        ProbeParameters parameters = mfwClient.getProbeParamaters(probeId);\r\n        if (parameters != null) {\r\n            for (ProbeParameter parameter : parameters.getProbeParameter()) {\r\n                params.add(parameter);\r\n            }\r\n        }\r\n        return params;\r\n    }\r\n\r\n    public void setProbeParameter(long probeId, String paramName, String paramValue) {\r\n        mfwClient.setProbeParamaters(probeId, paramName, paramValue);\r\n    }\r\n\r\n    public Availability getAvailability() {\r\n        Availability availability = mfwClient.getAvailability();\r\n        return availability;\r\n    }\r\n\r\n    public void registerMFWClient(MFWClient mfwClient2) {\r\n        mfwClient = mfwClient2;\r\n    }\r\n\r\n    public void subscribeToBM(long bmId, long deviceId, long frequency) {\r\n        if (frequency == 0) {\r\n            mfwClient.requestBM(bmId, deviceId);\r\n        } else if (frequency > 0) {\r\n            mfwClient.subscribeToBM(bmId, deviceId, frequency);\r\n        }\r\n    }\r\n\r\n    public void unsubscribeToBM(long bmId, long deviceId) {\r\n        mfwClient.unsubscribeToBM(bmId, deviceId);\r\n    }\r\n\r\n    public Map<String, String> getLatestValues() {\r\n        return latestValues;\r\n    }\r\n\r\n    public MFW getMFWInformation() {\r\n        MFW mfwInfo = mfwClient.getMFW();\r\n        return mfwInfo;\r\n    }\r\n\r\n    public void setReference(BMReport bmReport) {\r\n        server.setReference(bmReport.getSubscriptionId(), bmReport.getCurrentValue());\r\n    }\r\n\r\n    public List<BMReport> getBMReports() {\r\n        return bmreports.getBmReports();\r\n    }\r\n\r\n    public void addBMReport(BMReport bmReport) {\r\n        bmreports.addBMReport(bmReport);\r\n    }\r\n\r\n    public void clearBMReports() {\r\n        bmreports = new BMReportsStorage();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/WebUIPlugin_0Test.java",
		"test_prompt": "// WebUIPlugin_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui;\n\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage.BMReportsStorage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResult;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResultsStorage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.DMMonitorPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.Availability;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.MFW;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.MFWClient;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameters;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.apache.felix.http.api.ExtHttpService;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.Constants;\nimport org.osgi.framework.InvalidSyntaxException;\nimport org.osgi.framework.ServiceReference;\nimport org.osgi.service.http.HttpService;\nimport javax.servlet.ServletException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUIPlugin}.\n* It contains ten unit test cases for the {@link WebUIPlugin#getInstance()} method.\n*/\nclass WebUIPlugin_0Test {"
	},
	{
		"original_code": "// WebUIPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui;\r\n\r\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage.BMReportsStorage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResult;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResultsStorage;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.DMMonitorPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.Availability;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.MFW;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.MFWClient;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameters;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport org.apache.felix.http.api.ExtHttpService;\r\nimport org.osgi.framework.BundleContext;\r\nimport org.osgi.framework.Constants;\r\nimport org.osgi.framework.InvalidSyntaxException;\r\nimport org.osgi.framework.ServiceReference;\r\nimport org.osgi.service.http.HttpService;\r\nimport javax.servlet.ServletException;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Hashtable;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\n/**\r\n * Provides a browser-based UI to see and manage information about the MFW operation. Uses the OSGI HTTP service\r\n * as the web-server.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class WebUIPlugin extends BasePlugin implements ServerUser, RegistryUser {\r\n\r\n    private final static Logger log = new Logger(WebUIPlugin.class);\r\n\r\n    //service itself..\r\n    private static WebUIPlugin webui = null;\r\n\r\n    //stores dm values and provides access to them on the DM page\r\n    private DMMonitorPlugin dmMonitor = null;\r\n\r\n    //  private AlertLabel alert = null;\r\n    private boolean initialized = false;\r\n\r\n    private BMResultsStorage bmresults;\r\n\r\n    private MFWClient mfwClient;\r\n\r\n    private ServerPlugin server;\r\n\r\n    private BMReportsStorage bmreports;\r\n\r\n    private Map<String, String> latestValues = new HashMap<String, String>();\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        //    this.registry = registry;\r\n    }\r\n\r\n    public static WebUIPlugin getInstance() {\r\n        return webui;\r\n    }\r\n\r\n    public BundleContext getBundleContext() {\r\n        return bc;\r\n    }\r\n\r\n    public WebUIPlugin(BundleContext bc) {\r\n        super(bc, log);\r\n        webui = this;\r\n        //we add listener here since init() can be called multiple times\r\n        HttpServiceListener listener = new HttpServiceListener(bc, this);\r\n        bc.addServiceListener(listener);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener registryListener = new RegistryServiceListener(bc, log, this);\r\n        registryListener.init();\r\n        bmresults = new BMResultsStorage();\r\n        bmreports = new BMReportsStorage();\r\n    }\r\n\r\n    public Set getCommands() {\r\n        return createCommandSet(BMReport.class, Value.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof BMReport) {\r\n            BMReport bmReport = (BMReport) data;\r\n            log.debug(\"received bm report:\" + bmReport);\r\n            bmreports.addBMReport(bmReport);\r\n        }\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            String uri = value.getMeasureURI();\r\n            latestValues.put(uri, value.getString());\r\n        }\r\n    }\r\n\r\n    public void terminate() {\r\n        //here we should put any code needed to remove something that was done in the \"init\" method.\r\n        //this happens when the httpservice is de-registered and later re-registered (new init() call)\r\n        initialized = false;\r\n    }\r\n\r\n    public void init() {\r\n        if (initialized) {\r\n            return;\r\n        }\r\n        try {\r\n            ServiceReference[] srs = bc.getAllServiceReferences(null, null);\r\n            log.debug(\"HTTP NAME:\" + HttpService.class.getName());\r\n            for (ServiceReference sr : srs) {\r\n                String[] names = (String[]) sr.getProperty(Constants.OBJECTCLASS);\r\n                for (String name : names) {\r\n                    log.debug(\"Service:\" + name);\r\n                }\r\n            }\r\n        } catch (InvalidSyntaxException e) {\r\n            log.error(\"Failed to read service names\", e);\r\n        }\r\n        ServiceReference sRef = bc.getServiceReference(HttpService.class.getName());\r\n        if (sRef != null) {\r\n            log.debug(\"Starting servlet\");\r\n            ExtHttpService service = (ExtHttpService) bc.getService(sRef);\r\n            /*\r\n      try {\r\n        service.registerServlet(\"/hello\", new WebUIServlet(), null, null);\r\n      } catch (Exception e) {\r\n        e.printStackTrace();\r\n      }*/\r\n            Hashtable<String, String> props = new Hashtable<String, String>();\r\n            props.put(\"applicationClassName\", WebUIWicketApplication.class.getName());\r\n            //      props.put(\"filterMappingUrlPattern\", \"/ui/*\");\r\n            try {\r\n                //grab all requests for any URL and pass them to Wicket\r\n                //        service.registerFilter(new WebUIWicketFilter(), \"/ui/.*\", props, 0, null);\r\n                service.registerFilter(new WebUIWicketFilter(), \"/.*\", props, 0, null);\r\n            } catch (ServletException e) {\r\n                log.error(\"Failed to register Wicket filter and start WebUI\", e);\r\n            }\r\n            initialized = true;\r\n            log.debug(\"wicket started\");\r\n        } else {\r\n            log.debug(\"Failed to start Wicket: No HTTP service found\");\r\n        }\r\n    }\r\n\r\n    public Blackboard locateBlackboard() {\r\n        return bb;\r\n    }\r\n\r\n    public DMMonitorPlugin getDMMonitor() {\r\n        return dmMonitor;\r\n    }\r\n\r\n    public void setDMMonitor(DMMonitorPlugin dmMonitor) {\r\n        this.dmMonitor = dmMonitor;\r\n    }\r\n\r\n    public List<BMResult> getBMResults() {\r\n        return bmresults.getBmResults();\r\n    }\r\n\r\n    public void addBMResult(BMResult bm) {\r\n        bmresults.addBMResult(bm);\r\n    }\r\n\r\n    public List<ProbeParameter> getProbeParameters(long probeId) {\r\n        List<ProbeParameter> params = new ArrayList<ProbeParameter>();\r\n        ProbeParameters parameters = mfwClient.getProbeParamaters(probeId);\r\n        if (parameters != null) {\r\n            for (ProbeParameter parameter : parameters.getProbeParameter()) {\r\n                params.add(parameter);\r\n            }\r\n        }\r\n        return params;\r\n    }\r\n\r\n    public void setProbeParameter(long probeId, String paramName, String paramValue) {\r\n        mfwClient.setProbeParamaters(probeId, paramName, paramValue);\r\n    }\r\n\r\n    public Availability getAvailability() {\r\n        Availability availability = mfwClient.getAvailability();\r\n        return availability;\r\n    }\r\n\r\n    public void registerMFWClient(MFWClient mfwClient2) {\r\n        mfwClient = mfwClient2;\r\n    }\r\n\r\n    public void subscribeToBM(long bmId, long deviceId, long frequency) {\r\n        if (frequency == 0) {\r\n            mfwClient.requestBM(bmId, deviceId);\r\n        } else if (frequency > 0) {\r\n            mfwClient.subscribeToBM(bmId, deviceId, frequency);\r\n        }\r\n    }\r\n\r\n    public void unsubscribeToBM(long bmId, long deviceId) {\r\n        mfwClient.unsubscribeToBM(bmId, deviceId);\r\n    }\r\n\r\n    public Map<String, String> getLatestValues() {\r\n        return latestValues;\r\n    }\r\n\r\n    public MFW getMFWInformation() {\r\n        MFW mfwInfo = mfwClient.getMFW();\r\n        return mfwInfo;\r\n    }\r\n\r\n    public void setReference(BMReport bmReport) {\r\n        server.setReference(bmReport.getSubscriptionId(), bmReport.getCurrentValue());\r\n    }\r\n\r\n    public List<BMReport> getBMReports() {\r\n        return bmreports.getBmReports();\r\n    }\r\n\r\n    public void addBMReport(BMReport bmReport) {\r\n        bmreports.addBMReport(bmReport);\r\n    }\r\n\r\n    public void clearBMReports() {\r\n        bmreports = new BMReportsStorage();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/WebUIPlugin_1Test.java",
		"test_prompt": "// WebUIPlugin_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui;\n\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmreportspage.BMReportsStorage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResult;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.bmresultspage.BMResultsStorage;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.derivedmeasurepage.DMMonitorPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.Availability;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.MFW;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.MFWClient;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameter;\nimport fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient.ProbeParameters;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.apache.felix.http.api.ExtHttpService;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.Constants;\nimport org.osgi.framework.InvalidSyntaxException;\nimport org.osgi.framework.ServiceReference;\nimport org.osgi.service.http.HttpService;\nimport javax.servlet.ServletException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link WebUIPlugin}.\n* It contains ten unit test cases for the {@link WebUIPlugin#locateBlackboard()} method.\n*/\nclass WebUIPlugin_1Test {"
	},
	{
		"original_code": "// EventComparator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class EventComparator implements Comparator<ServerEvent> {\r\n\r\n    private final String sortKey;\r\n\r\n    private final boolean ascending;\r\n\r\n    public EventComparator(String sortKey, boolean ascending) {\r\n        this.sortKey = sortKey;\r\n        this.ascending = ascending;\r\n    }\r\n\r\n    public int compare(ServerEvent a1, ServerEvent a2) {\r\n        int result = 0;\r\n        if (sortKey.equals(\"time\")) {\r\n            result = a1.getTimeString().compareTo(a2.getTimeString());\r\n        }\r\n        if (sortKey.equals(\"message\")) {\r\n            result = a1.getMessage().compareTo(a2.getMessage());\r\n        }\r\n        if (!ascending) {\r\n            result = 0 - result;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/eventlistpage/EventComparator.java",
		"test_prompt": "// EventComparatorTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage;\n\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport java.util.Comparator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EventComparator}.\n* It contains ten unit test cases for the {@link EventComparator#compare(ServerEvent, ServerEvent)} method.\n*/\nclass EventComparatorTest {"
	},
	{
		"original_code": "// EventHistoryDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class EventHistoryDataProvider extends SortableDataProvider<ServerEvent> {\r\n\r\n    private final static Logger log = new Logger(EventHistoryDataProvider.class);\r\n\r\n    private PersistencePlugin persistence;\r\n\r\n    public EventHistoryDataProvider(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n        setSort(ServerEvent.SortKey.TIME.toString(), true);\r\n    }\r\n\r\n    public Iterator<ServerEvent> iterator(int i1, int i2) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        return persistence.getEvents(i1, i2, ServerEvent.SortKey.valueOf(key), sp.isAscending()).iterator();\r\n        /*    if (sp.isAscending()) {\r\n      Collections.sort(events, new EventComparator(key, true));\r\n    } else {\r\n      Collections.sort(events, new EventComparator(key, false));\r\n    }\r\n    return events.subList(i, i + i1).iterator();*/\r\n    }\r\n\r\n    public int size() {\r\n        return persistence.getEventCount();\r\n    }\r\n\r\n    public IModel<ServerEvent> model(ServerEvent event) {\r\n        return new DetachableEventModel(event);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/eventlistpage/EventHistoryDataProvider_0Test.java",
		"test_prompt": "// EventHistoryDataProvider_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EventHistoryDataProvider}.\n* It contains ten unit test cases for the {@link EventHistoryDataProvider#iterator(int, int)} method.\n*/\nclass EventHistoryDataProvider_0Test {"
	},
	{
		"original_code": "// EventHistoryDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class EventHistoryDataProvider extends SortableDataProvider<ServerEvent> {\r\n\r\n    private final static Logger log = new Logger(EventHistoryDataProvider.class);\r\n\r\n    private PersistencePlugin persistence;\r\n\r\n    public EventHistoryDataProvider(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n        setSort(ServerEvent.SortKey.TIME.toString(), true);\r\n    }\r\n\r\n    public Iterator<ServerEvent> iterator(int i1, int i2) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        return persistence.getEvents(i1, i2, ServerEvent.SortKey.valueOf(key), sp.isAscending()).iterator();\r\n        /*    if (sp.isAscending()) {\r\n      Collections.sort(events, new EventComparator(key, true));\r\n    } else {\r\n      Collections.sort(events, new EventComparator(key, false));\r\n    }\r\n    return events.subList(i, i + i1).iterator();*/\r\n    }\r\n\r\n    public int size() {\r\n        return persistence.getEventCount();\r\n    }\r\n\r\n    public IModel<ServerEvent> model(ServerEvent event) {\r\n        return new DetachableEventModel(event);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/eventlistpage/EventHistoryDataProvider_1Test.java",
		"test_prompt": "// EventHistoryDataProvider_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EventHistoryDataProvider}.\n* It contains ten unit test cases for the {@link EventHistoryDataProvider#size()} method.\n*/\nclass EventHistoryDataProvider_1Test {"
	},
	{
		"original_code": "// EventHistoryDataProvider.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\r\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\r\nimport org.apache.wicket.model.IModel;\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class EventHistoryDataProvider extends SortableDataProvider<ServerEvent> {\r\n\r\n    private final static Logger log = new Logger(EventHistoryDataProvider.class);\r\n\r\n    private PersistencePlugin persistence;\r\n\r\n    public EventHistoryDataProvider(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n        setSort(ServerEvent.SortKey.TIME.toString(), true);\r\n    }\r\n\r\n    public Iterator<ServerEvent> iterator(int i1, int i2) {\r\n        SortParam sp = getSort();\r\n        String key = sp.getProperty();\r\n        log.debug(\"sort key:\" + key);\r\n        return persistence.getEvents(i1, i2, ServerEvent.SortKey.valueOf(key), sp.isAscending()).iterator();\r\n        /*    if (sp.isAscending()) {\r\n      Collections.sort(events, new EventComparator(key, true));\r\n    } else {\r\n      Collections.sort(events, new EventComparator(key, false));\r\n    }\r\n    return events.subList(i, i + i1).iterator();*/\r\n    }\r\n\r\n    public int size() {\r\n        return persistence.getEventCount();\r\n    }\r\n\r\n    public IModel<ServerEvent> model(ServerEvent event) {\r\n        return new DetachableEventModel(event);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/eventlistpage/EventHistoryDataProvider_2Test.java",
		"test_prompt": "// EventHistoryDataProvider_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.eventlistpage;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortableDataProvider;\nimport org.apache.wicket.model.IModel;\nimport java.util.Iterator;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EventHistoryDataProvider}.\n* It contains ten unit test cases for the {@link EventHistoryDataProvider#model(ServerEvent)} method.\n*/\nclass EventHistoryDataProvider_2Test {"
	},
	{
		"original_code": "// BM.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element name=\"device_id\" type=\"{http://www.w3.org/2001/XMLSchema}long\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"class\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"description\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\", propOrder = { \"deviceId\" })\r\n@XmlRootElement(name = \"BM\")\r\npublic class BM {\r\n\r\n    @XmlElement(name = \"device_id\", namespace = \"\", type = Long.class)\r\n    protected List<Long> deviceId;\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"class\")\r\n    protected String clazz;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"description\")\r\n    protected String description;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the deviceId property.\r\n     *\r\n     * <p>\r\n     * This accessor method returns a reference to the live list,\r\n     * not a snapshot. Therefore any modification you make to the\r\n     * returned list will be present inside the JAXB object.\r\n     * This is why there is not a <CODE>set</CODE> method for the deviceId property.\r\n     *\r\n     * <p>\r\n     * For example, to add a new item, do as follows:\r\n     * <pre>\r\n     *    getDeviceId().add(newItem);\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Objects of the following type(s) are allowed in the list\r\n     * {@link Long }\r\n     */\r\n    public List<Long> getDeviceId() {\r\n        if (deviceId == null) {\r\n            deviceId = new ArrayList<Long>();\r\n        }\r\n        return this.deviceId;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the clazz property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getClazz() {\r\n        return clazz;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the clazz property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setClazz(String value) {\r\n        this.clazz = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the description property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the description property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setDescription(String value) {\r\n        this.description = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/BM.java",
		"test_prompt": "// BMTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BM}.\n* It contains ten unit test cases for the {@link BM#isDisabled()} method.\n*/\nclass BMTest {"
	},
	{
		"original_code": "// ProbeParameter.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"name\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"description\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"mandatory\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *       &lt;attribute name=\"value\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"ProbeParameter\")\r\npublic class ProbeParameter {\r\n\r\n    @XmlAttribute(name = \"name\", required = true)\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"description\", required = true)\r\n    protected String description;\r\n\r\n    @XmlAttribute(name = \"mandatory\", required = true)\r\n    protected boolean mandatory;\r\n\r\n    @XmlAttribute(name = \"value\", required = true)\r\n    protected String value;\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the description property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the description property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setDescription(String value) {\r\n        this.description = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the mandatory property.\r\n     */\r\n    public boolean isMandatory() {\r\n        return mandatory;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the mandatory property.\r\n     */\r\n    public void setMandatory(boolean value) {\r\n        this.mandatory = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the value property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the value property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ProbeParameter.java",
		"test_prompt": "// ProbeParameterTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeParameter}.\n* It contains ten unit test cases for the {@link ProbeParameter#isMandatory()} method.\n*/\nclass ProbeParameterTest {"
	},
	{
		"original_code": "// MFWClient.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.xml.namespace.QName;\r\nimport java.net.URL;\r\n\r\npublic final class MFWClient {\r\n\r\n    private final static Logger log = new Logger(MFWClient.class);\r\n\r\n    private static final QName SERVICE_NAME = new QName(\"http://www.bugyobeyond.org/SAC_MFW/\", \"SAC_MFW_service\");\r\n\r\n    private URL wsdlURL;\r\n\r\n    private SACMFWService ss;\r\n\r\n    private SACMFW port;\r\n\r\n    private final long sacId;\r\n\r\n    public MFWClient(String mfwURL, long sacId) {\r\n        wsdlURL = SACMFWService.WSDL_LOCATION;\r\n        ss = new SACMFWService(wsdlURL, SERVICE_NAME);\r\n        port = ss.getSACMFW(mfwURL);\r\n        this.sacId = sacId;\r\n    }\r\n\r\n    public MFW getMFW() {\r\n        try {\r\n            log.debug(\"Invoking getMFW web service\");\r\n            GetMFW getMFW = new GetMFW();\r\n            getMFW.setSacId(sacId);\r\n            MFW mfwInfo = port.getMFW(getMFW);\r\n            return mfwInfo;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public boolean requestBM(long bmId, long deviceId) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(0);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean subscribeToBM(long bmId, long deviceId, long frequency) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(frequency);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean unsubscribeToBM(long bmId, long deviceId) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(-1);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public ProbeParameters getProbeParamaters(long probeId) {\r\n        log.debug(\"Invoking getProbeParameters web service\");\r\n        try {\r\n            ProbeParametersRequest request = new ProbeParametersRequest();\r\n            request.setSacId(sacId);\r\n            request.setProbeId(probeId);\r\n            ProbeParameters result = port.getProbeParameters(request);\r\n            return result;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public boolean setProbeParamaters(long probeId, String name, String value) {\r\n        log.debug(\"Invoking setProbeParameters web service\");\r\n        try {\r\n            ProbeParameterValues request = new ProbeParameterValues();\r\n            request.setSacId(sacId);\r\n            request.setProbeId(probeId);\r\n            ProbeParameterValue paramValue = new ProbeParameterValue();\r\n            paramValue.setName(name);\r\n            paramValue.setValue(value);\r\n            request.getProbeParameterValue().add(paramValue);\r\n            OperationResult result = port.setProbeParameters(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public Availability getAvailability() {\r\n        try {\r\n            log.debug(\"Invoking getAvailability web service\");\r\n            GetAvailability request = new GetAvailability();\r\n            request.setSacId(sacId);\r\n            Availability availability = null;\r\n            try {\r\n                availability = port.getAvailability(request);\r\n            } catch (Exception e) {\r\n                log.debug(\"Failed to invoke getAvailability web service. Exception occured\");\r\n                e.printStackTrace();\r\n            }\r\n            return availability;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/MFWClient_0Test.java",
		"test_prompt": "// MFWClient_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.xml.namespace.QName;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MFWClient}.\n* It contains ten unit test cases for the {@link MFWClient#requestBM(long, long)} method.\n*/\nclass MFWClient_0Test {"
	},
	{
		"original_code": "// MFWClient.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.xml.namespace.QName;\r\nimport java.net.URL;\r\n\r\npublic final class MFWClient {\r\n\r\n    private final static Logger log = new Logger(MFWClient.class);\r\n\r\n    private static final QName SERVICE_NAME = new QName(\"http://www.bugyobeyond.org/SAC_MFW/\", \"SAC_MFW_service\");\r\n\r\n    private URL wsdlURL;\r\n\r\n    private SACMFWService ss;\r\n\r\n    private SACMFW port;\r\n\r\n    private final long sacId;\r\n\r\n    public MFWClient(String mfwURL, long sacId) {\r\n        wsdlURL = SACMFWService.WSDL_LOCATION;\r\n        ss = new SACMFWService(wsdlURL, SERVICE_NAME);\r\n        port = ss.getSACMFW(mfwURL);\r\n        this.sacId = sacId;\r\n    }\r\n\r\n    public MFW getMFW() {\r\n        try {\r\n            log.debug(\"Invoking getMFW web service\");\r\n            GetMFW getMFW = new GetMFW();\r\n            getMFW.setSacId(sacId);\r\n            MFW mfwInfo = port.getMFW(getMFW);\r\n            return mfwInfo;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public boolean requestBM(long bmId, long deviceId) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(0);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean subscribeToBM(long bmId, long deviceId, long frequency) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(frequency);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean unsubscribeToBM(long bmId, long deviceId) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(-1);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public ProbeParameters getProbeParamaters(long probeId) {\r\n        log.debug(\"Invoking getProbeParameters web service\");\r\n        try {\r\n            ProbeParametersRequest request = new ProbeParametersRequest();\r\n            request.setSacId(sacId);\r\n            request.setProbeId(probeId);\r\n            ProbeParameters result = port.getProbeParameters(request);\r\n            return result;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public boolean setProbeParamaters(long probeId, String name, String value) {\r\n        log.debug(\"Invoking setProbeParameters web service\");\r\n        try {\r\n            ProbeParameterValues request = new ProbeParameterValues();\r\n            request.setSacId(sacId);\r\n            request.setProbeId(probeId);\r\n            ProbeParameterValue paramValue = new ProbeParameterValue();\r\n            paramValue.setName(name);\r\n            paramValue.setValue(value);\r\n            request.getProbeParameterValue().add(paramValue);\r\n            OperationResult result = port.setProbeParameters(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public Availability getAvailability() {\r\n        try {\r\n            log.debug(\"Invoking getAvailability web service\");\r\n            GetAvailability request = new GetAvailability();\r\n            request.setSacId(sacId);\r\n            Availability availability = null;\r\n            try {\r\n                availability = port.getAvailability(request);\r\n            } catch (Exception e) {\r\n                log.debug(\"Failed to invoke getAvailability web service. Exception occured\");\r\n                e.printStackTrace();\r\n            }\r\n            return availability;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/MFWClient_1Test.java",
		"test_prompt": "// MFWClient_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.xml.namespace.QName;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MFWClient}.\n* It contains ten unit test cases for the {@link MFWClient#subscribeToBM(long, long, long)} method.\n*/\nclass MFWClient_1Test {"
	},
	{
		"original_code": "// MFWClient.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.xml.namespace.QName;\r\nimport java.net.URL;\r\n\r\npublic final class MFWClient {\r\n\r\n    private final static Logger log = new Logger(MFWClient.class);\r\n\r\n    private static final QName SERVICE_NAME = new QName(\"http://www.bugyobeyond.org/SAC_MFW/\", \"SAC_MFW_service\");\r\n\r\n    private URL wsdlURL;\r\n\r\n    private SACMFWService ss;\r\n\r\n    private SACMFW port;\r\n\r\n    private final long sacId;\r\n\r\n    public MFWClient(String mfwURL, long sacId) {\r\n        wsdlURL = SACMFWService.WSDL_LOCATION;\r\n        ss = new SACMFWService(wsdlURL, SERVICE_NAME);\r\n        port = ss.getSACMFW(mfwURL);\r\n        this.sacId = sacId;\r\n    }\r\n\r\n    public MFW getMFW() {\r\n        try {\r\n            log.debug(\"Invoking getMFW web service\");\r\n            GetMFW getMFW = new GetMFW();\r\n            getMFW.setSacId(sacId);\r\n            MFW mfwInfo = port.getMFW(getMFW);\r\n            return mfwInfo;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public boolean requestBM(long bmId, long deviceId) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(0);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean subscribeToBM(long bmId, long deviceId, long frequency) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(frequency);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public boolean unsubscribeToBM(long bmId, long deviceId) {\r\n        try {\r\n            log.debug(\"Invoking getBMResults web service\");\r\n            BMResultsRequest request = new BMResultsRequest();\r\n            request.setSacId(sacId);\r\n            BMResultRequest req = new BMResultRequest();\r\n            req.setFrequency(-1);\r\n            req.setId(bmId);\r\n            req.getDeviceId().add(deviceId);\r\n            request.getBMResultRequest().add(req);\r\n            OperationResult result = port.getBMResults(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public ProbeParameters getProbeParamaters(long probeId) {\r\n        log.debug(\"Invoking getProbeParameters web service\");\r\n        try {\r\n            ProbeParametersRequest request = new ProbeParametersRequest();\r\n            request.setSacId(sacId);\r\n            request.setProbeId(probeId);\r\n            ProbeParameters result = port.getProbeParameters(request);\r\n            return result;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public boolean setProbeParamaters(long probeId, String name, String value) {\r\n        log.debug(\"Invoking setProbeParameters web service\");\r\n        try {\r\n            ProbeParameterValues request = new ProbeParameterValues();\r\n            request.setSacId(sacId);\r\n            request.setProbeId(probeId);\r\n            ProbeParameterValue paramValue = new ProbeParameterValue();\r\n            paramValue.setName(name);\r\n            paramValue.setValue(value);\r\n            request.getProbeParameterValue().add(paramValue);\r\n            OperationResult result = port.setProbeParameters(request);\r\n            if (result.isError()) {\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public Availability getAvailability() {\r\n        try {\r\n            log.debug(\"Invoking getAvailability web service\");\r\n            GetAvailability request = new GetAvailability();\r\n            request.setSacId(sacId);\r\n            Availability availability = null;\r\n            try {\r\n                availability = port.getAvailability(request);\r\n            } catch (Exception e) {\r\n                log.debug(\"Failed to invoke getAvailability web service. Exception occured\");\r\n                e.printStackTrace();\r\n            }\r\n            return availability;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return null;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/MFWClient_2Test.java",
		"test_prompt": "// MFWClient_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.xml.namespace.QName;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MFWClient}.\n* It contains ten unit test cases for the {@link MFWClient#unsubscribeToBM(long, long)} method.\n*/\nclass MFWClient_2Test {"
	},
	{
		"original_code": "// Probe.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;sequence>\r\n *         &lt;element name=\"bm_id\" type=\"{http://www.w3.org/2001/XMLSchema}long\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\r\n *       &lt;/sequence>\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\", propOrder = { \"bmId\" })\r\n@XmlRootElement(name = \"Probe\")\r\npublic class Probe {\r\n\r\n    @XmlElement(name = \"bm_id\", namespace = \"\", type = Long.class)\r\n    protected List<Long> bmId;\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the bmId property.\r\n     *\r\n     * <p>\r\n     * This accessor method returns a reference to the live list,\r\n     * not a snapshot. Therefore any modification you make to the\r\n     * returned list will be present inside the JAXB object.\r\n     * This is why there is not a <CODE>set</CODE> method for the bmId property.\r\n     *\r\n     * <p>\r\n     * For example, to add a new item, do as follows:\r\n     * <pre>\r\n     *    getBmId().add(newItem);\r\n     * </pre>\r\n     *\r\n     * <p>\r\n     * Objects of the following type(s) are allowed in the list\r\n     * {@link Long }\r\n     */\r\n    public List<Long> getBmId() {\r\n        if (bmId == null) {\r\n            bmId = new ArrayList<Long>();\r\n        }\r\n        return this.bmId;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/Probe.java",
		"test_prompt": "// ProbeTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Probe}.\n* It contains ten unit test cases for the {@link Probe#isDisabled()} method.\n*/\nclass ProbeTest {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_0Test.java",
		"test_prompt": "// ObjectFactory_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createOperationResult()} method.\n*/\nclass ObjectFactory_0Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_1Test.java",
		"test_prompt": "// ObjectFactory_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createMFW()} method.\n*/\nclass ObjectFactory_1Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_2Test.java",
		"test_prompt": "// ObjectFactory_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createDevice()} method.\n*/\nclass ObjectFactory_2Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_3Test.java",
		"test_prompt": "// ObjectFactory_3Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createGetMFW()} method.\n*/\nclass ObjectFactory_3Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_4Test.java",
		"test_prompt": "// ObjectFactory_4Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createGetAvailability()} method.\n*/\nclass ObjectFactory_4Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_5Test.java",
		"test_prompt": "// ObjectFactory_5Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbe()} method.\n*/\nclass ObjectFactory_5Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_6Test.java",
		"test_prompt": "// ObjectFactory_6Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParameter()} method.\n*/\nclass ObjectFactory_6Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_7Test.java",
		"test_prompt": "// ObjectFactory_7Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParameters()} method.\n*/\nclass ObjectFactory_7Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_8Test.java",
		"test_prompt": "// ObjectFactory_8Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParameterValue()} method.\n*/\nclass ObjectFactory_8Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_9Test.java",
		"test_prompt": "// ObjectFactory_9Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createAvailability()} method.\n*/\nclass ObjectFactory_9Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_10Test.java",
		"test_prompt": "// ObjectFactory_10Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBM()} method.\n*/\nclass ObjectFactory_10Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_11Test.java",
		"test_prompt": "// ObjectFactory_11Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParametersRequest()} method.\n*/\nclass ObjectFactory_11Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_12Test.java",
		"test_prompt": "// ObjectFactory_12Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResultRequest()} method.\n*/\nclass ObjectFactory_12Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_13Test.java",
		"test_prompt": "// ObjectFactory_13Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createBMResultsRequest()} method.\n*/\nclass ObjectFactory_13Test {"
	},
	{
		"original_code": "// ObjectFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlRegistry;\r\n\r\n/**\r\n * This object contains factory methods for each\r\n * Java content interface and Java element interface\r\n * generated in the fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient package.\r\n * <p>An ObjectFactory allows you to programatically\r\n * construct new instances of the Java representation\r\n * for XML content. The Java representation of XML\r\n * content can consist of schema derived interfaces\r\n * and classes representing the binding of schema\r\n * type definitions, element declarations and model\r\n * groups.  Factory methods for each of these are\r\n * provided in this class.\r\n */\r\n@XmlRegistry\r\npublic class ObjectFactory {\r\n\r\n    /**\r\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: fi.vtt.noen.mfw.bundle.server.plugins.webui.sacpage.mfwclient\r\n     */\r\n    public ObjectFactory() {\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link OperationResult }\r\n     */\r\n    public OperationResult createOperationResult() {\r\n        return new OperationResult();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link MFW }\r\n     */\r\n    public MFW createMFW() {\r\n        return new MFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Device }\r\n     */\r\n    public Device createDevice() {\r\n        return new Device();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetMFW }\r\n     */\r\n    public GetMFW createGetMFW() {\r\n        return new GetMFW();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link GetAvailability }\r\n     */\r\n    public GetAvailability createGetAvailability() {\r\n        return new GetAvailability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Probe }\r\n     */\r\n    public Probe createProbe() {\r\n        return new Probe();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameter }\r\n     */\r\n    public ProbeParameter createProbeParameter() {\r\n        return new ProbeParameter();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameters }\r\n     */\r\n    public ProbeParameters createProbeParameters() {\r\n        return new ProbeParameters();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValue }\r\n     */\r\n    public ProbeParameterValue createProbeParameterValue() {\r\n        return new ProbeParameterValue();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link Availability }\r\n     */\r\n    public Availability createAvailability() {\r\n        return new Availability();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BM }\r\n     */\r\n    public BM createBM() {\r\n        return new BM();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParametersRequest }\r\n     */\r\n    public ProbeParametersRequest createProbeParametersRequest() {\r\n        return new ProbeParametersRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultRequest }\r\n     */\r\n    public BMResultRequest createBMResultRequest() {\r\n        return new BMResultRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link BMResultsRequest }\r\n     */\r\n    public BMResultsRequest createBMResultsRequest() {\r\n        return new BMResultsRequest();\r\n    }\r\n\r\n    /**\r\n     * Create an instance of {@link ProbeParameterValues }\r\n     */\r\n    public ProbeParameterValues createProbeParameterValues() {\r\n        return new ProbeParameterValues();\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/ObjectFactory_14Test.java",
		"test_prompt": "// ObjectFactory_14Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlRegistry;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ObjectFactory}.\n* It contains ten unit test cases for the {@link ObjectFactory#createProbeParameterValues()} method.\n*/\nclass ObjectFactory_14Test {"
	},
	{
		"original_code": "// Device.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"id\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}long\" />\r\n *       &lt;attribute name=\"name\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"type\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *       &lt;attribute name=\"disabled\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"Device\")\r\npublic class Device {\r\n\r\n    @XmlAttribute(name = \"id\", required = true)\r\n    protected long id;\r\n\r\n    @XmlAttribute(name = \"name\")\r\n    protected String name;\r\n\r\n    @XmlAttribute(name = \"type\")\r\n    protected String type;\r\n\r\n    @XmlAttribute(name = \"disabled\")\r\n    protected Boolean disabled;\r\n\r\n    /**\r\n     * Gets the value of the id property.\r\n     */\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the id property.\r\n     */\r\n    public void setId(long value) {\r\n        this.id = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the name property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the name property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setName(String value) {\r\n        this.name = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the type property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the type property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     */\r\n    public void setType(String value) {\r\n        this.type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the disabled property.\r\n     *\r\n     * @return\r\n     *     possible object is\r\n     *     {@link Boolean }\r\n     */\r\n    public Boolean isDisabled() {\r\n        return disabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the disabled property.\r\n     *\r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link Boolean }\r\n     */\r\n    public void setDisabled(Boolean value) {\r\n        this.disabled = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/Device.java",
		"test_prompt": "// DeviceTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Device}.\n* It contains ten unit test cases for the {@link Device#isDisabled()} method.\n*/\nclass DeviceTest {"
	},
	{
		"original_code": "// OperationResult.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n *\r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n *\r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"error\" use=\"required\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"OperationResult\")\r\npublic class OperationResult {\r\n\r\n    @XmlAttribute(name = \"error\", required = true)\r\n    protected boolean error;\r\n\r\n    /**\r\n     * Gets the value of the error property.\r\n     */\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the error property.\r\n     */\r\n    public void setError(boolean value) {\r\n        this.error = value;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/webui/mfwclient/OperationResult.java",
		"test_prompt": "// OperationResultTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.webui.mfwclient;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OperationResult}.\n* It contains ten unit test cases for the {@link OperationResult#isError()} method.\n*/\nclass OperationResultTest {"
	},
	{
		"original_code": "// ServerPluginImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeAgent;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\nimport java.net.URL;\r\nimport java.util.Collection;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * A facade to forward requests to the client. Whereas the ServerAgentImpl is the server-agent that the\r\n * probe-agent communicates with, this would be the part that the client (e.g. SAC) interacts with.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class ServerPluginImpl extends BasePlugin implements ServerPlugin, RegistryUser {\r\n\r\n    private final static Logger log = new Logger(ServerPluginImpl.class);\r\n\r\n    private RegistryPlugin registry;\r\n\r\n    private final Map<String, ProbeAgent> probeEndpoints = new HashMap<String, ProbeAgent>();\r\n\r\n    private ProbeAgent localLink = null;\r\n\r\n    private Boolean localInUse = false;\r\n\r\n    public ServerPluginImpl(BundleContext bc, Boolean localInUse) {\r\n        super(bc, log);\r\n        this.localInUse = localInUse;\r\n    }\r\n\r\n    public void start() {\r\n        RegistryServiceListener rl = new RegistryServiceListener(bc, log, this);\r\n        rl.init();\r\n        ProbeAgentListener pl = new ProbeAgentListener(bc, this);\r\n        pl.init();\r\n        if (localInUse != null) {\r\n            return;\r\n        }\r\n        try {\r\n            InputStream in = new FileInputStream(Const.CONFIGURATION_FILENAME);\r\n            Properties props = new Properties();\r\n            props.load(in);\r\n            if (props.getProperty(Const.LOCAL_LINK_IN_USE) != null) {\r\n                this.localInUse = true;\r\n            }\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"Failed to read configuration file '\" + Const.CONFIGURATION_FILENAME + \"'\", e);\r\n        }\r\n    }\r\n\r\n    public void setLocalLink(ProbeAgent localLink) {\r\n        this.localLink = localLink;\r\n    }\r\n\r\n    public synchronized void requestBM(long bmId, long subscriptionId) {\r\n        ProbeDescription desc = registry.getProbeForBM(bmId);\r\n        if (desc == null) {\r\n            throw new IllegalArgumentException(\"No probe available for bmid:\" + bmId);\r\n        }\r\n        ProbeAgent probe = getProbeFor(desc);\r\n        log.debug(\"Requesting bm:\" + bmId);\r\n        probe.requestMeasure(desc.getMeasureURI(), subscriptionId);\r\n    }\r\n\r\n    public synchronized void subscribeToBM(long bmId, long frequency, long subscriptionId) {\r\n        ProbeDescription desc = registry.getProbeForBM(bmId);\r\n        if (desc == null) {\r\n            throw new IllegalArgumentException(\"No probe available for bmid:\" + bmId);\r\n        }\r\n        ProbeAgent probe = getProbeFor(desc);\r\n        log.debug(\"Requesting bm:\" + bmId);\r\n        probe.subscribe(desc.getMeasureURI(), frequency, subscriptionId);\r\n    }\r\n\r\n    public synchronized void unSubscribeToBM(long bmId, long subscriptionId) {\r\n        ProbeDescription desc = registry.getProbeForBM(bmId);\r\n        if (desc == null) {\r\n            throw new IllegalArgumentException(\"No probe available for bmid:\" + bmId);\r\n        }\r\n        ProbeAgent probe = getProbeFor(desc);\r\n        log.debug(\"Requesting bm:\" + bmId);\r\n        probe.unSubscribe(desc.getMeasureURI(), subscriptionId);\r\n    }\r\n\r\n    public synchronized void unSubscribeToBM(ProbeDescription probeDescription, Long subscriptionId) {\r\n        ProbeAgent probe = getProbeFor(probeDescription);\r\n        log.debug(\"unSubscribeToBM\");\r\n        probe.unSubscribe(probeDescription.getMeasureURI(), subscriptionId);\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        ProbeDescription desc = registry.getProbeFor(probeId);\r\n        ProbeAgent probe = getProbeFor(desc);\r\n        probe.setConfiguration(probeId, configuration);\r\n        return true;\r\n    }\r\n\r\n    private ProbeAgent getProbeFor(ProbeDescription desc) {\r\n        String endpoint = desc.getEndpoint();\r\n        if (endpoint.equals(Const.LOCAL_LINK_ENDPOINT_URL)) {\r\n            //    if (localInUse) {\r\n            return localLink;\r\n        }\r\n        ProbeAgent probe = probeEndpoints.get(endpoint);\r\n        if (probe == null) {\r\n            try {\r\n                probe = new XmlRpcProbeClient(new URL(endpoint));\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(\"Unable to create XMLRPC connection to probe for URL:\" + endpoint, e);\r\n            }\r\n            probeEndpoints.put(endpoint, probe);\r\n        }\r\n        return probe;\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> requestProbeConfigurationParameters(long probeId) {\r\n        ProbeDescription desc = registry.getProbeFor(probeId);\r\n        ProbeAgent probe = getProbeFor(desc);\r\n        log.debug(\"probe:\" + probe);\r\n        return probe.getConfigurationParameters(probeId);\r\n    }\r\n\r\n    public void setReference(long subscriptionId, String reference) {\r\n        ProbeDescription desc = registry.getProbeForSubscription(subscriptionId);\r\n        ProbeAgent probe = getProbeFor(desc);\r\n        log.debug(\"probe:\" + probe);\r\n        probe.setReference(subscriptionId, reference);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/xmlrpc/ServerPluginImpl.java",
		"test_prompt": "// ServerPluginImplTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeAgent;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport org.osgi.framework.BundleContext;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerPluginImpl}.\n* It contains ten unit test cases for the {@link ServerPluginImpl#requestProbeConfigurationParameters(long)} method.\n*/\nclass ServerPluginImplTest {"
	},
	{
		"original_code": "// MfwXmlRpcServlet.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.xmlrpc.XmlRpcException;\r\nimport org.apache.xmlrpc.server.PropertyHandlerMapping;\r\nimport org.apache.xmlrpc.server.XmlRpcHandlerMapping;\r\nimport org.apache.xmlrpc.server.XmlRpcServerConfigImpl;\r\nimport org.apache.xmlrpc.webserver.XmlRpcServlet;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class MfwXmlRpcServlet extends XmlRpcServlet {\r\n\r\n    private final static Logger log = new Logger(MfwXmlRpcServlet.class);\r\n\r\n    private static ThreadLocal<String> clientIpAddress = new ThreadLocal<String>();\r\n\r\n    private final PropertyHandlerMapping handler;\r\n\r\n    public MfwXmlRpcServlet(PropertyHandlerMapping handler) {\r\n        this.handler = handler;\r\n    }\r\n\r\n    public static String getClientIp() {\r\n        String ip = clientIpAddress.get();\r\n        return ip;\r\n    }\r\n\r\n    @Override\r\n    public void doPost(HttpServletRequest pRequest, HttpServletResponse pResponse) throws IOException, ServletException {\r\n        try {\r\n            XmlRpcServerConfigImpl config = (XmlRpcServerConfigImpl) getXmlRpcServletServer().getConfig();\r\n            config.setEnabledForExceptions(true);\r\n            String clientIp = pRequest.getRemoteAddr();\r\n            clientIpAddress.set(clientIp);\r\n            //    clientPort.set(pRequest.getRemotePort());\r\n            //      log.debug(\"POST request is in processing\");\r\n            super.doPost(pRequest, pResponse);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while handling XMLRPC POST message\", e);\r\n        }\r\n        //    log.debug(\"POST has been processed\");\r\n    }\r\n\r\n    @Override\r\n    protected XmlRpcHandlerMapping newXmlRpcHandlerMapping() throws XmlRpcException {\r\n        return handler;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/xmlrpc/MfwXmlRpcServlet.java",
		"test_prompt": "// MfwXmlRpcServletTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.xmlrpc.XmlRpcException;\nimport org.apache.xmlrpc.server.PropertyHandlerMapping;\nimport org.apache.xmlrpc.server.XmlRpcHandlerMapping;\nimport org.apache.xmlrpc.server.XmlRpcServerConfigImpl;\nimport org.apache.xmlrpc.webserver.XmlRpcServlet;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MfwXmlRpcServlet}.\n* It contains ten unit test cases for the {@link MfwXmlRpcServlet#getClientIp()} method.\n*/\nclass MfwXmlRpcServletTest {"
	},
	{
		"original_code": "// ServerAgentImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Implements the basic server-bundle functionality for probe-agents to connect to. The ServerPluginImpl provides\r\n * the interface for the client (e.g. SAC) to connect to.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class ServerAgentImpl extends BasePlugin implements ServerAgent, RegistryUser {\r\n\r\n    private final static Logger log = new Logger(ServerAgentImpl.class);\r\n\r\n    //is this started? to avoid several starts if we get several calls from OSGI\r\n    private boolean started = false;\r\n\r\n    //http server to listen to for xmlrpc messages\r\n    private XmlRpcServerServer server;\r\n\r\n    //access to overall runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //where we listen to for xmlrpc messages\r\n    private final int port;\r\n\r\n    private boolean localInUse = false;\r\n\r\n    public ServerAgentImpl(BundleContext bc, int port, Boolean localInUse) {\r\n        super(bc, log);\r\n        if (localInUse != null) {\r\n            this.localInUse = localInUse;\r\n        }\r\n        //localinuse is non-null in testing\r\n        if (port <= 0 && localInUse == null) {\r\n            try {\r\n                InputStream in = new FileInputStream(Const.CONFIGURATION_FILENAME);\r\n                Properties props = new Properties();\r\n                props.load(in);\r\n                port = Integer.parseInt(props.getProperty(Const.SERVER_AGENT_PORT_KEY));\r\n                if (props.getProperty(Const.LOCAL_LINK_IN_USE) != null) {\r\n                    this.localInUse = true;\r\n                }\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"Failed to read configuration file '\" + Const.CONFIGURATION_FILENAME + \"'\", e);\r\n            } catch (NumberFormatException ne) {\r\n                log.error(\"Unable to parse port number from configuration. Assuming local connection.\", ne);\r\n                this.localInUse = true;\r\n            }\r\n        }\r\n        this.port = port;\r\n    }\r\n\r\n    //called from OSGI bundle.start()\r\n    public void startAgent() {\r\n        if (started) {\r\n            throw new IllegalStateException(\"Trying to start the server while already started - cannot be started more than once.\");\r\n        }\r\n        started = true;\r\n        if (port > 0) {\r\n            server = new XmlRpcServerServer(port, this);\r\n            server.start();\r\n        }\r\n        log.debug(\"Started XMLRPC server on port \" + port);\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        log.debug(\"Setting registry:\" + registry);\r\n        this.registry = registry;\r\n    }\r\n\r\n    //called from OSGI bundle.stop()\r\n    public void stopAgent() {\r\n        started = false;\r\n        if (port > 0) {\r\n            server.stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A measurement value from the probe-agent.\r\n     *\r\n     * @param time Measurement time.\r\n     * @param measureURI BM Identifier.\r\n     * @param precision Prevision of measurement.\r\n     * @param data The value itself. Only strings are currently supported, others can be added as needed.\r\n     */\r\n    public boolean measurement(long time, String measureURI, int precision, String data, long subscriptionId) {\r\n        try {\r\n            log.debug(\"received String measure for:\" + measureURI);\r\n            BMDescription bm = registry.descriptionFor(measureURI);\r\n            if (bm == null) {\r\n                return false;\r\n            }\r\n            Value value = new Value(bm, precision, data, time, subscriptionId);\r\n            bb.process(value);\r\n        } catch (Exception e) {\r\n            handleException(e, measureURI, precision, data);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * For probe-agents to report errors. These are basically turned into events noting that it is an error\r\n     * reported from the probe-agent.\r\n     *\r\n     * @param time Time when the event was observed.\r\n     * @param msg The message describing the error/event.\r\n     */\r\n    public void event(long time, String type, String source, String msg, long subscriptionId) {\r\n        ServerEvent event = new ServerEvent(time, EventType.valueOf(type), source, msg, subscriptionId);\r\n        bb.process(event);\r\n    }\r\n\r\n    //a probe-agent noting that it is still alive\r\n    public boolean keepAlive(long probeId) {\r\n        try {\r\n            return registry.processKeepAlive(probeId);\r\n        } catch (Exception e) {\r\n            handleException(e, probeId);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    //a probe-agent registering itself\r\n    public synchronized long register(Map<String, String> properties) {\r\n        log.info(\"Probe is registering:\" + properties);\r\n        try {\r\n            String url = properties.get(Const.XMLRPC_URL);\r\n            //local link means we are making local connect,\r\n            //\"http\" means that the user manually defined the URL in probe-agent configuration\r\n            if (url == null || (!url.equals(Const.LOCAL_LINK_ENDPOINT_URL) && !url.startsWith(\"http://\"))) {\r\n                String port = properties.get(Const.XMLRPC_PORT);\r\n                String ip = MfwXmlRpcServlet.getClientIp();\r\n                String newURL = \"http://\" + ip + \":\" + port + \"/xmlrpc\";\r\n                properties.put(Const.XMLRPC_URL, newURL);\r\n                log.debug(\"set new XMLRPC URL:\" + newURL);\r\n            }\r\n            log.debug(\"Registering with URL:\" + properties.get(Const.XMLRPC_URL));\r\n            long probeId = registry.registerProbe(properties);\r\n            log.debug(\"Registration done:\" + probeId);\r\n            return probeId;\r\n        } catch (Exception e) {\r\n            handleException(e, properties);\r\n            throw new RuntimeException(\"Error in registering probe information\", e);\r\n        }\r\n    }\r\n\r\n    //a probe-agent unregistering itself.. currently not clear what it should do, or if it is needed, so nothing is done\r\n    public void unregister(long probeId) {\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        registry.checkSubscriptions(probeId, subscriptionIds);\r\n    }\r\n\r\n    //log the exception..\r\n    private void handleException(Exception e, Object... data) {\r\n        String parameters = \"::\";\r\n        for (Object param : data) {\r\n            parameters += param;\r\n            parameters += \",\";\r\n        }\r\n        log.error(\"Error processing a message from client:\" + parameters, e);\r\n    }\r\n\r\n    public boolean BMReport(long time, String measureURI, String value, long subscriptionId, boolean matchReference, String reference) {\r\n        try {\r\n            log.debug(\"received BM report for:\" + measureURI);\r\n            log.debug(\"subscriptionId:\" + subscriptionId);\r\n            /*      BMDescription bm = registry.descriptionFor(measureURI);\r\n      if (bm == null) {\r\n        return false;\r\n      }*/\r\n            BMReport bmReport = new BMReport(measureURI, value, time, subscriptionId, matchReference, reference);\r\n            bb.process(bmReport);\r\n        } catch (Exception e) {\r\n            handleException(e, measureURI, value);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/xmlrpc/ServerAgentImpl_0Test.java",
		"test_prompt": "// ServerAgentImpl_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport org.osgi.framework.BundleContext;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerAgentImpl}.\n* It contains ten unit test cases for the {@link ServerAgentImpl#measurement(long, String, int, String, long)} method.\n*/\nclass ServerAgentImpl_0Test {"
	},
	{
		"original_code": "// ServerAgentImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Implements the basic server-bundle functionality for probe-agents to connect to. The ServerPluginImpl provides\r\n * the interface for the client (e.g. SAC) to connect to.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class ServerAgentImpl extends BasePlugin implements ServerAgent, RegistryUser {\r\n\r\n    private final static Logger log = new Logger(ServerAgentImpl.class);\r\n\r\n    //is this started? to avoid several starts if we get several calls from OSGI\r\n    private boolean started = false;\r\n\r\n    //http server to listen to for xmlrpc messages\r\n    private XmlRpcServerServer server;\r\n\r\n    //access to overall runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //where we listen to for xmlrpc messages\r\n    private final int port;\r\n\r\n    private boolean localInUse = false;\r\n\r\n    public ServerAgentImpl(BundleContext bc, int port, Boolean localInUse) {\r\n        super(bc, log);\r\n        if (localInUse != null) {\r\n            this.localInUse = localInUse;\r\n        }\r\n        //localinuse is non-null in testing\r\n        if (port <= 0 && localInUse == null) {\r\n            try {\r\n                InputStream in = new FileInputStream(Const.CONFIGURATION_FILENAME);\r\n                Properties props = new Properties();\r\n                props.load(in);\r\n                port = Integer.parseInt(props.getProperty(Const.SERVER_AGENT_PORT_KEY));\r\n                if (props.getProperty(Const.LOCAL_LINK_IN_USE) != null) {\r\n                    this.localInUse = true;\r\n                }\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"Failed to read configuration file '\" + Const.CONFIGURATION_FILENAME + \"'\", e);\r\n            } catch (NumberFormatException ne) {\r\n                log.error(\"Unable to parse port number from configuration. Assuming local connection.\", ne);\r\n                this.localInUse = true;\r\n            }\r\n        }\r\n        this.port = port;\r\n    }\r\n\r\n    //called from OSGI bundle.start()\r\n    public void startAgent() {\r\n        if (started) {\r\n            throw new IllegalStateException(\"Trying to start the server while already started - cannot be started more than once.\");\r\n        }\r\n        started = true;\r\n        if (port > 0) {\r\n            server = new XmlRpcServerServer(port, this);\r\n            server.start();\r\n        }\r\n        log.debug(\"Started XMLRPC server on port \" + port);\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        log.debug(\"Setting registry:\" + registry);\r\n        this.registry = registry;\r\n    }\r\n\r\n    //called from OSGI bundle.stop()\r\n    public void stopAgent() {\r\n        started = false;\r\n        if (port > 0) {\r\n            server.stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A measurement value from the probe-agent.\r\n     *\r\n     * @param time Measurement time.\r\n     * @param measureURI BM Identifier.\r\n     * @param precision Prevision of measurement.\r\n     * @param data The value itself. Only strings are currently supported, others can be added as needed.\r\n     */\r\n    public boolean measurement(long time, String measureURI, int precision, String data, long subscriptionId) {\r\n        try {\r\n            log.debug(\"received String measure for:\" + measureURI);\r\n            BMDescription bm = registry.descriptionFor(measureURI);\r\n            if (bm == null) {\r\n                return false;\r\n            }\r\n            Value value = new Value(bm, precision, data, time, subscriptionId);\r\n            bb.process(value);\r\n        } catch (Exception e) {\r\n            handleException(e, measureURI, precision, data);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * For probe-agents to report errors. These are basically turned into events noting that it is an error\r\n     * reported from the probe-agent.\r\n     *\r\n     * @param time Time when the event was observed.\r\n     * @param msg The message describing the error/event.\r\n     */\r\n    public void event(long time, String type, String source, String msg, long subscriptionId) {\r\n        ServerEvent event = new ServerEvent(time, EventType.valueOf(type), source, msg, subscriptionId);\r\n        bb.process(event);\r\n    }\r\n\r\n    //a probe-agent noting that it is still alive\r\n    public boolean keepAlive(long probeId) {\r\n        try {\r\n            return registry.processKeepAlive(probeId);\r\n        } catch (Exception e) {\r\n            handleException(e, probeId);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    //a probe-agent registering itself\r\n    public synchronized long register(Map<String, String> properties) {\r\n        log.info(\"Probe is registering:\" + properties);\r\n        try {\r\n            String url = properties.get(Const.XMLRPC_URL);\r\n            //local link means we are making local connect,\r\n            //\"http\" means that the user manually defined the URL in probe-agent configuration\r\n            if (url == null || (!url.equals(Const.LOCAL_LINK_ENDPOINT_URL) && !url.startsWith(\"http://\"))) {\r\n                String port = properties.get(Const.XMLRPC_PORT);\r\n                String ip = MfwXmlRpcServlet.getClientIp();\r\n                String newURL = \"http://\" + ip + \":\" + port + \"/xmlrpc\";\r\n                properties.put(Const.XMLRPC_URL, newURL);\r\n                log.debug(\"set new XMLRPC URL:\" + newURL);\r\n            }\r\n            log.debug(\"Registering with URL:\" + properties.get(Const.XMLRPC_URL));\r\n            long probeId = registry.registerProbe(properties);\r\n            log.debug(\"Registration done:\" + probeId);\r\n            return probeId;\r\n        } catch (Exception e) {\r\n            handleException(e, properties);\r\n            throw new RuntimeException(\"Error in registering probe information\", e);\r\n        }\r\n    }\r\n\r\n    //a probe-agent unregistering itself.. currently not clear what it should do, or if it is needed, so nothing is done\r\n    public void unregister(long probeId) {\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        registry.checkSubscriptions(probeId, subscriptionIds);\r\n    }\r\n\r\n    //log the exception..\r\n    private void handleException(Exception e, Object... data) {\r\n        String parameters = \"::\";\r\n        for (Object param : data) {\r\n            parameters += param;\r\n            parameters += \",\";\r\n        }\r\n        log.error(\"Error processing a message from client:\" + parameters, e);\r\n    }\r\n\r\n    public boolean BMReport(long time, String measureURI, String value, long subscriptionId, boolean matchReference, String reference) {\r\n        try {\r\n            log.debug(\"received BM report for:\" + measureURI);\r\n            log.debug(\"subscriptionId:\" + subscriptionId);\r\n            /*      BMDescription bm = registry.descriptionFor(measureURI);\r\n      if (bm == null) {\r\n        return false;\r\n      }*/\r\n            BMReport bmReport = new BMReport(measureURI, value, time, subscriptionId, matchReference, reference);\r\n            bb.process(bmReport);\r\n        } catch (Exception e) {\r\n            handleException(e, measureURI, value);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/xmlrpc/ServerAgentImpl_1Test.java",
		"test_prompt": "// ServerAgentImpl_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport org.osgi.framework.BundleContext;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerAgentImpl}.\n* It contains ten unit test cases for the {@link ServerAgentImpl#keepAlive(long)} method.\n*/\nclass ServerAgentImpl_1Test {"
	},
	{
		"original_code": "// ServerAgentImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Implements the basic server-bundle functionality for probe-agents to connect to. The ServerPluginImpl provides\r\n * the interface for the client (e.g. SAC) to connect to.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class ServerAgentImpl extends BasePlugin implements ServerAgent, RegistryUser {\r\n\r\n    private final static Logger log = new Logger(ServerAgentImpl.class);\r\n\r\n    //is this started? to avoid several starts if we get several calls from OSGI\r\n    private boolean started = false;\r\n\r\n    //http server to listen to for xmlrpc messages\r\n    private XmlRpcServerServer server;\r\n\r\n    //access to overall runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //where we listen to for xmlrpc messages\r\n    private final int port;\r\n\r\n    private boolean localInUse = false;\r\n\r\n    public ServerAgentImpl(BundleContext bc, int port, Boolean localInUse) {\r\n        super(bc, log);\r\n        if (localInUse != null) {\r\n            this.localInUse = localInUse;\r\n        }\r\n        //localinuse is non-null in testing\r\n        if (port <= 0 && localInUse == null) {\r\n            try {\r\n                InputStream in = new FileInputStream(Const.CONFIGURATION_FILENAME);\r\n                Properties props = new Properties();\r\n                props.load(in);\r\n                port = Integer.parseInt(props.getProperty(Const.SERVER_AGENT_PORT_KEY));\r\n                if (props.getProperty(Const.LOCAL_LINK_IN_USE) != null) {\r\n                    this.localInUse = true;\r\n                }\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"Failed to read configuration file '\" + Const.CONFIGURATION_FILENAME + \"'\", e);\r\n            } catch (NumberFormatException ne) {\r\n                log.error(\"Unable to parse port number from configuration. Assuming local connection.\", ne);\r\n                this.localInUse = true;\r\n            }\r\n        }\r\n        this.port = port;\r\n    }\r\n\r\n    //called from OSGI bundle.start()\r\n    public void startAgent() {\r\n        if (started) {\r\n            throw new IllegalStateException(\"Trying to start the server while already started - cannot be started more than once.\");\r\n        }\r\n        started = true;\r\n        if (port > 0) {\r\n            server = new XmlRpcServerServer(port, this);\r\n            server.start();\r\n        }\r\n        log.debug(\"Started XMLRPC server on port \" + port);\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        log.debug(\"Setting registry:\" + registry);\r\n        this.registry = registry;\r\n    }\r\n\r\n    //called from OSGI bundle.stop()\r\n    public void stopAgent() {\r\n        started = false;\r\n        if (port > 0) {\r\n            server.stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A measurement value from the probe-agent.\r\n     *\r\n     * @param time Measurement time.\r\n     * @param measureURI BM Identifier.\r\n     * @param precision Prevision of measurement.\r\n     * @param data The value itself. Only strings are currently supported, others can be added as needed.\r\n     */\r\n    public boolean measurement(long time, String measureURI, int precision, String data, long subscriptionId) {\r\n        try {\r\n            log.debug(\"received String measure for:\" + measureURI);\r\n            BMDescription bm = registry.descriptionFor(measureURI);\r\n            if (bm == null) {\r\n                return false;\r\n            }\r\n            Value value = new Value(bm, precision, data, time, subscriptionId);\r\n            bb.process(value);\r\n        } catch (Exception e) {\r\n            handleException(e, measureURI, precision, data);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * For probe-agents to report errors. These are basically turned into events noting that it is an error\r\n     * reported from the probe-agent.\r\n     *\r\n     * @param time Time when the event was observed.\r\n     * @param msg The message describing the error/event.\r\n     */\r\n    public void event(long time, String type, String source, String msg, long subscriptionId) {\r\n        ServerEvent event = new ServerEvent(time, EventType.valueOf(type), source, msg, subscriptionId);\r\n        bb.process(event);\r\n    }\r\n\r\n    //a probe-agent noting that it is still alive\r\n    public boolean keepAlive(long probeId) {\r\n        try {\r\n            return registry.processKeepAlive(probeId);\r\n        } catch (Exception e) {\r\n            handleException(e, probeId);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    //a probe-agent registering itself\r\n    public synchronized long register(Map<String, String> properties) {\r\n        log.info(\"Probe is registering:\" + properties);\r\n        try {\r\n            String url = properties.get(Const.XMLRPC_URL);\r\n            //local link means we are making local connect,\r\n            //\"http\" means that the user manually defined the URL in probe-agent configuration\r\n            if (url == null || (!url.equals(Const.LOCAL_LINK_ENDPOINT_URL) && !url.startsWith(\"http://\"))) {\r\n                String port = properties.get(Const.XMLRPC_PORT);\r\n                String ip = MfwXmlRpcServlet.getClientIp();\r\n                String newURL = \"http://\" + ip + \":\" + port + \"/xmlrpc\";\r\n                properties.put(Const.XMLRPC_URL, newURL);\r\n                log.debug(\"set new XMLRPC URL:\" + newURL);\r\n            }\r\n            log.debug(\"Registering with URL:\" + properties.get(Const.XMLRPC_URL));\r\n            long probeId = registry.registerProbe(properties);\r\n            log.debug(\"Registration done:\" + probeId);\r\n            return probeId;\r\n        } catch (Exception e) {\r\n            handleException(e, properties);\r\n            throw new RuntimeException(\"Error in registering probe information\", e);\r\n        }\r\n    }\r\n\r\n    //a probe-agent unregistering itself.. currently not clear what it should do, or if it is needed, so nothing is done\r\n    public void unregister(long probeId) {\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        registry.checkSubscriptions(probeId, subscriptionIds);\r\n    }\r\n\r\n    //log the exception..\r\n    private void handleException(Exception e, Object... data) {\r\n        String parameters = \"::\";\r\n        for (Object param : data) {\r\n            parameters += param;\r\n            parameters += \",\";\r\n        }\r\n        log.error(\"Error processing a message from client:\" + parameters, e);\r\n    }\r\n\r\n    public boolean BMReport(long time, String measureURI, String value, long subscriptionId, boolean matchReference, String reference) {\r\n        try {\r\n            log.debug(\"received BM report for:\" + measureURI);\r\n            log.debug(\"subscriptionId:\" + subscriptionId);\r\n            /*      BMDescription bm = registry.descriptionFor(measureURI);\r\n      if (bm == null) {\r\n        return false;\r\n      }*/\r\n            BMReport bmReport = new BMReport(measureURI, value, time, subscriptionId, matchReference, reference);\r\n            bb.process(bmReport);\r\n        } catch (Exception e) {\r\n            handleException(e, measureURI, value);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/xmlrpc/ServerAgentImpl_2Test.java",
		"test_prompt": "// ServerAgentImpl_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport org.osgi.framework.BundleContext;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerAgentImpl}.\n* It contains ten unit test cases for the {@link ServerAgentImpl#register(Map)} method.\n*/\nclass ServerAgentImpl_2Test {"
	},
	{
		"original_code": "// ServerAgentImpl.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\r\nimport org.osgi.framework.BundleContext;\r\nimport java.io.FileInputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Implements the basic server-bundle functionality for probe-agents to connect to. The ServerPluginImpl provides\r\n * the interface for the client (e.g. SAC) to connect to.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class ServerAgentImpl extends BasePlugin implements ServerAgent, RegistryUser {\r\n\r\n    private final static Logger log = new Logger(ServerAgentImpl.class);\r\n\r\n    //is this started? to avoid several starts if we get several calls from OSGI\r\n    private boolean started = false;\r\n\r\n    //http server to listen to for xmlrpc messages\r\n    private XmlRpcServerServer server;\r\n\r\n    //access to overall runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //where we listen to for xmlrpc messages\r\n    private final int port;\r\n\r\n    private boolean localInUse = false;\r\n\r\n    public ServerAgentImpl(BundleContext bc, int port, Boolean localInUse) {\r\n        super(bc, log);\r\n        if (localInUse != null) {\r\n            this.localInUse = localInUse;\r\n        }\r\n        //localinuse is non-null in testing\r\n        if (port <= 0 && localInUse == null) {\r\n            try {\r\n                InputStream in = new FileInputStream(Const.CONFIGURATION_FILENAME);\r\n                Properties props = new Properties();\r\n                props.load(in);\r\n                port = Integer.parseInt(props.getProperty(Const.SERVER_AGENT_PORT_KEY));\r\n                if (props.getProperty(Const.LOCAL_LINK_IN_USE) != null) {\r\n                    this.localInUse = true;\r\n                }\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"Failed to read configuration file '\" + Const.CONFIGURATION_FILENAME + \"'\", e);\r\n            } catch (NumberFormatException ne) {\r\n                log.error(\"Unable to parse port number from configuration. Assuming local connection.\", ne);\r\n                this.localInUse = true;\r\n            }\r\n        }\r\n        this.port = port;\r\n    }\r\n\r\n    //called from OSGI bundle.start()\r\n    public void startAgent() {\r\n        if (started) {\r\n            throw new IllegalStateException(\"Trying to start the server while already started - cannot be started more than once.\");\r\n        }\r\n        started = true;\r\n        if (port > 0) {\r\n            server = new XmlRpcServerServer(port, this);\r\n            server.start();\r\n        }\r\n        log.debug(\"Started XMLRPC server on port \" + port);\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        log.debug(\"Setting registry:\" + registry);\r\n        this.registry = registry;\r\n    }\r\n\r\n    //called from OSGI bundle.stop()\r\n    public void stopAgent() {\r\n        started = false;\r\n        if (port > 0) {\r\n            server.stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A measurement value from the probe-agent.\r\n     *\r\n     * @param time Measurement time.\r\n     * @param measureURI BM Identifier.\r\n     * @param precision Prevision of measurement.\r\n     * @param data The value itself. Only strings are currently supported, others can be added as needed.\r\n     */\r\n    public boolean measurement(long time, String measureURI, int precision, String data, long subscriptionId) {\r\n        try {\r\n            log.debug(\"received String measure for:\" + measureURI);\r\n            BMDescription bm = registry.descriptionFor(measureURI);\r\n            if (bm == null) {\r\n                return false;\r\n            }\r\n            Value value = new Value(bm, precision, data, time, subscriptionId);\r\n            bb.process(value);\r\n        } catch (Exception e) {\r\n            handleException(e, measureURI, precision, data);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * For probe-agents to report errors. These are basically turned into events noting that it is an error\r\n     * reported from the probe-agent.\r\n     *\r\n     * @param time Time when the event was observed.\r\n     * @param msg The message describing the error/event.\r\n     */\r\n    public void event(long time, String type, String source, String msg, long subscriptionId) {\r\n        ServerEvent event = new ServerEvent(time, EventType.valueOf(type), source, msg, subscriptionId);\r\n        bb.process(event);\r\n    }\r\n\r\n    //a probe-agent noting that it is still alive\r\n    public boolean keepAlive(long probeId) {\r\n        try {\r\n            return registry.processKeepAlive(probeId);\r\n        } catch (Exception e) {\r\n            handleException(e, probeId);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    //a probe-agent registering itself\r\n    public synchronized long register(Map<String, String> properties) {\r\n        log.info(\"Probe is registering:\" + properties);\r\n        try {\r\n            String url = properties.get(Const.XMLRPC_URL);\r\n            //local link means we are making local connect,\r\n            //\"http\" means that the user manually defined the URL in probe-agent configuration\r\n            if (url == null || (!url.equals(Const.LOCAL_LINK_ENDPOINT_URL) && !url.startsWith(\"http://\"))) {\r\n                String port = properties.get(Const.XMLRPC_PORT);\r\n                String ip = MfwXmlRpcServlet.getClientIp();\r\n                String newURL = \"http://\" + ip + \":\" + port + \"/xmlrpc\";\r\n                properties.put(Const.XMLRPC_URL, newURL);\r\n                log.debug(\"set new XMLRPC URL:\" + newURL);\r\n            }\r\n            log.debug(\"Registering with URL:\" + properties.get(Const.XMLRPC_URL));\r\n            long probeId = registry.registerProbe(properties);\r\n            log.debug(\"Registration done:\" + probeId);\r\n            return probeId;\r\n        } catch (Exception e) {\r\n            handleException(e, properties);\r\n            throw new RuntimeException(\"Error in registering probe information\", e);\r\n        }\r\n    }\r\n\r\n    //a probe-agent unregistering itself.. currently not clear what it should do, or if it is needed, so nothing is done\r\n    public void unregister(long probeId) {\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        registry.checkSubscriptions(probeId, subscriptionIds);\r\n    }\r\n\r\n    //log the exception..\r\n    private void handleException(Exception e, Object... data) {\r\n        String parameters = \"::\";\r\n        for (Object param : data) {\r\n            parameters += param;\r\n            parameters += \",\";\r\n        }\r\n        log.error(\"Error processing a message from client:\" + parameters, e);\r\n    }\r\n\r\n    public boolean BMReport(long time, String measureURI, String value, long subscriptionId, boolean matchReference, String reference) {\r\n        try {\r\n            log.debug(\"received BM report for:\" + measureURI);\r\n            log.debug(\"subscriptionId:\" + subscriptionId);\r\n            /*      BMDescription bm = registry.descriptionFor(measureURI);\r\n      if (bm == null) {\r\n        return false;\r\n      }*/\r\n            BMReport bmReport = new BMReport(measureURI, value, time, subscriptionId, matchReference, reference);\r\n            bb.process(bmReport);\r\n        } catch (Exception e) {\r\n            handleException(e, measureURI, value);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/xmlrpc/ServerAgentImpl_3Test.java",
		"test_prompt": "// ServerAgentImpl_3Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ServerEvent;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMReport;\nimport org.osgi.framework.BundleContext;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServerAgentImpl}.\n* It contains ten unit test cases for the {@link ServerAgentImpl#BMReport(long, String, String, long, boolean, String)} method.\n*/\nclass ServerAgentImpl_3Test {"
	},
	{
		"original_code": "// HttpServiceTracker.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\r\n\r\nimport com.sun.jersey.spi.container.servlet.ServletContainer;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.apache.felix.http.api.ExtHttpService;\r\nimport org.osgi.framework.BundleContext;\r\nimport org.osgi.framework.ServiceReference;\r\nimport org.osgi.service.http.HttpService;\r\nimport org.osgi.util.tracker.ServiceTracker;\r\nimport java.util.Dictionary;\r\nimport java.util.Hashtable;\r\n\r\n/**\r\n * Looks for the OSGI HTTP service and registers the Jersey services as a filter to this service when available.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class HttpServiceTracker extends ServiceTracker {\r\n\r\n    private final static Logger log = new Logger(HttpServiceTracker.class);\r\n\r\n    private ExtHttpService httpService = null;\r\n\r\n    public HttpServiceTracker(BundleContext bc) {\r\n        super(bc, HttpService.class.getName(), null);\r\n    }\r\n\r\n    @Override\r\n    public Object addingService(ServiceReference sr) {\r\n        httpService = (ExtHttpService) super.addingService(sr);\r\n        try {\r\n            Dictionary<String, String> config = new Hashtable<String, String>();\r\n            config.put(\"javax.ws.rs.Application\", JerseyApplication.class.getName());\r\n            //      config.put(\"com.sun.jersey.config.property.packages\", \"fi.vtt.noen.mfw.bundle.server.plugins.rest\");\r\n            //      config.put(\"filterMappingUrlPattern\", \"/mfw/rest/*\");\r\n            httpService.registerServlet(\"/rest\", new ServletContainer(), config, null);\r\n            //      httpService.registerFilter(new ServletContainer(), \"/mfw/rest/*\", config, 0, null);\r\n            //      httpService.registerServlet(\"/test/*\", new BaseMeasureServlet(), null, null);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to register servlet\", e);\r\n        }\r\n        /*\r\n    Dictionary<String, String> jerseyParameters = new Hashtable<String, String>();\r\n    jerseyParameters.put(\"javax.ws.rs.Application\", JerseyApplication.class.getName());\r\n    try {\r\n      httpService.registerServlet(\"/jersey\", new ServletContainer(), jerseyParameters, null);\r\n    } catch (Exception e) {\r\n      log.error(\"Failed to register Jersey servlet\", e);\r\n    }*/\r\n        return httpService;\r\n    }\r\n\r\n    @Override\r\n    public void removedService(ServiceReference reference, Object service) {\r\n        super.removedService(reference, service);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/HttpServiceTracker.java",
		"test_prompt": "// HttpServiceTrackerTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\n\nimport com.sun.jersey.spi.container.servlet.ServletContainer;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.apache.felix.http.api.ExtHttpService;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.ServiceReference;\nimport org.osgi.service.http.HttpService;\nimport org.osgi.util.tracker.ServiceTracker;\nimport java.util.Dictionary;\nimport java.util.Hashtable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HttpServiceTracker}.\n* It contains ten unit test cases for the {@link HttpServiceTracker#addingService(ServiceReference)} method.\n*/\nclass HttpServiceTrackerTest {"
	},
	{
		"original_code": "// RequestFrameworkInfoResource.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\r\n\r\nimport javax.ws.rs.GET;\r\nimport javax.ws.rs.Path;\r\nimport javax.ws.rs.Produces;\r\nimport javax.ws.rs.core.MediaType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.RestPlugin;\r\n\r\n@Path(\"/client/mfwinformation\")\r\npublic class RequestFrameworkInfoResource {\r\n\r\n    private final static Logger log = new Logger(RequestFrameworkInfoResource.class);\r\n\r\n    private RestPlugin restPlugin;\r\n\r\n    @GET\r\n    @Produces(MediaType.APPLICATION_XML)\r\n    public FrameworkInfo requestFrameworkInfo() {\r\n        restPlugin = RestPlugin.getInstance();\r\n        FrameworkInfo info = restPlugin.getFrameworkInfo();\r\n        return info;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/resources/RequestFrameworkInfoResource.java",
		"test_prompt": "// RequestFrameworkInfoResourceTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\n\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.RestPlugin;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RequestFrameworkInfoResource}.\n* It contains ten unit test cases for the {@link RequestFrameworkInfoResource#requestFrameworkInfo()} method.\n*/\nclass RequestFrameworkInfoResourceTest {"
	},
	{
		"original_code": "// RegisterClientResource.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\r\n\r\nimport javax.ws.rs.Consumes;\r\nimport javax.ws.rs.HeaderParam;\r\nimport javax.ws.rs.POST;\r\nimport javax.ws.rs.Path;\r\nimport javax.ws.rs.Produces;\r\nimport javax.ws.rs.WebApplicationException;\r\nimport javax.ws.rs.core.MediaType;\r\nimport javax.ws.rs.core.Response.Status;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.RestPlugin;\r\n\r\n@Path(\"/client/register\")\r\npublic class RegisterClientResource {\r\n\r\n    private final static Logger log = new Logger(RegisterClientResource.class);\r\n\r\n    private RestPlugin restPlugin;\r\n\r\n    @POST\r\n    @Consumes(MediaType.APPLICATION_XML)\r\n    @Produces(MediaType.APPLICATION_XML)\r\n    public Session registerClient(@HeaderParam(\"authorization\") String authHeader, ClientRequest client) {\r\n        restPlugin = RestPlugin.getInstance();\r\n        log.debug(\"Registering new client (\" + client.getName() + \":\" + client.getEndpoint() + \") with auth-header: \" + authHeader);\r\n        Session session = null;\r\n        if (restPlugin.isAuthorized(authHeader)) {\r\n            if (client != null && client.getName() != null && client.getEndpoint() != null) {\r\n                session = restPlugin.registerClient(authHeader, client);\r\n                log.debug(\"Session: \" + session.getId());\r\n            } else {\r\n                throw new WebApplicationException(Status.BAD_REQUEST);\r\n            }\r\n        } else {\r\n            throw new WebApplicationException(Status.UNAUTHORIZED);\r\n        }\r\n        return session;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/resources/RegisterClientResource.java",
		"test_prompt": "// RegisterClientResourceTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.WebApplicationException;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response.Status;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.RestPlugin;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RegisterClientResource}.\n* It contains ten unit test cases for the {@link RegisterClientResource#registerClient(String, ClientRequest)} method.\n*/\nclass RegisterClientResourceTest {"
	},
	{
		"original_code": "// Availability.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\r\n\r\nimport javax.xml.bind.annotation.XmlElement;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@XmlRootElement(name = \"availability\")\r\npublic class Availability {\r\n\r\n    private List<BM> bms = new ArrayList<BM>();\r\n\r\n    public Availability() {\r\n    }\r\n\r\n    @XmlElement(name = \"baseMeasure\")\r\n    public List<BM> getBms() {\r\n        return bms;\r\n    }\r\n\r\n    public void setBms(List<BM> bms) {\r\n        this.bms = bms;\r\n    }\r\n\r\n    public boolean addBm(BM bm) {\r\n        return bms.add(bm);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/resources/Availability.java",
		"test_prompt": "// AvailabilityTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\n\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Availability}.\n* It contains ten unit test cases for the {@link Availability#addBm(BM)} method.\n*/\nclass AvailabilityTest {"
	},
	{
		"original_code": "// ShutdownResource.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.ws.rs.GET;\r\nimport javax.ws.rs.Path;\r\nimport javax.ws.rs.Produces;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\n@Path(\"/shutdown\")\r\npublic class ShutdownResource {\r\n\r\n    private final static Logger log = new Logger(ShutdownResource.class);\r\n\r\n    @GET\r\n    @Produces(\"text/plain\")\r\n    public String shutdown() {\r\n        log.debug(\"SHUTDOWN initiated via REST service\");\r\n        System.exit(0);\r\n        return \"OK, shutting down.\";\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/resources/ShutdownResource.java",
		"test_prompt": "// ShutdownResourceTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ShutdownResource}.\n* It contains ten unit test cases for the {@link ShutdownResource#shutdown()} method.\n*/\nclass ShutdownResourceTest {"
	},
	{
		"original_code": "// MeasurementHistoryResource.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport javax.ws.rs.Consumes;\r\nimport javax.ws.rs.HeaderParam;\r\nimport javax.ws.rs.POST;\r\nimport javax.ws.rs.Path;\r\nimport javax.ws.rs.Produces;\r\nimport javax.ws.rs.WebApplicationException;\r\nimport javax.ws.rs.core.MediaType;\r\nimport javax.ws.rs.core.Response.Status;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.RestPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\n\r\n@Path(\"/client/history\")\r\npublic class MeasurementHistoryResource {\r\n\r\n    private final static Logger log = new Logger(MeasurementHistoryResource.class);\r\n\r\n    private RestPlugin restPlugin;\r\n\r\n    @POST\r\n    @Consumes(MediaType.APPLICATION_XML)\r\n    @Produces(MediaType.APPLICATION_XML)\r\n    public MeasurementHistory requestHistory(@HeaderParam(\"authorization\") String authHeader, HistoryRequest request) {\r\n        restPlugin = RestPlugin.getInstance();\r\n        log.debug(\"measurementHistory request\");\r\n        MeasurementHistory measurementHistory = null;\r\n        if (restPlugin.isAlive(authHeader)) {\r\n            measurementHistory = new MeasurementHistory();\r\n            // read measurements history from database according to requested time interval\r\n            // and push it to the client\r\n            List<Value> measurements = restPlugin.getHistory(request);\r\n            ArrayList<MeasurementValue> values = new ArrayList<MeasurementValue>();\r\n            // conversion to rest class\r\n            if (measurements != null) {\r\n                for (Value value : measurements) {\r\n                    String bmid = Long.toString(value.getBm().getBmId());\r\n                    Long timestamp = value.getTime().getTime();\r\n                    values.add(new MeasurementValue(bmid, value.valueString(), timestamp));\r\n                }\r\n            }\r\n            measurementHistory.setValues(values);\r\n        } else {\r\n            throw new WebApplicationException(Status.BAD_REQUEST);\r\n        }\r\n        return measurementHistory;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/resources/MeasurementHistoryResource.java",
		"test_prompt": "// MeasurementHistoryResourceTest.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest.resources;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.WebApplicationException;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response.Status;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.RestPlugin;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementHistoryResource}.\n* It contains ten unit test cases for the {@link MeasurementHistoryResource#requestHistory(String, HistoryRequest)} method.\n*/\nclass MeasurementHistoryResourceTest {"
	},
	{
		"original_code": "// RestPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.UUID;\r\nimport org.osgi.framework.BundleContext;\r\nimport com.sun.jersey.core.util.Base64;\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RestPlugin extends BasePlugin implements KnowledgeSource, RegistryUser, ServerUser, PersistenceUser {\r\n\r\n    private final static Logger log = new Logger(RestPlugin.class);\r\n\r\n    private static RestPlugin restPlugin = null;\r\n\r\n    //for the server-agent to communicate with the probe-agents\r\n    private ServerPlugin server;\r\n\r\n    //for accessing runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //provides bundle to database\r\n    private PersistencePlugin persistence;\r\n\r\n    //for sending BM results\r\n    //  private RestClient restClient;\r\n    //(sac)Id for measurement subscriptions\r\n    private long restId = -2;\r\n\r\n    // registered clients\r\n    private Map<String, ClientRequest> clients;\r\n\r\n    // client subsciptions\r\n    private ClientSubscriptionRegistry subs;\r\n\r\n    public static RestPlugin getInstance() {\r\n        return restPlugin;\r\n    }\r\n\r\n    public RestPlugin(BundleContext bc) {\r\n        super(bc, log);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n        PersistenceServiceListener persListener = new PersistenceServiceListener(bc, log, this);\r\n        persListener.init();\r\n        restPlugin = this;\r\n        //    restClient = new RestClient();\r\n        clients = new LinkedHashMap<String, ClientRequest>();\r\n        subs = new ClientSubscriptionRegistry();\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    @Override\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new RestPlugin(null).start();\r\n    }\r\n\r\n    public void start() {\r\n    }\r\n\r\n    public void stop() {\r\n    }\r\n\r\n    //Gives a list of available BM.\r\n    public List<BMDescription> getAvailableBMList() {\r\n        return registry.getAvailableBM();\r\n    }\r\n\r\n    public List<ProbeDescription> getProbes() {\r\n        return registry.getProbes();\r\n    }\r\n\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        return registry.getProbeForBM(bmId);\r\n    }\r\n\r\n    public Collection<TargetDescription> getTargets() {\r\n        return registry.getTargets();\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public boolean requestBM(long bmId) {\r\n        log.debug(\"requestBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n        return true;\r\n    }\r\n\r\n    public void requestBaseMeasure(String base64auth, long bmId) {\r\n        ClientRequest client = clients.get(extractAuthentication(base64auth));\r\n        log.debug(\"Client (\" + client.getName() + \") is requesting base measure, id=\" + bmId);\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public void subscribeToBM(long bmId, long interval) {\r\n        log.debug(\"subscribeToBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(bmId, interval, subscriptionId);\r\n    }\r\n\r\n    public void subscribeBaseMeasure(String authHeader, long id, long interval) {\r\n        ProbeDescription probe = registry.getProbeForBM(id);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(id, interval, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.add(subscriptionId, client);\r\n    }\r\n\r\n    //removes an existing subscription\r\n    public void unSubscribeToBM(long bmId) {\r\n        log.debug(\"unSubscribeToBM\");\r\n        long subscriptionId = registry.getIdForSubscription(restId, bmId);\r\n        server.unSubscribeToBM(bmId, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n    }\r\n\r\n    public void unsubscribeBaseMeasure(String authHeader, long id) {\r\n        long subscriptionId = registry.getIdForSubscription(restId, id);\r\n        server.unSubscribeToBM(id, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.remove(subscriptionId, client);\r\n    }\r\n\r\n    public void bmValue(Value value) {\r\n        log.debug(\"received BM value\");\r\n        long subscriptionId = value.getSubscriptionId();\r\n        long sacId = registry.getSacIdForSubscription(subscriptionId);\r\n        if (sacId == restId) {\r\n            log.debug(\"subscriptionId: \" + subscriptionId + \", sacId: \" + sacId);\r\n            ArrayList<ClientRequest> clients = subs.get(subscriptionId);\r\n            //if one time measurement remove subscription from registry\r\n            if (registry.getFrequencyForSubscription(subscriptionId) == 0) {\r\n                registry.removeSubscription(restId, subscriptionId);\r\n                for (ClientRequest client : clients) {\r\n                    subs.remove(subscriptionId, client);\r\n                }\r\n            }\r\n            for (ClientRequest client : clients) {\r\n                log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n                try {\r\n                    new RestClientEndpoint(client.getEndpoint()).measurement(value);\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void event(DataObject data) {\r\n        log.debug(\"received probe event\");\r\n        ProbeEvent pe = null;\r\n        ProbeRegistered pr = null;\r\n        ProbeDisabled pd = null;\r\n        if (data instanceof ProbeEvent) {\r\n            pe = (ProbeEvent) data;\r\n        } else if (data instanceof ProbeRegistered) {\r\n            pr = (ProbeRegistered) data;\r\n        } else if (data instanceof ProbeDisabled) {\r\n            pd = (ProbeDisabled) data;\r\n        }\r\n        for (ClientRequest client : clients.values()) {\r\n            log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n            try {\r\n                RestClientEndpoint rce = new RestClientEndpoint(client.getEndpoint());\r\n                if (pe != null)\r\n                    rce.probeEvent(pe);\r\n                if (pr != null)\r\n                    rce.probeRegistered(pr);\r\n                if (pd != null)\r\n                    rce.probeDisabled(pd);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    //list of information to be received from the blackboard\r\n    public Set getCommands() {\r\n        return createCommandSet(Value.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            log.debug(\"received value:\" + value);\r\n            bmValue(value);\r\n        } else if (data instanceof ProbeEvent || data instanceof ProbeRegistered || data instanceof ProbeDisabled) {\r\n            event(data);\r\n        }\r\n    }\r\n\r\n    public String getName() {\r\n        return RestPlugin.class.getName();\r\n    }\r\n\r\n    public Session registerClient(String base64auth, ClientRequest client) {\r\n        log.debug(\"Registering client: \" + client);\r\n        String authentication = extractAuthentication(base64auth);\r\n        // if client has already registered, all subscriptions should be released\r\n        if (clients.containsKey(authentication)) {\r\n            clients.remove(authentication);\r\n            //TODO: release all subsciptions here:\r\n            //TODO: add mechanism for outdating session\r\n        }\r\n        // create new session for the client\r\n        UUID id = UUID.randomUUID();\r\n        Session session = new Session(id);\r\n        client.setSession(session);\r\n        clients.put(authentication, client);\r\n        return session;\r\n    }\r\n\r\n    public boolean isAlive(String base64auth) {\r\n        return clients.containsKey(extractAuthentication(base64auth));\r\n    }\r\n\r\n    public boolean isAuthorized(String base64auth) {\r\n        String authentication = extractAuthentication(base64auth);\r\n        boolean authorized = false;\r\n        if (authentication.length() > 0) {\r\n            // now we are ready to check authentication string\r\n            String decoded = Base64.base64Decode(authentication);\r\n            log.debug(\"Decoded authentication string: \" + decoded);\r\n            String[] userpass = decoded.split(\":\");\r\n            log.debug(\"User credentials: [\" + userpass[0] + \":\" + userpass[1] + \"]\");\r\n            String pass = \"password\";\r\n            String user = \"username\";\r\n            //      try\r\n            //      {\r\n            //        MessageDigest md5 = MessageDigest.getInstance( \"SHA-256\" );\r\n            //        pass = new String( md5.digest( \"password\".getBytes() ) );\r\n            //\r\n            //        log.debug( \"Accepted password md5 digest: \" + pass );\r\n            //      }\r\n            //      catch ( NoSuchAlgorithmException e )\r\n            //      {\r\n            //        // TODO Auto-generated catch block\r\n            //        e.printStackTrace();\r\n            //      }\r\n            // check username and password from database?\r\n            if (user.equals(userpass[0]) && pass.equals(userpass[1])) {\r\n                authorized = true;\r\n            }\r\n        }\r\n        return authorized;\r\n    }\r\n\r\n    // helper method for splitting authorization header\r\n    private String extractAuthentication(String auth) {\r\n        String result = \"\";\r\n        if (auth != null) {\r\n            String[] items = auth.split(\" \");\r\n            if (items.length == 2 && \"Basic\".equals(items[0])) {\r\n                result = items[1];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getProbeConfiguration(long probeId) {\r\n        return server.requestProbeConfigurationParameters(probeId);\r\n    }\r\n\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        boolean success = false;\r\n        try {\r\n            success = server.setProbeConfiguration(probeId, configuration);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to set probe (\" + probeId + \") configuration.\", e);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    public FrameworkInfo getFrameworkInfo() {\r\n        FrameworkInfo info = new FrameworkInfo(\"-1\", getName());\r\n        return info;\r\n    }\r\n\r\n    public List<Value> getHistory(HistoryRequest request) {\r\n        long start = request.getStart();\r\n        long end = request.getEnd();\r\n        Long[] bmids = new Long[request.getBms().size()];\r\n        request.getBms().toArray(bmids);\r\n        List<Value> data = persistence.getValues(start, end, bmids, SortKey.TIME, true);\r\n        return data;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/RestPlugin_0Test.java",
		"test_prompt": "// RestPlugin_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport org.osgi.framework.BundleContext;\nimport com.sun.jersey.core.util.Base64;\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RestPlugin}.\n* It contains ten unit test cases for the {@link RestPlugin#getInstance()} method.\n*/\nclass RestPlugin_0Test {"
	},
	{
		"original_code": "// RestPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.UUID;\r\nimport org.osgi.framework.BundleContext;\r\nimport com.sun.jersey.core.util.Base64;\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RestPlugin extends BasePlugin implements KnowledgeSource, RegistryUser, ServerUser, PersistenceUser {\r\n\r\n    private final static Logger log = new Logger(RestPlugin.class);\r\n\r\n    private static RestPlugin restPlugin = null;\r\n\r\n    //for the server-agent to communicate with the probe-agents\r\n    private ServerPlugin server;\r\n\r\n    //for accessing runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //provides bundle to database\r\n    private PersistencePlugin persistence;\r\n\r\n    //for sending BM results\r\n    //  private RestClient restClient;\r\n    //(sac)Id for measurement subscriptions\r\n    private long restId = -2;\r\n\r\n    // registered clients\r\n    private Map<String, ClientRequest> clients;\r\n\r\n    // client subsciptions\r\n    private ClientSubscriptionRegistry subs;\r\n\r\n    public static RestPlugin getInstance() {\r\n        return restPlugin;\r\n    }\r\n\r\n    public RestPlugin(BundleContext bc) {\r\n        super(bc, log);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n        PersistenceServiceListener persListener = new PersistenceServiceListener(bc, log, this);\r\n        persListener.init();\r\n        restPlugin = this;\r\n        //    restClient = new RestClient();\r\n        clients = new LinkedHashMap<String, ClientRequest>();\r\n        subs = new ClientSubscriptionRegistry();\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    @Override\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new RestPlugin(null).start();\r\n    }\r\n\r\n    public void start() {\r\n    }\r\n\r\n    public void stop() {\r\n    }\r\n\r\n    //Gives a list of available BM.\r\n    public List<BMDescription> getAvailableBMList() {\r\n        return registry.getAvailableBM();\r\n    }\r\n\r\n    public List<ProbeDescription> getProbes() {\r\n        return registry.getProbes();\r\n    }\r\n\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        return registry.getProbeForBM(bmId);\r\n    }\r\n\r\n    public Collection<TargetDescription> getTargets() {\r\n        return registry.getTargets();\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public boolean requestBM(long bmId) {\r\n        log.debug(\"requestBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n        return true;\r\n    }\r\n\r\n    public void requestBaseMeasure(String base64auth, long bmId) {\r\n        ClientRequest client = clients.get(extractAuthentication(base64auth));\r\n        log.debug(\"Client (\" + client.getName() + \") is requesting base measure, id=\" + bmId);\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public void subscribeToBM(long bmId, long interval) {\r\n        log.debug(\"subscribeToBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(bmId, interval, subscriptionId);\r\n    }\r\n\r\n    public void subscribeBaseMeasure(String authHeader, long id, long interval) {\r\n        ProbeDescription probe = registry.getProbeForBM(id);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(id, interval, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.add(subscriptionId, client);\r\n    }\r\n\r\n    //removes an existing subscription\r\n    public void unSubscribeToBM(long bmId) {\r\n        log.debug(\"unSubscribeToBM\");\r\n        long subscriptionId = registry.getIdForSubscription(restId, bmId);\r\n        server.unSubscribeToBM(bmId, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n    }\r\n\r\n    public void unsubscribeBaseMeasure(String authHeader, long id) {\r\n        long subscriptionId = registry.getIdForSubscription(restId, id);\r\n        server.unSubscribeToBM(id, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.remove(subscriptionId, client);\r\n    }\r\n\r\n    public void bmValue(Value value) {\r\n        log.debug(\"received BM value\");\r\n        long subscriptionId = value.getSubscriptionId();\r\n        long sacId = registry.getSacIdForSubscription(subscriptionId);\r\n        if (sacId == restId) {\r\n            log.debug(\"subscriptionId: \" + subscriptionId + \", sacId: \" + sacId);\r\n            ArrayList<ClientRequest> clients = subs.get(subscriptionId);\r\n            //if one time measurement remove subscription from registry\r\n            if (registry.getFrequencyForSubscription(subscriptionId) == 0) {\r\n                registry.removeSubscription(restId, subscriptionId);\r\n                for (ClientRequest client : clients) {\r\n                    subs.remove(subscriptionId, client);\r\n                }\r\n            }\r\n            for (ClientRequest client : clients) {\r\n                log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n                try {\r\n                    new RestClientEndpoint(client.getEndpoint()).measurement(value);\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void event(DataObject data) {\r\n        log.debug(\"received probe event\");\r\n        ProbeEvent pe = null;\r\n        ProbeRegistered pr = null;\r\n        ProbeDisabled pd = null;\r\n        if (data instanceof ProbeEvent) {\r\n            pe = (ProbeEvent) data;\r\n        } else if (data instanceof ProbeRegistered) {\r\n            pr = (ProbeRegistered) data;\r\n        } else if (data instanceof ProbeDisabled) {\r\n            pd = (ProbeDisabled) data;\r\n        }\r\n        for (ClientRequest client : clients.values()) {\r\n            log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n            try {\r\n                RestClientEndpoint rce = new RestClientEndpoint(client.getEndpoint());\r\n                if (pe != null)\r\n                    rce.probeEvent(pe);\r\n                if (pr != null)\r\n                    rce.probeRegistered(pr);\r\n                if (pd != null)\r\n                    rce.probeDisabled(pd);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    //list of information to be received from the blackboard\r\n    public Set getCommands() {\r\n        return createCommandSet(Value.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            log.debug(\"received value:\" + value);\r\n            bmValue(value);\r\n        } else if (data instanceof ProbeEvent || data instanceof ProbeRegistered || data instanceof ProbeDisabled) {\r\n            event(data);\r\n        }\r\n    }\r\n\r\n    public String getName() {\r\n        return RestPlugin.class.getName();\r\n    }\r\n\r\n    public Session registerClient(String base64auth, ClientRequest client) {\r\n        log.debug(\"Registering client: \" + client);\r\n        String authentication = extractAuthentication(base64auth);\r\n        // if client has already registered, all subscriptions should be released\r\n        if (clients.containsKey(authentication)) {\r\n            clients.remove(authentication);\r\n            //TODO: release all subsciptions here:\r\n            //TODO: add mechanism for outdating session\r\n        }\r\n        // create new session for the client\r\n        UUID id = UUID.randomUUID();\r\n        Session session = new Session(id);\r\n        client.setSession(session);\r\n        clients.put(authentication, client);\r\n        return session;\r\n    }\r\n\r\n    public boolean isAlive(String base64auth) {\r\n        return clients.containsKey(extractAuthentication(base64auth));\r\n    }\r\n\r\n    public boolean isAuthorized(String base64auth) {\r\n        String authentication = extractAuthentication(base64auth);\r\n        boolean authorized = false;\r\n        if (authentication.length() > 0) {\r\n            // now we are ready to check authentication string\r\n            String decoded = Base64.base64Decode(authentication);\r\n            log.debug(\"Decoded authentication string: \" + decoded);\r\n            String[] userpass = decoded.split(\":\");\r\n            log.debug(\"User credentials: [\" + userpass[0] + \":\" + userpass[1] + \"]\");\r\n            String pass = \"password\";\r\n            String user = \"username\";\r\n            //      try\r\n            //      {\r\n            //        MessageDigest md5 = MessageDigest.getInstance( \"SHA-256\" );\r\n            //        pass = new String( md5.digest( \"password\".getBytes() ) );\r\n            //\r\n            //        log.debug( \"Accepted password md5 digest: \" + pass );\r\n            //      }\r\n            //      catch ( NoSuchAlgorithmException e )\r\n            //      {\r\n            //        // TODO Auto-generated catch block\r\n            //        e.printStackTrace();\r\n            //      }\r\n            // check username and password from database?\r\n            if (user.equals(userpass[0]) && pass.equals(userpass[1])) {\r\n                authorized = true;\r\n            }\r\n        }\r\n        return authorized;\r\n    }\r\n\r\n    // helper method for splitting authorization header\r\n    private String extractAuthentication(String auth) {\r\n        String result = \"\";\r\n        if (auth != null) {\r\n            String[] items = auth.split(\" \");\r\n            if (items.length == 2 && \"Basic\".equals(items[0])) {\r\n                result = items[1];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getProbeConfiguration(long probeId) {\r\n        return server.requestProbeConfigurationParameters(probeId);\r\n    }\r\n\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        boolean success = false;\r\n        try {\r\n            success = server.setProbeConfiguration(probeId, configuration);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to set probe (\" + probeId + \") configuration.\", e);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    public FrameworkInfo getFrameworkInfo() {\r\n        FrameworkInfo info = new FrameworkInfo(\"-1\", getName());\r\n        return info;\r\n    }\r\n\r\n    public List<Value> getHistory(HistoryRequest request) {\r\n        long start = request.getStart();\r\n        long end = request.getEnd();\r\n        Long[] bmids = new Long[request.getBms().size()];\r\n        request.getBms().toArray(bmids);\r\n        List<Value> data = persistence.getValues(start, end, bmids, SortKey.TIME, true);\r\n        return data;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/RestPlugin_1Test.java",
		"test_prompt": "// RestPlugin_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport org.osgi.framework.BundleContext;\nimport com.sun.jersey.core.util.Base64;\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RestPlugin}.\n* It contains ten unit test cases for the {@link RestPlugin#requestBM(long)} method.\n*/\nclass RestPlugin_1Test {"
	},
	{
		"original_code": "// RestPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.UUID;\r\nimport org.osgi.framework.BundleContext;\r\nimport com.sun.jersey.core.util.Base64;\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RestPlugin extends BasePlugin implements KnowledgeSource, RegistryUser, ServerUser, PersistenceUser {\r\n\r\n    private final static Logger log = new Logger(RestPlugin.class);\r\n\r\n    private static RestPlugin restPlugin = null;\r\n\r\n    //for the server-agent to communicate with the probe-agents\r\n    private ServerPlugin server;\r\n\r\n    //for accessing runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //provides bundle to database\r\n    private PersistencePlugin persistence;\r\n\r\n    //for sending BM results\r\n    //  private RestClient restClient;\r\n    //(sac)Id for measurement subscriptions\r\n    private long restId = -2;\r\n\r\n    // registered clients\r\n    private Map<String, ClientRequest> clients;\r\n\r\n    // client subsciptions\r\n    private ClientSubscriptionRegistry subs;\r\n\r\n    public static RestPlugin getInstance() {\r\n        return restPlugin;\r\n    }\r\n\r\n    public RestPlugin(BundleContext bc) {\r\n        super(bc, log);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n        PersistenceServiceListener persListener = new PersistenceServiceListener(bc, log, this);\r\n        persListener.init();\r\n        restPlugin = this;\r\n        //    restClient = new RestClient();\r\n        clients = new LinkedHashMap<String, ClientRequest>();\r\n        subs = new ClientSubscriptionRegistry();\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    @Override\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new RestPlugin(null).start();\r\n    }\r\n\r\n    public void start() {\r\n    }\r\n\r\n    public void stop() {\r\n    }\r\n\r\n    //Gives a list of available BM.\r\n    public List<BMDescription> getAvailableBMList() {\r\n        return registry.getAvailableBM();\r\n    }\r\n\r\n    public List<ProbeDescription> getProbes() {\r\n        return registry.getProbes();\r\n    }\r\n\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        return registry.getProbeForBM(bmId);\r\n    }\r\n\r\n    public Collection<TargetDescription> getTargets() {\r\n        return registry.getTargets();\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public boolean requestBM(long bmId) {\r\n        log.debug(\"requestBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n        return true;\r\n    }\r\n\r\n    public void requestBaseMeasure(String base64auth, long bmId) {\r\n        ClientRequest client = clients.get(extractAuthentication(base64auth));\r\n        log.debug(\"Client (\" + client.getName() + \") is requesting base measure, id=\" + bmId);\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public void subscribeToBM(long bmId, long interval) {\r\n        log.debug(\"subscribeToBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(bmId, interval, subscriptionId);\r\n    }\r\n\r\n    public void subscribeBaseMeasure(String authHeader, long id, long interval) {\r\n        ProbeDescription probe = registry.getProbeForBM(id);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(id, interval, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.add(subscriptionId, client);\r\n    }\r\n\r\n    //removes an existing subscription\r\n    public void unSubscribeToBM(long bmId) {\r\n        log.debug(\"unSubscribeToBM\");\r\n        long subscriptionId = registry.getIdForSubscription(restId, bmId);\r\n        server.unSubscribeToBM(bmId, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n    }\r\n\r\n    public void unsubscribeBaseMeasure(String authHeader, long id) {\r\n        long subscriptionId = registry.getIdForSubscription(restId, id);\r\n        server.unSubscribeToBM(id, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.remove(subscriptionId, client);\r\n    }\r\n\r\n    public void bmValue(Value value) {\r\n        log.debug(\"received BM value\");\r\n        long subscriptionId = value.getSubscriptionId();\r\n        long sacId = registry.getSacIdForSubscription(subscriptionId);\r\n        if (sacId == restId) {\r\n            log.debug(\"subscriptionId: \" + subscriptionId + \", sacId: \" + sacId);\r\n            ArrayList<ClientRequest> clients = subs.get(subscriptionId);\r\n            //if one time measurement remove subscription from registry\r\n            if (registry.getFrequencyForSubscription(subscriptionId) == 0) {\r\n                registry.removeSubscription(restId, subscriptionId);\r\n                for (ClientRequest client : clients) {\r\n                    subs.remove(subscriptionId, client);\r\n                }\r\n            }\r\n            for (ClientRequest client : clients) {\r\n                log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n                try {\r\n                    new RestClientEndpoint(client.getEndpoint()).measurement(value);\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void event(DataObject data) {\r\n        log.debug(\"received probe event\");\r\n        ProbeEvent pe = null;\r\n        ProbeRegistered pr = null;\r\n        ProbeDisabled pd = null;\r\n        if (data instanceof ProbeEvent) {\r\n            pe = (ProbeEvent) data;\r\n        } else if (data instanceof ProbeRegistered) {\r\n            pr = (ProbeRegistered) data;\r\n        } else if (data instanceof ProbeDisabled) {\r\n            pd = (ProbeDisabled) data;\r\n        }\r\n        for (ClientRequest client : clients.values()) {\r\n            log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n            try {\r\n                RestClientEndpoint rce = new RestClientEndpoint(client.getEndpoint());\r\n                if (pe != null)\r\n                    rce.probeEvent(pe);\r\n                if (pr != null)\r\n                    rce.probeRegistered(pr);\r\n                if (pd != null)\r\n                    rce.probeDisabled(pd);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    //list of information to be received from the blackboard\r\n    public Set getCommands() {\r\n        return createCommandSet(Value.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            log.debug(\"received value:\" + value);\r\n            bmValue(value);\r\n        } else if (data instanceof ProbeEvent || data instanceof ProbeRegistered || data instanceof ProbeDisabled) {\r\n            event(data);\r\n        }\r\n    }\r\n\r\n    public String getName() {\r\n        return RestPlugin.class.getName();\r\n    }\r\n\r\n    public Session registerClient(String base64auth, ClientRequest client) {\r\n        log.debug(\"Registering client: \" + client);\r\n        String authentication = extractAuthentication(base64auth);\r\n        // if client has already registered, all subscriptions should be released\r\n        if (clients.containsKey(authentication)) {\r\n            clients.remove(authentication);\r\n            //TODO: release all subsciptions here:\r\n            //TODO: add mechanism for outdating session\r\n        }\r\n        // create new session for the client\r\n        UUID id = UUID.randomUUID();\r\n        Session session = new Session(id);\r\n        client.setSession(session);\r\n        clients.put(authentication, client);\r\n        return session;\r\n    }\r\n\r\n    public boolean isAlive(String base64auth) {\r\n        return clients.containsKey(extractAuthentication(base64auth));\r\n    }\r\n\r\n    public boolean isAuthorized(String base64auth) {\r\n        String authentication = extractAuthentication(base64auth);\r\n        boolean authorized = false;\r\n        if (authentication.length() > 0) {\r\n            // now we are ready to check authentication string\r\n            String decoded = Base64.base64Decode(authentication);\r\n            log.debug(\"Decoded authentication string: \" + decoded);\r\n            String[] userpass = decoded.split(\":\");\r\n            log.debug(\"User credentials: [\" + userpass[0] + \":\" + userpass[1] + \"]\");\r\n            String pass = \"password\";\r\n            String user = \"username\";\r\n            //      try\r\n            //      {\r\n            //        MessageDigest md5 = MessageDigest.getInstance( \"SHA-256\" );\r\n            //        pass = new String( md5.digest( \"password\".getBytes() ) );\r\n            //\r\n            //        log.debug( \"Accepted password md5 digest: \" + pass );\r\n            //      }\r\n            //      catch ( NoSuchAlgorithmException e )\r\n            //      {\r\n            //        // TODO Auto-generated catch block\r\n            //        e.printStackTrace();\r\n            //      }\r\n            // check username and password from database?\r\n            if (user.equals(userpass[0]) && pass.equals(userpass[1])) {\r\n                authorized = true;\r\n            }\r\n        }\r\n        return authorized;\r\n    }\r\n\r\n    // helper method for splitting authorization header\r\n    private String extractAuthentication(String auth) {\r\n        String result = \"\";\r\n        if (auth != null) {\r\n            String[] items = auth.split(\" \");\r\n            if (items.length == 2 && \"Basic\".equals(items[0])) {\r\n                result = items[1];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getProbeConfiguration(long probeId) {\r\n        return server.requestProbeConfigurationParameters(probeId);\r\n    }\r\n\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        boolean success = false;\r\n        try {\r\n            success = server.setProbeConfiguration(probeId, configuration);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to set probe (\" + probeId + \") configuration.\", e);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    public FrameworkInfo getFrameworkInfo() {\r\n        FrameworkInfo info = new FrameworkInfo(\"-1\", getName());\r\n        return info;\r\n    }\r\n\r\n    public List<Value> getHistory(HistoryRequest request) {\r\n        long start = request.getStart();\r\n        long end = request.getEnd();\r\n        Long[] bmids = new Long[request.getBms().size()];\r\n        request.getBms().toArray(bmids);\r\n        List<Value> data = persistence.getValues(start, end, bmids, SortKey.TIME, true);\r\n        return data;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/RestPlugin_2Test.java",
		"test_prompt": "// RestPlugin_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport org.osgi.framework.BundleContext;\nimport com.sun.jersey.core.util.Base64;\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RestPlugin}.\n* It contains ten unit test cases for the {@link RestPlugin#registerClient(String, ClientRequest)} method.\n*/\nclass RestPlugin_2Test {"
	},
	{
		"original_code": "// RestPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.UUID;\r\nimport org.osgi.framework.BundleContext;\r\nimport com.sun.jersey.core.util.Base64;\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RestPlugin extends BasePlugin implements KnowledgeSource, RegistryUser, ServerUser, PersistenceUser {\r\n\r\n    private final static Logger log = new Logger(RestPlugin.class);\r\n\r\n    private static RestPlugin restPlugin = null;\r\n\r\n    //for the server-agent to communicate with the probe-agents\r\n    private ServerPlugin server;\r\n\r\n    //for accessing runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //provides bundle to database\r\n    private PersistencePlugin persistence;\r\n\r\n    //for sending BM results\r\n    //  private RestClient restClient;\r\n    //(sac)Id for measurement subscriptions\r\n    private long restId = -2;\r\n\r\n    // registered clients\r\n    private Map<String, ClientRequest> clients;\r\n\r\n    // client subsciptions\r\n    private ClientSubscriptionRegistry subs;\r\n\r\n    public static RestPlugin getInstance() {\r\n        return restPlugin;\r\n    }\r\n\r\n    public RestPlugin(BundleContext bc) {\r\n        super(bc, log);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n        PersistenceServiceListener persListener = new PersistenceServiceListener(bc, log, this);\r\n        persListener.init();\r\n        restPlugin = this;\r\n        //    restClient = new RestClient();\r\n        clients = new LinkedHashMap<String, ClientRequest>();\r\n        subs = new ClientSubscriptionRegistry();\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    @Override\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new RestPlugin(null).start();\r\n    }\r\n\r\n    public void start() {\r\n    }\r\n\r\n    public void stop() {\r\n    }\r\n\r\n    //Gives a list of available BM.\r\n    public List<BMDescription> getAvailableBMList() {\r\n        return registry.getAvailableBM();\r\n    }\r\n\r\n    public List<ProbeDescription> getProbes() {\r\n        return registry.getProbes();\r\n    }\r\n\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        return registry.getProbeForBM(bmId);\r\n    }\r\n\r\n    public Collection<TargetDescription> getTargets() {\r\n        return registry.getTargets();\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public boolean requestBM(long bmId) {\r\n        log.debug(\"requestBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n        return true;\r\n    }\r\n\r\n    public void requestBaseMeasure(String base64auth, long bmId) {\r\n        ClientRequest client = clients.get(extractAuthentication(base64auth));\r\n        log.debug(\"Client (\" + client.getName() + \") is requesting base measure, id=\" + bmId);\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public void subscribeToBM(long bmId, long interval) {\r\n        log.debug(\"subscribeToBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(bmId, interval, subscriptionId);\r\n    }\r\n\r\n    public void subscribeBaseMeasure(String authHeader, long id, long interval) {\r\n        ProbeDescription probe = registry.getProbeForBM(id);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(id, interval, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.add(subscriptionId, client);\r\n    }\r\n\r\n    //removes an existing subscription\r\n    public void unSubscribeToBM(long bmId) {\r\n        log.debug(\"unSubscribeToBM\");\r\n        long subscriptionId = registry.getIdForSubscription(restId, bmId);\r\n        server.unSubscribeToBM(bmId, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n    }\r\n\r\n    public void unsubscribeBaseMeasure(String authHeader, long id) {\r\n        long subscriptionId = registry.getIdForSubscription(restId, id);\r\n        server.unSubscribeToBM(id, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.remove(subscriptionId, client);\r\n    }\r\n\r\n    public void bmValue(Value value) {\r\n        log.debug(\"received BM value\");\r\n        long subscriptionId = value.getSubscriptionId();\r\n        long sacId = registry.getSacIdForSubscription(subscriptionId);\r\n        if (sacId == restId) {\r\n            log.debug(\"subscriptionId: \" + subscriptionId + \", sacId: \" + sacId);\r\n            ArrayList<ClientRequest> clients = subs.get(subscriptionId);\r\n            //if one time measurement remove subscription from registry\r\n            if (registry.getFrequencyForSubscription(subscriptionId) == 0) {\r\n                registry.removeSubscription(restId, subscriptionId);\r\n                for (ClientRequest client : clients) {\r\n                    subs.remove(subscriptionId, client);\r\n                }\r\n            }\r\n            for (ClientRequest client : clients) {\r\n                log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n                try {\r\n                    new RestClientEndpoint(client.getEndpoint()).measurement(value);\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void event(DataObject data) {\r\n        log.debug(\"received probe event\");\r\n        ProbeEvent pe = null;\r\n        ProbeRegistered pr = null;\r\n        ProbeDisabled pd = null;\r\n        if (data instanceof ProbeEvent) {\r\n            pe = (ProbeEvent) data;\r\n        } else if (data instanceof ProbeRegistered) {\r\n            pr = (ProbeRegistered) data;\r\n        } else if (data instanceof ProbeDisabled) {\r\n            pd = (ProbeDisabled) data;\r\n        }\r\n        for (ClientRequest client : clients.values()) {\r\n            log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n            try {\r\n                RestClientEndpoint rce = new RestClientEndpoint(client.getEndpoint());\r\n                if (pe != null)\r\n                    rce.probeEvent(pe);\r\n                if (pr != null)\r\n                    rce.probeRegistered(pr);\r\n                if (pd != null)\r\n                    rce.probeDisabled(pd);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    //list of information to be received from the blackboard\r\n    public Set getCommands() {\r\n        return createCommandSet(Value.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            log.debug(\"received value:\" + value);\r\n            bmValue(value);\r\n        } else if (data instanceof ProbeEvent || data instanceof ProbeRegistered || data instanceof ProbeDisabled) {\r\n            event(data);\r\n        }\r\n    }\r\n\r\n    public String getName() {\r\n        return RestPlugin.class.getName();\r\n    }\r\n\r\n    public Session registerClient(String base64auth, ClientRequest client) {\r\n        log.debug(\"Registering client: \" + client);\r\n        String authentication = extractAuthentication(base64auth);\r\n        // if client has already registered, all subscriptions should be released\r\n        if (clients.containsKey(authentication)) {\r\n            clients.remove(authentication);\r\n            //TODO: release all subsciptions here:\r\n            //TODO: add mechanism for outdating session\r\n        }\r\n        // create new session for the client\r\n        UUID id = UUID.randomUUID();\r\n        Session session = new Session(id);\r\n        client.setSession(session);\r\n        clients.put(authentication, client);\r\n        return session;\r\n    }\r\n\r\n    public boolean isAlive(String base64auth) {\r\n        return clients.containsKey(extractAuthentication(base64auth));\r\n    }\r\n\r\n    public boolean isAuthorized(String base64auth) {\r\n        String authentication = extractAuthentication(base64auth);\r\n        boolean authorized = false;\r\n        if (authentication.length() > 0) {\r\n            // now we are ready to check authentication string\r\n            String decoded = Base64.base64Decode(authentication);\r\n            log.debug(\"Decoded authentication string: \" + decoded);\r\n            String[] userpass = decoded.split(\":\");\r\n            log.debug(\"User credentials: [\" + userpass[0] + \":\" + userpass[1] + \"]\");\r\n            String pass = \"password\";\r\n            String user = \"username\";\r\n            //      try\r\n            //      {\r\n            //        MessageDigest md5 = MessageDigest.getInstance( \"SHA-256\" );\r\n            //        pass = new String( md5.digest( \"password\".getBytes() ) );\r\n            //\r\n            //        log.debug( \"Accepted password md5 digest: \" + pass );\r\n            //      }\r\n            //      catch ( NoSuchAlgorithmException e )\r\n            //      {\r\n            //        // TODO Auto-generated catch block\r\n            //        e.printStackTrace();\r\n            //      }\r\n            // check username and password from database?\r\n            if (user.equals(userpass[0]) && pass.equals(userpass[1])) {\r\n                authorized = true;\r\n            }\r\n        }\r\n        return authorized;\r\n    }\r\n\r\n    // helper method for splitting authorization header\r\n    private String extractAuthentication(String auth) {\r\n        String result = \"\";\r\n        if (auth != null) {\r\n            String[] items = auth.split(\" \");\r\n            if (items.length == 2 && \"Basic\".equals(items[0])) {\r\n                result = items[1];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getProbeConfiguration(long probeId) {\r\n        return server.requestProbeConfigurationParameters(probeId);\r\n    }\r\n\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        boolean success = false;\r\n        try {\r\n            success = server.setProbeConfiguration(probeId, configuration);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to set probe (\" + probeId + \") configuration.\", e);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    public FrameworkInfo getFrameworkInfo() {\r\n        FrameworkInfo info = new FrameworkInfo(\"-1\", getName());\r\n        return info;\r\n    }\r\n\r\n    public List<Value> getHistory(HistoryRequest request) {\r\n        long start = request.getStart();\r\n        long end = request.getEnd();\r\n        Long[] bmids = new Long[request.getBms().size()];\r\n        request.getBms().toArray(bmids);\r\n        List<Value> data = persistence.getValues(start, end, bmids, SortKey.TIME, true);\r\n        return data;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/RestPlugin_3Test.java",
		"test_prompt": "// RestPlugin_3Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport org.osgi.framework.BundleContext;\nimport com.sun.jersey.core.util.Base64;\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RestPlugin}.\n* It contains ten unit test cases for the {@link RestPlugin#isAlive(String)} method.\n*/\nclass RestPlugin_3Test {"
	},
	{
		"original_code": "// RestPlugin.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.UUID;\r\nimport org.osgi.framework.BundleContext;\r\nimport com.sun.jersey.core.util.Base64;\r\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\r\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class RestPlugin extends BasePlugin implements KnowledgeSource, RegistryUser, ServerUser, PersistenceUser {\r\n\r\n    private final static Logger log = new Logger(RestPlugin.class);\r\n\r\n    private static RestPlugin restPlugin = null;\r\n\r\n    //for the server-agent to communicate with the probe-agents\r\n    private ServerPlugin server;\r\n\r\n    //for accessing runtime state\r\n    private RegistryPlugin registry;\r\n\r\n    //provides bundle to database\r\n    private PersistencePlugin persistence;\r\n\r\n    //for sending BM results\r\n    //  private RestClient restClient;\r\n    //(sac)Id for measurement subscriptions\r\n    private long restId = -2;\r\n\r\n    // registered clients\r\n    private Map<String, ClientRequest> clients;\r\n\r\n    // client subsciptions\r\n    private ClientSubscriptionRegistry subs;\r\n\r\n    public static RestPlugin getInstance() {\r\n        return restPlugin;\r\n    }\r\n\r\n    public RestPlugin(BundleContext bc) {\r\n        super(bc, log);\r\n        //set up listeners to capture server-agent and registry services\r\n        ServerServiceListener serverListener = new ServerServiceListener(bc, log, this);\r\n        serverListener.init();\r\n        RegistryServiceListener listener = new RegistryServiceListener(bc, log, this);\r\n        listener.init();\r\n        PersistenceServiceListener persListener = new PersistenceServiceListener(bc, log, this);\r\n        persListener.init();\r\n        restPlugin = this;\r\n        //    restClient = new RestClient();\r\n        clients = new LinkedHashMap<String, ClientRequest>();\r\n        subs = new ClientSubscriptionRegistry();\r\n    }\r\n\r\n    public void setServer(ServerPlugin server) {\r\n        this.server = server;\r\n    }\r\n\r\n    public void setRegistry(RegistryPlugin registry) {\r\n        this.registry = registry;\r\n    }\r\n\r\n    @Override\r\n    public void setPersistence(PersistencePlugin persistence) {\r\n        this.persistence = persistence;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        new RestPlugin(null).start();\r\n    }\r\n\r\n    public void start() {\r\n    }\r\n\r\n    public void stop() {\r\n    }\r\n\r\n    //Gives a list of available BM.\r\n    public List<BMDescription> getAvailableBMList() {\r\n        return registry.getAvailableBM();\r\n    }\r\n\r\n    public List<ProbeDescription> getProbes() {\r\n        return registry.getProbes();\r\n    }\r\n\r\n    public ProbeDescription getProbeForBM(long bmId) {\r\n        return registry.getProbeForBM(bmId);\r\n    }\r\n\r\n    public Collection<TargetDescription> getTargets() {\r\n        return registry.getTargets();\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public boolean requestBM(long bmId) {\r\n        log.debug(\"requestBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n        return true;\r\n    }\r\n\r\n    public void requestBaseMeasure(String base64auth, long bmId) {\r\n        ClientRequest client = clients.get(extractAuthentication(base64auth));\r\n        log.debug(\"Client (\" + client.getName() + \") is requesting base measure, id=\" + bmId);\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addMeasurementRequest(restId, probe.getBm(), probe.getProbeId());\r\n        server.requestBM(bmId, subscriptionId);\r\n    }\r\n\r\n    //Requests for a given measurement to be provided\r\n    public void subscribeToBM(long bmId, long interval) {\r\n        log.debug(\"subscribeToBM\");\r\n        ProbeDescription probe = registry.getProbeForBM(bmId);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(bmId, interval, subscriptionId);\r\n    }\r\n\r\n    public void subscribeBaseMeasure(String authHeader, long id, long interval) {\r\n        ProbeDescription probe = registry.getProbeForBM(id);\r\n        long subscriptionId = registry.addSubscription(restId, probe.getBm(), interval, probe.getProbeId());\r\n        server.subscribeToBM(id, interval, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.add(subscriptionId, client);\r\n    }\r\n\r\n    //removes an existing subscription\r\n    public void unSubscribeToBM(long bmId) {\r\n        log.debug(\"unSubscribeToBM\");\r\n        long subscriptionId = registry.getIdForSubscription(restId, bmId);\r\n        server.unSubscribeToBM(bmId, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n    }\r\n\r\n    public void unsubscribeBaseMeasure(String authHeader, long id) {\r\n        long subscriptionId = registry.getIdForSubscription(restId, id);\r\n        server.unSubscribeToBM(id, subscriptionId);\r\n        registry.removeSubscription(restId, subscriptionId);\r\n        ClientRequest client = clients.get(extractAuthentication(authHeader));\r\n        subs.remove(subscriptionId, client);\r\n    }\r\n\r\n    public void bmValue(Value value) {\r\n        log.debug(\"received BM value\");\r\n        long subscriptionId = value.getSubscriptionId();\r\n        long sacId = registry.getSacIdForSubscription(subscriptionId);\r\n        if (sacId == restId) {\r\n            log.debug(\"subscriptionId: \" + subscriptionId + \", sacId: \" + sacId);\r\n            ArrayList<ClientRequest> clients = subs.get(subscriptionId);\r\n            //if one time measurement remove subscription from registry\r\n            if (registry.getFrequencyForSubscription(subscriptionId) == 0) {\r\n                registry.removeSubscription(restId, subscriptionId);\r\n                for (ClientRequest client : clients) {\r\n                    subs.remove(subscriptionId, client);\r\n                }\r\n            }\r\n            for (ClientRequest client : clients) {\r\n                log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n                try {\r\n                    new RestClientEndpoint(client.getEndpoint()).measurement(value);\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void event(DataObject data) {\r\n        log.debug(\"received probe event\");\r\n        ProbeEvent pe = null;\r\n        ProbeRegistered pr = null;\r\n        ProbeDisabled pd = null;\r\n        if (data instanceof ProbeEvent) {\r\n            pe = (ProbeEvent) data;\r\n        } else if (data instanceof ProbeRegistered) {\r\n            pr = (ProbeRegistered) data;\r\n        } else if (data instanceof ProbeDisabled) {\r\n            pd = (ProbeDisabled) data;\r\n        }\r\n        for (ClientRequest client : clients.values()) {\r\n            log.debug(\"send value to: \" + client.getName() + \",(\" + client.getEndpoint() + \")\");\r\n            try {\r\n                RestClientEndpoint rce = new RestClientEndpoint(client.getEndpoint());\r\n                if (pe != null)\r\n                    rce.probeEvent(pe);\r\n                if (pr != null)\r\n                    rce.probeRegistered(pr);\r\n                if (pd != null)\r\n                    rce.probeDisabled(pd);\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    //list of information to be received from the blackboard\r\n    public Set getCommands() {\r\n        return createCommandSet(Value.class);\r\n    }\r\n\r\n    public void process(DataObject data) {\r\n        if (data instanceof Value) {\r\n            Value value = (Value) data;\r\n            log.debug(\"received value:\" + value);\r\n            bmValue(value);\r\n        } else if (data instanceof ProbeEvent || data instanceof ProbeRegistered || data instanceof ProbeDisabled) {\r\n            event(data);\r\n        }\r\n    }\r\n\r\n    public String getName() {\r\n        return RestPlugin.class.getName();\r\n    }\r\n\r\n    public Session registerClient(String base64auth, ClientRequest client) {\r\n        log.debug(\"Registering client: \" + client);\r\n        String authentication = extractAuthentication(base64auth);\r\n        // if client has already registered, all subscriptions should be released\r\n        if (clients.containsKey(authentication)) {\r\n            clients.remove(authentication);\r\n            //TODO: release all subsciptions here:\r\n            //TODO: add mechanism for outdating session\r\n        }\r\n        // create new session for the client\r\n        UUID id = UUID.randomUUID();\r\n        Session session = new Session(id);\r\n        client.setSession(session);\r\n        clients.put(authentication, client);\r\n        return session;\r\n    }\r\n\r\n    public boolean isAlive(String base64auth) {\r\n        return clients.containsKey(extractAuthentication(base64auth));\r\n    }\r\n\r\n    public boolean isAuthorized(String base64auth) {\r\n        String authentication = extractAuthentication(base64auth);\r\n        boolean authorized = false;\r\n        if (authentication.length() > 0) {\r\n            // now we are ready to check authentication string\r\n            String decoded = Base64.base64Decode(authentication);\r\n            log.debug(\"Decoded authentication string: \" + decoded);\r\n            String[] userpass = decoded.split(\":\");\r\n            log.debug(\"User credentials: [\" + userpass[0] + \":\" + userpass[1] + \"]\");\r\n            String pass = \"password\";\r\n            String user = \"username\";\r\n            //      try\r\n            //      {\r\n            //        MessageDigest md5 = MessageDigest.getInstance( \"SHA-256\" );\r\n            //        pass = new String( md5.digest( \"password\".getBytes() ) );\r\n            //\r\n            //        log.debug( \"Accepted password md5 digest: \" + pass );\r\n            //      }\r\n            //      catch ( NoSuchAlgorithmException e )\r\n            //      {\r\n            //        // TODO Auto-generated catch block\r\n            //        e.printStackTrace();\r\n            //      }\r\n            // check username and password from database?\r\n            if (user.equals(userpass[0]) && pass.equals(userpass[1])) {\r\n                authorized = true;\r\n            }\r\n        }\r\n        return authorized;\r\n    }\r\n\r\n    // helper method for splitting authorization header\r\n    private String extractAuthentication(String auth) {\r\n        String result = \"\";\r\n        if (auth != null) {\r\n            String[] items = auth.split(\" \");\r\n            if (items.length == 2 && \"Basic\".equals(items[0])) {\r\n                result = items[1];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public Collection<ProbeConfiguration> getProbeConfiguration(long probeId) {\r\n        return server.requestProbeConfigurationParameters(probeId);\r\n    }\r\n\r\n    public boolean setProbeConfiguration(long probeId, Map<String, String> configuration) {\r\n        boolean success = false;\r\n        try {\r\n            success = server.setProbeConfiguration(probeId, configuration);\r\n        } catch (Exception e) {\r\n            log.error(\"Failed to set probe (\" + probeId + \") configuration.\", e);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    public FrameworkInfo getFrameworkInfo() {\r\n        FrameworkInfo info = new FrameworkInfo(\"-1\", getName());\r\n        return info;\r\n    }\r\n\r\n    public List<Value> getHistory(HistoryRequest request) {\r\n        long start = request.getStart();\r\n        long end = request.getEnd();\r\n        Long[] bmids = new Long[request.getBms().size()];\r\n        request.getBms().toArray(bmids);\r\n        List<Value> data = persistence.getValues(start, end, bmids, SortKey.TIME, true);\r\n        return data;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/plugins/rest/RestPlugin_4Test.java",
		"test_prompt": "// RestPlugin_4Test.java\npackage fi.vtt.noen.mfw.bundle.server.plugins.rest;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport org.osgi.framework.BundleContext;\nimport com.sun.jersey.core.util.Base64;\nimport fi.vtt.noen.mfw.bundle.common.BasePlugin;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistencePlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.persistence.PersistenceUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.registry.RegistryUser;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.ClientRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.FrameworkInfo;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.HistoryRequest;\nimport fi.vtt.noen.mfw.bundle.server.plugins.rest.resources.Session;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerPlugin;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerServiceListener;\nimport fi.vtt.noen.mfw.bundle.server.plugins.xmlrpc.ServerUser;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.BMDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeDisabled;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.ProbeRegistered;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.TargetDescription;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value;\nimport fi.vtt.noen.mfw.bundle.server.shared.datamodel.Value.SortKey;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RestPlugin}.\n* It contains ten unit test cases for the {@link RestPlugin#isAuthorized(String)} method.\n*/\nclass RestPlugin_4Test {"
	},
	{
		"original_code": "// BMReport.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport java.text.DateFormat;\r\nimport java.util.Date;\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\npublic class BMReport extends DataObject {\r\n\r\n    private final String measureURI;\r\n\r\n    private final String currentValue;\r\n\r\n    private final Date measureTime;\r\n\r\n    private final long subscriptionId;\r\n\r\n    private final boolean matchReference;\r\n\r\n    private final String referenceValue;\r\n\r\n    public BMReport(String measureURI, String value, long time, long subscriptionId, boolean matchReference, String reference) {\r\n        super(DataType.BM_REPORT);\r\n        this.measureURI = measureURI;\r\n        this.currentValue = value;\r\n        this.measureTime = new Date(time);\r\n        this.subscriptionId = subscriptionId;\r\n        this.matchReference = matchReference;\r\n        this.referenceValue = reference;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return measureURI;\r\n    }\r\n\r\n    public String getCurrentValue() {\r\n        return currentValue;\r\n    }\r\n\r\n    public String getMeasureTime() {\r\n        return DateFormat.getDateTimeInstance().format(measureTime);\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public boolean isMatchReference() {\r\n        return matchReference;\r\n    }\r\n\r\n    public String getReferenceValue() {\r\n        return referenceValue;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/BMReport.java",
		"test_prompt": "// BMReportTest.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport java.text.DateFormat;\nimport java.util.Date;\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMReport}.\n* It contains ten unit test cases for the {@link BMReport#isMatchReference()} method.\n*/\nclass BMReportTest {"
	},
	{
		"original_code": "// ProbeRegistered.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\n\r\n/**\r\n * When a new probe is created, this Event is created. TODO: check if it would be better to extend the Event class.\r\n */\r\npublic class ProbeRegistered extends DataObject {\r\n\r\n    private final ProbeDescription probeDescription;\r\n\r\n    private final boolean newBM;\r\n\r\n    private final boolean newTarget;\r\n\r\n    public ProbeRegistered(ProbeDescription probeDescription, boolean newBM, boolean newTarget) {\r\n        super(DataType.PROBE_REGISTERED);\r\n        this.probeDescription = probeDescription;\r\n        this.newBM = newBM;\r\n        this.newTarget = newTarget;\r\n    }\r\n\r\n    public ProbeDescription getProbeDescription() {\r\n        return probeDescription;\r\n    }\r\n\r\n    public boolean isNewBM() {\r\n        return newBM;\r\n    }\r\n\r\n    public boolean isNewTarget() {\r\n        return newTarget;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ProbeRegistered{\" + \"probeDescription=\" + probeDescription + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/ProbeRegistered_0Test.java",
		"test_prompt": "// ProbeRegistered_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeRegistered}.\n* It contains ten unit test cases for the {@link ProbeRegistered#isNewBM()} method.\n*/\nclass ProbeRegistered_0Test {"
	},
	{
		"original_code": "// ProbeRegistered.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\n\r\n/**\r\n * When a new probe is created, this Event is created. TODO: check if it would be better to extend the Event class.\r\n */\r\npublic class ProbeRegistered extends DataObject {\r\n\r\n    private final ProbeDescription probeDescription;\r\n\r\n    private final boolean newBM;\r\n\r\n    private final boolean newTarget;\r\n\r\n    public ProbeRegistered(ProbeDescription probeDescription, boolean newBM, boolean newTarget) {\r\n        super(DataType.PROBE_REGISTERED);\r\n        this.probeDescription = probeDescription;\r\n        this.newBM = newBM;\r\n        this.newTarget = newTarget;\r\n    }\r\n\r\n    public ProbeDescription getProbeDescription() {\r\n        return probeDescription;\r\n    }\r\n\r\n    public boolean isNewBM() {\r\n        return newBM;\r\n    }\r\n\r\n    public boolean isNewTarget() {\r\n        return newTarget;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ProbeRegistered{\" + \"probeDescription=\" + probeDescription + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/ProbeRegistered_1Test.java",
		"test_prompt": "// ProbeRegistered_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeRegistered}.\n* It contains ten unit test cases for the {@link ProbeRegistered#isNewTarget()} method.\n*/\nclass ProbeRegistered_1Test {"
	},
	{
		"original_code": "// BMDescription.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Transient;\r\n\r\n/**\r\n * Describes a base measure in terms of BM class, BM name, BM description, and measurement target.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"bm_description\")\r\npublic class BMDescription implements Comparable {\r\n\r\n    private final static Logger log = new Logger(BMDescription.class);\r\n\r\n    //automatically generated id value from JPA/DB\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long bmId;\r\n\r\n    //the class of base measure. not used for anything atm. but could be used to group BM types together.\r\n    @Column(name = \"class\")\r\n    private String bmClass;\r\n\r\n    //the name of a base measure\r\n    @Column(name = \"name\")\r\n    private String bmName;\r\n\r\n    //the target of measurement\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private TargetDescription target;\r\n\r\n    //the description of the base measure. free form text for human consumption.\r\n    @Column(name = \"description\")\r\n    private String bmDescription;\r\n\r\n    @Column(name = \"data_type\")\r\n    private Type dataType;\r\n\r\n    public enum Type {\r\n\r\n        STRING, BOOLEAN, NUMERIC\r\n    }\r\n\r\n    public BMDescription() {\r\n    }\r\n\r\n    public BMDescription(TargetDescription target, String bmClass, String bmName, String bmDescription) {\r\n        this.target = target;\r\n        this.bmClass = bmClass;\r\n        this.bmName = bmName;\r\n        this.bmDescription = bmDescription;\r\n        this.dataType = Type.STRING;\r\n    }\r\n\r\n    public BMDescription(TargetDescription target, String bmClass, String bmName, String bmDescription, Type dataType) {\r\n        this.target = target;\r\n        this.bmClass = bmClass;\r\n        this.bmName = bmName;\r\n        this.bmDescription = bmDescription;\r\n        this.dataType = dataType;\r\n    }\r\n\r\n    @Transient\r\n    public String getMeasureURI() {\r\n        return Const.createMeasureURI(target.getTargetType(), target.getTargetName(), bmClass, bmName);\r\n    }\r\n\r\n    public String getBmDescription() {\r\n        return bmDescription;\r\n    }\r\n\r\n    public String getBmName() {\r\n        return bmName;\r\n    }\r\n\r\n    public String getBmClass() {\r\n        return bmClass;\r\n    }\r\n\r\n    public TargetDescription getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public long getBmId() {\r\n        return bmId;\r\n    }\r\n\r\n    public Type getDataType() {\r\n        return dataType;\r\n    }\r\n\r\n    /**\r\n     * Check if this is the same as the given one. Comparison is based on the measureURI.\r\n     * Could probably be turned into equals..\r\n     *\r\n     * @param desc What we are comparing against.\r\n     * @return True if they have the same measureURI.\r\n     */\r\n    public boolean matches(BMDescription desc) {\r\n        return desc.getMeasureURI().equals(getMeasureURI());\r\n    }\r\n\r\n    /**\r\n     * Check if this BM matches a measurement values. That is, is the value a value for this BM.\r\n     * Comparison based on the measureURI.\r\n     *\r\n     * @param value What we are comparing against.\r\n     * @return True if they have the same measureURI.\r\n     */\r\n    public boolean matches(Value value) {\r\n        return value.getMeasureURI().equals(getMeasureURI());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return getMeasureURI();\r\n    }\r\n\r\n    //for the comparator interface\r\n    public int compareTo(Object o) {\r\n        BMDescription other = (BMDescription) o;\r\n        return getMeasureURI().compareTo(other.getMeasureURI());\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/BMDescription_0Test.java",
		"test_prompt": "// BMDescription_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Transient;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMDescription}.\n* It contains ten unit test cases for the {@link BMDescription#matches(BMDescription)} method.\n*/\nclass BMDescription_0Test {"
	},
	{
		"original_code": "// BMDescription.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Transient;\r\n\r\n/**\r\n * Describes a base measure in terms of BM class, BM name, BM description, and measurement target.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"bm_description\")\r\npublic class BMDescription implements Comparable {\r\n\r\n    private final static Logger log = new Logger(BMDescription.class);\r\n\r\n    //automatically generated id value from JPA/DB\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long bmId;\r\n\r\n    //the class of base measure. not used for anything atm. but could be used to group BM types together.\r\n    @Column(name = \"class\")\r\n    private String bmClass;\r\n\r\n    //the name of a base measure\r\n    @Column(name = \"name\")\r\n    private String bmName;\r\n\r\n    //the target of measurement\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private TargetDescription target;\r\n\r\n    //the description of the base measure. free form text for human consumption.\r\n    @Column(name = \"description\")\r\n    private String bmDescription;\r\n\r\n    @Column(name = \"data_type\")\r\n    private Type dataType;\r\n\r\n    public enum Type {\r\n\r\n        STRING, BOOLEAN, NUMERIC\r\n    }\r\n\r\n    public BMDescription() {\r\n    }\r\n\r\n    public BMDescription(TargetDescription target, String bmClass, String bmName, String bmDescription) {\r\n        this.target = target;\r\n        this.bmClass = bmClass;\r\n        this.bmName = bmName;\r\n        this.bmDescription = bmDescription;\r\n        this.dataType = Type.STRING;\r\n    }\r\n\r\n    public BMDescription(TargetDescription target, String bmClass, String bmName, String bmDescription, Type dataType) {\r\n        this.target = target;\r\n        this.bmClass = bmClass;\r\n        this.bmName = bmName;\r\n        this.bmDescription = bmDescription;\r\n        this.dataType = dataType;\r\n    }\r\n\r\n    @Transient\r\n    public String getMeasureURI() {\r\n        return Const.createMeasureURI(target.getTargetType(), target.getTargetName(), bmClass, bmName);\r\n    }\r\n\r\n    public String getBmDescription() {\r\n        return bmDescription;\r\n    }\r\n\r\n    public String getBmName() {\r\n        return bmName;\r\n    }\r\n\r\n    public String getBmClass() {\r\n        return bmClass;\r\n    }\r\n\r\n    public TargetDescription getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public long getBmId() {\r\n        return bmId;\r\n    }\r\n\r\n    public Type getDataType() {\r\n        return dataType;\r\n    }\r\n\r\n    /**\r\n     * Check if this is the same as the given one. Comparison is based on the measureURI.\r\n     * Could probably be turned into equals..\r\n     *\r\n     * @param desc What we are comparing against.\r\n     * @return True if they have the same measureURI.\r\n     */\r\n    public boolean matches(BMDescription desc) {\r\n        return desc.getMeasureURI().equals(getMeasureURI());\r\n    }\r\n\r\n    /**\r\n     * Check if this BM matches a measurement values. That is, is the value a value for this BM.\r\n     * Comparison based on the measureURI.\r\n     *\r\n     * @param value What we are comparing against.\r\n     * @return True if they have the same measureURI.\r\n     */\r\n    public boolean matches(Value value) {\r\n        return value.getMeasureURI().equals(getMeasureURI());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return getMeasureURI();\r\n    }\r\n\r\n    //for the comparator interface\r\n    public int compareTo(Object o) {\r\n        BMDescription other = (BMDescription) o;\r\n        return getMeasureURI().compareTo(other.getMeasureURI());\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/BMDescription_1Test.java",
		"test_prompt": "// BMDescription_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Transient;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMDescription}.\n* It contains ten unit test cases for the {@link BMDescription#matches(Value)} method.\n*/\nclass BMDescription_1Test {"
	},
	{
		"original_code": "// BMDescription.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Transient;\r\n\r\n/**\r\n * Describes a base measure in terms of BM class, BM name, BM description, and measurement target.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"bm_description\")\r\npublic class BMDescription implements Comparable {\r\n\r\n    private final static Logger log = new Logger(BMDescription.class);\r\n\r\n    //automatically generated id value from JPA/DB\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long bmId;\r\n\r\n    //the class of base measure. not used for anything atm. but could be used to group BM types together.\r\n    @Column(name = \"class\")\r\n    private String bmClass;\r\n\r\n    //the name of a base measure\r\n    @Column(name = \"name\")\r\n    private String bmName;\r\n\r\n    //the target of measurement\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private TargetDescription target;\r\n\r\n    //the description of the base measure. free form text for human consumption.\r\n    @Column(name = \"description\")\r\n    private String bmDescription;\r\n\r\n    @Column(name = \"data_type\")\r\n    private Type dataType;\r\n\r\n    public enum Type {\r\n\r\n        STRING, BOOLEAN, NUMERIC\r\n    }\r\n\r\n    public BMDescription() {\r\n    }\r\n\r\n    public BMDescription(TargetDescription target, String bmClass, String bmName, String bmDescription) {\r\n        this.target = target;\r\n        this.bmClass = bmClass;\r\n        this.bmName = bmName;\r\n        this.bmDescription = bmDescription;\r\n        this.dataType = Type.STRING;\r\n    }\r\n\r\n    public BMDescription(TargetDescription target, String bmClass, String bmName, String bmDescription, Type dataType) {\r\n        this.target = target;\r\n        this.bmClass = bmClass;\r\n        this.bmName = bmName;\r\n        this.bmDescription = bmDescription;\r\n        this.dataType = dataType;\r\n    }\r\n\r\n    @Transient\r\n    public String getMeasureURI() {\r\n        return Const.createMeasureURI(target.getTargetType(), target.getTargetName(), bmClass, bmName);\r\n    }\r\n\r\n    public String getBmDescription() {\r\n        return bmDescription;\r\n    }\r\n\r\n    public String getBmName() {\r\n        return bmName;\r\n    }\r\n\r\n    public String getBmClass() {\r\n        return bmClass;\r\n    }\r\n\r\n    public TargetDescription getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public long getBmId() {\r\n        return bmId;\r\n    }\r\n\r\n    public Type getDataType() {\r\n        return dataType;\r\n    }\r\n\r\n    /**\r\n     * Check if this is the same as the given one. Comparison is based on the measureURI.\r\n     * Could probably be turned into equals..\r\n     *\r\n     * @param desc What we are comparing against.\r\n     * @return True if they have the same measureURI.\r\n     */\r\n    public boolean matches(BMDescription desc) {\r\n        return desc.getMeasureURI().equals(getMeasureURI());\r\n    }\r\n\r\n    /**\r\n     * Check if this BM matches a measurement values. That is, is the value a value for this BM.\r\n     * Comparison based on the measureURI.\r\n     *\r\n     * @param value What we are comparing against.\r\n     * @return True if they have the same measureURI.\r\n     */\r\n    public boolean matches(Value value) {\r\n        return value.getMeasureURI().equals(getMeasureURI());\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return getMeasureURI();\r\n    }\r\n\r\n    //for the comparator interface\r\n    public int compareTo(Object o) {\r\n        BMDescription other = (BMDescription) o;\r\n        return getMeasureURI().compareTo(other.getMeasureURI());\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/BMDescription_2Test.java",
		"test_prompt": "// BMDescription_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Transient;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BMDescription}.\n* It contains ten unit test cases for the {@link BMDescription#compareTo(Object)} method.\n*/\nclass BMDescription_2Test {"
	},
	{
		"original_code": "// ProbeDisabled.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\n\r\n/**\r\n * When a probe is disabled (does not provide keep-alive), an event is created on the blackboard.\r\n * //TODO: check if this would be better of as an Event class extension.\r\n */\r\npublic class ProbeDisabled extends DataObject {\r\n\r\n    private final ProbeDescription probeDescription;\r\n\r\n    private final boolean bmDisabled;\r\n\r\n    private final boolean targetDisabled;\r\n\r\n    public ProbeDisabled(ProbeDescription probe, boolean bmDisabled, boolean targetDisabled) {\r\n        super(DataType.PROBE_DISABLED);\r\n        this.probeDescription = probe;\r\n        this.bmDisabled = bmDisabled;\r\n        this.targetDisabled = targetDisabled;\r\n    }\r\n\r\n    public ProbeDescription getProbeDescription() {\r\n        return probeDescription;\r\n    }\r\n\r\n    public boolean isBmDisabled() {\r\n        return bmDisabled;\r\n    }\r\n\r\n    public boolean isTargetDisabled() {\r\n        return targetDisabled;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/ProbeDisabled_0Test.java",
		"test_prompt": "// ProbeDisabled_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeDisabled}.\n* It contains ten unit test cases for the {@link ProbeDisabled#isBmDisabled()} method.\n*/\nclass ProbeDisabled_0Test {"
	},
	{
		"original_code": "// ProbeDisabled.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\n\r\n/**\r\n * When a probe is disabled (does not provide keep-alive), an event is created on the blackboard.\r\n * //TODO: check if this would be better of as an Event class extension.\r\n */\r\npublic class ProbeDisabled extends DataObject {\r\n\r\n    private final ProbeDescription probeDescription;\r\n\r\n    private final boolean bmDisabled;\r\n\r\n    private final boolean targetDisabled;\r\n\r\n    public ProbeDisabled(ProbeDescription probe, boolean bmDisabled, boolean targetDisabled) {\r\n        super(DataType.PROBE_DISABLED);\r\n        this.probeDescription = probe;\r\n        this.bmDisabled = bmDisabled;\r\n        this.targetDisabled = targetDisabled;\r\n    }\r\n\r\n    public ProbeDescription getProbeDescription() {\r\n        return probeDescription;\r\n    }\r\n\r\n    public boolean isBmDisabled() {\r\n        return bmDisabled;\r\n    }\r\n\r\n    public boolean isTargetDisabled() {\r\n        return targetDisabled;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/ProbeDisabled_1Test.java",
		"test_prompt": "// ProbeDisabled_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeDisabled}.\n* It contains ten unit test cases for the {@link ProbeDisabled#isTargetDisabled()} method.\n*/\nclass ProbeDisabled_1Test {"
	},
	{
		"original_code": "// Value.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Temporal;\r\nimport javax.persistence.TemporalType;\r\nimport javax.persistence.Transient;\r\nimport java.io.Serializable;\r\nimport java.text.DateFormat;\r\nimport java.util.Date;\r\n\r\n/**\r\n * Data value for a measurement.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"bm_value\")\r\npublic class Value extends DataObject implements Serializable {\r\n\r\n    //generated by JPA, unique identifier\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long id;\r\n\r\n    //  @Column(name=\"bm\")\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private BMDescription bm;\r\n\r\n    //we have a separate precision here to tell the exact precision of this value when it was measured..\r\n    @Column(name = \"value_precision\")\r\n    private int precision;\r\n\r\n    //the actual value, only strings are supported now\r\n    @Column(name = \"value_string\")\r\n    private String value;\r\n\r\n    //time of measurement\r\n    @Column(name = \"value_time\")\r\n    @Temporal(TemporalType.TIMESTAMP)\r\n    private Date time;\r\n\r\n    //subscriptionId to identify every measurement request/response subscription\r\n    //to support the use of multiple SACs\r\n    //this value is not stored in the DB, since historically it has not meaning\r\n    @Transient\r\n    private Long subscriptionId;\r\n\r\n    @Column(name = \"error_flag\")\r\n    private boolean error;\r\n\r\n    public enum SortKey {\r\n\r\n        PRECISION, MEASUREURI, VALUE, TIME\r\n    }\r\n\r\n    public Value() {\r\n        super(DataType.STRINGVALUE);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time) {\r\n        this(bm, precision, value, time, -1);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time, long subscriptionId) {\r\n        this(bm, precision, value, time, subscriptionId, false);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time, long subscriptionId, boolean error) {\r\n        super(DataType.STRINGVALUE);\r\n        this.bm = bm;\r\n        this.precision = precision;\r\n        this.value = value;\r\n        this.time = new Date(time);\r\n        this.subscriptionId = subscriptionId;\r\n        this.error = error;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    @Transient\r\n    public String getMeasureURI() {\r\n        return bm.getMeasureURI();\r\n    }\r\n\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    public BMDescription getBm() {\r\n        return bm;\r\n    }\r\n\r\n    public int getPrecision() {\r\n        return precision;\r\n    }\r\n\r\n    public String getString() {\r\n        checkType(DataType.STRINGVALUE);\r\n        return value;\r\n    }\r\n\r\n    @Transient\r\n    public Date getTime() {\r\n        return time;\r\n    }\r\n\r\n    @Transient\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    @Transient\r\n    public String getTimeFormatted() {\r\n        return DateFormat.getDateTimeInstance().format(time);\r\n    }\r\n\r\n    private void checkType(DataType expected) {\r\n        if (getType() != expected) {\r\n            throw new IllegalArgumentException(\"Not \" + expected + \" type value (actually \" + getType() + \").\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return bm.getMeasureURI() + \":\" + value;\r\n    }\r\n\r\n    public String valueString() {\r\n        if (getType() == DataType.STRINGVALUE) {\r\n            return \"\\\"\" + value + \"\\\"\";\r\n        }\r\n        return \"\" + value;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        Value value1 = (Value) o;\r\n        if (precision != value1.precision)\r\n            return false;\r\n        if (bm != null ? !bm.equals(value1.bm) : value1.bm != null)\r\n            return false;\r\n        if (time != null ? !time.equals(value1.time) : value1.time != null)\r\n            return false;\r\n        if (value != null ? !value.equals(value1.value) : value1.value != null)\r\n            return false;\r\n        if (subscriptionId != value1.subscriptionId)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = bm != null ? bm.hashCode() : 0;\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (value != null ? value.hashCode() : 0);\r\n        result = 31 * result + (time != null ? time.hashCode() : 0);\r\n        result = 31 * result + subscriptionId.hashCode();\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/Value_0Test.java",
		"test_prompt": "// Value_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Temporal;\nimport javax.persistence.TemporalType;\nimport javax.persistence.Transient;\nimport java.io.Serializable;\nimport java.text.DateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Value}.\n* It contains ten unit test cases for the {@link Value#isError()} method.\n*/\nclass Value_0Test {"
	},
	{
		"original_code": "// Value.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Temporal;\r\nimport javax.persistence.TemporalType;\r\nimport javax.persistence.Transient;\r\nimport java.io.Serializable;\r\nimport java.text.DateFormat;\r\nimport java.util.Date;\r\n\r\n/**\r\n * Data value for a measurement.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"bm_value\")\r\npublic class Value extends DataObject implements Serializable {\r\n\r\n    //generated by JPA, unique identifier\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long id;\r\n\r\n    //  @Column(name=\"bm\")\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private BMDescription bm;\r\n\r\n    //we have a separate precision here to tell the exact precision of this value when it was measured..\r\n    @Column(name = \"value_precision\")\r\n    private int precision;\r\n\r\n    //the actual value, only strings are supported now\r\n    @Column(name = \"value_string\")\r\n    private String value;\r\n\r\n    //time of measurement\r\n    @Column(name = \"value_time\")\r\n    @Temporal(TemporalType.TIMESTAMP)\r\n    private Date time;\r\n\r\n    //subscriptionId to identify every measurement request/response subscription\r\n    //to support the use of multiple SACs\r\n    //this value is not stored in the DB, since historically it has not meaning\r\n    @Transient\r\n    private Long subscriptionId;\r\n\r\n    @Column(name = \"error_flag\")\r\n    private boolean error;\r\n\r\n    public enum SortKey {\r\n\r\n        PRECISION, MEASUREURI, VALUE, TIME\r\n    }\r\n\r\n    public Value() {\r\n        super(DataType.STRINGVALUE);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time) {\r\n        this(bm, precision, value, time, -1);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time, long subscriptionId) {\r\n        this(bm, precision, value, time, subscriptionId, false);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time, long subscriptionId, boolean error) {\r\n        super(DataType.STRINGVALUE);\r\n        this.bm = bm;\r\n        this.precision = precision;\r\n        this.value = value;\r\n        this.time = new Date(time);\r\n        this.subscriptionId = subscriptionId;\r\n        this.error = error;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    @Transient\r\n    public String getMeasureURI() {\r\n        return bm.getMeasureURI();\r\n    }\r\n\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    public BMDescription getBm() {\r\n        return bm;\r\n    }\r\n\r\n    public int getPrecision() {\r\n        return precision;\r\n    }\r\n\r\n    public String getString() {\r\n        checkType(DataType.STRINGVALUE);\r\n        return value;\r\n    }\r\n\r\n    @Transient\r\n    public Date getTime() {\r\n        return time;\r\n    }\r\n\r\n    @Transient\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    @Transient\r\n    public String getTimeFormatted() {\r\n        return DateFormat.getDateTimeInstance().format(time);\r\n    }\r\n\r\n    private void checkType(DataType expected) {\r\n        if (getType() != expected) {\r\n            throw new IllegalArgumentException(\"Not \" + expected + \" type value (actually \" + getType() + \").\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return bm.getMeasureURI() + \":\" + value;\r\n    }\r\n\r\n    public String valueString() {\r\n        if (getType() == DataType.STRINGVALUE) {\r\n            return \"\\\"\" + value + \"\\\"\";\r\n        }\r\n        return \"\" + value;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        Value value1 = (Value) o;\r\n        if (precision != value1.precision)\r\n            return false;\r\n        if (bm != null ? !bm.equals(value1.bm) : value1.bm != null)\r\n            return false;\r\n        if (time != null ? !time.equals(value1.time) : value1.time != null)\r\n            return false;\r\n        if (value != null ? !value.equals(value1.value) : value1.value != null)\r\n            return false;\r\n        if (subscriptionId != value1.subscriptionId)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = bm != null ? bm.hashCode() : 0;\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (value != null ? value.hashCode() : 0);\r\n        result = 31 * result + (time != null ? time.hashCode() : 0);\r\n        result = 31 * result + subscriptionId.hashCode();\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/Value_1Test.java",
		"test_prompt": "// Value_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Temporal;\nimport javax.persistence.TemporalType;\nimport javax.persistence.Transient;\nimport java.io.Serializable;\nimport java.text.DateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Value}.\n* It contains ten unit test cases for the {@link Value#valueString()} method.\n*/\nclass Value_1Test {"
	},
	{
		"original_code": "// Value.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Temporal;\r\nimport javax.persistence.TemporalType;\r\nimport javax.persistence.Transient;\r\nimport java.io.Serializable;\r\nimport java.text.DateFormat;\r\nimport java.util.Date;\r\n\r\n/**\r\n * Data value for a measurement.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"bm_value\")\r\npublic class Value extends DataObject implements Serializable {\r\n\r\n    //generated by JPA, unique identifier\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long id;\r\n\r\n    //  @Column(name=\"bm\")\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private BMDescription bm;\r\n\r\n    //we have a separate precision here to tell the exact precision of this value when it was measured..\r\n    @Column(name = \"value_precision\")\r\n    private int precision;\r\n\r\n    //the actual value, only strings are supported now\r\n    @Column(name = \"value_string\")\r\n    private String value;\r\n\r\n    //time of measurement\r\n    @Column(name = \"value_time\")\r\n    @Temporal(TemporalType.TIMESTAMP)\r\n    private Date time;\r\n\r\n    //subscriptionId to identify every measurement request/response subscription\r\n    //to support the use of multiple SACs\r\n    //this value is not stored in the DB, since historically it has not meaning\r\n    @Transient\r\n    private Long subscriptionId;\r\n\r\n    @Column(name = \"error_flag\")\r\n    private boolean error;\r\n\r\n    public enum SortKey {\r\n\r\n        PRECISION, MEASUREURI, VALUE, TIME\r\n    }\r\n\r\n    public Value() {\r\n        super(DataType.STRINGVALUE);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time) {\r\n        this(bm, precision, value, time, -1);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time, long subscriptionId) {\r\n        this(bm, precision, value, time, subscriptionId, false);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time, long subscriptionId, boolean error) {\r\n        super(DataType.STRINGVALUE);\r\n        this.bm = bm;\r\n        this.precision = precision;\r\n        this.value = value;\r\n        this.time = new Date(time);\r\n        this.subscriptionId = subscriptionId;\r\n        this.error = error;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    @Transient\r\n    public String getMeasureURI() {\r\n        return bm.getMeasureURI();\r\n    }\r\n\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    public BMDescription getBm() {\r\n        return bm;\r\n    }\r\n\r\n    public int getPrecision() {\r\n        return precision;\r\n    }\r\n\r\n    public String getString() {\r\n        checkType(DataType.STRINGVALUE);\r\n        return value;\r\n    }\r\n\r\n    @Transient\r\n    public Date getTime() {\r\n        return time;\r\n    }\r\n\r\n    @Transient\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    @Transient\r\n    public String getTimeFormatted() {\r\n        return DateFormat.getDateTimeInstance().format(time);\r\n    }\r\n\r\n    private void checkType(DataType expected) {\r\n        if (getType() != expected) {\r\n            throw new IllegalArgumentException(\"Not \" + expected + \" type value (actually \" + getType() + \").\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return bm.getMeasureURI() + \":\" + value;\r\n    }\r\n\r\n    public String valueString() {\r\n        if (getType() == DataType.STRINGVALUE) {\r\n            return \"\\\"\" + value + \"\\\"\";\r\n        }\r\n        return \"\" + value;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        Value value1 = (Value) o;\r\n        if (precision != value1.precision)\r\n            return false;\r\n        if (bm != null ? !bm.equals(value1.bm) : value1.bm != null)\r\n            return false;\r\n        if (time != null ? !time.equals(value1.time) : value1.time != null)\r\n            return false;\r\n        if (value != null ? !value.equals(value1.value) : value1.value != null)\r\n            return false;\r\n        if (subscriptionId != value1.subscriptionId)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = bm != null ? bm.hashCode() : 0;\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (value != null ? value.hashCode() : 0);\r\n        result = 31 * result + (time != null ? time.hashCode() : 0);\r\n        result = 31 * result + subscriptionId.hashCode();\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/Value_2Test.java",
		"test_prompt": "// Value_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Temporal;\nimport javax.persistence.TemporalType;\nimport javax.persistence.Transient;\nimport java.io.Serializable;\nimport java.text.DateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Value}.\n* It contains ten unit test cases for the {@link Value#equals(Object)} method.\n*/\nclass Value_2Test {"
	},
	{
		"original_code": "// Value.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Temporal;\r\nimport javax.persistence.TemporalType;\r\nimport javax.persistence.Transient;\r\nimport java.io.Serializable;\r\nimport java.text.DateFormat;\r\nimport java.util.Date;\r\n\r\n/**\r\n * Data value for a measurement.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"bm_value\")\r\npublic class Value extends DataObject implements Serializable {\r\n\r\n    //generated by JPA, unique identifier\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long id;\r\n\r\n    //  @Column(name=\"bm\")\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private BMDescription bm;\r\n\r\n    //we have a separate precision here to tell the exact precision of this value when it was measured..\r\n    @Column(name = \"value_precision\")\r\n    private int precision;\r\n\r\n    //the actual value, only strings are supported now\r\n    @Column(name = \"value_string\")\r\n    private String value;\r\n\r\n    //time of measurement\r\n    @Column(name = \"value_time\")\r\n    @Temporal(TemporalType.TIMESTAMP)\r\n    private Date time;\r\n\r\n    //subscriptionId to identify every measurement request/response subscription\r\n    //to support the use of multiple SACs\r\n    //this value is not stored in the DB, since historically it has not meaning\r\n    @Transient\r\n    private Long subscriptionId;\r\n\r\n    @Column(name = \"error_flag\")\r\n    private boolean error;\r\n\r\n    public enum SortKey {\r\n\r\n        PRECISION, MEASUREURI, VALUE, TIME\r\n    }\r\n\r\n    public Value() {\r\n        super(DataType.STRINGVALUE);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time) {\r\n        this(bm, precision, value, time, -1);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time, long subscriptionId) {\r\n        this(bm, precision, value, time, subscriptionId, false);\r\n    }\r\n\r\n    public Value(BMDescription bm, int precision, String value, long time, long subscriptionId, boolean error) {\r\n        super(DataType.STRINGVALUE);\r\n        this.bm = bm;\r\n        this.precision = precision;\r\n        this.value = value;\r\n        this.time = new Date(time);\r\n        this.subscriptionId = subscriptionId;\r\n        this.error = error;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    @Transient\r\n    public String getMeasureURI() {\r\n        return bm.getMeasureURI();\r\n    }\r\n\r\n    public long getId() {\r\n        return id;\r\n    }\r\n\r\n    public BMDescription getBm() {\r\n        return bm;\r\n    }\r\n\r\n    public int getPrecision() {\r\n        return precision;\r\n    }\r\n\r\n    public String getString() {\r\n        checkType(DataType.STRINGVALUE);\r\n        return value;\r\n    }\r\n\r\n    @Transient\r\n    public Date getTime() {\r\n        return time;\r\n    }\r\n\r\n    @Transient\r\n    public boolean isError() {\r\n        return error;\r\n    }\r\n\r\n    @Transient\r\n    public String getTimeFormatted() {\r\n        return DateFormat.getDateTimeInstance().format(time);\r\n    }\r\n\r\n    private void checkType(DataType expected) {\r\n        if (getType() != expected) {\r\n            throw new IllegalArgumentException(\"Not \" + expected + \" type value (actually \" + getType() + \").\");\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return bm.getMeasureURI() + \":\" + value;\r\n    }\r\n\r\n    public String valueString() {\r\n        if (getType() == DataType.STRINGVALUE) {\r\n            return \"\\\"\" + value + \"\\\"\";\r\n        }\r\n        return \"\" + value;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        Value value1 = (Value) o;\r\n        if (precision != value1.precision)\r\n            return false;\r\n        if (bm != null ? !bm.equals(value1.bm) : value1.bm != null)\r\n            return false;\r\n        if (time != null ? !time.equals(value1.time) : value1.time != null)\r\n            return false;\r\n        if (value != null ? !value.equals(value1.value) : value1.value != null)\r\n            return false;\r\n        if (subscriptionId != value1.subscriptionId)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = bm != null ? bm.hashCode() : 0;\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (value != null ? value.hashCode() : 0);\r\n        result = 31 * result + (time != null ? time.hashCode() : 0);\r\n        result = 31 * result + subscriptionId.hashCode();\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/Value_3Test.java",
		"test_prompt": "// Value_3Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Temporal;\nimport javax.persistence.TemporalType;\nimport javax.persistence.Transient;\nimport java.io.Serializable;\nimport java.text.DateFormat;\nimport java.util.Date;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Value}.\n* It contains ten unit test cases for the {@link Value#hashCode()} method.\n*/\nclass Value_3Test {"
	},
	{
		"original_code": "// ProbeDescription.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Transient;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Describes a probe.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"probe_description\")\r\npublic class ProbeDescription {\r\n\r\n    private final static Logger log = new Logger(ProbeDescription.class);\r\n\r\n    //unique identifier generated by the JPA persistence provider/DB storage.\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long probeId;\r\n\r\n    //the (XMLRPC) endpoint to reach this probe\r\n    @Column(name = \"endpoint\")\r\n    private String endpoint;\r\n\r\n    //measurement precision\r\n    @Column(name = \"bm_precision\")\r\n    private int precision;\r\n\r\n    //how much time has elapsed in milliseconds since the last time we heard a keep-alive message from this probe\r\n    @Transient\r\n    private int delay = 0;\r\n\r\n    //name of the probe\r\n    @Column(name = \"probe_name\")\r\n    private String probeName;\r\n\r\n    //target of measurement (also embedded in BMdescription, so could be removed..)\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private TargetDescription target;\r\n\r\n    //the base measure that the probe provides\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private BMDescription bm;\r\n\r\n    public ProbeDescription() {\r\n        resetDelay();\r\n    }\r\n\r\n    public ProbeDescription(Map<String, String> properties, TargetDescription target, BMDescription bm) {\r\n        String probeUrl = properties.get(Const.XMLRPC_URL);\r\n        setEndpoint(probeUrl);\r\n        this.target = target;\r\n        this.bm = bm;\r\n        this.probeName = properties.get(Const.PROBE_NAME);\r\n        this.precision = Integer.parseInt(properties.get(Const.PROBE_PRECISION));\r\n        resetDelay();\r\n    }\r\n\r\n    //typically we do not change the probe endpoint address but when we read the existing data from the database,\r\n    //we need to update the endpoint with the actual current endpoint that may wary. the basic scenario is the\r\n    //change of the HTTP server port but other changes are also possible. Reading the values from the DB is needed\r\n    //in order the ensure that the probe identifier numbers are persistent for the clients. The probe is identified\r\n    //by its base measure, that is, the bm class, bm name, target type, target name = measureURI\r\n    public void updateEndpoint(Map<String, String> properties) {\r\n        String probeUrl = properties.get(Const.XMLRPC_URL);\r\n        setEndpoint(probeUrl);\r\n    }\r\n\r\n    public long getProbeId() {\r\n        return probeId;\r\n    }\r\n\r\n    public TargetDescription getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public void resetDelay() {\r\n        delay = 0;\r\n    }\r\n\r\n    public String getEndpoint() {\r\n        return endpoint;\r\n    }\r\n\r\n    public void setEndpoint(String probeUrl) {\r\n        this.endpoint = probeUrl;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return Const.createMeasureURI(target.getTargetType(), target.getTargetName(), bm.getBmClass(), bm.getBmName());\r\n    }\r\n\r\n    public int getPrecision() {\r\n        return precision;\r\n    }\r\n\r\n    public int getDelay() {\r\n        return delay;\r\n    }\r\n\r\n    public void increaseDelay(int increment) {\r\n        this.delay += increment;\r\n    }\r\n\r\n    public String getProbeName() {\r\n        return probeName;\r\n    }\r\n\r\n    public BMDescription getBm() {\r\n        return bm;\r\n    }\r\n\r\n    public boolean matches(ProbeDescription probe) {\r\n        if (getMeasureURI() != null ? !getMeasureURI().equals(probe.getMeasureURI()) : probe.getMeasureURI() != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    //this provides a check if two probe descriptions are the same, for example, to avoid duplicate registrations after network cutoff\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        ProbeDescription that = (ProbeDescription) o;\r\n        int endIndex = endpoint.indexOf(\"/xmlrpc\");\r\n        String thisEndpoint = endpoint.substring(0, endIndex - 4);\r\n        String thatEndpoint = that.endpoint.substring(0, endIndex - 4);\r\n        if (precision != that.precision)\r\n            return false;\r\n        if (getBm() != null ? !getBm().equals(that.getBm()) : that.getBm() != null)\r\n            return false;\r\n        if (getMeasureURI() != null ? !getMeasureURI().equals(that.getMeasureURI()) : that.getMeasureURI() != null)\r\n            return false;\r\n        if (getTarget() != null ? !getTarget().equals(that.getTarget()) : that.getTarget() != null)\r\n            return false;\r\n        if (thisEndpoint != null ? !thisEndpoint.equals(thatEndpoint) : thatEndpoint != null)\r\n            return false;\r\n        if (probeName != null ? !probeName.equals(that.probeName) : that.probeName != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = endpoint != null ? endpoint.hashCode() : 0;\r\n        result = 31 * result + (getMeasureURI() != null ? getMeasureURI().hashCode() : 0);\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (probeName != null ? probeName.hashCode() : 0);\r\n        result = 31 * result + (bm != null ? bm.hashCode() : 0);\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ProbeDescription{\" + \"endpoint='\" + endpoint + '\\'' + \", measureURI='\" + getMeasureURI() + '\\'' + \", precision=\" + precision + \", probeId=\" + probeId + \", delay=\" + delay + \", name='\" + probeName + '\\'' + \", deviceName='\" + target.getTargetName() + '\\'' + \", deviceType='\" + target.getTargetType() + '\\'' + \", bmName='\" + bm.getBmName() + '\\'' + \", bmDescription='\" + bm.getBmDescription() + '\\'' + \", id='\" + probeId + '\\'' + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/ProbeDescription_0Test.java",
		"test_prompt": "// ProbeDescription_0Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Transient;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeDescription}.\n* It contains ten unit test cases for the {@link ProbeDescription#matches(ProbeDescription)} method.\n*/\nclass ProbeDescription_0Test {"
	},
	{
		"original_code": "// ProbeDescription.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Transient;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Describes a probe.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"probe_description\")\r\npublic class ProbeDescription {\r\n\r\n    private final static Logger log = new Logger(ProbeDescription.class);\r\n\r\n    //unique identifier generated by the JPA persistence provider/DB storage.\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long probeId;\r\n\r\n    //the (XMLRPC) endpoint to reach this probe\r\n    @Column(name = \"endpoint\")\r\n    private String endpoint;\r\n\r\n    //measurement precision\r\n    @Column(name = \"bm_precision\")\r\n    private int precision;\r\n\r\n    //how much time has elapsed in milliseconds since the last time we heard a keep-alive message from this probe\r\n    @Transient\r\n    private int delay = 0;\r\n\r\n    //name of the probe\r\n    @Column(name = \"probe_name\")\r\n    private String probeName;\r\n\r\n    //target of measurement (also embedded in BMdescription, so could be removed..)\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private TargetDescription target;\r\n\r\n    //the base measure that the probe provides\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private BMDescription bm;\r\n\r\n    public ProbeDescription() {\r\n        resetDelay();\r\n    }\r\n\r\n    public ProbeDescription(Map<String, String> properties, TargetDescription target, BMDescription bm) {\r\n        String probeUrl = properties.get(Const.XMLRPC_URL);\r\n        setEndpoint(probeUrl);\r\n        this.target = target;\r\n        this.bm = bm;\r\n        this.probeName = properties.get(Const.PROBE_NAME);\r\n        this.precision = Integer.parseInt(properties.get(Const.PROBE_PRECISION));\r\n        resetDelay();\r\n    }\r\n\r\n    //typically we do not change the probe endpoint address but when we read the existing data from the database,\r\n    //we need to update the endpoint with the actual current endpoint that may wary. the basic scenario is the\r\n    //change of the HTTP server port but other changes are also possible. Reading the values from the DB is needed\r\n    //in order the ensure that the probe identifier numbers are persistent for the clients. The probe is identified\r\n    //by its base measure, that is, the bm class, bm name, target type, target name = measureURI\r\n    public void updateEndpoint(Map<String, String> properties) {\r\n        String probeUrl = properties.get(Const.XMLRPC_URL);\r\n        setEndpoint(probeUrl);\r\n    }\r\n\r\n    public long getProbeId() {\r\n        return probeId;\r\n    }\r\n\r\n    public TargetDescription getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public void resetDelay() {\r\n        delay = 0;\r\n    }\r\n\r\n    public String getEndpoint() {\r\n        return endpoint;\r\n    }\r\n\r\n    public void setEndpoint(String probeUrl) {\r\n        this.endpoint = probeUrl;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return Const.createMeasureURI(target.getTargetType(), target.getTargetName(), bm.getBmClass(), bm.getBmName());\r\n    }\r\n\r\n    public int getPrecision() {\r\n        return precision;\r\n    }\r\n\r\n    public int getDelay() {\r\n        return delay;\r\n    }\r\n\r\n    public void increaseDelay(int increment) {\r\n        this.delay += increment;\r\n    }\r\n\r\n    public String getProbeName() {\r\n        return probeName;\r\n    }\r\n\r\n    public BMDescription getBm() {\r\n        return bm;\r\n    }\r\n\r\n    public boolean matches(ProbeDescription probe) {\r\n        if (getMeasureURI() != null ? !getMeasureURI().equals(probe.getMeasureURI()) : probe.getMeasureURI() != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    //this provides a check if two probe descriptions are the same, for example, to avoid duplicate registrations after network cutoff\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        ProbeDescription that = (ProbeDescription) o;\r\n        int endIndex = endpoint.indexOf(\"/xmlrpc\");\r\n        String thisEndpoint = endpoint.substring(0, endIndex - 4);\r\n        String thatEndpoint = that.endpoint.substring(0, endIndex - 4);\r\n        if (precision != that.precision)\r\n            return false;\r\n        if (getBm() != null ? !getBm().equals(that.getBm()) : that.getBm() != null)\r\n            return false;\r\n        if (getMeasureURI() != null ? !getMeasureURI().equals(that.getMeasureURI()) : that.getMeasureURI() != null)\r\n            return false;\r\n        if (getTarget() != null ? !getTarget().equals(that.getTarget()) : that.getTarget() != null)\r\n            return false;\r\n        if (thisEndpoint != null ? !thisEndpoint.equals(thatEndpoint) : thatEndpoint != null)\r\n            return false;\r\n        if (probeName != null ? !probeName.equals(that.probeName) : that.probeName != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = endpoint != null ? endpoint.hashCode() : 0;\r\n        result = 31 * result + (getMeasureURI() != null ? getMeasureURI().hashCode() : 0);\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (probeName != null ? probeName.hashCode() : 0);\r\n        result = 31 * result + (bm != null ? bm.hashCode() : 0);\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ProbeDescription{\" + \"endpoint='\" + endpoint + '\\'' + \", measureURI='\" + getMeasureURI() + '\\'' + \", precision=\" + precision + \", probeId=\" + probeId + \", delay=\" + delay + \", name='\" + probeName + '\\'' + \", deviceName='\" + target.getTargetName() + '\\'' + \", deviceType='\" + target.getTargetType() + '\\'' + \", bmName='\" + bm.getBmName() + '\\'' + \", bmDescription='\" + bm.getBmDescription() + '\\'' + \", id='\" + probeId + '\\'' + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/ProbeDescription_1Test.java",
		"test_prompt": "// ProbeDescription_1Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Transient;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeDescription}.\n* It contains ten unit test cases for the {@link ProbeDescription#equals(Object)} method.\n*/\nclass ProbeDescription_1Test {"
	},
	{
		"original_code": "// ProbeDescription.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Transient;\r\nimport java.util.Map;\r\n\r\n/**\r\n * Describes a probe.\r\n * Annotations are for persistence with JPA (DB storage).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\n@Entity\r\n@Table(name = \"probe_description\")\r\npublic class ProbeDescription {\r\n\r\n    private final static Logger log = new Logger(ProbeDescription.class);\r\n\r\n    //unique identifier generated by the JPA persistence provider/DB storage.\r\n    @GeneratedValue\r\n    @Id\r\n    @Column(name = \"id\", nullable = false, updatable = false)\r\n    private Long probeId;\r\n\r\n    //the (XMLRPC) endpoint to reach this probe\r\n    @Column(name = \"endpoint\")\r\n    private String endpoint;\r\n\r\n    //measurement precision\r\n    @Column(name = \"bm_precision\")\r\n    private int precision;\r\n\r\n    //how much time has elapsed in milliseconds since the last time we heard a keep-alive message from this probe\r\n    @Transient\r\n    private int delay = 0;\r\n\r\n    //name of the probe\r\n    @Column(name = \"probe_name\")\r\n    private String probeName;\r\n\r\n    //target of measurement (also embedded in BMdescription, so could be removed..)\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private TargetDescription target;\r\n\r\n    //the base measure that the probe provides\r\n    @ManyToOne(fetch = FetchType.EAGER)\r\n    private BMDescription bm;\r\n\r\n    public ProbeDescription() {\r\n        resetDelay();\r\n    }\r\n\r\n    public ProbeDescription(Map<String, String> properties, TargetDescription target, BMDescription bm) {\r\n        String probeUrl = properties.get(Const.XMLRPC_URL);\r\n        setEndpoint(probeUrl);\r\n        this.target = target;\r\n        this.bm = bm;\r\n        this.probeName = properties.get(Const.PROBE_NAME);\r\n        this.precision = Integer.parseInt(properties.get(Const.PROBE_PRECISION));\r\n        resetDelay();\r\n    }\r\n\r\n    //typically we do not change the probe endpoint address but when we read the existing data from the database,\r\n    //we need to update the endpoint with the actual current endpoint that may wary. the basic scenario is the\r\n    //change of the HTTP server port but other changes are also possible. Reading the values from the DB is needed\r\n    //in order the ensure that the probe identifier numbers are persistent for the clients. The probe is identified\r\n    //by its base measure, that is, the bm class, bm name, target type, target name = measureURI\r\n    public void updateEndpoint(Map<String, String> properties) {\r\n        String probeUrl = properties.get(Const.XMLRPC_URL);\r\n        setEndpoint(probeUrl);\r\n    }\r\n\r\n    public long getProbeId() {\r\n        return probeId;\r\n    }\r\n\r\n    public TargetDescription getTarget() {\r\n        return target;\r\n    }\r\n\r\n    public void resetDelay() {\r\n        delay = 0;\r\n    }\r\n\r\n    public String getEndpoint() {\r\n        return endpoint;\r\n    }\r\n\r\n    public void setEndpoint(String probeUrl) {\r\n        this.endpoint = probeUrl;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return Const.createMeasureURI(target.getTargetType(), target.getTargetName(), bm.getBmClass(), bm.getBmName());\r\n    }\r\n\r\n    public int getPrecision() {\r\n        return precision;\r\n    }\r\n\r\n    public int getDelay() {\r\n        return delay;\r\n    }\r\n\r\n    public void increaseDelay(int increment) {\r\n        this.delay += increment;\r\n    }\r\n\r\n    public String getProbeName() {\r\n        return probeName;\r\n    }\r\n\r\n    public BMDescription getBm() {\r\n        return bm;\r\n    }\r\n\r\n    public boolean matches(ProbeDescription probe) {\r\n        if (getMeasureURI() != null ? !getMeasureURI().equals(probe.getMeasureURI()) : probe.getMeasureURI() != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    //this provides a check if two probe descriptions are the same, for example, to avoid duplicate registrations after network cutoff\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        ProbeDescription that = (ProbeDescription) o;\r\n        int endIndex = endpoint.indexOf(\"/xmlrpc\");\r\n        String thisEndpoint = endpoint.substring(0, endIndex - 4);\r\n        String thatEndpoint = that.endpoint.substring(0, endIndex - 4);\r\n        if (precision != that.precision)\r\n            return false;\r\n        if (getBm() != null ? !getBm().equals(that.getBm()) : that.getBm() != null)\r\n            return false;\r\n        if (getMeasureURI() != null ? !getMeasureURI().equals(that.getMeasureURI()) : that.getMeasureURI() != null)\r\n            return false;\r\n        if (getTarget() != null ? !getTarget().equals(that.getTarget()) : that.getTarget() != null)\r\n            return false;\r\n        if (thisEndpoint != null ? !thisEndpoint.equals(thatEndpoint) : thatEndpoint != null)\r\n            return false;\r\n        if (probeName != null ? !probeName.equals(that.probeName) : that.probeName != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = endpoint != null ? endpoint.hashCode() : 0;\r\n        result = 31 * result + (getMeasureURI() != null ? getMeasureURI().hashCode() : 0);\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (probeName != null ? probeName.hashCode() : 0);\r\n        result = 31 * result + (bm != null ? bm.hashCode() : 0);\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ProbeDescription{\" + \"endpoint='\" + endpoint + '\\'' + \", measureURI='\" + getMeasureURI() + '\\'' + \", precision=\" + precision + \", probeId=\" + probeId + \", delay=\" + delay + \", name='\" + probeName + '\\'' + \", deviceName='\" + target.getTargetName() + '\\'' + \", deviceType='\" + target.getTargetType() + '\\'' + \", bmName='\" + bm.getBmName() + '\\'' + \", bmDescription='\" + bm.getBmDescription() + '\\'' + \", id='\" + probeId + '\\'' + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/server/shared/datamodel/ProbeDescription_2Test.java",
		"test_prompt": "// ProbeDescription_2Test.java\npackage fi.vtt.noen.mfw.bundle.server.shared.datamodel;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.persistence.Transient;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeDescription}.\n* It contains ten unit test cases for the {@link ProbeDescription#hashCode()} method.\n*/\nclass ProbeDescription_2Test {"
	},
	{
		"original_code": "// ProbeConfiguration.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.common;\r\n\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * Describes a probe configuration parameter.\r\n */\r\npublic class ProbeConfiguration implements Serializable {\r\n\r\n    //the name of the parameter (also the key in key-value pair)\r\n    private String name;\r\n\r\n    //describes the parameter in a natural language\r\n    private String description;\r\n\r\n    //is this parameter mandatory (can it be left undefined?)\r\n    private boolean mandatory;\r\n\r\n    //the value of the parameter\r\n    private String value;\r\n\r\n    public ProbeConfiguration(String name, String description, boolean mandatory, Object value) {\r\n        this.name = name;\r\n        this.description = description;\r\n        this.mandatory = mandatory;\r\n        if (value == null) {\r\n            this.value = null;\r\n        } else {\r\n            this.value = value.toString();\r\n        }\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    public void setDescription(String description) {\r\n        this.description = description;\r\n    }\r\n\r\n    public boolean isMandatory() {\r\n        return mandatory;\r\n    }\r\n\r\n    public void setMandatory(boolean mandatory) {\r\n        this.mandatory = mandatory;\r\n    }\r\n\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        ProbeConfiguration that = (ProbeConfiguration) o;\r\n        if (name != null ? !name.equals(that.name) : that.name != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return name != null ? name.hashCode() : 0;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/common/ProbeConfiguration_0Test.java",
		"test_prompt": "// ProbeConfiguration_0Test.java\npackage fi.vtt.noen.mfw.bundle.common;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeConfiguration}.\n* It contains ten unit test cases for the {@link ProbeConfiguration#isMandatory()} method.\n*/\nclass ProbeConfiguration_0Test {"
	},
	{
		"original_code": "// ProbeConfiguration.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.common;\r\n\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * Describes a probe configuration parameter.\r\n */\r\npublic class ProbeConfiguration implements Serializable {\r\n\r\n    //the name of the parameter (also the key in key-value pair)\r\n    private String name;\r\n\r\n    //describes the parameter in a natural language\r\n    private String description;\r\n\r\n    //is this parameter mandatory (can it be left undefined?)\r\n    private boolean mandatory;\r\n\r\n    //the value of the parameter\r\n    private String value;\r\n\r\n    public ProbeConfiguration(String name, String description, boolean mandatory, Object value) {\r\n        this.name = name;\r\n        this.description = description;\r\n        this.mandatory = mandatory;\r\n        if (value == null) {\r\n            this.value = null;\r\n        } else {\r\n            this.value = value.toString();\r\n        }\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    public void setDescription(String description) {\r\n        this.description = description;\r\n    }\r\n\r\n    public boolean isMandatory() {\r\n        return mandatory;\r\n    }\r\n\r\n    public void setMandatory(boolean mandatory) {\r\n        this.mandatory = mandatory;\r\n    }\r\n\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        ProbeConfiguration that = (ProbeConfiguration) o;\r\n        if (name != null ? !name.equals(that.name) : that.name != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return name != null ? name.hashCode() : 0;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/common/ProbeConfiguration_1Test.java",
		"test_prompt": "// ProbeConfiguration_1Test.java\npackage fi.vtt.noen.mfw.bundle.common;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeConfiguration}.\n* It contains ten unit test cases for the {@link ProbeConfiguration#equals(Object)} method.\n*/\nclass ProbeConfiguration_1Test {"
	},
	{
		"original_code": "// ProbeConfiguration.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.common;\r\n\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * Describes a probe configuration parameter.\r\n */\r\npublic class ProbeConfiguration implements Serializable {\r\n\r\n    //the name of the parameter (also the key in key-value pair)\r\n    private String name;\r\n\r\n    //describes the parameter in a natural language\r\n    private String description;\r\n\r\n    //is this parameter mandatory (can it be left undefined?)\r\n    private boolean mandatory;\r\n\r\n    //the value of the parameter\r\n    private String value;\r\n\r\n    public ProbeConfiguration(String name, String description, boolean mandatory, Object value) {\r\n        this.name = name;\r\n        this.description = description;\r\n        this.mandatory = mandatory;\r\n        if (value == null) {\r\n            this.value = null;\r\n        } else {\r\n            this.value = value.toString();\r\n        }\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n\r\n    public void setDescription(String description) {\r\n        this.description = description;\r\n    }\r\n\r\n    public boolean isMandatory() {\r\n        return mandatory;\r\n    }\r\n\r\n    public void setMandatory(boolean mandatory) {\r\n        this.mandatory = mandatory;\r\n    }\r\n\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        ProbeConfiguration that = (ProbeConfiguration) o;\r\n        if (name != null ? !name.equals(that.name) : that.name != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return name != null ? name.hashCode() : 0;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/common/ProbeConfiguration_2Test.java",
		"test_prompt": "// ProbeConfiguration_2Test.java\npackage fi.vtt.noen.mfw.bundle.common;\n\nimport java.io.Serializable;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeConfiguration}.\n* It contains ten unit test cases for the {@link ProbeConfiguration#hashCode()} method.\n*/\nclass ProbeConfiguration_2Test {"
	},
	{
		"original_code": "// ValuePair.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.common;\r\n\r\n/**\r\n * A key-value pair object (tuple?).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class ValuePair {\r\n\r\n    private final String key;\r\n\r\n    private final String value;\r\n\r\n    public ValuePair(String key, String value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    public String getKey() {\r\n        return key;\r\n    }\r\n\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ValuePair{\" + \"key='\" + key + '\\'' + \", value='\" + value + '\\'' + '}';\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        ValuePair valuePair = (ValuePair) o;\r\n        if (key != null ? !key.equals(valuePair.key) : valuePair.key != null)\r\n            return false;\r\n        if (value != null ? !value.equals(valuePair.value) : valuePair.value != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = key != null ? key.hashCode() : 0;\r\n        result = 31 * result + (value != null ? value.hashCode() : 0);\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/common/ValuePair_0Test.java",
		"test_prompt": "// ValuePair_0Test.java\npackage fi.vtt.noen.mfw.bundle.common;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ValuePair}.\n* It contains ten unit test cases for the {@link ValuePair#equals(Object)} method.\n*/\nclass ValuePair_0Test {"
	},
	{
		"original_code": "// ValuePair.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.common;\r\n\r\n/**\r\n * A key-value pair object (tuple?).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class ValuePair {\r\n\r\n    private final String key;\r\n\r\n    private final String value;\r\n\r\n    public ValuePair(String key, String value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n\r\n    public String getKey() {\r\n        return key;\r\n    }\r\n\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ValuePair{\" + \"key='\" + key + '\\'' + \", value='\" + value + '\\'' + '}';\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        ValuePair valuePair = (ValuePair) o;\r\n        if (key != null ? !key.equals(valuePair.key) : valuePair.key != null)\r\n            return false;\r\n        if (value != null ? !value.equals(valuePair.value) : valuePair.value != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = key != null ? key.hashCode() : 0;\r\n        result = 31 * result + (value != null ? value.hashCode() : 0);\r\n        return result;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/common/ValuePair_1Test.java",
		"test_prompt": "// ValuePair_1Test.java\npackage fi.vtt.noen.mfw.bundle.common;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ValuePair}.\n* It contains ten unit test cases for the {@link ValuePair#hashCode()} method.\n*/\nclass ValuePair_1Test {"
	},
	{
		"original_code": "// MFWXmlRpcFactoryFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.common;\r\n\r\nimport org.apache.xmlrpc.client.XmlRpcClient;\r\nimport org.apache.xmlrpc.client.XmlRpcClientConfigImpl;\r\nimport org.apache.xmlrpc.client.XmlRpcSun15HttpTransportFactory;\r\nimport org.apache.xmlrpc.client.util.ClientFactory;\r\nimport java.net.URL;\r\n\r\n/**\r\n * Provides some base features for XML-RPC clients as a base class to be extended.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MFWXmlRpcFactoryFactory {\r\n\r\n    /**\r\n     * Initializes the factory object to create new connections to the given url. The factory is used in the child class.\r\n     *\r\n     * @param url Address of the XMLRPC server to connect to.\r\n     */\r\n    public static ClientFactory createFactory(URL url) {\r\n        XmlRpcClientConfigImpl xmlRpcConfig = new XmlRpcClientConfigImpl();\r\n        xmlRpcConfig.setServerURL(url);\r\n        xmlRpcConfig.setEnabledForExtensions(true);\r\n        //todo: put these values in a configuration file\r\n        xmlRpcConfig.setConnectionTimeout(5000);\r\n        xmlRpcConfig.setReplyTimeout(5000);\r\n        XmlRpcClient client = new XmlRpcClient();\r\n        XmlRpcSun15HttpTransportFactory transportFactory = new XmlRpcSun15HttpTransportFactory(client);\r\n        client.setTransportFactory(transportFactory);\r\n        client.setConfig(xmlRpcConfig);\r\n        return new ClientFactory(client);\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/common/MFWXmlRpcFactoryFactory.java",
		"test_prompt": "// MFWXmlRpcFactoryFactoryTest.java\npackage fi.vtt.noen.mfw.bundle.common;\n\nimport org.apache.xmlrpc.client.XmlRpcClient;\nimport org.apache.xmlrpc.client.XmlRpcClientConfigImpl;\nimport org.apache.xmlrpc.client.XmlRpcSun15HttpTransportFactory;\nimport org.apache.xmlrpc.client.util.ClientFactory;\nimport java.net.URL;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MFWXmlRpcFactoryFactory}.\n* It contains ten unit test cases for the {@link MFWXmlRpcFactoryFactory#createFactory(URL)} method.\n*/\nclass MFWXmlRpcFactoryFactoryTest {"
	},
	{
		"original_code": "// Const.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.common;\r\n\r\n/**\r\n * Contains shared constant values for the different MFW implementation elements.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class Const {\r\n\r\n    //server-agent xmlrpc address in probe-agent configuration\r\n    public static final String MFW_SERVER_URL_KEY = \"server_agent_url\";\r\n\r\n    //configuration port for where probe-agent will listen to xmlrpc messages\r\n    public static final String PROBE_AGENT_PORT_KEY = \"probe_agent_xmlrpc_port\";\r\n\r\n    //configuration port for where server-agent will listen to xmlrpc messages\r\n    public static final String SERVER_AGENT_PORT_KEY = \"server_agent_xmlrpc_port\";\r\n\r\n    //configuration parameter for how often the probe-agent sends keep-alive messages to the server-agent\r\n    public static final String KEEP_ALIVE_INTERVAL = \"keep-alive_interval\";\r\n\r\n    //configuration parameter for how often the probe-agent checks for new measurement requests if no notify() is done\r\n    public static final String MEASUREMENT_CHECK_INTERVAL = \"measurement_check_interval\";\r\n\r\n    //a property given by probe-agent when registering to the server-agent. defines the probe-agent xmlrpc address.\r\n    public static final String XMLRPC_URL = \"xmlrpc_url\";\r\n\r\n    //describes the base measure \"class\" for a probe\r\n    public static final String PROBE_BM_CLASS = \"bm_class\";\r\n\r\n    //base measure name for a probe\r\n    public static final String PROBE_BM_NAME = \"bm_name\";\r\n\r\n    //base measure description for a probe\r\n    public static final String PROBE_BM_DESCRIPTION = \"bm_description\";\r\n\r\n    //the name of a probe\r\n    public static final String PROBE_NAME = \"description\";\r\n\r\n    //precision of a probe, integer, higher is better probe with better measurements\r\n    public static final String PROBE_PRECISION = \"precision\";\r\n\r\n    //the name of the target of measurement for a probe\r\n    public static final String PROBE_TARGET_NAME = \"target_name\";\r\n\r\n    //the type of the target of measurement for a probe\r\n    public static final String PROBE_TARGET_TYPE = \"target_type\";\r\n\r\n    //configuration key for ssh probe script file name\r\n    public static final String SSH_SCRIPT_FILENAME = \"ssh_script_file\";\r\n\r\n    //configuration key for ssh probe script file contents\r\n    public static final String SSH_SCRIPT_FILE_CONTENTS = \"ssh_script_file_contents\";\r\n\r\n    //configuration key for ssh probe user name to do the login on the target\r\n    public static final String SSH_USERNAME = \"ssh_username\";\r\n\r\n    //configuration key for ssh probe password to do the login on the target\r\n    public static final String SSH_PASSWORD = \"ssh_password\";\r\n\r\n    //configuration key for ssh probe giving the shell command to execute the given script\r\n    public static final String SSH_SCRIPT_COMMAND = \"ssh_command\";\r\n\r\n    //prefix for ssh probe-agent configuration file\r\n    public static final String SSH_CONFIG_PREFIX = \"ssh\";\r\n\r\n    //prefix for http probe-agent configuration file\r\n    public static final String HTTP_CONFIG_PREFIX = \"http\";\r\n\r\n    //prefix for test probe-agent configuration file\r\n    public static final String TEST_PROBE_AGENT_CONFIG_PREFIX = \"test\";\r\n\r\n    //provided as an error msg to the server-agent when a probe-agent is unable to produce a suitable measurement value.\r\n    public static final String ERROR_MSG_NO_VALID_VALUE = \"No valid measurement value available.\";\r\n\r\n    //not used atm but left here as a reminder that java.util.Formatter can be used to format this type of a string\r\n    public static final String ERROR_UNSUPPORTED_MEASURE_TYPE = \"Probe returned unsupported data type for value:%1$.\";\r\n\r\n    //the port where the server-agent provides the WSDL interface\r\n    //  public static final String MFW_WS_PORT = \"mfw_ws_port\";\r\n    //the address to the MFW web service\r\n    public static final String MFW_WS_URL = \"mfw_ws_url\";\r\n\r\n    //the address to the SAC web service\r\n    public static final String SAC_WS_URL = \"sac_ws_url_\";\r\n\r\n    //the identifier of the SAC\r\n    public static final String SAC_ID = \"sac_id_\";\r\n\r\n    //the address to the web ui SAC webservice\r\n    public static final String WEB_UI_WS_URL = \"web_ui_ws_url\";\r\n\r\n    //the identifier of the web ui (sac id)\r\n    public static final String WEB_UI_ID = \"web_ui_id\";\r\n\r\n    //name of the filename from which all the configuration of agents is always read\r\n    public static final String CONFIGURATION_FILENAME = \"noen-mfw.properties\";\r\n\r\n    public static final int ERROR_CODE_ILLEGAL_ARGUMENTS_FOR_PROBE = -1;\r\n\r\n    //maximum time (in milliseconds) for not receiving a keep-alive message from a probe before \"disabling\" that probe\r\n    public static final String MAX_KEEPALIVE_DELAY = \"max_keepalive_delay\";\r\n\r\n    //time to wait between trying to reconnect to server\r\n    public static final String RETRY_DELAY = \"retry_delay\";\r\n\r\n    //a configuration file property that describes a probe-agent and a server-agent connecting locally\r\n    public static final String LOCAL_LINK_IN_USE = \"local_link\";\r\n\r\n    //a url that describes a probe-agent and a server-agent connecting locally\r\n    public static final String LOCAL_LINK_ENDPOINT_URL = \"mfw://local\";\r\n\r\n    public static final String XMLRPC_PORT = \"xmlrpc_port\";\r\n\r\n    public static final String REST_CLIENT_ENDPOINT_URL = \"rest_client_endpoint\";\r\n\r\n    public static final String THREAD_POOL_SIZE = \"thread_pool_size\";\r\n\r\n    public static final String TASK_TIMEOUT = \"task_timeout\";\r\n\r\n    public static final String SUBSCRIPTION_CHECK_INTERVAL = \"subscription_check_interval\";\r\n\r\n    public static final String AVAILABILITY_INTERVAL = \"availability_interval\";\r\n\r\n    public static String createMeasureURI(String targetType, String targetName, String bmClass, String bmName) {\r\n        return \"MFW://\" + targetType + \"/\" + targetName + \"/\" + bmClass + \"/\" + bmName;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/common/Const.java",
		"test_prompt": "// ConstTest.java\npackage fi.vtt.noen.mfw.bundle.common;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Const}.\n* It contains ten unit test cases for the {@link Const#createMeasureURI(String, String, String, String)} method.\n*/\nclass ConstTest {"
	},
	{
		"original_code": "// BlackboardActivator.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.blackboard;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport org.osgi.framework.BundleActivator;\r\nimport org.osgi.framework.BundleContext;\r\nimport org.osgi.framework.ServiceReference;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class BlackboardActivator implements BundleActivator {\r\n\r\n    private final static Logger log = new Logger(BlackboardActivator.class);\r\n\r\n    private Blackboard bb;\r\n\r\n    public void start(BundleContext bc) throws Exception {\r\n        log.info(\"Starting up blackboard plugin\");\r\n        startBlackboard(bc);\r\n    }\r\n\r\n    public void stop(BundleContext bundleContext) throws Exception {\r\n        bb.shutdown();\r\n    }\r\n\r\n    /**\r\n     * Creates the blackboard, a listener for knowledge sources and captures all currently\r\n     * registered knowledge sources. All existing knowledge sources are registered with the\r\n     * blackboard at the time of creation and new ones are captured with the help of the\r\n     * listener.\r\n     *\r\n     * @param bc Link to the OSGI container.\r\n     * @throws Exception\r\n     */\r\n    public Blackboard startBlackboard(BundleContext bc) throws Exception {\r\n        log.debug(\"Starting blackboard\");\r\n        bb = new BlackboardImpl();\r\n        //we create a proxy to capture a log of interactions as needed\r\n        //    bb = (Blackboard) ServiceProxy.createProxy(bb, bc);\r\n        bc.addServiceListener(new KnowledgeSourceListener(bb, bc));\r\n        Properties props = new Properties();\r\n        props.put(\"version\", \"1.0\");\r\n        bc.registerService(Blackboard.class.getName(), bb, props);\r\n        ServiceReference[] ksRefs = bc.getServiceReferences(KnowledgeSource.class.getName(), null);\r\n        if (ksRefs == null) {\r\n            return bb;\r\n        }\r\n        for (ServiceReference ksRef : ksRefs) {\r\n            log.debug(\"Found service:\" + ksRef);\r\n            KnowledgeSource ks = (KnowledgeSource) bc.getService(ksRef);\r\n            bb.register(ks);\r\n        }\r\n        return bb;\r\n    }\r\n\r\n    public Blackboard getBlackboard() {\r\n        return bb;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/blackboard/BlackboardActivator.java",
		"test_prompt": "// BlackboardActivatorTest.java\npackage fi.vtt.noen.mfw.bundle.blackboard;\n\nimport fi.vtt.noen.mfw.bundle.common.KnowledgeSource;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport org.osgi.framework.BundleActivator;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.ServiceReference;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BlackboardActivator}.\n* It contains ten unit test cases for the {@link BlackboardActivator#startBlackboard(BundleContext)} method.\n*/\nclass BlackboardActivatorTest {"
	},
	{
		"original_code": "// MeasurementThreadFactory.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.plugins.measurement;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\r\nimport java.util.concurrent.ThreadFactory;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\n/**\r\n * Creates threads for the thread pool. Delegates to Executors.detaultThreadFactory with the difference that\r\n * all threads created as defined as daemon threads.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementThreadFactory implements ThreadFactory {\r\n\r\n    private final static Logger log = new Logger(MeasurementThreadFactory.class);\r\n\r\n    private final ThreadFactory delegate = Executors.defaultThreadFactory();\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1, new MeasurementThreadFactory());\r\n        executor.scheduleAtFixedRate(new Runnable() {\r\n\r\n            public void run() {\r\n                System.out.println(\"hello\");\r\n            }\r\n        }, 0, 100, TimeUnit.MILLISECONDS);\r\n        Thread.sleep(500);\r\n    }\r\n\r\n    public Thread newThread(Runnable r) {\r\n        log.debug(\"new thread created\");\r\n        Thread t = delegate.newThread(r);\r\n        t.setDaemon(true);\r\n        return t;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/plugins/measurement/MeasurementThreadFactory.java",
		"test_prompt": "// MeasurementThreadFactoryTest.java\npackage fi.vtt.noen.mfw.bundle.probe.plugins.measurement;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledThreadPoolExecutor;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementThreadFactory}.\n* It contains ten unit test cases for the {@link MeasurementThreadFactory#newThread(Runnable)} method.\n*/\nclass MeasurementThreadFactoryTest {"
	},
	{
		"original_code": "// MeasurementTask.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.plugins.measurement;\r\n\r\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\r\nimport fi.vtt.noen.mfw.bundle.common.EventType;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.MeasurementReport;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.MeasurementRequest;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.MeasurementResponse;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.Probe;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\r\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport java.util.Map;\r\n\r\n/**\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementTask implements Runnable {\r\n\r\n    private final static Logger log = new Logger(MeasurementProvider.class);\r\n\r\n    private final Probe probe;\r\n\r\n    private final ServerAgent server;\r\n\r\n    private final Long subscriptionId;\r\n\r\n    private final Blackboard bb;\r\n\r\n    private long startTime;\r\n\r\n    private boolean running = false;\r\n\r\n    private boolean compareMode = false;\r\n\r\n    private String reference;\r\n\r\n    public MeasurementTask(MeasurementRequest req, Blackboard bb) {\r\n        //actual probe instance is saved with the request when it is created when an xmlrpc request was received\r\n        this.probe = req.getProbe();\r\n        this.server = req.getServer();\r\n        this.subscriptionId = req.getSubscriptionId();\r\n        this.bb = bb;\r\n        this.compareMode = isCompareMode();\r\n    }\r\n\r\n    public void run() {\r\n        log.debug(\"Calling measure on:\" + probe);\r\n        startTime = System.currentTimeMillis();\r\n        running = true;\r\n        BaseMeasure measure = null;\r\n        try {\r\n            measure = probe.measure();\r\n        } catch (Exception e) {\r\n            log.error(\"Error while performing measurement on probe \" + probe.getInformation().getMeasureURI(), e);\r\n        }\r\n        running = false;\r\n        log.debug(\"Received measure:\" + measure + \" from:\" + probe);\r\n        int precision = probe.getInformation().getPrecision();\r\n        if (measure == null || measure.getMeasure() == null) {\r\n            ProbeEvent event = new ProbeEvent(server, EventType.NO_VALUE_FOR_BM, probe.getInformation().getMeasureURI(), \"No valid measurement value available.\", subscriptionId);\r\n            bb.process(event);\r\n            return;\r\n        }\r\n        //if compare mode is used current measure value needs to be compared with reference\r\n        if (compareMode) {\r\n            log.debug(\"probe in compare mode\");\r\n            //log.debug(\"mode:\"+probe.getConfigurationParameters().iterator().next().getValue());\r\n            boolean matchReference = false;\r\n            if (reference == null) {\r\n                this.reference = measure.getMeasure();\r\n            }\r\n            if (reference.equals(measure.getMeasure())) {\r\n                matchReference = true;\r\n            }\r\n            MeasurementReport report = new MeasurementReport(measure, server, probe.getInformation(), subscriptionId, matchReference, reference);\r\n            bb.process(report);\r\n            MeasurementResponse resp = new MeasurementResponse(new BaseMeasure(\"\" + matchReference), server, probe.getInformation(), precision, subscriptionId);\r\n            bb.process(resp);\r\n        } else {\r\n            MeasurementResponse resp = new MeasurementResponse(measure, server, probe.getInformation(), precision, subscriptionId);\r\n            bb.process(resp);\r\n        }\r\n    }\r\n\r\n    public ProbeInformation getProbeInfo() {\r\n        return probe.getInformation();\r\n    }\r\n\r\n    public Long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public long getRunningTime() {\r\n        log.debug(\"Running:\" + running);\r\n        if (!running) {\r\n            return 0;\r\n        }\r\n        long now = System.currentTimeMillis();\r\n        return now - startTime;\r\n    }\r\n\r\n    public long getStartTime() {\r\n        return startTime;\r\n    }\r\n\r\n    public boolean isRunning() {\r\n        return running;\r\n    }\r\n\r\n    public Probe getProbe() {\r\n        return probe;\r\n    }\r\n\r\n    public synchronized void setReference(String reference) {\r\n        log.debug(\"setReference\");\r\n        this.reference = reference;\r\n    }\r\n\r\n    public synchronized void setCompare(boolean compare) {\r\n        log.debug(\"setCompare\");\r\n        this.compareMode = compare;\r\n    }\r\n\r\n    private boolean isCompareMode() {\r\n        if (probe.getConfigurationParameters() != null) {\r\n            for (ProbeConfiguration param : probe.getConfigurationParameters()) {\r\n                if (param.getName().equals(\"mode\") && param.getValue().equals(\"compare\")) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/plugins/measurement/MeasurementTask.java",
		"test_prompt": "// MeasurementTaskTest.java\npackage fi.vtt.noen.mfw.bundle.probe.plugins.measurement;\n\nimport fi.vtt.noen.mfw.bundle.blackboard.Blackboard;\nimport fi.vtt.noen.mfw.bundle.common.EventType;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.ProbeConfiguration;\nimport fi.vtt.noen.mfw.bundle.probe.shared.BaseMeasure;\nimport fi.vtt.noen.mfw.bundle.probe.shared.MeasurementReport;\nimport fi.vtt.noen.mfw.bundle.probe.shared.MeasurementRequest;\nimport fi.vtt.noen.mfw.bundle.probe.shared.MeasurementResponse;\nimport fi.vtt.noen.mfw.bundle.probe.shared.Probe;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeEvent;\nimport fi.vtt.noen.mfw.bundle.probe.shared.ProbeInformation;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementTask}.\n* It contains ten unit test cases for the {@link MeasurementTask#isRunning()} method.\n*/\nclass MeasurementTaskTest {"
	},
	{
		"original_code": "// XmlRpcServerClient.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.MFWXmlRpcFactoryFactory;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport org.apache.xmlrpc.client.util.ClientFactory;\r\nimport java.net.URL;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * An XML-RPC client for calling a server-bundle.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class XmlRpcServerClient implements ServerAgent {\r\n\r\n    private final static Logger log = new Logger(XmlRpcServerClient.class);\r\n\r\n    private ServerAgent server;\r\n\r\n    private final URL url;\r\n\r\n    public XmlRpcServerClient(URL url) {\r\n        this.url = url;\r\n        //we need this for osgi tricks\r\n        ClassLoader classLoader = getClass().getClassLoader();\r\n        ClientFactory factory = MFWXmlRpcFactoryFactory.createFactory(url);\r\n        server = (ServerAgent) factory.newInstance(classLoader, ServerAgent.class);\r\n    }\r\n\r\n    public boolean measurement(long time, String measureURI, int precision, String value, long subscriptionId) {\r\n        try {\r\n            return server.measurement(time, measureURI, precision, value, subscriptionId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public void event(long time, String type, String source, String msg, long subscriptionId) {\r\n        try {\r\n            server.event(time, type, source, msg, subscriptionId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    public long register(Map<String, String> properties) {\r\n        try {\r\n            return server.register(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            throw new RuntimeException(\"Error while calling server over XMLRPC\", e);\r\n        }\r\n    }\r\n\r\n    public boolean keepAlive(long probeId) {\r\n        try {\r\n            return server.keepAlive(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            throw new RuntimeException(\"Error while calling server over XMLRPC\", e);\r\n        }\r\n    }\r\n\r\n    public void unregister(long probeId) {\r\n        try {\r\n            server.unregister(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        try {\r\n            server.checkSubscriptions(probeId, subscriptionIds);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"XmlRpcServerClient{\" + \"url=\" + url + '}';\r\n    }\r\n\r\n    public boolean BMReport(long time, String measureURI, String value, long subscriptionId, boolean matchReference, String reference) {\r\n        try {\r\n            return server.BMReport(time, measureURI, value, subscriptionId, matchReference, reference);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/plugins/xmlrpc/XmlRpcServerClient_0Test.java",
		"test_prompt": "// XmlRpcServerClient_0Test.java\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.MFWXmlRpcFactoryFactory;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.apache.xmlrpc.client.util.ClientFactory;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlRpcServerClient}.\n* It contains ten unit test cases for the {@link XmlRpcServerClient#measurement(long, String, int, String, long)} method.\n*/\nclass XmlRpcServerClient_0Test {"
	},
	{
		"original_code": "// XmlRpcServerClient.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.MFWXmlRpcFactoryFactory;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport org.apache.xmlrpc.client.util.ClientFactory;\r\nimport java.net.URL;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * An XML-RPC client for calling a server-bundle.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class XmlRpcServerClient implements ServerAgent {\r\n\r\n    private final static Logger log = new Logger(XmlRpcServerClient.class);\r\n\r\n    private ServerAgent server;\r\n\r\n    private final URL url;\r\n\r\n    public XmlRpcServerClient(URL url) {\r\n        this.url = url;\r\n        //we need this for osgi tricks\r\n        ClassLoader classLoader = getClass().getClassLoader();\r\n        ClientFactory factory = MFWXmlRpcFactoryFactory.createFactory(url);\r\n        server = (ServerAgent) factory.newInstance(classLoader, ServerAgent.class);\r\n    }\r\n\r\n    public boolean measurement(long time, String measureURI, int precision, String value, long subscriptionId) {\r\n        try {\r\n            return server.measurement(time, measureURI, precision, value, subscriptionId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public void event(long time, String type, String source, String msg, long subscriptionId) {\r\n        try {\r\n            server.event(time, type, source, msg, subscriptionId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    public long register(Map<String, String> properties) {\r\n        try {\r\n            return server.register(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            throw new RuntimeException(\"Error while calling server over XMLRPC\", e);\r\n        }\r\n    }\r\n\r\n    public boolean keepAlive(long probeId) {\r\n        try {\r\n            return server.keepAlive(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            throw new RuntimeException(\"Error while calling server over XMLRPC\", e);\r\n        }\r\n    }\r\n\r\n    public void unregister(long probeId) {\r\n        try {\r\n            server.unregister(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        try {\r\n            server.checkSubscriptions(probeId, subscriptionIds);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"XmlRpcServerClient{\" + \"url=\" + url + '}';\r\n    }\r\n\r\n    public boolean BMReport(long time, String measureURI, String value, long subscriptionId, boolean matchReference, String reference) {\r\n        try {\r\n            return server.BMReport(time, measureURI, value, subscriptionId, matchReference, reference);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/plugins/xmlrpc/XmlRpcServerClient_1Test.java",
		"test_prompt": "// XmlRpcServerClient_1Test.java\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.MFWXmlRpcFactoryFactory;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.apache.xmlrpc.client.util.ClientFactory;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlRpcServerClient}.\n* It contains ten unit test cases for the {@link XmlRpcServerClient#register(Map)} method.\n*/\nclass XmlRpcServerClient_1Test {"
	},
	{
		"original_code": "// XmlRpcServerClient.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.MFWXmlRpcFactoryFactory;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport org.apache.xmlrpc.client.util.ClientFactory;\r\nimport java.net.URL;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * An XML-RPC client for calling a server-bundle.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class XmlRpcServerClient implements ServerAgent {\r\n\r\n    private final static Logger log = new Logger(XmlRpcServerClient.class);\r\n\r\n    private ServerAgent server;\r\n\r\n    private final URL url;\r\n\r\n    public XmlRpcServerClient(URL url) {\r\n        this.url = url;\r\n        //we need this for osgi tricks\r\n        ClassLoader classLoader = getClass().getClassLoader();\r\n        ClientFactory factory = MFWXmlRpcFactoryFactory.createFactory(url);\r\n        server = (ServerAgent) factory.newInstance(classLoader, ServerAgent.class);\r\n    }\r\n\r\n    public boolean measurement(long time, String measureURI, int precision, String value, long subscriptionId) {\r\n        try {\r\n            return server.measurement(time, measureURI, precision, value, subscriptionId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public void event(long time, String type, String source, String msg, long subscriptionId) {\r\n        try {\r\n            server.event(time, type, source, msg, subscriptionId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    public long register(Map<String, String> properties) {\r\n        try {\r\n            return server.register(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            throw new RuntimeException(\"Error while calling server over XMLRPC\", e);\r\n        }\r\n    }\r\n\r\n    public boolean keepAlive(long probeId) {\r\n        try {\r\n            return server.keepAlive(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            throw new RuntimeException(\"Error while calling server over XMLRPC\", e);\r\n        }\r\n    }\r\n\r\n    public void unregister(long probeId) {\r\n        try {\r\n            server.unregister(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        try {\r\n            server.checkSubscriptions(probeId, subscriptionIds);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"XmlRpcServerClient{\" + \"url=\" + url + '}';\r\n    }\r\n\r\n    public boolean BMReport(long time, String measureURI, String value, long subscriptionId, boolean matchReference, String reference) {\r\n        try {\r\n            return server.BMReport(time, measureURI, value, subscriptionId, matchReference, reference);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/plugins/xmlrpc/XmlRpcServerClient_2Test.java",
		"test_prompt": "// XmlRpcServerClient_2Test.java\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.MFWXmlRpcFactoryFactory;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.apache.xmlrpc.client.util.ClientFactory;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlRpcServerClient}.\n* It contains ten unit test cases for the {@link XmlRpcServerClient#keepAlive(long)} method.\n*/\nclass XmlRpcServerClient_2Test {"
	},
	{
		"original_code": "// XmlRpcServerClient.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.common.MFWXmlRpcFactoryFactory;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport org.apache.xmlrpc.client.util.ClientFactory;\r\nimport java.net.URL;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n/**\r\n * An XML-RPC client for calling a server-bundle.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class XmlRpcServerClient implements ServerAgent {\r\n\r\n    private final static Logger log = new Logger(XmlRpcServerClient.class);\r\n\r\n    private ServerAgent server;\r\n\r\n    private final URL url;\r\n\r\n    public XmlRpcServerClient(URL url) {\r\n        this.url = url;\r\n        //we need this for osgi tricks\r\n        ClassLoader classLoader = getClass().getClassLoader();\r\n        ClientFactory factory = MFWXmlRpcFactoryFactory.createFactory(url);\r\n        server = (ServerAgent) factory.newInstance(classLoader, ServerAgent.class);\r\n    }\r\n\r\n    public boolean measurement(long time, String measureURI, int precision, String value, long subscriptionId) {\r\n        try {\r\n            return server.measurement(time, measureURI, precision, value, subscriptionId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public void event(long time, String type, String source, String msg, long subscriptionId) {\r\n        try {\r\n            server.event(time, type, source, msg, subscriptionId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    public long register(Map<String, String> properties) {\r\n        try {\r\n            return server.register(properties);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            throw new RuntimeException(\"Error while calling server over XMLRPC\", e);\r\n        }\r\n    }\r\n\r\n    public boolean keepAlive(long probeId) {\r\n        try {\r\n            return server.keepAlive(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            throw new RuntimeException(\"Error while calling server over XMLRPC\", e);\r\n        }\r\n    }\r\n\r\n    public void unregister(long probeId) {\r\n        try {\r\n            server.unregister(probeId);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    public void checkSubscriptions(long probeId, List<Long> subscriptionIds) {\r\n        try {\r\n            server.checkSubscriptions(probeId, subscriptionIds);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"XmlRpcServerClient{\" + \"url=\" + url + '}';\r\n    }\r\n\r\n    public boolean BMReport(long time, String measureURI, String value, long subscriptionId, boolean matchReference, String reference) {\r\n        try {\r\n            return server.BMReport(time, measureURI, value, subscriptionId, matchReference, reference);\r\n        } catch (Exception e) {\r\n            log.error(\"Error while calling server over XMLRPC:\" + this);\r\n            log.debug(\"Exception\", e);\r\n            return false;\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/plugins/xmlrpc/XmlRpcServerClient_3Test.java",
		"test_prompt": "// XmlRpcServerClient_3Test.java\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.common.MFWXmlRpcFactoryFactory;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.apache.xmlrpc.client.util.ClientFactory;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Map;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XmlRpcServerClient}.\n* It contains ten unit test cases for the {@link XmlRpcServerClient#BMReport(long, String, String, long, boolean, String)} method.\n*/\nclass XmlRpcServerClient_3Test {"
	},
	{
		"original_code": "// ProbeAgentConfig.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.Const;\r\nimport fi.vtt.noen.mfw.bundle.common.Logger;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.net.MalformedURLException;\r\nimport java.net.URL;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Defines a configuration for a probe-bundle.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class ProbeAgentConfig {\r\n\r\n    private final static Logger log = new Logger(ProbeAgentConfig.class);\r\n\r\n    //only initialize it once\r\n    private boolean initialized = false;\r\n\r\n    //port where the xmlrpc server will listen to the incoming messages\r\n    private int port = -1;\r\n\r\n    //default interval between sending the keep-alive messages\r\n    private static final int DEFAULT_KEEPALIVE_INTERVAL = 1000;\r\n\r\n    //default interval between trying to reconnect to server\r\n    private static final int DEFAULT_RETRY_DELAY = 5000;\r\n\r\n    //actual keep alive interval for this thread\r\n    private int keepAliveInterval;\r\n\r\n    //the server-agent where the keep-alive messages are sent\r\n    private ServerAgent destination = null;\r\n\r\n    //time to wait between retrying a failed connection to a server-agent\r\n    private int retryDelay;\r\n\r\n    //is this a local connection or distributed\r\n    private boolean localInUse = false;\r\n\r\n    //default subscription check interval\r\n    private static final int DEFAULT_SUBSCRIPTION_CHECK_INTERVAL = 20000;\r\n\r\n    //subscription checking interval\r\n    private int subscriptionCheckInterval;\r\n\r\n    public ProbeAgentConfig(int port, String destinationUrl, int keepAliveInterval, int retryDelay, int subscriptionCheckInterval) {\r\n        init(port, destinationUrl, keepAliveInterval, retryDelay, subscriptionCheckInterval);\r\n    }\r\n\r\n    public ProbeAgentConfig(int port, ServerAgent server, int keepAliveInterval, int retryDelay, int subscriptionCheckInterval) {\r\n        init(port, server, keepAliveInterval, retryDelay, subscriptionCheckInterval);\r\n    }\r\n\r\n    public ProbeAgentConfig(InputStream in) {\r\n        init(in);\r\n    }\r\n\r\n    public ProbeAgentConfig() {\r\n    }\r\n\r\n    private void init(int port, String destinationUrl, int keepAliveInterval, int retryDelay, int subscriptionCheckInterval) {\r\n        if (port < 0) {\r\n            //this means we need to use a local connection\r\n            init(port, (ServerAgent) null, keepAliveInterval, retryDelay, subscriptionCheckInterval);\r\n            return;\r\n        }\r\n        URL url = null;\r\n        try {\r\n            log.debug(\"Creating connection to server agent at:\" + destinationUrl);\r\n            url = new URL(destinationUrl);\r\n        } catch (MalformedURLException e) {\r\n            log.error(\"Unable to create connection with URL:\" + destinationUrl, e);\r\n        }\r\n        //create the component to send XMLRPC requests to the server-agent\r\n        XmlRpcServerClient server = new XmlRpcServerClient(url);\r\n        init(port, server, keepAliveInterval, retryDelay, subscriptionCheckInterval);\r\n    }\r\n\r\n    private void init(int port, ServerAgent server, int keepAliveInterval, int retryDelay, int subscriptionCheckInterval) {\r\n        if (initialized) {\r\n            throw new IllegalStateException(\"Trying to initialize configuration twice\");\r\n        }\r\n        log.debug(\"initializing: XMLRPC server port = \" + port);\r\n        this.port = port;\r\n        if (port < 0) {\r\n            localInUse = true;\r\n        }\r\n        this.keepAliveInterval = keepAliveInterval;\r\n        this.destination = server;\r\n        this.retryDelay = retryDelay;\r\n        this.subscriptionCheckInterval = subscriptionCheckInterval;\r\n        initialized = true;\r\n    }\r\n\r\n    public boolean isLocalInUse() {\r\n        return localInUse;\r\n    }\r\n\r\n    public ServerAgent getDestination() {\r\n        return destination;\r\n    }\r\n\r\n    public void setDestination(ServerAgent destination) {\r\n        this.destination = destination;\r\n    }\r\n\r\n    public int getProbeAgentServerPort() {\r\n        return port;\r\n    }\r\n\r\n    public int getKeepAliveInterval() {\r\n        return keepAliveInterval;\r\n    }\r\n\r\n    public int getRetryDelay() {\r\n        return retryDelay;\r\n    }\r\n\r\n    public int getSubscriptionCheckInterval() {\r\n        return subscriptionCheckInterval;\r\n    }\r\n\r\n    /**\r\n     * Reads the initial configuration from the properties file given as the input stream.\r\n     *\r\n     * @param in The data for the properties file.\r\n     */\r\n    private void init(InputStream in) {\r\n        if (initialized) {\r\n            throw new IllegalStateException(\"Trying to initialize configuration twice\");\r\n        }\r\n        Properties properties = new Properties();\r\n        try {\r\n            properties.load(in);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"Failed to load properties from given inputstream\", e);\r\n        }\r\n        log.debug(\"Loaded properties:\" + properties);\r\n        String destinationUrl = properties.getProperty(Const.MFW_SERVER_URL_KEY);\r\n        String portValue = properties.getProperty(Const.PROBE_AGENT_PORT_KEY);\r\n        int port = -1;\r\n        if (portValue != null) {\r\n            //we leave it at -1 as undefined if nothing found in configuration. this defaults to local node connection.\r\n            port = Integer.parseInt(portValue);\r\n        }\r\n        String reportIntervalValue = properties.getProperty(Const.KEEP_ALIVE_INTERVAL);\r\n        int reportInterval = DEFAULT_KEEPALIVE_INTERVAL;\r\n        if (reportIntervalValue != null) {\r\n            try {\r\n                reportInterval = Integer.parseInt(reportIntervalValue);\r\n            } catch (NumberFormatException e) {\r\n                log.error(\"Failed to read report interval from config, gof:\" + reportIntervalValue + \". Using defaults.\");\r\n            }\r\n        }\r\n        String retryDelayValue = properties.getProperty(Const.RETRY_DELAY);\r\n        int retryDelay = DEFAULT_RETRY_DELAY;\r\n        if (retryDelayValue != null) {\r\n            try {\r\n                retryDelay = Integer.parseInt(retryDelayValue);\r\n            } catch (NumberFormatException e) {\r\n                log.error(\"Failed to read retry delay from config, gof:\" + retryDelayValue + \". Using defaults.\");\r\n            }\r\n        }\r\n        String checkIntervalValue = properties.getProperty(Const.SUBSCRIPTION_CHECK_INTERVAL);\r\n        int checkInterval = DEFAULT_SUBSCRIPTION_CHECK_INTERVAL;\r\n        if (checkIntervalValue != null) {\r\n            try {\r\n                checkInterval = Integer.parseInt(checkIntervalValue);\r\n            } catch (NumberFormatException e) {\r\n                log.error(\"Failed to read subscription check interval from config, gof:\" + checkIntervalValue + \". Using defaults.\");\r\n            }\r\n        }\r\n        if (destinationUrl == null) {\r\n            init(-1, (ServerAgent) null, reportInterval, retryDelay, checkInterval);\r\n        } else {\r\n            init(port, destinationUrl, reportInterval, retryDelay, checkInterval);\r\n        }\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/plugins/xmlrpc/ProbeAgentConfig.java",
		"test_prompt": "// ProbeAgentConfigTest.java\npackage fi.vtt.noen.mfw.bundle.probe.plugins.xmlrpc;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport fi.vtt.noen.mfw.bundle.common.Logger;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Properties;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeAgentConfig}.\n* It contains ten unit test cases for the {@link ProbeAgentConfig#isLocalInUse()} method.\n*/\nclass ProbeAgentConfigTest {"
	},
	{
		"original_code": "// ProbeInformation.java\n/*\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\n\n/**\n * This describes a probe. It is basically the same as a base measure description since at this point a base measure is the same\n * as a probe. This is because all of these properties listed here also apply to each base measure. It is thus not different in\n * any way to call something a probe or a base measure. The separate terms are still kept since it seems conceptually clearer..\n * The only difference here is the probe description field. If there are several probes capable of providing a single base\n * measure, the probe description is what should set them apart. If they have the same measureURI, they are considered to provide\n * the same base measure. A measureURI consists of targetName,targetType,bmClass,bmName value combination.\n *\n * @author Teemu Kanstren\n */\npublic class ProbeInformation {\n\n    //property of the target of measurement, defined typically in a configuration file. part of measure identifier\n    private final String targetName;\n\n    //property of the target of measurement, defined typically in a configuration file. part of measure identifier\n    private final String targetType;\n\n    //property of the base measure from a probe, defined typically in a configuration file. part of measure identifier\n    private final String bmClass;\n\n    //property of the base measure from a probe, defined typically in a configuration file. part of measure identifier\n    private final String bmName;\n\n    //property of the base measure from a probe, defined typically in a configuration file. freeform text, only for human input\n    private final String bmDescription;\n\n    //name of the probe..\n    private final String probeName;\n\n    //precision of the probe, that is how good is the measurement provided. bigger is better. if several have the same measurement identifier properties, the one with highest precision is taken.\n    private final int precision;\n\n    //url where the server-agent can invoke this probe-agent over xmlrpc\n    private final String xmlRpcUrl;\n\n    public ProbeInformation(String targetName, String targetType, String bmClass, String bmName, String bmDescription, String probeDescription, int precision, String xmlRpcUrl) {\n        this.targetName = targetName;\n        this.targetType = targetType;\n        this.bmClass = bmClass;\n        this.bmName = bmName;\n        this.bmDescription = bmDescription;\n        this.probeName = probeDescription;\n        this.precision = precision;\n        this.xmlRpcUrl = xmlRpcUrl;\n    }\n\n    public String getTargetType() {\n        return targetType;\n    }\n\n    public String getBmName() {\n        return bmName;\n    }\n\n    public String getProbeName() {\n        return probeName;\n    }\n\n    public String getTargetName() {\n        return targetName;\n    }\n\n    public String getBmClass() {\n        return bmClass;\n    }\n\n    public String getBmDescription() {\n        return bmDescription;\n    }\n\n    public int getPrecision() {\n        return precision;\n    }\n\n    public String getMeasureURI() {\n        return Const.createMeasureURI(targetType, targetName, bmClass, bmName);\n    }\n\n    public String getXmlRpcUrl() {\n        return xmlRpcUrl;\n    }\n\n    @Override\n    public String toString() {\n        return \"ProbeInformation{\" + \"targetName='\" + targetName + '\\'' + \", targetType='\" + targetType + '\\'' + \", bmClass='\" + bmClass + '\\'' + \", bmName='\" + bmName + '\\'' + \", bmDescription='\" + bmDescription + '\\'' + \", probeDescription='\" + probeName + '\\'' + \", precision=\" + precision + '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        ProbeInformation that = (ProbeInformation) o;\n        if (precision != that.precision)\n            return false;\n        if (bmClass != null ? !bmClass.equals(that.bmClass) : that.bmClass != null)\n            return false;\n        if (bmDescription != null ? !bmDescription.equals(that.bmDescription) : that.bmDescription != null)\n            return false;\n        if (bmName != null ? !bmName.equals(that.bmName) : that.bmName != null)\n            return false;\n        if (probeName != null ? !probeName.equals(that.probeName) : that.probeName != null)\n            return false;\n        if (targetName != null ? !targetName.equals(that.targetName) : that.targetName != null)\n            return false;\n        if (targetType != null ? !targetType.equals(that.targetType) : that.targetType != null)\n            return false;\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = targetName != null ? targetName.hashCode() : 0;\n        result = 31 * result + (targetType != null ? targetType.hashCode() : 0);\n        result = 31 * result + (bmClass != null ? bmClass.hashCode() : 0);\n        result = 31 * result + (bmName != null ? bmName.hashCode() : 0);\n        result = 31 * result + (bmDescription != null ? bmDescription.hashCode() : 0);\n        result = 31 * result + (probeName != null ? probeName.hashCode() : 0);\n        result = 31 * result + precision;\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/ProbeInformation_0Test.java",
		"test_prompt": "// ProbeInformation_0Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeInformation}.\n* It contains ten unit test cases for the {@link ProbeInformation#equals(Object)} method.\n*/\nclass ProbeInformation_0Test {"
	},
	{
		"original_code": "// ProbeInformation.java\n/*\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\n\n/**\n * This describes a probe. It is basically the same as a base measure description since at this point a base measure is the same\n * as a probe. This is because all of these properties listed here also apply to each base measure. It is thus not different in\n * any way to call something a probe or a base measure. The separate terms are still kept since it seems conceptually clearer..\n * The only difference here is the probe description field. If there are several probes capable of providing a single base\n * measure, the probe description is what should set them apart. If they have the same measureURI, they are considered to provide\n * the same base measure. A measureURI consists of targetName,targetType,bmClass,bmName value combination.\n *\n * @author Teemu Kanstren\n */\npublic class ProbeInformation {\n\n    //property of the target of measurement, defined typically in a configuration file. part of measure identifier\n    private final String targetName;\n\n    //property of the target of measurement, defined typically in a configuration file. part of measure identifier\n    private final String targetType;\n\n    //property of the base measure from a probe, defined typically in a configuration file. part of measure identifier\n    private final String bmClass;\n\n    //property of the base measure from a probe, defined typically in a configuration file. part of measure identifier\n    private final String bmName;\n\n    //property of the base measure from a probe, defined typically in a configuration file. freeform text, only for human input\n    private final String bmDescription;\n\n    //name of the probe..\n    private final String probeName;\n\n    //precision of the probe, that is how good is the measurement provided. bigger is better. if several have the same measurement identifier properties, the one with highest precision is taken.\n    private final int precision;\n\n    //url where the server-agent can invoke this probe-agent over xmlrpc\n    private final String xmlRpcUrl;\n\n    public ProbeInformation(String targetName, String targetType, String bmClass, String bmName, String bmDescription, String probeDescription, int precision, String xmlRpcUrl) {\n        this.targetName = targetName;\n        this.targetType = targetType;\n        this.bmClass = bmClass;\n        this.bmName = bmName;\n        this.bmDescription = bmDescription;\n        this.probeName = probeDescription;\n        this.precision = precision;\n        this.xmlRpcUrl = xmlRpcUrl;\n    }\n\n    public String getTargetType() {\n        return targetType;\n    }\n\n    public String getBmName() {\n        return bmName;\n    }\n\n    public String getProbeName() {\n        return probeName;\n    }\n\n    public String getTargetName() {\n        return targetName;\n    }\n\n    public String getBmClass() {\n        return bmClass;\n    }\n\n    public String getBmDescription() {\n        return bmDescription;\n    }\n\n    public int getPrecision() {\n        return precision;\n    }\n\n    public String getMeasureURI() {\n        return Const.createMeasureURI(targetType, targetName, bmClass, bmName);\n    }\n\n    public String getXmlRpcUrl() {\n        return xmlRpcUrl;\n    }\n\n    @Override\n    public String toString() {\n        return \"ProbeInformation{\" + \"targetName='\" + targetName + '\\'' + \", targetType='\" + targetType + '\\'' + \", bmClass='\" + bmClass + '\\'' + \", bmName='\" + bmName + '\\'' + \", bmDescription='\" + bmDescription + '\\'' + \", probeDescription='\" + probeName + '\\'' + \", precision=\" + precision + '}';\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        ProbeInformation that = (ProbeInformation) o;\n        if (precision != that.precision)\n            return false;\n        if (bmClass != null ? !bmClass.equals(that.bmClass) : that.bmClass != null)\n            return false;\n        if (bmDescription != null ? !bmDescription.equals(that.bmDescription) : that.bmDescription != null)\n            return false;\n        if (bmName != null ? !bmName.equals(that.bmName) : that.bmName != null)\n            return false;\n        if (probeName != null ? !probeName.equals(that.probeName) : that.probeName != null)\n            return false;\n        if (targetName != null ? !targetName.equals(that.targetName) : that.targetName != null)\n            return false;\n        if (targetType != null ? !targetType.equals(that.targetType) : that.targetType != null)\n            return false;\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = targetName != null ? targetName.hashCode() : 0;\n        result = 31 * result + (targetType != null ? targetType.hashCode() : 0);\n        result = 31 * result + (bmClass != null ? bmClass.hashCode() : 0);\n        result = 31 * result + (bmName != null ? bmName.hashCode() : 0);\n        result = 31 * result + (bmDescription != null ? bmDescription.hashCode() : 0);\n        result = 31 * result + (probeName != null ? probeName.hashCode() : 0);\n        result = 31 * result + precision;\n        return result;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/ProbeInformation_1Test.java",
		"test_prompt": "// ProbeInformation_1Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.Const;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProbeInformation}.\n* It contains ten unit test cases for the {@link ProbeInformation#hashCode()} method.\n*/\nclass ProbeInformation_1Test {"
	},
	{
		"original_code": "// MeasurementReport.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\npublic class MeasurementReport extends DataObject {\r\n\r\n    //the actual value that was measured\r\n    private final BaseMeasure measure;\r\n\r\n    //the server-agent where the measure should be delivered\r\n    private final ServerAgent server;\r\n\r\n    //the probe information for the provided measure\r\n    private final ProbeInformation probeInfo;\r\n\r\n    //unique identifier for measurement request/response subscription\r\n    private final long subscriptionId;\r\n\r\n    //does current measurement value match with reference value\r\n    private final boolean matchReference;\r\n\r\n    //the reference value probe uses in compare mode\r\n    private final String reference;\r\n\r\n    public MeasurementReport(BaseMeasure measure, ServerAgent server, ProbeInformation probeInfo, long subscriptionId, boolean matchReference, String reference) {\r\n        super(DataType.MEASUREMENT_REPORT);\r\n        this.measure = measure;\r\n        this.server = server;\r\n        this.probeInfo = probeInfo;\r\n        this.subscriptionId = subscriptionId;\r\n        this.matchReference = matchReference;\r\n        this.reference = reference;\r\n    }\r\n\r\n    public BaseMeasure getMeasure() {\r\n        return measure;\r\n    }\r\n\r\n    public ServerAgent getServer() {\r\n        return server;\r\n    }\r\n\r\n    public ProbeInformation getProbeInfo() {\r\n        return probeInfo;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public boolean isMatchReference() {\r\n        return matchReference;\r\n    }\r\n\r\n    public String getReference() {\r\n        return reference;\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/MeasurementReport.java",
		"test_prompt": "// MeasurementReportTest.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementReport}.\n* It contains ten unit test cases for the {@link MeasurementReport#isMatchReference()} method.\n*/\nclass MeasurementReportTest {"
	},
	{
		"original_code": "// MeasurementRequest.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.shared;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\n/**\r\n * Represents a request to provide a measurement from a probe, either once or at a given sampling interval.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementRequest extends DataObject {\r\n\r\n    //the probe that provides the measure. currently assumed to give only the one exact measure.\r\n    private final String measureURI;\r\n\r\n    //sampling interval for continuously providing the values\r\n    private final long interval;\r\n\r\n    //the last time when a measurement was done\r\n    private long lastMeasureTime = -1;\r\n\r\n    //the server-agent where the measurement should be delivered\r\n    private final ServerAgent server;\r\n\r\n    //the probe that should perform the measure\r\n    private final Probe probe;\r\n\r\n    //unique identifier for measurement request/response subscription\r\n    private final long subscriptionId;\r\n\r\n    public MeasurementRequest(ServerAgent server, String measureURI, Probe probe) {\r\n        this(server, measureURI, probe, -1, -1);\r\n    }\r\n\r\n    public MeasurementRequest(ServerAgent server, String measureURI, Probe probe, long interval) {\r\n        this(server, measureURI, probe, interval, -1);\r\n    }\r\n\r\n    public MeasurementRequest(ServerAgent server, String measureURI, Probe probe, long interval, long subscriptionId) {\r\n        super(DataType.MEASUREMENT_REQUEST);\r\n        this.measureURI = measureURI;\r\n        this.interval = interval;\r\n        this.server = server;\r\n        this.probe = probe;\r\n        this.subscriptionId = subscriptionId;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public Probe getProbe() {\r\n        return probe;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return measureURI;\r\n    }\r\n\r\n    public long getInterval() {\r\n        return interval;\r\n    }\r\n\r\n    public long getLastMeasureTime() {\r\n        return lastMeasureTime;\r\n    }\r\n\r\n    public void setLastMeasureTime(long lastMeasureTime) {\r\n        this.lastMeasureTime = lastMeasureTime;\r\n    }\r\n\r\n    public ServerAgent getServer() {\r\n        return server;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        MeasurementRequest that = (MeasurementRequest) o;\r\n        if (interval != that.interval)\r\n            return false;\r\n        if (measureURI != null ? !measureURI.equals(that.measureURI) : that.measureURI != null)\r\n            return false;\r\n        if (server != null ? !server.equals(that.server) : that.server != null)\r\n            return false;\r\n        if (subscriptionId != that.subscriptionId)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = measureURI != null ? measureURI.hashCode() : 0;\r\n        result = 31 * result + (int) interval;\r\n        result = 31 * result + (server != null ? server.hashCode() : 0);\r\n        result = 31 * result + (int) subscriptionId;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"MeasurementRequest{\" + \"measureURI='\" + measureURI + '\\'' + \", interval=\" + interval + \", server=\" + server + \", subscriptionId=\" + subscriptionId + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/MeasurementRequest_0Test.java",
		"test_prompt": "// MeasurementRequest_0Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementRequest}.\n* It contains ten unit test cases for the {@link MeasurementRequest#equals(Object)} method.\n*/\nclass MeasurementRequest_0Test {"
	},
	{
		"original_code": "// MeasurementRequest.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.shared;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\n/**\r\n * Represents a request to provide a measurement from a probe, either once or at a given sampling interval.\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementRequest extends DataObject {\r\n\r\n    //the probe that provides the measure. currently assumed to give only the one exact measure.\r\n    private final String measureURI;\r\n\r\n    //sampling interval for continuously providing the values\r\n    private final long interval;\r\n\r\n    //the last time when a measurement was done\r\n    private long lastMeasureTime = -1;\r\n\r\n    //the server-agent where the measurement should be delivered\r\n    private final ServerAgent server;\r\n\r\n    //the probe that should perform the measure\r\n    private final Probe probe;\r\n\r\n    //unique identifier for measurement request/response subscription\r\n    private final long subscriptionId;\r\n\r\n    public MeasurementRequest(ServerAgent server, String measureURI, Probe probe) {\r\n        this(server, measureURI, probe, -1, -1);\r\n    }\r\n\r\n    public MeasurementRequest(ServerAgent server, String measureURI, Probe probe, long interval) {\r\n        this(server, measureURI, probe, interval, -1);\r\n    }\r\n\r\n    public MeasurementRequest(ServerAgent server, String measureURI, Probe probe, long interval, long subscriptionId) {\r\n        super(DataType.MEASUREMENT_REQUEST);\r\n        this.measureURI = measureURI;\r\n        this.interval = interval;\r\n        this.server = server;\r\n        this.probe = probe;\r\n        this.subscriptionId = subscriptionId;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public Probe getProbe() {\r\n        return probe;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return measureURI;\r\n    }\r\n\r\n    public long getInterval() {\r\n        return interval;\r\n    }\r\n\r\n    public long getLastMeasureTime() {\r\n        return lastMeasureTime;\r\n    }\r\n\r\n    public void setLastMeasureTime(long lastMeasureTime) {\r\n        this.lastMeasureTime = lastMeasureTime;\r\n    }\r\n\r\n    public ServerAgent getServer() {\r\n        return server;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        MeasurementRequest that = (MeasurementRequest) o;\r\n        if (interval != that.interval)\r\n            return false;\r\n        if (measureURI != null ? !measureURI.equals(that.measureURI) : that.measureURI != null)\r\n            return false;\r\n        if (server != null ? !server.equals(that.server) : that.server != null)\r\n            return false;\r\n        if (subscriptionId != that.subscriptionId)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = measureURI != null ? measureURI.hashCode() : 0;\r\n        result = 31 * result + (int) interval;\r\n        result = 31 * result + (server != null ? server.hashCode() : 0);\r\n        result = 31 * result + (int) subscriptionId;\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"MeasurementRequest{\" + \"measureURI='\" + measureURI + '\\'' + \", interval=\" + interval + \", server=\" + server + \", subscriptionId=\" + subscriptionId + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/MeasurementRequest_1Test.java",
		"test_prompt": "// MeasurementRequest_1Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementRequest}.\n* It contains ten unit test cases for the {@link MeasurementRequest#hashCode()} method.\n*/\nclass MeasurementRequest_1Test {"
	},
	{
		"original_code": "// MeasurementResponse.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.shared;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\n/**\r\n * Describes a base measure value as a result of a measurement performed by a probe (in response to measurementrequest).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementResponse extends DataObject {\r\n\r\n    //the actual value that was measured\r\n    private final BaseMeasure measure;\r\n\r\n    //the server-agent where the measure should be delivered\r\n    private final ServerAgent server;\r\n\r\n    //the probe information for the provided measure\r\n    private final ProbeInformation probeInfo;\r\n\r\n    //the precision of the measurement\r\n    private final int precision;\r\n\r\n    //unique identifier for measurement request/response subscription\r\n    private final long subscriptionId;\r\n\r\n    public MeasurementResponse(BaseMeasure measure, ServerAgent server, ProbeInformation probeInfo, int precision, long subscriptionId) {\r\n        super(DataType.MEASUREMENT_RESPONSE);\r\n        this.measure = measure;\r\n        this.server = server;\r\n        this.probeInfo = probeInfo;\r\n        this.precision = precision;\r\n        this.subscriptionId = subscriptionId;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public BaseMeasure value() {\r\n        return measure;\r\n    }\r\n\r\n    public int precision() {\r\n        return precision;\r\n    }\r\n\r\n    public ServerAgent server() {\r\n        return server;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return probeInfo.getMeasureURI();\r\n    }\r\n\r\n    public ProbeInformation getProbeInfo() {\r\n        return probeInfo;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        MeasurementResponse that = (MeasurementResponse) o;\r\n        if (precision != that.precision)\r\n            return false;\r\n        if (subscriptionId != that.subscriptionId)\r\n            return false;\r\n        if (measure != null ? !measure.equals(that.measure) : that.measure != null)\r\n            return false;\r\n        if (probeInfo != null ? !probeInfo.equals(that.probeInfo) : that.probeInfo != null)\r\n            return false;\r\n        if (server != null ? !server.equals(that.server) : that.server != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = measure != null ? measure.hashCode() : 0;\r\n        result = 31 * result + (server != null ? server.hashCode() : 0);\r\n        result = 31 * result + (probeInfo != null ? probeInfo.hashCode() : 0);\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (int) (subscriptionId ^ (subscriptionId >>> 32));\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"MeasurementResponse{\" + \"measure=\" + measure + \", server=\" + server + \", probeInfo=\" + probeInfo + \", precision=\" + precision + \", subscriptionId=\" + subscriptionId + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/MeasurementResponse_0Test.java",
		"test_prompt": "// MeasurementResponse_0Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementResponse}.\n* It contains ten unit test cases for the {@link MeasurementResponse#value()} method.\n*/\nclass MeasurementResponse_0Test {"
	},
	{
		"original_code": "// MeasurementResponse.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.shared;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\n/**\r\n * Describes a base measure value as a result of a measurement performed by a probe (in response to measurementrequest).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementResponse extends DataObject {\r\n\r\n    //the actual value that was measured\r\n    private final BaseMeasure measure;\r\n\r\n    //the server-agent where the measure should be delivered\r\n    private final ServerAgent server;\r\n\r\n    //the probe information for the provided measure\r\n    private final ProbeInformation probeInfo;\r\n\r\n    //the precision of the measurement\r\n    private final int precision;\r\n\r\n    //unique identifier for measurement request/response subscription\r\n    private final long subscriptionId;\r\n\r\n    public MeasurementResponse(BaseMeasure measure, ServerAgent server, ProbeInformation probeInfo, int precision, long subscriptionId) {\r\n        super(DataType.MEASUREMENT_RESPONSE);\r\n        this.measure = measure;\r\n        this.server = server;\r\n        this.probeInfo = probeInfo;\r\n        this.precision = precision;\r\n        this.subscriptionId = subscriptionId;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public BaseMeasure value() {\r\n        return measure;\r\n    }\r\n\r\n    public int precision() {\r\n        return precision;\r\n    }\r\n\r\n    public ServerAgent server() {\r\n        return server;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return probeInfo.getMeasureURI();\r\n    }\r\n\r\n    public ProbeInformation getProbeInfo() {\r\n        return probeInfo;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        MeasurementResponse that = (MeasurementResponse) o;\r\n        if (precision != that.precision)\r\n            return false;\r\n        if (subscriptionId != that.subscriptionId)\r\n            return false;\r\n        if (measure != null ? !measure.equals(that.measure) : that.measure != null)\r\n            return false;\r\n        if (probeInfo != null ? !probeInfo.equals(that.probeInfo) : that.probeInfo != null)\r\n            return false;\r\n        if (server != null ? !server.equals(that.server) : that.server != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = measure != null ? measure.hashCode() : 0;\r\n        result = 31 * result + (server != null ? server.hashCode() : 0);\r\n        result = 31 * result + (probeInfo != null ? probeInfo.hashCode() : 0);\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (int) (subscriptionId ^ (subscriptionId >>> 32));\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"MeasurementResponse{\" + \"measure=\" + measure + \", server=\" + server + \", probeInfo=\" + probeInfo + \", precision=\" + precision + \", subscriptionId=\" + subscriptionId + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/MeasurementResponse_1Test.java",
		"test_prompt": "// MeasurementResponse_1Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementResponse}.\n* It contains ten unit test cases for the {@link MeasurementResponse#precision()} method.\n*/\nclass MeasurementResponse_1Test {"
	},
	{
		"original_code": "// MeasurementResponse.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.shared;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\n/**\r\n * Describes a base measure value as a result of a measurement performed by a probe (in response to measurementrequest).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementResponse extends DataObject {\r\n\r\n    //the actual value that was measured\r\n    private final BaseMeasure measure;\r\n\r\n    //the server-agent where the measure should be delivered\r\n    private final ServerAgent server;\r\n\r\n    //the probe information for the provided measure\r\n    private final ProbeInformation probeInfo;\r\n\r\n    //the precision of the measurement\r\n    private final int precision;\r\n\r\n    //unique identifier for measurement request/response subscription\r\n    private final long subscriptionId;\r\n\r\n    public MeasurementResponse(BaseMeasure measure, ServerAgent server, ProbeInformation probeInfo, int precision, long subscriptionId) {\r\n        super(DataType.MEASUREMENT_RESPONSE);\r\n        this.measure = measure;\r\n        this.server = server;\r\n        this.probeInfo = probeInfo;\r\n        this.precision = precision;\r\n        this.subscriptionId = subscriptionId;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public BaseMeasure value() {\r\n        return measure;\r\n    }\r\n\r\n    public int precision() {\r\n        return precision;\r\n    }\r\n\r\n    public ServerAgent server() {\r\n        return server;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return probeInfo.getMeasureURI();\r\n    }\r\n\r\n    public ProbeInformation getProbeInfo() {\r\n        return probeInfo;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        MeasurementResponse that = (MeasurementResponse) o;\r\n        if (precision != that.precision)\r\n            return false;\r\n        if (subscriptionId != that.subscriptionId)\r\n            return false;\r\n        if (measure != null ? !measure.equals(that.measure) : that.measure != null)\r\n            return false;\r\n        if (probeInfo != null ? !probeInfo.equals(that.probeInfo) : that.probeInfo != null)\r\n            return false;\r\n        if (server != null ? !server.equals(that.server) : that.server != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = measure != null ? measure.hashCode() : 0;\r\n        result = 31 * result + (server != null ? server.hashCode() : 0);\r\n        result = 31 * result + (probeInfo != null ? probeInfo.hashCode() : 0);\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (int) (subscriptionId ^ (subscriptionId >>> 32));\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"MeasurementResponse{\" + \"measure=\" + measure + \", server=\" + server + \", probeInfo=\" + probeInfo + \", precision=\" + precision + \", subscriptionId=\" + subscriptionId + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/MeasurementResponse_2Test.java",
		"test_prompt": "// MeasurementResponse_2Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementResponse}.\n* It contains ten unit test cases for the {@link MeasurementResponse#server()} method.\n*/\nclass MeasurementResponse_2Test {"
	},
	{
		"original_code": "// MeasurementResponse.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.shared;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\n/**\r\n * Describes a base measure value as a result of a measurement performed by a probe (in response to measurementrequest).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementResponse extends DataObject {\r\n\r\n    //the actual value that was measured\r\n    private final BaseMeasure measure;\r\n\r\n    //the server-agent where the measure should be delivered\r\n    private final ServerAgent server;\r\n\r\n    //the probe information for the provided measure\r\n    private final ProbeInformation probeInfo;\r\n\r\n    //the precision of the measurement\r\n    private final int precision;\r\n\r\n    //unique identifier for measurement request/response subscription\r\n    private final long subscriptionId;\r\n\r\n    public MeasurementResponse(BaseMeasure measure, ServerAgent server, ProbeInformation probeInfo, int precision, long subscriptionId) {\r\n        super(DataType.MEASUREMENT_RESPONSE);\r\n        this.measure = measure;\r\n        this.server = server;\r\n        this.probeInfo = probeInfo;\r\n        this.precision = precision;\r\n        this.subscriptionId = subscriptionId;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public BaseMeasure value() {\r\n        return measure;\r\n    }\r\n\r\n    public int precision() {\r\n        return precision;\r\n    }\r\n\r\n    public ServerAgent server() {\r\n        return server;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return probeInfo.getMeasureURI();\r\n    }\r\n\r\n    public ProbeInformation getProbeInfo() {\r\n        return probeInfo;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        MeasurementResponse that = (MeasurementResponse) o;\r\n        if (precision != that.precision)\r\n            return false;\r\n        if (subscriptionId != that.subscriptionId)\r\n            return false;\r\n        if (measure != null ? !measure.equals(that.measure) : that.measure != null)\r\n            return false;\r\n        if (probeInfo != null ? !probeInfo.equals(that.probeInfo) : that.probeInfo != null)\r\n            return false;\r\n        if (server != null ? !server.equals(that.server) : that.server != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = measure != null ? measure.hashCode() : 0;\r\n        result = 31 * result + (server != null ? server.hashCode() : 0);\r\n        result = 31 * result + (probeInfo != null ? probeInfo.hashCode() : 0);\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (int) (subscriptionId ^ (subscriptionId >>> 32));\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"MeasurementResponse{\" + \"measure=\" + measure + \", server=\" + server + \", probeInfo=\" + probeInfo + \", precision=\" + precision + \", subscriptionId=\" + subscriptionId + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/MeasurementResponse_3Test.java",
		"test_prompt": "// MeasurementResponse_3Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementResponse}.\n* It contains ten unit test cases for the {@link MeasurementResponse#equals(Object)} method.\n*/\nclass MeasurementResponse_3Test {"
	},
	{
		"original_code": "// MeasurementResponse.java\n/*\r\n * Copyright (C) 2010-2011 VTT Technical Research Centre of Finland.\r\n *\r\n * This library is free software; you can redistribute it and/or\r\n * modify it under the terms of the GNU Lesser General Public\r\n * License as published by the Free Software Foundation;\r\n * version 2.1 of the License.\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n * Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n * License along with this library; if not, write to the Free Software\r\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\r\n */\r\npackage fi.vtt.noen.mfw.bundle.probe.shared;\r\n\r\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\r\nimport fi.vtt.noen.mfw.bundle.common.DataType;\r\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\r\n\r\n/**\r\n * Describes a base measure value as a result of a measurement performed by a probe (in response to measurementrequest).\r\n *\r\n * @author Teemu Kanstren\r\n */\r\npublic class MeasurementResponse extends DataObject {\r\n\r\n    //the actual value that was measured\r\n    private final BaseMeasure measure;\r\n\r\n    //the server-agent where the measure should be delivered\r\n    private final ServerAgent server;\r\n\r\n    //the probe information for the provided measure\r\n    private final ProbeInformation probeInfo;\r\n\r\n    //the precision of the measurement\r\n    private final int precision;\r\n\r\n    //unique identifier for measurement request/response subscription\r\n    private final long subscriptionId;\r\n\r\n    public MeasurementResponse(BaseMeasure measure, ServerAgent server, ProbeInformation probeInfo, int precision, long subscriptionId) {\r\n        super(DataType.MEASUREMENT_RESPONSE);\r\n        this.measure = measure;\r\n        this.server = server;\r\n        this.probeInfo = probeInfo;\r\n        this.precision = precision;\r\n        this.subscriptionId = subscriptionId;\r\n    }\r\n\r\n    public long getSubscriptionId() {\r\n        return subscriptionId;\r\n    }\r\n\r\n    public BaseMeasure value() {\r\n        return measure;\r\n    }\r\n\r\n    public int precision() {\r\n        return precision;\r\n    }\r\n\r\n    public ServerAgent server() {\r\n        return server;\r\n    }\r\n\r\n    public String getMeasureURI() {\r\n        return probeInfo.getMeasureURI();\r\n    }\r\n\r\n    public ProbeInformation getProbeInfo() {\r\n        return probeInfo;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o)\r\n            return true;\r\n        if (o == null || getClass() != o.getClass())\r\n            return false;\r\n        MeasurementResponse that = (MeasurementResponse) o;\r\n        if (precision != that.precision)\r\n            return false;\r\n        if (subscriptionId != that.subscriptionId)\r\n            return false;\r\n        if (measure != null ? !measure.equals(that.measure) : that.measure != null)\r\n            return false;\r\n        if (probeInfo != null ? !probeInfo.equals(that.probeInfo) : that.probeInfo != null)\r\n            return false;\r\n        if (server != null ? !server.equals(that.server) : that.server != null)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int result = measure != null ? measure.hashCode() : 0;\r\n        result = 31 * result + (server != null ? server.hashCode() : 0);\r\n        result = 31 * result + (probeInfo != null ? probeInfo.hashCode() : 0);\r\n        result = 31 * result + precision;\r\n        result = 31 * result + (int) (subscriptionId ^ (subscriptionId >>> 32));\r\n        return result;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"MeasurementResponse{\" + \"measure=\" + measure + \", server=\" + server + \", probeInfo=\" + probeInfo + \", precision=\" + precision + \", subscriptionId=\" + subscriptionId + '}';\r\n    }\r\n}\r\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/noen/mfw/bundle/probe/shared/MeasurementResponse_4Test.java",
		"test_prompt": "// MeasurementResponse_4Test.java\npackage fi.vtt.noen.mfw.bundle.probe.shared;\n\nimport fi.vtt.noen.mfw.bundle.common.DataObject;\nimport fi.vtt.noen.mfw.bundle.common.DataType;\nimport fi.vtt.noen.mfw.bundle.server.shared.ServerAgent;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MeasurementResponse}.\n* It contains ten unit test cases for the {@link MeasurementResponse#hashCode()} method.\n*/\nclass MeasurementResponse_4Test {"
	},
	{
		"original_code": "// BaseBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport java.io.UnsupportedEncodingException;\n\npublic class BaseBuilder {\n\n    private static final String CHARSET = \"US-ASCII\";\n\n    protected final PFTest test;\n\n    public BaseBuilder(PFTest test) {\n        this.test = test;\n    }\n\n    /**\n     * Calculate length of a given string. Takes into consideration the\n     * number of bytes used to store the string length and gives this\n     * max value if string is longer. Length is calculated from the byte\n     * array with US-ASCII encoding, in case unicode chars would be used\n     * that would make the array length different from string length.\n     *\n     * @param str     String to process\n     * @param bytes   Number of bytes used to hold the length, defining max length of bytearray\n     * @return        Length of string as bytes, within given constraints\n     */\n    public int strlen(String str, int bytes) {\n        if (str == null) {\n            return 0;\n        }\n        int len = 0;\n        try {\n            len = str.getBytes(CHARSET).length;\n        } catch (UnsupportedEncodingException e) {\n            // TODO exception handling\n            e.printStackTrace();\n        }\n        int maxlen = (int) Math.pow(2, bytes * 8) - 1;\n        if (len > maxlen) {\n            len = maxlen;\n        }\n        return len;\n    }\n\n    /**\n     * Convert a string into an array of bytes and copy the result into the given\n     * bytearray starting at the given location. Respects the given maximum size\n     * by leaving out any data that does not fit into given size. Size is given as\n     * the number of bytes that is used to hold the length. Thus 1 equals max of\n     * 2^8-1=255 characters and 2 equals 2^16-1=65535 characters and so on.\n     *\n     * @param str   String to convert\n     * @param msg   The bytearray into which the converted bytes are stored\n     * @param start Start index for storing in bytearray\n     * @param bytes Number of bytes to hold size (1=255, 2=65535)\n     */\n    public void stringToBytes(String str, byte[] msg, int start, int bytes) {\n        int len = strlen(str, bytes);\n        //    System.out.println(\"strlen:\"+len);\n        longToBytes(len, msg, start, bytes);\n        if (len == 0) {\n            //no need to copy anything, avoid possible NPE\n            return;\n        }\n        start += bytes;\n        byte[] strBytes = null;\n        try {\n            strBytes = str.getBytes(CHARSET);\n        } catch (UnsupportedEncodingException e) {\n            // TODO exception handling\n            e.printStackTrace();\n        }\n        System.arraycopy(strBytes, 0, msg, start, len);\n    }\n\n    public static void longToBytes(long value, byte[] msg, int start, int bytes) {\n        for (int i = bytes - 1; i >= 0; i--) {\n            msg[start + i] = (byte) value;\n            value >>>= 8;\n        }\n    }\n\n    public void setTime(byte[] msg, int index) {\n        longToBytes(test.timeDelta(), msg, index, 4);\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/BaseBuilder.java",
		"test_prompt": "// BaseBuilderTest.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BaseBuilder}.\n* It contains ten unit test cases for the {@link BaseBuilder#strlen(String, int)} method.\n*/\nclass BaseBuilderTest {"
	},
	{
		"original_code": "// StartBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport java.util.Calendar;\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\npublic class StartBuilder extends BaseBuilder {\n\n    public StartBuilder(PFTest test) {\n        super(test);\n    }\n\n    public byte[] startMsg() {\n        //+1 for id + 1 for byte-order + 1 for protocol version\n        //+ project name size (1+number of characters)\n        //+ test description size (1+number of characters)\n        //+1 for empty versionname\n        //+1 for empty targetname\n        //+ description size (1+number of characters)\n        //+1 for time accuracy + 4 for starttime + 3 for packet id\n        //this is project name\n        int projLen = strlen(test.getProject()) + 1;\n        //test name\n        int testLen = strlen(test.getName()) + 1;\n        //suite is description is spec\n        int descLen = strlen(test.getSuite()) + 1;\n        //project version\n        int versionLen = strlen(test.getProjectVersion()) + 1;\n        //test target\n        int targetLen = strlen(test.getTestTarget()) + 1;\n        //+1 for empty projectname + 1 for empty testcase number\n        byte[] msg = new byte[1 + 1 + 1 + projLen + versionLen + testLen + targetLen + descLen + 1 + 4 + 3];\n        int i = 0;\n        //ID for start binary message\n        msg[i++] = (byte) 0xFF;\n        //big-endian byte order = FF\n        msg[i++] = (byte) 0xFF;\n        //protocol version\n        msg[i++] = 2;\n        //project name\n        stringToBytes(test.getProject(), msg, i, 1);\n        i += projLen;\n        //project version\n        stringToBytes(test.getProjectVersion(), msg, i, 1);\n        i += versionLen;\n        //test case identifier\n        stringToBytes(test.getName(), msg, i, 1);\n        i += testLen;\n        //test target\n        stringToBytes(test.getTestTarget(), msg, i, 1);\n        i += targetLen;\n        //suite name (test description)\n        stringToBytes(test.getSuite(), msg, i, 1);\n        i += descLen;\n        msg[i++] = test.getAccuracy().id;\n        Calendar cal = Calendar.getInstance();\n        cal.set(2007, Calendar.JANUARY, 1, 0, 0, 0);\n        long baseTime = cal.getTime().getTime();\n        long millis = test.startTime();\n        millis -= baseTime;\n        millis /= 1000;\n        longToBytes(millis, msg, i, 4);\n        i += 4;\n        //TODO for now only one connection from a VM is supported\n        longToBytes(test.getTestId(), msg, i, 3);\n        return msg;\n    }\n\n    private int strlen(String testDescription) {\n        if (testDescription == null) {\n            return 0;\n        }\n        int descLen = testDescription.length();\n        if (descLen > 255) {\n            descLen = 255;\n        }\n        return descLen;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/StartBuilder.java",
		"test_prompt": "// StartBuilderTest.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport java.util.Calendar;\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StartBuilder}.\n* It contains ten unit test cases for the {@link StartBuilder#startMsg()} method.\n*/\nclass StartBuilderTest {"
	},
	{
		"original_code": "// InputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\n//TODO this is not fully implemented, missing ID values from beginning\npublic class InputBuilder extends BaseBuilder {\n\n    //id(1)+inputn(2)+datatype(1)+time(4)\n    public static final int INPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public InputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startInput1(byte[] msg, int inputN, byte dataType) {\n        int i = 0;\n        msg[i++] = 0x0a;\n        longToBytes(inputN, msg, i, 2);\n        i += 2;\n        msg[i++] = dataType;\n        return i;\n    }\n\n    public byte[] input1Msg(int n, boolean value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 1];\n        int i = startInput1(msg, n, (byte) 0x01);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, long value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 8];\n        int i = startInput1(msg, n, (byte) 0x6);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, String text) {\n        byte[] msg = new byte[INPUT1BASELENGTH + text.length() + 2];\n        int i = startInput1(msg, n, (byte) 0x8);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, byte[] data) {\n        byte[] msg = new byte[INPUT1BASELENGTH + data.length + 2];\n        int i = startInput1(msg, n, (byte) 0x9);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/InputBuilder_0Test.java",
		"test_prompt": "// InputBuilder_0Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InputBuilder}.\n* It contains ten unit test cases for the {@link InputBuilder#startInput1(byte[], int, byte)} method.\n*/\nclass InputBuilder_0Test {"
	},
	{
		"original_code": "// InputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\n//TODO this is not fully implemented, missing ID values from beginning\npublic class InputBuilder extends BaseBuilder {\n\n    //id(1)+inputn(2)+datatype(1)+time(4)\n    public static final int INPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public InputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startInput1(byte[] msg, int inputN, byte dataType) {\n        int i = 0;\n        msg[i++] = 0x0a;\n        longToBytes(inputN, msg, i, 2);\n        i += 2;\n        msg[i++] = dataType;\n        return i;\n    }\n\n    public byte[] input1Msg(int n, boolean value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 1];\n        int i = startInput1(msg, n, (byte) 0x01);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, long value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 8];\n        int i = startInput1(msg, n, (byte) 0x6);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, String text) {\n        byte[] msg = new byte[INPUT1BASELENGTH + text.length() + 2];\n        int i = startInput1(msg, n, (byte) 0x8);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, byte[] data) {\n        byte[] msg = new byte[INPUT1BASELENGTH + data.length + 2];\n        int i = startInput1(msg, n, (byte) 0x9);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/InputBuilder_1Test.java",
		"test_prompt": "// InputBuilder_1Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InputBuilder}.\n* It contains ten unit test cases for the {@link InputBuilder#input1Msg(int, boolean)} method.\n*/\nclass InputBuilder_1Test {"
	},
	{
		"original_code": "// InputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\n//TODO this is not fully implemented, missing ID values from beginning\npublic class InputBuilder extends BaseBuilder {\n\n    //id(1)+inputn(2)+datatype(1)+time(4)\n    public static final int INPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public InputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startInput1(byte[] msg, int inputN, byte dataType) {\n        int i = 0;\n        msg[i++] = 0x0a;\n        longToBytes(inputN, msg, i, 2);\n        i += 2;\n        msg[i++] = dataType;\n        return i;\n    }\n\n    public byte[] input1Msg(int n, boolean value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 1];\n        int i = startInput1(msg, n, (byte) 0x01);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, long value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 8];\n        int i = startInput1(msg, n, (byte) 0x6);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, String text) {\n        byte[] msg = new byte[INPUT1BASELENGTH + text.length() + 2];\n        int i = startInput1(msg, n, (byte) 0x8);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, byte[] data) {\n        byte[] msg = new byte[INPUT1BASELENGTH + data.length + 2];\n        int i = startInput1(msg, n, (byte) 0x9);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/InputBuilder_2Test.java",
		"test_prompt": "// InputBuilder_2Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InputBuilder}.\n* It contains ten unit test cases for the {@link InputBuilder#input1Msg(int, long)} method.\n*/\nclass InputBuilder_2Test {"
	},
	{
		"original_code": "// InputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\n//TODO this is not fully implemented, missing ID values from beginning\npublic class InputBuilder extends BaseBuilder {\n\n    //id(1)+inputn(2)+datatype(1)+time(4)\n    public static final int INPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public InputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startInput1(byte[] msg, int inputN, byte dataType) {\n        int i = 0;\n        msg[i++] = 0x0a;\n        longToBytes(inputN, msg, i, 2);\n        i += 2;\n        msg[i++] = dataType;\n        return i;\n    }\n\n    public byte[] input1Msg(int n, boolean value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 1];\n        int i = startInput1(msg, n, (byte) 0x01);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, long value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 8];\n        int i = startInput1(msg, n, (byte) 0x6);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, String text) {\n        byte[] msg = new byte[INPUT1BASELENGTH + text.length() + 2];\n        int i = startInput1(msg, n, (byte) 0x8);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, byte[] data) {\n        byte[] msg = new byte[INPUT1BASELENGTH + data.length + 2];\n        int i = startInput1(msg, n, (byte) 0x9);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/InputBuilder_3Test.java",
		"test_prompt": "// InputBuilder_3Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InputBuilder}.\n* It contains ten unit test cases for the {@link InputBuilder#input1Msg(int, String)} method.\n*/\nclass InputBuilder_3Test {"
	},
	{
		"original_code": "// InputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\n//TODO this is not fully implemented, missing ID values from beginning\npublic class InputBuilder extends BaseBuilder {\n\n    //id(1)+inputn(2)+datatype(1)+time(4)\n    public static final int INPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public InputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startInput1(byte[] msg, int inputN, byte dataType) {\n        int i = 0;\n        msg[i++] = 0x0a;\n        longToBytes(inputN, msg, i, 2);\n        i += 2;\n        msg[i++] = dataType;\n        return i;\n    }\n\n    public byte[] input1Msg(int n, boolean value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 1];\n        int i = startInput1(msg, n, (byte) 0x01);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, long value) {\n        byte[] msg = new byte[INPUT1BASELENGTH + 8];\n        int i = startInput1(msg, n, (byte) 0x6);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, String text) {\n        byte[] msg = new byte[INPUT1BASELENGTH + text.length() + 2];\n        int i = startInput1(msg, n, (byte) 0x8);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] input1Msg(int n, byte[] data) {\n        byte[] msg = new byte[INPUT1BASELENGTH + data.length + 2];\n        int i = startInput1(msg, n, (byte) 0x9);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/InputBuilder_4Test.java",
		"test_prompt": "// InputBuilder_4Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link InputBuilder}.\n* It contains ten unit test cases for the {@link InputBuilder#input1Msg(int, byte[])} method.\n*/\nclass InputBuilder_4Test {"
	},
	{
		"original_code": "// OutputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\npublic class OutputBuilder extends BaseBuilder {\n\n    //outputid(1)+outputn(2)+datatype(1)+time(4)\n    public static final int OUTPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public OutputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startOutput1(byte[] msg, int outputN, byte typeId) {\n        int i = 0;\n        msg[i++] = 0x11;\n        longToBytes(outputN, msg, i, 2);\n        i += 2;\n        msg[i++] = typeId;\n        return i;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, boolean value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 1];\n        int i = startOutput1(msg, n, typeId);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, long value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 8];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, String text) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + strlen(text, 2) + 2];\n        int i = startOutput1(msg, n, typeId);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, byte[] data) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + data.length + 2];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/OutputBuilder_0Test.java",
		"test_prompt": "// OutputBuilder_0Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OutputBuilder}.\n* It contains ten unit test cases for the {@link OutputBuilder#startOutput1(byte[], int, byte)} method.\n*/\nclass OutputBuilder_0Test {"
	},
	{
		"original_code": "// OutputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\npublic class OutputBuilder extends BaseBuilder {\n\n    //outputid(1)+outputn(2)+datatype(1)+time(4)\n    public static final int OUTPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public OutputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startOutput1(byte[] msg, int outputN, byte typeId) {\n        int i = 0;\n        msg[i++] = 0x11;\n        longToBytes(outputN, msg, i, 2);\n        i += 2;\n        msg[i++] = typeId;\n        return i;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, boolean value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 1];\n        int i = startOutput1(msg, n, typeId);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, long value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 8];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, String text) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + strlen(text, 2) + 2];\n        int i = startOutput1(msg, n, typeId);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, byte[] data) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + data.length + 2];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/OutputBuilder_1Test.java",
		"test_prompt": "// OutputBuilder_1Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OutputBuilder}.\n* It contains ten unit test cases for the {@link OutputBuilder#output1Msg(int, byte, boolean)} method.\n*/\nclass OutputBuilder_1Test {"
	},
	{
		"original_code": "// OutputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\npublic class OutputBuilder extends BaseBuilder {\n\n    //outputid(1)+outputn(2)+datatype(1)+time(4)\n    public static final int OUTPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public OutputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startOutput1(byte[] msg, int outputN, byte typeId) {\n        int i = 0;\n        msg[i++] = 0x11;\n        longToBytes(outputN, msg, i, 2);\n        i += 2;\n        msg[i++] = typeId;\n        return i;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, boolean value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 1];\n        int i = startOutput1(msg, n, typeId);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, long value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 8];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, String text) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + strlen(text, 2) + 2];\n        int i = startOutput1(msg, n, typeId);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, byte[] data) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + data.length + 2];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/OutputBuilder_2Test.java",
		"test_prompt": "// OutputBuilder_2Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OutputBuilder}.\n* It contains ten unit test cases for the {@link OutputBuilder#output1Msg(int, byte, long)} method.\n*/\nclass OutputBuilder_2Test {"
	},
	{
		"original_code": "// OutputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\npublic class OutputBuilder extends BaseBuilder {\n\n    //outputid(1)+outputn(2)+datatype(1)+time(4)\n    public static final int OUTPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public OutputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startOutput1(byte[] msg, int outputN, byte typeId) {\n        int i = 0;\n        msg[i++] = 0x11;\n        longToBytes(outputN, msg, i, 2);\n        i += 2;\n        msg[i++] = typeId;\n        return i;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, boolean value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 1];\n        int i = startOutput1(msg, n, typeId);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, long value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 8];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, String text) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + strlen(text, 2) + 2];\n        int i = startOutput1(msg, n, typeId);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, byte[] data) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + data.length + 2];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/OutputBuilder_3Test.java",
		"test_prompt": "// OutputBuilder_3Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OutputBuilder}.\n* It contains ten unit test cases for the {@link OutputBuilder#output1Msg(int, byte, String)} method.\n*/\nclass OutputBuilder_3Test {"
	},
	{
		"original_code": "// OutputBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\npublic class OutputBuilder extends BaseBuilder {\n\n    //outputid(1)+outputn(2)+datatype(1)+time(4)\n    public static final int OUTPUT1BASELENGTH = 1 + 2 + 1 + 4;\n\n    public OutputBuilder(PFTest test) {\n        super(test);\n    }\n\n    public int startOutput1(byte[] msg, int outputN, byte typeId) {\n        int i = 0;\n        msg[i++] = 0x11;\n        longToBytes(outputN, msg, i, 2);\n        i += 2;\n        msg[i++] = typeId;\n        return i;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, boolean value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 1];\n        int i = startOutput1(msg, n, typeId);\n        if (value) {\n            msg[i++] = 0x01;\n        } else {\n            msg[i++] = 0x00;\n        }\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, long value) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + 8];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(value, msg, i, 8);\n        i += 8;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, String text) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + strlen(text, 2) + 2];\n        int i = startOutput1(msg, n, typeId);\n        stringToBytes(text, msg, i, 2);\n        i += text.length() + 2;\n        setTime(msg, i);\n        return msg;\n    }\n\n    public byte[] output1Msg(int n, byte typeId, byte[] data) {\n        byte[] msg = new byte[OUTPUT1BASELENGTH + data.length + 2];\n        int i = startOutput1(msg, n, typeId);\n        longToBytes(data.length, msg, i, 2);\n        i += 2;\n        for (int d = 0; d < data.length; d++) {\n            msg[i++] = data[d];\n        }\n        setTime(msg, i);\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/OutputBuilder_4Test.java",
		"test_prompt": "// OutputBuilder_4Test.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OutputBuilder}.\n* It contains ten unit test cases for the {@link OutputBuilder#output1Msg(int, byte, byte[])} method.\n*/\nclass OutputBuilder_4Test {"
	},
	{
		"original_code": "// OutputTypeBuilder.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\n\npublic class OutputTypeBuilder extends BaseBuilder {\n\n    public OutputTypeBuilder(PFTest test) {\n        super(test);\n    }\n\n    public byte[] outputTypeMsg(OutputType type, int id, String name) {\n        //+1 for the byte to store name size\n        int namelen = 1 + strlen(name, 1);\n        int len = 1 + 1 + namelen + 1;\n        byte[] msg = new byte[len];\n        int i = 0;\n        msg[i++] = 0x10;\n        longToBytes(id, msg, i, 1);\n        i++;\n        stringToBytes(name, msg, i, 1);\n        i += namelen;\n        msg[i] = type.id;\n        return msg;\n    }\n}\n",
		"id": "/EvoSuiteBenchmark/61_noen/src/main/java/fi/vtt/probeframework/javaclient/protocol/messages/OutputTypeBuilder.java",
		"test_prompt": "// OutputTypeBuilderTest.java\npackage fi.vtt.probeframework.javaclient.protocol.messages;\n\nimport fi.vtt.probeframework.javaclient.api.probe.PFTest;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OutputTypeBuilder}.\n* It contains ten unit test cases for the {@link OutputTypeBuilder#outputTypeMsg(OutputType, int, String)} method.\n*/\nclass OutputTypeBuilderTest {"
	}
]