[
	{
		"original_code": "// ReceiverServiceBootstrap.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\n\n/**\n * <code>ReceiverServiceBootstrap</code> starts the\n * {@link net.sf.xbus.technical.ReceiverService}, using the\n * {@link net.sf.xbus.base.core.reflection.XBUSClassLoader}.\n */\npublic class ReceiverServiceBootstrap {\n\n    private static final String mReceiverServiceClassName = \"net.sf.xbus.technical.ReceiverService\";\n\n    /**\n     * Starts the {@link net.sf.xbus.technical.ReceiverService} in a way, that\n     * it is stoppable by the\n     * {@link net.sf.xbus.technical.ReceiverServiceAdministrator}\n     *\n     * @param args not used\n     */\n    public static void main(String[] args) {\n        callReceiverServiceMethod(\"startWithoutServletEngine\", null);\n    }\n\n    public static void start(boolean insideServletEngine) {\n        if (insideServletEngine) {\n            callReceiverServiceMethod(\"startInsideServletEngine\", Thread.currentThread().getContextClassLoader());\n        } else {\n            callReceiverServiceMethod(\"startWithoutServletEngine\", Thread.currentThread().getContextClassLoader());\n        }\n    }\n\n    public static Object getInstance() {\n        return callReceiverServiceMethod(\"getInstance\", null);\n    }\n\n    private static Object callReceiverServiceMethod(String methodName, ClassLoader parent) {\n        Thread.currentThread().setContextClassLoader(XBUSClassLoader.getInstance(parent));\n        Object retObject = null;\n        try {\n            Object obj = ReflectionSupport.createObject(mReceiverServiceClassName);\n            retObject = ReflectionSupport.callMethod(methodName, obj, null, null);\n        } catch (XException e) {\n            System.exit(1);\n        }\n        return retObject;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/bootstrap/ReceiverServiceBootstrapTest.java",
		"test_prompt": "// ReceiverServiceBootstrapTest.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverServiceBootstrap}.\n* It contains ten unit test cases for the {@link ReceiverServiceBootstrap#getInstance()} method.\n*/\nclass ReceiverServiceBootstrapTest {"
	},
	{
		"original_code": "// SOAPAdministratorBootstrap.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * Restarts the xBus by calling a web service.\n */\npublic class SOAPAdministratorBootstrap {\n\n    /**\n     * Starts the client program to send a SOAP request to the xBus to restart.\n     *\n     * @param args host and port of the servlet engine\n     */\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"There must be exactly 2 parameters: host and port\");\n            System.exit(1);\n        }\n        try {\n            String host = args[0];\n            Integer port = new Integer(Integer.parseInt(args[1]));\n            Thread.currentThread().setContextClassLoader(XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n            Object obj = ReflectionSupport.createObject(\"net.sf.xbus.admin.soap.SOAPAdministrator\");\n            Class[] parameterTypes = new Class[] { String.class, Integer.class };\n            Object[] arguments = new Object[] { host, port };\n            String message = (String) ReflectionSupport.callMethod(\"restart\", obj, parameterTypes, arguments);\n            Trace.always(message);\n        } catch (Exception e) {\n            Trace.error(e);\n            System.exit(1);\n        }\n    }\n\n    /**\n     * Called by the web service to restart the xBus.\n     *\n     * @return a message of success or failure\n     */\n    public String restart() {\n        ClassLoader currentCL = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(XBUSClassLoader.getInstance(currentCL));\n        String retString = null;\n        try {\n            Object obj = ReflectionSupport.createObject(\"net.sf.xbus.admin.Administrator\");\n            retString = (String) ReflectionSupport.callMethod(\"restartReceiverService\", obj, null, null);\n        } catch (XException e) {\n            retString = e.getMessage();\n        }\n        return retString;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/bootstrap/SOAPAdministratorBootstrapTest.java",
		"test_prompt": "// SOAPAdministratorBootstrapTest.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SOAPAdministratorBootstrap}.\n* It contains ten unit test cases for the {@link SOAPAdministratorBootstrap#restart()} method.\n*/\nclass SOAPAdministratorBootstrapTest {"
	},
	{
		"original_code": "// JavaReceiverBootstrap.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\n\n/**\n * <code>JavaReceiverBootstrap</code> is used to call the xBus directly from\n * another Java application. It receives a request via a call of its\n * <code>receive</code> method.\n */\npublic class JavaReceiverBootstrap {\n\n    /**\n     * Receives a request, processes the message as configured in\n     * <code>standard.conf</code> and returns a response.\n     *\n     * @param system name of the system as configured in\n     *            <code>standard.conf</code>\n     * @param request the message that shall be processed by the xBus\n     * @return the outcome of processing the request\n     * @throws XException if the request cannot be processed\n     */\n    public static Object receive(String system, Object request) throws XException {\n        Object responseObject = null;\n        ClassLoader tmpCL = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(XBUSClassLoader.getInstance(tmpCL));\n        try {\n            Object obj = ReflectionSupport.createObject(\"net.sf.xbus.technical.java.JavaReceiver\");\n            Class[] parameterTypes = new Class[] { String.class, Object.class };\n            Object[] arguments = new Object[] { system, request };\n            responseObject = ReflectionSupport.callMethod(\"receive\", obj, parameterTypes, arguments);\n        } finally {\n            Thread.currentThread().setContextClassLoader(tmpCL);\n        }\n        return responseObject;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/bootstrap/JavaReceiverBootstrapTest.java",
		"test_prompt": "// JavaReceiverBootstrapTest.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaReceiverBootstrap}.\n* It contains ten unit test cases for the {@link JavaReceiverBootstrap#receive(String, Object)} method.\n*/\nclass JavaReceiverBootstrapTest {"
	},
	{
		"original_code": "// ReceiverServiceWrapper.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.tanukisoftware.wrapper.WrapperListener;\nimport org.tanukisoftware.wrapper.WrapperManager;\n\n/**\n * Starts the {@link net.sf.xbus.technical.ReceiverService} as a background\n * service, using the {@link net.sf.xbus.base.core.reflection.XBUSClassLoader}.\n * <p>\n * It works together with the Java Service Wrapper from Silveregg Technologies\n * to start it as a service in Windows NT, Linux or Solaris. This is an\n * open-source packages which can be found at SourceForge.\n */\npublic class ReceiverServiceWrapper implements WrapperListener {\n\n    /**\n     * Start the application. If the JVM was launched from the native Wrapper\n     * then the application will wait for the native Wrapper to call the\n     * application's start method. Otherwise the start method will be called\n     * immediately.\n     */\n    public static void main(String[] args) {\n        WrapperManager.start(new ReceiverServiceWrapper(), args);\n    }\n\n    /**\n     * Called when the WrapperManager is signaled by the native wrapper code\n     * that it can start its application. The\n     * {@link net.sf.xbus.technical.ReceiverService} will be started.\n     *\n     * @param arg0 not used\n     * @return NULL if the <code>ReceiverService</code> have been started,\n     *         otherwise 1\n     */\n    public Integer start(String[] arg0) {\n        Thread.currentThread().setContextClassLoader(XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n        try {\n            Object obj = ReflectionSupport.createObject(\"net.sf.xbus.technical.ReceiverService\");\n            ReflectionSupport.callMethod(\"startWithoutServletEngine\", obj, null, null);\n        } catch (XException e) {\n            return new Integer(1);\n        }\n        return null;\n    }\n\n    /**\n     * Called when the application is shutting down. The\n     * {@link net.sf.xbus.technical.ReceiverService} will be stopped.\n     *\n     * @param arg0 not used\n     * @return the exit code to actually return to the OS<br>\n     *         (1 - if there are any problems during shutdown, otherwise 0).\n     */\n    public int stop(int arg0) {\n        Trace.always(\"Stopping ReceiverServiceWrapper...\");\n        try {\n            ReceiverServiceAdministratorBootstrap.shutdown();\n        } catch (XException e) {\n            return 1;\n        }\n        Trace.always(\"ReceiverServiceWrapper stopped\");\n        return 0;\n    }\n\n    /**\n     * Called whenever the native wrapper code traps a system control signal\n     * against the Java process. All signals will be ignored.\n     */\n    public void controlEvent(int arg0) {\n        Trace.info(\"ReceiverServiceWrapper received controlEvent \" + arg0);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/bootstrap/ReceiverServiceWrapperTest0.java",
		"test_prompt": "// ReceiverServiceWrapperTest0.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.tanukisoftware.wrapper.WrapperListener;\nimport org.tanukisoftware.wrapper.WrapperManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverServiceWrapper}.\n* It contains ten unit test cases for the {@link ReceiverServiceWrapper#start(String[])} method.\n*/\nclass ReceiverServiceWrapperTest0 {"
	},
	{
		"original_code": "// ReceiverServiceWrapper.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.tanukisoftware.wrapper.WrapperListener;\nimport org.tanukisoftware.wrapper.WrapperManager;\n\n/**\n * Starts the {@link net.sf.xbus.technical.ReceiverService} as a background\n * service, using the {@link net.sf.xbus.base.core.reflection.XBUSClassLoader}.\n * <p>\n * It works together with the Java Service Wrapper from Silveregg Technologies\n * to start it as a service in Windows NT, Linux or Solaris. This is an\n * open-source packages which can be found at SourceForge.\n */\npublic class ReceiverServiceWrapper implements WrapperListener {\n\n    /**\n     * Start the application. If the JVM was launched from the native Wrapper\n     * then the application will wait for the native Wrapper to call the\n     * application's start method. Otherwise the start method will be called\n     * immediately.\n     */\n    public static void main(String[] args) {\n        WrapperManager.start(new ReceiverServiceWrapper(), args);\n    }\n\n    /**\n     * Called when the WrapperManager is signaled by the native wrapper code\n     * that it can start its application. The\n     * {@link net.sf.xbus.technical.ReceiverService} will be started.\n     *\n     * @param arg0 not used\n     * @return NULL if the <code>ReceiverService</code> have been started,\n     *         otherwise 1\n     */\n    public Integer start(String[] arg0) {\n        Thread.currentThread().setContextClassLoader(XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n        try {\n            Object obj = ReflectionSupport.createObject(\"net.sf.xbus.technical.ReceiverService\");\n            ReflectionSupport.callMethod(\"startWithoutServletEngine\", obj, null, null);\n        } catch (XException e) {\n            return new Integer(1);\n        }\n        return null;\n    }\n\n    /**\n     * Called when the application is shutting down. The\n     * {@link net.sf.xbus.technical.ReceiverService} will be stopped.\n     *\n     * @param arg0 not used\n     * @return the exit code to actually return to the OS<br>\n     *         (1 - if there are any problems during shutdown, otherwise 0).\n     */\n    public int stop(int arg0) {\n        Trace.always(\"Stopping ReceiverServiceWrapper...\");\n        try {\n            ReceiverServiceAdministratorBootstrap.shutdown();\n        } catch (XException e) {\n            return 1;\n        }\n        Trace.always(\"ReceiverServiceWrapper stopped\");\n        return 0;\n    }\n\n    /**\n     * Called whenever the native wrapper code traps a system control signal\n     * against the Java process. All signals will be ignored.\n     */\n    public void controlEvent(int arg0) {\n        Trace.info(\"ReceiverServiceWrapper received controlEvent \" + arg0);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/bootstrap/ReceiverServiceWrapperTest1.java",
		"test_prompt": "// ReceiverServiceWrapperTest1.java\npackage net.sf.xbus.bootstrap;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.tanukisoftware.wrapper.WrapperListener;\nimport org.tanukisoftware.wrapper.WrapperManager;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverServiceWrapper}.\n* It contains ten unit test cases for the {@link ReceiverServiceWrapper#stop(int)} method.\n*/\nclass ReceiverServiceWrapperTest1 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin.jmx;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator implements AdministratorMBean {\n\n    net.sf.xbus.admin.Administrator admin = new net.sf.xbus.admin.Administrator();\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    public String readEtc(String source) {\n        return admin.readEtc(source);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    public String readLog(String source, int expectedLength) {\n        return admin.readLog(source, expectedLength);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    public String explainErrorcode(String key) {\n        return admin.explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#restartReceiverService()\n     */\n    public String restartReceiverService() {\n        return admin.restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    public String stopReceiverService() {\n        return admin.stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    public String getReceiverServiceStatus() {\n        return admin.getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    public String getJVMStatus() {\n        return admin.getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        return admin.demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    public String startBackgroundReceiver(String system) {\n        return admin.startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    public String getDeletedMessageFilenames() {\n        return admin.getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    public String resendDeletedMessage(String filename) {\n        return admin.resendDeletedMessage(filename);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorTest0.java",
		"test_prompt": "// AdministratorTest0.java\npackage net.sf.xbus.admin.jmx;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#readEtc(String)} method.\n*/\nclass AdministratorTest0 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin.jmx;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator implements AdministratorMBean {\n\n    net.sf.xbus.admin.Administrator admin = new net.sf.xbus.admin.Administrator();\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    public String readEtc(String source) {\n        return admin.readEtc(source);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    public String readLog(String source, int expectedLength) {\n        return admin.readLog(source, expectedLength);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    public String explainErrorcode(String key) {\n        return admin.explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#restartReceiverService()\n     */\n    public String restartReceiverService() {\n        return admin.restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    public String stopReceiverService() {\n        return admin.stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    public String getReceiverServiceStatus() {\n        return admin.getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    public String getJVMStatus() {\n        return admin.getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        return admin.demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    public String startBackgroundReceiver(String system) {\n        return admin.startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    public String getDeletedMessageFilenames() {\n        return admin.getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    public String resendDeletedMessage(String filename) {\n        return admin.resendDeletedMessage(filename);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorTest1.java",
		"test_prompt": "// AdministratorTest1.java\npackage net.sf.xbus.admin.jmx;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#readLog(String, int)} method.\n*/\nclass AdministratorTest1 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin.jmx;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator implements AdministratorMBean {\n\n    net.sf.xbus.admin.Administrator admin = new net.sf.xbus.admin.Administrator();\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    public String readEtc(String source) {\n        return admin.readEtc(source);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    public String readLog(String source, int expectedLength) {\n        return admin.readLog(source, expectedLength);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    public String explainErrorcode(String key) {\n        return admin.explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#restartReceiverService()\n     */\n    public String restartReceiverService() {\n        return admin.restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    public String stopReceiverService() {\n        return admin.stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    public String getReceiverServiceStatus() {\n        return admin.getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    public String getJVMStatus() {\n        return admin.getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        return admin.demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    public String startBackgroundReceiver(String system) {\n        return admin.startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    public String getDeletedMessageFilenames() {\n        return admin.getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    public String resendDeletedMessage(String filename) {\n        return admin.resendDeletedMessage(filename);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorTest2.java",
		"test_prompt": "// AdministratorTest2.java\npackage net.sf.xbus.admin.jmx;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#explainErrorcode(String)} method.\n*/\nclass AdministratorTest2 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin.jmx;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator implements AdministratorMBean {\n\n    net.sf.xbus.admin.Administrator admin = new net.sf.xbus.admin.Administrator();\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    public String readEtc(String source) {\n        return admin.readEtc(source);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    public String readLog(String source, int expectedLength) {\n        return admin.readLog(source, expectedLength);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    public String explainErrorcode(String key) {\n        return admin.explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#restartReceiverService()\n     */\n    public String restartReceiverService() {\n        return admin.restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    public String stopReceiverService() {\n        return admin.stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    public String getReceiverServiceStatus() {\n        return admin.getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    public String getJVMStatus() {\n        return admin.getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        return admin.demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    public String startBackgroundReceiver(String system) {\n        return admin.startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    public String getDeletedMessageFilenames() {\n        return admin.getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    public String resendDeletedMessage(String filename) {\n        return admin.resendDeletedMessage(filename);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorTest3.java",
		"test_prompt": "// AdministratorTest3.java\npackage net.sf.xbus.admin.jmx;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#restartReceiverService()} method.\n*/\nclass AdministratorTest3 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin.jmx;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator implements AdministratorMBean {\n\n    net.sf.xbus.admin.Administrator admin = new net.sf.xbus.admin.Administrator();\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    public String readEtc(String source) {\n        return admin.readEtc(source);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    public String readLog(String source, int expectedLength) {\n        return admin.readLog(source, expectedLength);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    public String explainErrorcode(String key) {\n        return admin.explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#restartReceiverService()\n     */\n    public String restartReceiverService() {\n        return admin.restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    public String stopReceiverService() {\n        return admin.stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    public String getReceiverServiceStatus() {\n        return admin.getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    public String getJVMStatus() {\n        return admin.getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        return admin.demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    public String startBackgroundReceiver(String system) {\n        return admin.startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    public String getDeletedMessageFilenames() {\n        return admin.getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    public String resendDeletedMessage(String filename) {\n        return admin.resendDeletedMessage(filename);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorTest4.java",
		"test_prompt": "// AdministratorTest4.java\npackage net.sf.xbus.admin.jmx;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#stopReceiverService()} method.\n*/\nclass AdministratorTest4 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin.jmx;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator implements AdministratorMBean {\n\n    net.sf.xbus.admin.Administrator admin = new net.sf.xbus.admin.Administrator();\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    public String readEtc(String source) {\n        return admin.readEtc(source);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    public String readLog(String source, int expectedLength) {\n        return admin.readLog(source, expectedLength);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    public String explainErrorcode(String key) {\n        return admin.explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#restartReceiverService()\n     */\n    public String restartReceiverService() {\n        return admin.restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    public String stopReceiverService() {\n        return admin.stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    public String getReceiverServiceStatus() {\n        return admin.getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    public String getJVMStatus() {\n        return admin.getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        return admin.demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    public String startBackgroundReceiver(String system) {\n        return admin.startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    public String getDeletedMessageFilenames() {\n        return admin.getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    public String resendDeletedMessage(String filename) {\n        return admin.resendDeletedMessage(filename);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorTest5.java",
		"test_prompt": "// AdministratorTest5.java\npackage net.sf.xbus.admin.jmx;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#demandStopBackgroundReceiver(String)} method.\n*/\nclass AdministratorTest5 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin.jmx;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator implements AdministratorMBean {\n\n    net.sf.xbus.admin.Administrator admin = new net.sf.xbus.admin.Administrator();\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    public String readEtc(String source) {\n        return admin.readEtc(source);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    public String readLog(String source, int expectedLength) {\n        return admin.readLog(source, expectedLength);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    public String explainErrorcode(String key) {\n        return admin.explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#restartReceiverService()\n     */\n    public String restartReceiverService() {\n        return admin.restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    public String stopReceiverService() {\n        return admin.stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    public String getReceiverServiceStatus() {\n        return admin.getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    public String getJVMStatus() {\n        return admin.getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        return admin.demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    public String startBackgroundReceiver(String system) {\n        return admin.startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    public String getDeletedMessageFilenames() {\n        return admin.getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    public String resendDeletedMessage(String filename) {\n        return admin.resendDeletedMessage(filename);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorTest6.java",
		"test_prompt": "// AdministratorTest6.java\npackage net.sf.xbus.admin.jmx;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#startBackgroundReceiver(String)} method.\n*/\nclass AdministratorTest6 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin.jmx;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator implements AdministratorMBean {\n\n    net.sf.xbus.admin.Administrator admin = new net.sf.xbus.admin.Administrator();\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    public String readEtc(String source) {\n        return admin.readEtc(source);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    public String readLog(String source, int expectedLength) {\n        return admin.readLog(source, expectedLength);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    public String explainErrorcode(String key) {\n        return admin.explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#restartReceiverService()\n     */\n    public String restartReceiverService() {\n        return admin.restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    public String stopReceiverService() {\n        return admin.stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    public String getReceiverServiceStatus() {\n        return admin.getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    public String getJVMStatus() {\n        return admin.getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        return admin.demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    public String startBackgroundReceiver(String system) {\n        return admin.startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    public String getDeletedMessageFilenames() {\n        return admin.getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    public String resendDeletedMessage(String filename) {\n        return admin.resendDeletedMessage(filename);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorTest7.java",
		"test_prompt": "// AdministratorTest7.java\npackage net.sf.xbus.admin.jmx;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#resendDeletedMessage(String)} method.\n*/\nclass AdministratorTest7 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest0.java",
		"test_prompt": "// AdministratorJMXConnectorTest0.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#readEtc(String)} method.\n*/\nclass AdministratorJMXConnectorTest0 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest1.java",
		"test_prompt": "// AdministratorJMXConnectorTest1.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#readLog(String)} method.\n*/\nclass AdministratorJMXConnectorTest1 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest2.java",
		"test_prompt": "// AdministratorJMXConnectorTest2.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#explainErrorcode(String)} method.\n*/\nclass AdministratorJMXConnectorTest2 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest3.java",
		"test_prompt": "// AdministratorJMXConnectorTest3.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#restartReceiverService()} method.\n*/\nclass AdministratorJMXConnectorTest3 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest4.java",
		"test_prompt": "// AdministratorJMXConnectorTest4.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#stopReceiverService()} method.\n*/\nclass AdministratorJMXConnectorTest4 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest5.java",
		"test_prompt": "// AdministratorJMXConnectorTest5.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#getReceiverServiceStatus()} method.\n*/\nclass AdministratorJMXConnectorTest5 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest6.java",
		"test_prompt": "// AdministratorJMXConnectorTest6.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#getJVMStatus()} method.\n*/\nclass AdministratorJMXConnectorTest6 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest7.java",
		"test_prompt": "// AdministratorJMXConnectorTest7.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#demandStopBackgroundReceiver(String)} method.\n*/\nclass AdministratorJMXConnectorTest7 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest8.java",
		"test_prompt": "// AdministratorJMXConnectorTest8.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#startBackgroundReceiver(String)} method.\n*/\nclass AdministratorJMXConnectorTest8 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest9.java",
		"test_prompt": "// AdministratorJMXConnectorTest9.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#getDeletedMessageFilenames()} method.\n*/\nclass AdministratorJMXConnectorTest9 {"
	},
	{
		"original_code": "// AdministratorJMXConnector.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Provides several services to administrate the xBus via a JMX connection.\n */\npublic class AdministratorJMXConnector {\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readEtc(String)\n     */\n    static public String readEtc(String filename) throws XException {\n        return getMBean().readEtc(filename);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#readLog(String, int)\n     */\n    static public String readLog(String filename) throws XException {\n        return getMBean().readLog(filename, 9999);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#explainErrorcode(String)\n     */\n    static public String explainErrorcode(String key) throws XException {\n        return getMBean().explainErrorcode(key);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String restartReceiverService() throws XException {\n        return getMBean().restartReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#stopReceiverService()\n     */\n    static public String stopReceiverService() throws XException {\n        return getMBean().stopReceiverService();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getReceiverServiceStatus()\n     */\n    static public String getReceiverServiceStatus() throws XException {\n        return getMBean().getReceiverServiceStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getJVMStatus()\n     */\n    static public String getJVMStatus() throws XException {\n        return getMBean().getJVMStatus();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#demandStopBackgroundReceiver(String)\n     */\n    static public String demandStopBackgroundReceiver(String system) throws XException {\n        return getMBean().demandStopBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#startBackgroundReceiver(String)\n     */\n    static public String startBackgroundReceiver(String system) throws XException {\n        return getMBean().startBackgroundReceiver(system);\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#getDeletedMessageFilenames()\n     */\n    static public String getDeletedMessageFilenames() throws XException {\n        return getMBean().getDeletedMessageFilenames();\n    }\n\n    /**\n     * @see net.sf.xbus.admin.Administrator#resendDeletedMessage(String)\n     */\n    static public String resendDeletedMessage(String system) throws XException {\n        return getMBean().resendDeletedMessage(system);\n    }\n\n    private static AdministratorMBean getMBean() throws XException {\n        try {\n            JMXServiceURL url = new JMXServiceURL(\"service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi\");\n            JMXConnector jmxc = JMXConnectorFactory.connect(url, null);\n            MBeanServerConnection mbsc = jmxc.getMBeanServerConnection();\n            ObjectName adaptor = new ObjectName(\"xBus:mbean=Administrator\");\n            AdministratorMBean mbeanProxy = JMX.newMBeanProxy(mbsc, adaptor, AdministratorMBean.class, true);\n            return mbeanProxy;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/jmx/AdministratorJMXConnectorTest10.java",
		"test_prompt": "// AdministratorJMXConnectorTest10.java\npackage net.sf.xbus.admin.jmx;\n\nimport javax.management.JMX;\nimport javax.management.MBeanServerConnection;\nimport javax.management.ObjectName;\nimport javax.management.remote.JMXConnector;\nimport javax.management.remote.JMXConnectorFactory;\nimport javax.management.remote.JMXServiceURL;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AdministratorJMXConnector}.\n* It contains ten unit test cases for the {@link AdministratorJMXConnector#resendDeletedMessage(String)} method.\n*/\nclass AdministratorJMXConnectorTest10 {"
	},
	{
		"original_code": "// ReadJournal.java\npackage net.sf.xbus.admin.html;\n\nimport java.sql.ResultSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.technical.database.DBConnection;\n\n/**\n * <code>ReadJournal</code> reads information about the activities of the\n * middleware from the database and handles the information which is stored in\n * the database-table <code>journal</code>. An instance of\n * {@link net.sf.xbus.technical.database.DBConnection} is used for handling the\n * database-connection.\n */\npublic class ReadJournal {\n\n    private int mNumber;\n\n    private char mType;\n\n    private String mSystem;\n\n    private String mFunction;\n\n    private String mMessageId;\n\n    private String mRequestMessage;\n\n    private String mRequestTimestamp;\n\n    private String mResponseMessage;\n\n    private String mResponseTimestamp;\n\n    private String mReturncode;\n\n    private int mErrorcode;\n\n    private String mErrormessage;\n\n    /**\n     * Gets the number from the journal\n     */\n    public int getNumber() {\n        return mNumber;\n    }\n\n    /**\n     * Allows you to set the number in the journal\n     */\n    public void setNumber(int number) {\n        mNumber = number;\n    }\n\n    /**\n     * Gets the type of the message from the journal\n     */\n    public char getType() {\n        return mType;\n    }\n\n    /**\n     * Allows you to set the type of the message\n     */\n    public void setType(char type) {\n        mType = type;\n    }\n\n    /**\n     * Gets the system from the journal\n     */\n    public String getSystem() {\n        return mSystem;\n    }\n\n    /**\n     * Allows you to set the system\n     */\n    public void setSystem(String system) {\n        mSystem = system;\n    }\n\n    /**\n     * Gets the function from the journal\n     */\n    public String getFunction() {\n        return mFunction;\n    }\n\n    /**\n     * Allows you to set the function\n     */\n    public void setFunction(String function) {\n        mFunction = function;\n    }\n\n    /**\n     * Gets the message id from the journal\n     */\n    public String getMessageId() {\n        return mMessageId;\n    }\n\n    /**\n     * Allows you to set the message id\n     */\n    public void setMessageId(String messageId) {\n        mMessageId = messageId;\n    }\n\n    /**\n     * Gets the request message from the journal\n     */\n    public String getRequestMessage() {\n        return mRequestMessage;\n    }\n\n    /**\n     * Allows you to set the request message\n     */\n    public void setRequestMessage(String requestMessage) {\n        mRequestMessage = requestMessage;\n    }\n\n    /**\n     * Gets the request timestamp from the journal\n     */\n    public String getRequestTimestamp() {\n        return mRequestTimestamp;\n    }\n\n    /**\n     * Allows you to set the request timestamp\n     */\n    public void setRequestTimestamp(String requestTimestamp) {\n        mRequestTimestamp = requestTimestamp;\n    }\n\n    /**\n     * Gets the response message from the journal\n     */\n    public String getResponseMessage() {\n        return mResponseMessage;\n    }\n\n    public void setResponseMessage(String responseMessage) /**\n     * Allows you to set the response message\n     */\n    {\n        mResponseMessage = responseMessage;\n    }\n\n    /**\n     * Gets the response timestamp from the journal\n     */\n    public String getResponseTimestamp() {\n        return mResponseTimestamp;\n    }\n\n    /**\n     * Allows you to set the response timestamp\n     */\n    public void setResponseTimestamp(String responseTimestamp) {\n        mResponseTimestamp = responseTimestamp;\n    }\n\n    /**\n     * Gets the return code from the journal\n     */\n    public String getReturncode() {\n        return mReturncode;\n    }\n\n    /**\n     * Allows you to set the returncode\n     */\n    public void setReturncode(String returncode) {\n        mReturncode = returncode;\n    }\n\n    /**\n     * Gets the error code from the journal\n     */\n    public int getErrorcode() {\n        return mErrorcode;\n    }\n\n    /**\n     * Allows you to set the error code\n     */\n    public void setErrorcode(int errorcode) {\n        mErrorcode = errorcode;\n    }\n\n    /**\n     * Gets the error message from the journal\n     */\n    public String getErrormessage() {\n        return mErrormessage;\n    }\n\n    /**\n     * Allows you to set the error message\n     */\n    public void setErrormessage(String errormessage) {\n        mErrormessage = errormessage;\n    }\n\n    /**\n     * <code>readSelected(HashMap, String, String)</code> builds the SQL\n     * statement, connects to the database and executes it. All data from the\n     * <code>ResultSet</code> strore erst in the <code>ReadJournal</code>\n     * object and then in the List.\n     *\n     * @param selectionMap - HashMap with items should be selected\n     * @param orderBy - String (by wich data should be ordered)\n     * @param sorting -String (descending or not)\n     * @return List with the ReadJournal objects\n     */\n    static public List readSelected(HashMap selectionMap, String orderBy, String sorting) throws XException {\n        String sqlBefehl = \"SELECT * FROM journal \";\n        if (!selectionMap.isEmpty()) {\n            sqlBefehl += \"WHERE \";\n            List keyList = new Vector();\n            keyList.addAll(selectionMap.keySet());\n            for (int i = 0; i < keyList.size(); i++) {\n                String fieldName = (String) keyList.get(i);\n                String fieldValue = (String) selectionMap.get(fieldName);\n                if (fieldName.equals(\"RequestTimeMin\")) {\n                    sqlBefehl += \"jo_request_timestamp >='\" + fieldValue + \"' \";\n                } else if (fieldName.equals(\"RequestTimeMax\")) {\n                    sqlBefehl += \"jo_request_timestamp <='\" + fieldValue + \"' \";\n                } else if (fieldName.equals(\"RequestMessage\")) {\n                    sqlBefehl += \"jo_request_message LIKE '%\" + fieldValue + \"%'\";\n                } else if (fieldName.equals(\"ResponseMessage\")) {\n                    sqlBefehl += \"jo_response_message LIKE '%\" + fieldValue + \"%'\";\n                } else if (fieldName.equals(\"Type\")) {\n                    sqlBefehl += \"jo_type ='\" + fieldValue + \"' \";\n                } else if (fieldName.equals(\"Returncode\")) {\n                    sqlBefehl += \"jo_returncode ='\" + fieldValue + \"' \";\n                } else if (fieldName.equals(\"System\")) {\n                    sqlBefehl += \"jo_system ='\" + fieldValue + \"' \";\n                } else if (fieldName.equals(\"Function\")) {\n                    sqlBefehl += \"jo_function ='\" + fieldValue + \"' \";\n                } else if (fieldName.equals(\"MessageId\")) {\n                    sqlBefehl += \"jo_message_id ='\" + fieldValue + \"' \";\n                } else {\n                    List params = new Vector();\n                    params.add(fieldName);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_ADMIN, \"3\", params);\n                }\n                if (i < (keyList.size() - 1)) {\n                    sqlBefehl += \"AND \";\n                }\n            }\n        }\n        String order;\n        if (orderBy.equals(\"Number\")) {\n            order = \"jo_id\";\n        } else if (orderBy.equals(\"Returncode\")) {\n            order = \"jo_returncode\";\n        } else if (orderBy.equals(\"System\")) {\n            order = \"jo_system\";\n        } else if (orderBy.equals(\"Function\")) {\n            order = \"jo_function\";\n        } else if (orderBy.equals(\"MessageId\")) {\n            order = \"jo_message_id\";\n        } else if (orderBy.equals(\"type\")) {\n            order = \"jo_type\";\n        } else if (orderBy.equals(\"RequestTimestamp\")) {\n            order = \"jo_request_timestamp\";\n        } else {\n            List params = new Vector();\n            params.add(orderBy);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_ADMIN, \"4\", params);\n        }\n        sqlBefehl += \"ORDER BY \" + order;\n        if (sorting.equals(\"Descending\")) {\n            sqlBefehl += \" DESC\";\n        }\n        try {\n            String dbConnectionName = Configuration.getInstance().getValueOptional(\"Base\", \"Journal\", \"DBConnection\");\n            if (dbConnectionName == null) {\n                dbConnectionName = DBConnection.UNNAMED;\n            }\n            DBConnection dbCon = DBConnection.getInstance(dbConnectionName);\n            ResultSet result = dbCon.executeRead(sqlBefehl);\n            Vector list = new Vector();\n            while (result.next()) {\n                ReadJournal journal = new ReadJournal();\n                journal.setNumber(result.getInt(\"jo_id\"));\n                if ((result.getString(\"jo_type\") == null) || (result.getString(\"jo_type\").length() == 0)) {\n                    journal.setType(' ');\n                } else {\n                    journal.setType(result.getString(\"jo_type\").charAt(0));\n                }\n                journal.setSystem(result.getString(\"jo_system\"));\n                journal.setFunction(result.getString(\"jo_function\"));\n                journal.setMessageId(result.getString(\"jo_message_id\"));\n                journal.setRequestMessage(result.getString(\"jo_request_message\"));\n                journal.setRequestTimestamp(result.getString(\"jo_request_timestamp\"));\n                journal.setResponseMessage(result.getString(\"jo_response_message\"));\n                journal.setResponseTimestamp(result.getString(\"jo_response_timestamp\"));\n                journal.setReturncode(result.getString(\"jo_returncode\"));\n                journal.setErrorcode(result.getInt(\"jo_errorcode\"));\n                journal.setErrormessage(result.getString(\"jo_errormessage\"));\n                list.add(journal);\n            }\n            return list;\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_ADMIN, \"0\", e);\n        }\n    }\n\n    /**\n     * Gets all necessary information from the journal as one String in the\n     * following format:\n     *\n     * <pre>\n     * number | messageId | function | type | system | requestTimestamp\n     * \t\t| ResponseTimestamp | Returncode\n     * </pre>\n     *\n     * @return String\n     */\n    public String toString() {\n        return mNumber + \" | \" + mMessageId + \" | \" + mFunction + \" | \" + mType + \" | \" + mSystem + \" | \" + mRequestTimestamp + \" | \" + mResponseTimestamp + \" | \" + mReturncode;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/html/ReadJournalTest.java",
		"test_prompt": "// ReadJournalTest.java\npackage net.sf.xbus.admin.html;\n\nimport java.sql.ResultSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.technical.database.DBConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReadJournal}.\n* It contains ten unit test cases for the {@link ReadJournal#readSelected(HashMap, String, String)} method.\n*/\nclass ReadJournalTest {"
	},
	{
		"original_code": "// SOAPAdministrator.java\npackage net.sf.xbus.admin.soap;\n\nimport java.net.URL;\nimport javax.xml.namespace.QName;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.apache.axis.client.Call;\nimport org.apache.axis.client.Service;\n\n/**\n * Restarts the xBus by calling a web service. The xBus must run inside a\n * servlet engine.\n */\npublic class SOAPAdministrator {\n\n    /**\n     * Restarts the xBus by calling a web service. The xBus must run inside a\n     * servlet engine.\n     *\n     * @param host the host were the xBus is running\n     * @param port the port for the web service\n     * @return a message of success or failure\n     * @throws XException if something goes wrong\n     */\n    public String restart(String host, Integer port) throws XException {\n        try {\n            String endpoint = \"http://\" + host + \":\" + port + \"/xbus/services/xBusAdministration\";\n            Service service = new Service();\n            Call call = (Call) service.createCall();\n            call.setTargetEndpointAddress(new URL(endpoint));\n            call.setOperationName(new QName(\"http://soapinterop.org/\", \"restart\"));\n            return (String) call.invoke(new Object[0]);\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_SOAP, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/soap/SOAPAdministratorTest.java",
		"test_prompt": "// SOAPAdministratorTest.java\npackage net.sf.xbus.admin.soap;\n\nimport java.net.URL;\nimport javax.xml.namespace.QName;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.apache.axis.client.Call;\nimport org.apache.axis.client.Service;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SOAPAdministrator}.\n* It contains ten unit test cases for the {@link SOAPAdministrator#restart(String, Integer)} method.\n*/\nclass SOAPAdministratorTest {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator {\n\n    /**\n     * Reads a file from <code>XBUS_HOME/etc</code>.\n     *\n     * @param filename the name of the file to read\n     * @return the content of the file or an error message\n     */\n    public String readEtc(String filename) {\n        if (filename == null) {\n            return (\"Filename must not be null.\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename.\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"Filename must not start with / or \\\\.\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_ETC + filename, 0);\n    }\n\n    /**\n     * Reads a file from <code>XBUS_HOME/log</code>.\n     *\n     * @param filename the name of the file\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    public String readLog(String filename, int maxLength) {\n        if (filename == null) {\n            return (\"Filename must not be null\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"filename must not start with / or \\\\\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_LOG + filename, maxLength);\n    }\n\n    /**\n     * Explains an errorcode.\n     *\n     * @param key the errorcode to explain\n     * @return the message of the errorcode\n     */\n    public String explainErrorcode(String key) {\n        if (key == null) {\n            return (\"Key must not be null.\");\n        }\n        String basename = \"errors\";\n        // get the decompose key\n        ASCIITokenizer test = new ASCIITokenizer(key, \"_\");\n        String Location = test.nextToken();\n        String Layer = test.nextToken();\n        String Package = test.nextToken();\n        String Number = test.nextToken();\n        // get the Message\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessageOptional(key, null);\n        // get the Location\n        String LocationInformation = null;\n        if (Location.equals(\"I\")) {\n            LocationInformation = \"Intern\";\n        } else // if (Location.equals(\"I\"))\n        if (Location.equals(\"E\")) {\n            LocationInformation = \"Extern\";\n        } else // if (Location.equals(\"E\"))\n        {\n            return \"Wrong Location\";\n        }\n        // get the Layer\n        String LayerInformation = msg.getMessageOptional(Layer, null);\n        // get the Package\n        String PackageInformation = msg.getMessageOptional(Layer + \"_\" + Package, null);\n        String informations = new StringBuffer(Location).append(\" = \").append(LocationInformation).append(Constants.LINE_SEPERATOR).append(Layer).append(\" = \").append(LayerInformation).append(Constants.LINE_SEPERATOR).append(Package).append(\" = \").append(PackageInformation).append(Constants.LINE_SEPERATOR).append(\"Number\").append(\" = \").append(Number).append(Constants.LINE_SEPERATOR).append(\"Message text\").append(\" = \").append(messageText).toString();\n        return informations;\n    }\n\n    /**\n     * Stopping all background services, refreshes the configuration and starts\n     * the background services again.\n     *\n     * @return the confirmation or an error message\n     */\n    public String restartReceiverService() {\n        try {\n            /*\n\t\t\t * Stop background receivers\n\t\t\t */\n            ReceiverService.getInstance().stopAllSystems();\n            /*\n\t\t\t * Initialize all configurations\n\t\t\t */\n            Configuration.refresh(\"standard\");\n            Configuration.refresh(\"xbus\");\n            Configuration.refresh(\"mapping\");\n            /*\n\t\t\t * Initialize XException, Trace and Journal\n\t\t\t */\n            XException.clearExceptionInformation();\n            Trace.initialize();\n            Journal.initialize();\n            /*\n\t\t\t * Clear all connections\n\t\t\t */\n            DBConnection.clear();\n            AS400Connection.clear();\n            MQConnection.clear();\n            TAManager.clear();\n            /*\n\t\t\t * Start background receivers again\n\t\t\t */\n            ReceiverService.getInstance().startAllSystems();\n            ReceiverThreadManager.getInstance().clearStoppedHTTPReceivers();\n            HTTPReceiver.initializeAmountErrorsCompletely();\n            return \"ReceiverService has been restarted and configuration has been refreshed.\";\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n    }\n\n    /**\n     * Stops the ReceiverService completely, including the JMX server.\n     *\n     * @return the confirmation or an error message\n     */\n    public String stopReceiverService() {\n        try {\n            if (!ReceiverService.getInstance().stop()) {\n                return \"ReceiverService can not be stopped\";\n            }\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n        return \"ReceiverService has been stopped\";\n    }\n\n    /**\n     * Returns lists of running, stopped and killed ReceiverThreads.\n     *\n     * @return lists of running, stopped and killed ReceiverThreads\n     */\n    public String getReceiverServiceStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        /*\n\t\t * Retrieving state of ReveiverThreads\n\t\t */\n        ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n        Set runningSystems;\n        Set allSystems;\n        try {\n            allSystems = manager.getAllSystems();\n            runningSystems = manager.getRunningSystems();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        Set stoppedSystems = manager.getStoppedSystems();\n        StringBuffer tmpBuffer = new StringBuffer();\n        retBuffer.append(\"Running Background Receivers:\\n\");\n        for (Iterator it = runningSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        retBuffer.append(\"\\n\\nStopped Background Receivers:\\n\");\n        for (Iterator it = stoppedSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        String system = null;\n        retBuffer.append(\"\\n\\nKilled Background Receivers:\\n\");\n        for (Iterator it = allSystems.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            if ((!runningSystems.contains(system)) && (!stoppedSystems.contains(system))) {\n                tmpBuffer.append(\"\\n\").append(it.next());\n            }\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        if (ReceiverService.getInstance().isWatchdogRunning()) {\n            retBuffer.append(\"\\n\\nWatchdog is running\");\n        } else {\n            retBuffer.append(\"\\n\\nWatchdog is NOT running !!!\");\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Returns some information about the state of the Java Virtual Machine,\n     * containing memory consumption and information about the environment.\n     *\n     * @return some information about the state of the Java Virtual Machine\n     */\n    public String getJVMStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        retBuffer.append(\"Resources:\");\n        Runtime runtime = Runtime.getRuntime();\n        runtime.gc();\n        retBuffer.append(\"\\n\\nMaximum memory available:        \" + NumberFormat.getInstance().format(runtime.maxMemory()) + \" bytes\");\n        retBuffer.append(\"\\nMemory currently used:           \" + NumberFormat.getInstance().format(runtime.totalMemory()) + \" bytes\");\n        retBuffer.append(\"\\nFree memory currently available: \" + NumberFormat.getInstance().format(runtime.freeMemory()) + \" bytes\");\n        retBuffer.append(\"\\nAvailable processors:            \" + runtime.availableProcessors());\n        retBuffer.append(\"\\n\\nEnvironment:\\n\");\n        TreeSet envKeys = new TreeSet(System.getProperties().keySet());\n        String key = null;\n        for (Iterator it = envKeys.iterator(); it.hasNext(); ) {\n            key = (String) it.next();\n            retBuffer.append(\"\\n\" + key + \"=\" + System.getProperty(key));\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Demands the stop of a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a started background receiver\").toString();\n            }\n            manager.demandStopReceiverThread(system);\n            return \"Stop for background receiver \" + system + \" demanded\";\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Starts a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String startBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getAllSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a configured configured background receiver\").toString();\n            }\n            if (manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is already started\").toString();\n            }\n            manager.startReceiverThread(system);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        return \"Background receiver \" + system + \" started\";\n    }\n\n    /**\n     * Reads the filenames that are currently in the Deleted Message Store.\n     *\n     * @return the filenames that are currently in the Deleted Message Store\n     */\n    public String getDeletedMessageFilenames() {\n        try {\n            String[] filenames = DeletedMessageStore.getDeletedMessageFilenames();\n            StringBuffer retBuffer = new StringBuffer();\n            for (int i = 0; i < filenames.length; i++) {\n                retBuffer.append(filenames[i]).append(Constants.LINE_SEPERATOR);\n            }\n            return retBuffer.toString();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Resends a message from the Deleted Message Store\n     *\n     * @param filename the filename of the deleted message\n     * @return a message of success or failure\n     */\n    public String resendDeletedMessage(String filename) {\n        return DeletedMessageStore.resendDeletedMessage(filename);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename the name of the file including the directory\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    private String readFile(String filename, int maxLength) {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        try {\n            BufferedReader buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n            buffReader.close();\n        } catch (IOException e) {\n            return XException.getExceptionInformation();\n        }\n        if (maxLength > 0) {\n            int bufferLength = retBuffer.length();\n            int endLength = bufferLength - maxLength * 1024;\n            retBuffer.delete(0, endLength);\n        }\n        // if (expectedLength > 0)\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/AdministratorTest0.java",
		"test_prompt": "// AdministratorTest0.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#readEtc(String)} method.\n*/\nclass AdministratorTest0 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator {\n\n    /**\n     * Reads a file from <code>XBUS_HOME/etc</code>.\n     *\n     * @param filename the name of the file to read\n     * @return the content of the file or an error message\n     */\n    public String readEtc(String filename) {\n        if (filename == null) {\n            return (\"Filename must not be null.\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename.\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"Filename must not start with / or \\\\.\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_ETC + filename, 0);\n    }\n\n    /**\n     * Reads a file from <code>XBUS_HOME/log</code>.\n     *\n     * @param filename the name of the file\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    public String readLog(String filename, int maxLength) {\n        if (filename == null) {\n            return (\"Filename must not be null\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"filename must not start with / or \\\\\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_LOG + filename, maxLength);\n    }\n\n    /**\n     * Explains an errorcode.\n     *\n     * @param key the errorcode to explain\n     * @return the message of the errorcode\n     */\n    public String explainErrorcode(String key) {\n        if (key == null) {\n            return (\"Key must not be null.\");\n        }\n        String basename = \"errors\";\n        // get the decompose key\n        ASCIITokenizer test = new ASCIITokenizer(key, \"_\");\n        String Location = test.nextToken();\n        String Layer = test.nextToken();\n        String Package = test.nextToken();\n        String Number = test.nextToken();\n        // get the Message\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessageOptional(key, null);\n        // get the Location\n        String LocationInformation = null;\n        if (Location.equals(\"I\")) {\n            LocationInformation = \"Intern\";\n        } else // if (Location.equals(\"I\"))\n        if (Location.equals(\"E\")) {\n            LocationInformation = \"Extern\";\n        } else // if (Location.equals(\"E\"))\n        {\n            return \"Wrong Location\";\n        }\n        // get the Layer\n        String LayerInformation = msg.getMessageOptional(Layer, null);\n        // get the Package\n        String PackageInformation = msg.getMessageOptional(Layer + \"_\" + Package, null);\n        String informations = new StringBuffer(Location).append(\" = \").append(LocationInformation).append(Constants.LINE_SEPERATOR).append(Layer).append(\" = \").append(LayerInformation).append(Constants.LINE_SEPERATOR).append(Package).append(\" = \").append(PackageInformation).append(Constants.LINE_SEPERATOR).append(\"Number\").append(\" = \").append(Number).append(Constants.LINE_SEPERATOR).append(\"Message text\").append(\" = \").append(messageText).toString();\n        return informations;\n    }\n\n    /**\n     * Stopping all background services, refreshes the configuration and starts\n     * the background services again.\n     *\n     * @return the confirmation or an error message\n     */\n    public String restartReceiverService() {\n        try {\n            /*\n\t\t\t * Stop background receivers\n\t\t\t */\n            ReceiverService.getInstance().stopAllSystems();\n            /*\n\t\t\t * Initialize all configurations\n\t\t\t */\n            Configuration.refresh(\"standard\");\n            Configuration.refresh(\"xbus\");\n            Configuration.refresh(\"mapping\");\n            /*\n\t\t\t * Initialize XException, Trace and Journal\n\t\t\t */\n            XException.clearExceptionInformation();\n            Trace.initialize();\n            Journal.initialize();\n            /*\n\t\t\t * Clear all connections\n\t\t\t */\n            DBConnection.clear();\n            AS400Connection.clear();\n            MQConnection.clear();\n            TAManager.clear();\n            /*\n\t\t\t * Start background receivers again\n\t\t\t */\n            ReceiverService.getInstance().startAllSystems();\n            ReceiverThreadManager.getInstance().clearStoppedHTTPReceivers();\n            HTTPReceiver.initializeAmountErrorsCompletely();\n            return \"ReceiverService has been restarted and configuration has been refreshed.\";\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n    }\n\n    /**\n     * Stops the ReceiverService completely, including the JMX server.\n     *\n     * @return the confirmation or an error message\n     */\n    public String stopReceiverService() {\n        try {\n            if (!ReceiverService.getInstance().stop()) {\n                return \"ReceiverService can not be stopped\";\n            }\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n        return \"ReceiverService has been stopped\";\n    }\n\n    /**\n     * Returns lists of running, stopped and killed ReceiverThreads.\n     *\n     * @return lists of running, stopped and killed ReceiverThreads\n     */\n    public String getReceiverServiceStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        /*\n\t\t * Retrieving state of ReveiverThreads\n\t\t */\n        ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n        Set runningSystems;\n        Set allSystems;\n        try {\n            allSystems = manager.getAllSystems();\n            runningSystems = manager.getRunningSystems();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        Set stoppedSystems = manager.getStoppedSystems();\n        StringBuffer tmpBuffer = new StringBuffer();\n        retBuffer.append(\"Running Background Receivers:\\n\");\n        for (Iterator it = runningSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        retBuffer.append(\"\\n\\nStopped Background Receivers:\\n\");\n        for (Iterator it = stoppedSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        String system = null;\n        retBuffer.append(\"\\n\\nKilled Background Receivers:\\n\");\n        for (Iterator it = allSystems.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            if ((!runningSystems.contains(system)) && (!stoppedSystems.contains(system))) {\n                tmpBuffer.append(\"\\n\").append(it.next());\n            }\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        if (ReceiverService.getInstance().isWatchdogRunning()) {\n            retBuffer.append(\"\\n\\nWatchdog is running\");\n        } else {\n            retBuffer.append(\"\\n\\nWatchdog is NOT running !!!\");\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Returns some information about the state of the Java Virtual Machine,\n     * containing memory consumption and information about the environment.\n     *\n     * @return some information about the state of the Java Virtual Machine\n     */\n    public String getJVMStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        retBuffer.append(\"Resources:\");\n        Runtime runtime = Runtime.getRuntime();\n        runtime.gc();\n        retBuffer.append(\"\\n\\nMaximum memory available:        \" + NumberFormat.getInstance().format(runtime.maxMemory()) + \" bytes\");\n        retBuffer.append(\"\\nMemory currently used:           \" + NumberFormat.getInstance().format(runtime.totalMemory()) + \" bytes\");\n        retBuffer.append(\"\\nFree memory currently available: \" + NumberFormat.getInstance().format(runtime.freeMemory()) + \" bytes\");\n        retBuffer.append(\"\\nAvailable processors:            \" + runtime.availableProcessors());\n        retBuffer.append(\"\\n\\nEnvironment:\\n\");\n        TreeSet envKeys = new TreeSet(System.getProperties().keySet());\n        String key = null;\n        for (Iterator it = envKeys.iterator(); it.hasNext(); ) {\n            key = (String) it.next();\n            retBuffer.append(\"\\n\" + key + \"=\" + System.getProperty(key));\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Demands the stop of a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a started background receiver\").toString();\n            }\n            manager.demandStopReceiverThread(system);\n            return \"Stop for background receiver \" + system + \" demanded\";\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Starts a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String startBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getAllSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a configured configured background receiver\").toString();\n            }\n            if (manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is already started\").toString();\n            }\n            manager.startReceiverThread(system);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        return \"Background receiver \" + system + \" started\";\n    }\n\n    /**\n     * Reads the filenames that are currently in the Deleted Message Store.\n     *\n     * @return the filenames that are currently in the Deleted Message Store\n     */\n    public String getDeletedMessageFilenames() {\n        try {\n            String[] filenames = DeletedMessageStore.getDeletedMessageFilenames();\n            StringBuffer retBuffer = new StringBuffer();\n            for (int i = 0; i < filenames.length; i++) {\n                retBuffer.append(filenames[i]).append(Constants.LINE_SEPERATOR);\n            }\n            return retBuffer.toString();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Resends a message from the Deleted Message Store\n     *\n     * @param filename the filename of the deleted message\n     * @return a message of success or failure\n     */\n    public String resendDeletedMessage(String filename) {\n        return DeletedMessageStore.resendDeletedMessage(filename);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename the name of the file including the directory\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    private String readFile(String filename, int maxLength) {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        try {\n            BufferedReader buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n            buffReader.close();\n        } catch (IOException e) {\n            return XException.getExceptionInformation();\n        }\n        if (maxLength > 0) {\n            int bufferLength = retBuffer.length();\n            int endLength = bufferLength - maxLength * 1024;\n            retBuffer.delete(0, endLength);\n        }\n        // if (expectedLength > 0)\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/AdministratorTest1.java",
		"test_prompt": "// AdministratorTest1.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#readLog(String, int)} method.\n*/\nclass AdministratorTest1 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator {\n\n    /**\n     * Reads a file from <code>XBUS_HOME/etc</code>.\n     *\n     * @param filename the name of the file to read\n     * @return the content of the file or an error message\n     */\n    public String readEtc(String filename) {\n        if (filename == null) {\n            return (\"Filename must not be null.\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename.\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"Filename must not start with / or \\\\.\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_ETC + filename, 0);\n    }\n\n    /**\n     * Reads a file from <code>XBUS_HOME/log</code>.\n     *\n     * @param filename the name of the file\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    public String readLog(String filename, int maxLength) {\n        if (filename == null) {\n            return (\"Filename must not be null\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"filename must not start with / or \\\\\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_LOG + filename, maxLength);\n    }\n\n    /**\n     * Explains an errorcode.\n     *\n     * @param key the errorcode to explain\n     * @return the message of the errorcode\n     */\n    public String explainErrorcode(String key) {\n        if (key == null) {\n            return (\"Key must not be null.\");\n        }\n        String basename = \"errors\";\n        // get the decompose key\n        ASCIITokenizer test = new ASCIITokenizer(key, \"_\");\n        String Location = test.nextToken();\n        String Layer = test.nextToken();\n        String Package = test.nextToken();\n        String Number = test.nextToken();\n        // get the Message\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessageOptional(key, null);\n        // get the Location\n        String LocationInformation = null;\n        if (Location.equals(\"I\")) {\n            LocationInformation = \"Intern\";\n        } else // if (Location.equals(\"I\"))\n        if (Location.equals(\"E\")) {\n            LocationInformation = \"Extern\";\n        } else // if (Location.equals(\"E\"))\n        {\n            return \"Wrong Location\";\n        }\n        // get the Layer\n        String LayerInformation = msg.getMessageOptional(Layer, null);\n        // get the Package\n        String PackageInformation = msg.getMessageOptional(Layer + \"_\" + Package, null);\n        String informations = new StringBuffer(Location).append(\" = \").append(LocationInformation).append(Constants.LINE_SEPERATOR).append(Layer).append(\" = \").append(LayerInformation).append(Constants.LINE_SEPERATOR).append(Package).append(\" = \").append(PackageInformation).append(Constants.LINE_SEPERATOR).append(\"Number\").append(\" = \").append(Number).append(Constants.LINE_SEPERATOR).append(\"Message text\").append(\" = \").append(messageText).toString();\n        return informations;\n    }\n\n    /**\n     * Stopping all background services, refreshes the configuration and starts\n     * the background services again.\n     *\n     * @return the confirmation or an error message\n     */\n    public String restartReceiverService() {\n        try {\n            /*\n\t\t\t * Stop background receivers\n\t\t\t */\n            ReceiverService.getInstance().stopAllSystems();\n            /*\n\t\t\t * Initialize all configurations\n\t\t\t */\n            Configuration.refresh(\"standard\");\n            Configuration.refresh(\"xbus\");\n            Configuration.refresh(\"mapping\");\n            /*\n\t\t\t * Initialize XException, Trace and Journal\n\t\t\t */\n            XException.clearExceptionInformation();\n            Trace.initialize();\n            Journal.initialize();\n            /*\n\t\t\t * Clear all connections\n\t\t\t */\n            DBConnection.clear();\n            AS400Connection.clear();\n            MQConnection.clear();\n            TAManager.clear();\n            /*\n\t\t\t * Start background receivers again\n\t\t\t */\n            ReceiverService.getInstance().startAllSystems();\n            ReceiverThreadManager.getInstance().clearStoppedHTTPReceivers();\n            HTTPReceiver.initializeAmountErrorsCompletely();\n            return \"ReceiverService has been restarted and configuration has been refreshed.\";\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n    }\n\n    /**\n     * Stops the ReceiverService completely, including the JMX server.\n     *\n     * @return the confirmation or an error message\n     */\n    public String stopReceiverService() {\n        try {\n            if (!ReceiverService.getInstance().stop()) {\n                return \"ReceiverService can not be stopped\";\n            }\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n        return \"ReceiverService has been stopped\";\n    }\n\n    /**\n     * Returns lists of running, stopped and killed ReceiverThreads.\n     *\n     * @return lists of running, stopped and killed ReceiverThreads\n     */\n    public String getReceiverServiceStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        /*\n\t\t * Retrieving state of ReveiverThreads\n\t\t */\n        ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n        Set runningSystems;\n        Set allSystems;\n        try {\n            allSystems = manager.getAllSystems();\n            runningSystems = manager.getRunningSystems();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        Set stoppedSystems = manager.getStoppedSystems();\n        StringBuffer tmpBuffer = new StringBuffer();\n        retBuffer.append(\"Running Background Receivers:\\n\");\n        for (Iterator it = runningSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        retBuffer.append(\"\\n\\nStopped Background Receivers:\\n\");\n        for (Iterator it = stoppedSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        String system = null;\n        retBuffer.append(\"\\n\\nKilled Background Receivers:\\n\");\n        for (Iterator it = allSystems.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            if ((!runningSystems.contains(system)) && (!stoppedSystems.contains(system))) {\n                tmpBuffer.append(\"\\n\").append(it.next());\n            }\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        if (ReceiverService.getInstance().isWatchdogRunning()) {\n            retBuffer.append(\"\\n\\nWatchdog is running\");\n        } else {\n            retBuffer.append(\"\\n\\nWatchdog is NOT running !!!\");\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Returns some information about the state of the Java Virtual Machine,\n     * containing memory consumption and information about the environment.\n     *\n     * @return some information about the state of the Java Virtual Machine\n     */\n    public String getJVMStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        retBuffer.append(\"Resources:\");\n        Runtime runtime = Runtime.getRuntime();\n        runtime.gc();\n        retBuffer.append(\"\\n\\nMaximum memory available:        \" + NumberFormat.getInstance().format(runtime.maxMemory()) + \" bytes\");\n        retBuffer.append(\"\\nMemory currently used:           \" + NumberFormat.getInstance().format(runtime.totalMemory()) + \" bytes\");\n        retBuffer.append(\"\\nFree memory currently available: \" + NumberFormat.getInstance().format(runtime.freeMemory()) + \" bytes\");\n        retBuffer.append(\"\\nAvailable processors:            \" + runtime.availableProcessors());\n        retBuffer.append(\"\\n\\nEnvironment:\\n\");\n        TreeSet envKeys = new TreeSet(System.getProperties().keySet());\n        String key = null;\n        for (Iterator it = envKeys.iterator(); it.hasNext(); ) {\n            key = (String) it.next();\n            retBuffer.append(\"\\n\" + key + \"=\" + System.getProperty(key));\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Demands the stop of a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a started background receiver\").toString();\n            }\n            manager.demandStopReceiverThread(system);\n            return \"Stop for background receiver \" + system + \" demanded\";\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Starts a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String startBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getAllSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a configured configured background receiver\").toString();\n            }\n            if (manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is already started\").toString();\n            }\n            manager.startReceiverThread(system);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        return \"Background receiver \" + system + \" started\";\n    }\n\n    /**\n     * Reads the filenames that are currently in the Deleted Message Store.\n     *\n     * @return the filenames that are currently in the Deleted Message Store\n     */\n    public String getDeletedMessageFilenames() {\n        try {\n            String[] filenames = DeletedMessageStore.getDeletedMessageFilenames();\n            StringBuffer retBuffer = new StringBuffer();\n            for (int i = 0; i < filenames.length; i++) {\n                retBuffer.append(filenames[i]).append(Constants.LINE_SEPERATOR);\n            }\n            return retBuffer.toString();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Resends a message from the Deleted Message Store\n     *\n     * @param filename the filename of the deleted message\n     * @return a message of success or failure\n     */\n    public String resendDeletedMessage(String filename) {\n        return DeletedMessageStore.resendDeletedMessage(filename);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename the name of the file including the directory\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    private String readFile(String filename, int maxLength) {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        try {\n            BufferedReader buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n            buffReader.close();\n        } catch (IOException e) {\n            return XException.getExceptionInformation();\n        }\n        if (maxLength > 0) {\n            int bufferLength = retBuffer.length();\n            int endLength = bufferLength - maxLength * 1024;\n            retBuffer.delete(0, endLength);\n        }\n        // if (expectedLength > 0)\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/AdministratorTest2.java",
		"test_prompt": "// AdministratorTest2.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#explainErrorcode(String)} method.\n*/\nclass AdministratorTest2 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator {\n\n    /**\n     * Reads a file from <code>XBUS_HOME/etc</code>.\n     *\n     * @param filename the name of the file to read\n     * @return the content of the file or an error message\n     */\n    public String readEtc(String filename) {\n        if (filename == null) {\n            return (\"Filename must not be null.\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename.\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"Filename must not start with / or \\\\.\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_ETC + filename, 0);\n    }\n\n    /**\n     * Reads a file from <code>XBUS_HOME/log</code>.\n     *\n     * @param filename the name of the file\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    public String readLog(String filename, int maxLength) {\n        if (filename == null) {\n            return (\"Filename must not be null\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"filename must not start with / or \\\\\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_LOG + filename, maxLength);\n    }\n\n    /**\n     * Explains an errorcode.\n     *\n     * @param key the errorcode to explain\n     * @return the message of the errorcode\n     */\n    public String explainErrorcode(String key) {\n        if (key == null) {\n            return (\"Key must not be null.\");\n        }\n        String basename = \"errors\";\n        // get the decompose key\n        ASCIITokenizer test = new ASCIITokenizer(key, \"_\");\n        String Location = test.nextToken();\n        String Layer = test.nextToken();\n        String Package = test.nextToken();\n        String Number = test.nextToken();\n        // get the Message\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessageOptional(key, null);\n        // get the Location\n        String LocationInformation = null;\n        if (Location.equals(\"I\")) {\n            LocationInformation = \"Intern\";\n        } else // if (Location.equals(\"I\"))\n        if (Location.equals(\"E\")) {\n            LocationInformation = \"Extern\";\n        } else // if (Location.equals(\"E\"))\n        {\n            return \"Wrong Location\";\n        }\n        // get the Layer\n        String LayerInformation = msg.getMessageOptional(Layer, null);\n        // get the Package\n        String PackageInformation = msg.getMessageOptional(Layer + \"_\" + Package, null);\n        String informations = new StringBuffer(Location).append(\" = \").append(LocationInformation).append(Constants.LINE_SEPERATOR).append(Layer).append(\" = \").append(LayerInformation).append(Constants.LINE_SEPERATOR).append(Package).append(\" = \").append(PackageInformation).append(Constants.LINE_SEPERATOR).append(\"Number\").append(\" = \").append(Number).append(Constants.LINE_SEPERATOR).append(\"Message text\").append(\" = \").append(messageText).toString();\n        return informations;\n    }\n\n    /**\n     * Stopping all background services, refreshes the configuration and starts\n     * the background services again.\n     *\n     * @return the confirmation or an error message\n     */\n    public String restartReceiverService() {\n        try {\n            /*\n\t\t\t * Stop background receivers\n\t\t\t */\n            ReceiverService.getInstance().stopAllSystems();\n            /*\n\t\t\t * Initialize all configurations\n\t\t\t */\n            Configuration.refresh(\"standard\");\n            Configuration.refresh(\"xbus\");\n            Configuration.refresh(\"mapping\");\n            /*\n\t\t\t * Initialize XException, Trace and Journal\n\t\t\t */\n            XException.clearExceptionInformation();\n            Trace.initialize();\n            Journal.initialize();\n            /*\n\t\t\t * Clear all connections\n\t\t\t */\n            DBConnection.clear();\n            AS400Connection.clear();\n            MQConnection.clear();\n            TAManager.clear();\n            /*\n\t\t\t * Start background receivers again\n\t\t\t */\n            ReceiverService.getInstance().startAllSystems();\n            ReceiverThreadManager.getInstance().clearStoppedHTTPReceivers();\n            HTTPReceiver.initializeAmountErrorsCompletely();\n            return \"ReceiverService has been restarted and configuration has been refreshed.\";\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n    }\n\n    /**\n     * Stops the ReceiverService completely, including the JMX server.\n     *\n     * @return the confirmation or an error message\n     */\n    public String stopReceiverService() {\n        try {\n            if (!ReceiverService.getInstance().stop()) {\n                return \"ReceiverService can not be stopped\";\n            }\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n        return \"ReceiverService has been stopped\";\n    }\n\n    /**\n     * Returns lists of running, stopped and killed ReceiverThreads.\n     *\n     * @return lists of running, stopped and killed ReceiverThreads\n     */\n    public String getReceiverServiceStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        /*\n\t\t * Retrieving state of ReveiverThreads\n\t\t */\n        ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n        Set runningSystems;\n        Set allSystems;\n        try {\n            allSystems = manager.getAllSystems();\n            runningSystems = manager.getRunningSystems();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        Set stoppedSystems = manager.getStoppedSystems();\n        StringBuffer tmpBuffer = new StringBuffer();\n        retBuffer.append(\"Running Background Receivers:\\n\");\n        for (Iterator it = runningSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        retBuffer.append(\"\\n\\nStopped Background Receivers:\\n\");\n        for (Iterator it = stoppedSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        String system = null;\n        retBuffer.append(\"\\n\\nKilled Background Receivers:\\n\");\n        for (Iterator it = allSystems.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            if ((!runningSystems.contains(system)) && (!stoppedSystems.contains(system))) {\n                tmpBuffer.append(\"\\n\").append(it.next());\n            }\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        if (ReceiverService.getInstance().isWatchdogRunning()) {\n            retBuffer.append(\"\\n\\nWatchdog is running\");\n        } else {\n            retBuffer.append(\"\\n\\nWatchdog is NOT running !!!\");\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Returns some information about the state of the Java Virtual Machine,\n     * containing memory consumption and information about the environment.\n     *\n     * @return some information about the state of the Java Virtual Machine\n     */\n    public String getJVMStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        retBuffer.append(\"Resources:\");\n        Runtime runtime = Runtime.getRuntime();\n        runtime.gc();\n        retBuffer.append(\"\\n\\nMaximum memory available:        \" + NumberFormat.getInstance().format(runtime.maxMemory()) + \" bytes\");\n        retBuffer.append(\"\\nMemory currently used:           \" + NumberFormat.getInstance().format(runtime.totalMemory()) + \" bytes\");\n        retBuffer.append(\"\\nFree memory currently available: \" + NumberFormat.getInstance().format(runtime.freeMemory()) + \" bytes\");\n        retBuffer.append(\"\\nAvailable processors:            \" + runtime.availableProcessors());\n        retBuffer.append(\"\\n\\nEnvironment:\\n\");\n        TreeSet envKeys = new TreeSet(System.getProperties().keySet());\n        String key = null;\n        for (Iterator it = envKeys.iterator(); it.hasNext(); ) {\n            key = (String) it.next();\n            retBuffer.append(\"\\n\" + key + \"=\" + System.getProperty(key));\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Demands the stop of a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a started background receiver\").toString();\n            }\n            manager.demandStopReceiverThread(system);\n            return \"Stop for background receiver \" + system + \" demanded\";\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Starts a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String startBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getAllSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a configured configured background receiver\").toString();\n            }\n            if (manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is already started\").toString();\n            }\n            manager.startReceiverThread(system);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        return \"Background receiver \" + system + \" started\";\n    }\n\n    /**\n     * Reads the filenames that are currently in the Deleted Message Store.\n     *\n     * @return the filenames that are currently in the Deleted Message Store\n     */\n    public String getDeletedMessageFilenames() {\n        try {\n            String[] filenames = DeletedMessageStore.getDeletedMessageFilenames();\n            StringBuffer retBuffer = new StringBuffer();\n            for (int i = 0; i < filenames.length; i++) {\n                retBuffer.append(filenames[i]).append(Constants.LINE_SEPERATOR);\n            }\n            return retBuffer.toString();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Resends a message from the Deleted Message Store\n     *\n     * @param filename the filename of the deleted message\n     * @return a message of success or failure\n     */\n    public String resendDeletedMessage(String filename) {\n        return DeletedMessageStore.resendDeletedMessage(filename);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename the name of the file including the directory\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    private String readFile(String filename, int maxLength) {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        try {\n            BufferedReader buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n            buffReader.close();\n        } catch (IOException e) {\n            return XException.getExceptionInformation();\n        }\n        if (maxLength > 0) {\n            int bufferLength = retBuffer.length();\n            int endLength = bufferLength - maxLength * 1024;\n            retBuffer.delete(0, endLength);\n        }\n        // if (expectedLength > 0)\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/AdministratorTest3.java",
		"test_prompt": "// AdministratorTest3.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#restartReceiverService()} method.\n*/\nclass AdministratorTest3 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator {\n\n    /**\n     * Reads a file from <code>XBUS_HOME/etc</code>.\n     *\n     * @param filename the name of the file to read\n     * @return the content of the file or an error message\n     */\n    public String readEtc(String filename) {\n        if (filename == null) {\n            return (\"Filename must not be null.\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename.\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"Filename must not start with / or \\\\.\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_ETC + filename, 0);\n    }\n\n    /**\n     * Reads a file from <code>XBUS_HOME/log</code>.\n     *\n     * @param filename the name of the file\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    public String readLog(String filename, int maxLength) {\n        if (filename == null) {\n            return (\"Filename must not be null\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"filename must not start with / or \\\\\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_LOG + filename, maxLength);\n    }\n\n    /**\n     * Explains an errorcode.\n     *\n     * @param key the errorcode to explain\n     * @return the message of the errorcode\n     */\n    public String explainErrorcode(String key) {\n        if (key == null) {\n            return (\"Key must not be null.\");\n        }\n        String basename = \"errors\";\n        // get the decompose key\n        ASCIITokenizer test = new ASCIITokenizer(key, \"_\");\n        String Location = test.nextToken();\n        String Layer = test.nextToken();\n        String Package = test.nextToken();\n        String Number = test.nextToken();\n        // get the Message\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessageOptional(key, null);\n        // get the Location\n        String LocationInformation = null;\n        if (Location.equals(\"I\")) {\n            LocationInformation = \"Intern\";\n        } else // if (Location.equals(\"I\"))\n        if (Location.equals(\"E\")) {\n            LocationInformation = \"Extern\";\n        } else // if (Location.equals(\"E\"))\n        {\n            return \"Wrong Location\";\n        }\n        // get the Layer\n        String LayerInformation = msg.getMessageOptional(Layer, null);\n        // get the Package\n        String PackageInformation = msg.getMessageOptional(Layer + \"_\" + Package, null);\n        String informations = new StringBuffer(Location).append(\" = \").append(LocationInformation).append(Constants.LINE_SEPERATOR).append(Layer).append(\" = \").append(LayerInformation).append(Constants.LINE_SEPERATOR).append(Package).append(\" = \").append(PackageInformation).append(Constants.LINE_SEPERATOR).append(\"Number\").append(\" = \").append(Number).append(Constants.LINE_SEPERATOR).append(\"Message text\").append(\" = \").append(messageText).toString();\n        return informations;\n    }\n\n    /**\n     * Stopping all background services, refreshes the configuration and starts\n     * the background services again.\n     *\n     * @return the confirmation or an error message\n     */\n    public String restartReceiverService() {\n        try {\n            /*\n\t\t\t * Stop background receivers\n\t\t\t */\n            ReceiverService.getInstance().stopAllSystems();\n            /*\n\t\t\t * Initialize all configurations\n\t\t\t */\n            Configuration.refresh(\"standard\");\n            Configuration.refresh(\"xbus\");\n            Configuration.refresh(\"mapping\");\n            /*\n\t\t\t * Initialize XException, Trace and Journal\n\t\t\t */\n            XException.clearExceptionInformation();\n            Trace.initialize();\n            Journal.initialize();\n            /*\n\t\t\t * Clear all connections\n\t\t\t */\n            DBConnection.clear();\n            AS400Connection.clear();\n            MQConnection.clear();\n            TAManager.clear();\n            /*\n\t\t\t * Start background receivers again\n\t\t\t */\n            ReceiverService.getInstance().startAllSystems();\n            ReceiverThreadManager.getInstance().clearStoppedHTTPReceivers();\n            HTTPReceiver.initializeAmountErrorsCompletely();\n            return \"ReceiverService has been restarted and configuration has been refreshed.\";\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n    }\n\n    /**\n     * Stops the ReceiverService completely, including the JMX server.\n     *\n     * @return the confirmation or an error message\n     */\n    public String stopReceiverService() {\n        try {\n            if (!ReceiverService.getInstance().stop()) {\n                return \"ReceiverService can not be stopped\";\n            }\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n        return \"ReceiverService has been stopped\";\n    }\n\n    /**\n     * Returns lists of running, stopped and killed ReceiverThreads.\n     *\n     * @return lists of running, stopped and killed ReceiverThreads\n     */\n    public String getReceiverServiceStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        /*\n\t\t * Retrieving state of ReveiverThreads\n\t\t */\n        ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n        Set runningSystems;\n        Set allSystems;\n        try {\n            allSystems = manager.getAllSystems();\n            runningSystems = manager.getRunningSystems();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        Set stoppedSystems = manager.getStoppedSystems();\n        StringBuffer tmpBuffer = new StringBuffer();\n        retBuffer.append(\"Running Background Receivers:\\n\");\n        for (Iterator it = runningSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        retBuffer.append(\"\\n\\nStopped Background Receivers:\\n\");\n        for (Iterator it = stoppedSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        String system = null;\n        retBuffer.append(\"\\n\\nKilled Background Receivers:\\n\");\n        for (Iterator it = allSystems.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            if ((!runningSystems.contains(system)) && (!stoppedSystems.contains(system))) {\n                tmpBuffer.append(\"\\n\").append(it.next());\n            }\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        if (ReceiverService.getInstance().isWatchdogRunning()) {\n            retBuffer.append(\"\\n\\nWatchdog is running\");\n        } else {\n            retBuffer.append(\"\\n\\nWatchdog is NOT running !!!\");\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Returns some information about the state of the Java Virtual Machine,\n     * containing memory consumption and information about the environment.\n     *\n     * @return some information about the state of the Java Virtual Machine\n     */\n    public String getJVMStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        retBuffer.append(\"Resources:\");\n        Runtime runtime = Runtime.getRuntime();\n        runtime.gc();\n        retBuffer.append(\"\\n\\nMaximum memory available:        \" + NumberFormat.getInstance().format(runtime.maxMemory()) + \" bytes\");\n        retBuffer.append(\"\\nMemory currently used:           \" + NumberFormat.getInstance().format(runtime.totalMemory()) + \" bytes\");\n        retBuffer.append(\"\\nFree memory currently available: \" + NumberFormat.getInstance().format(runtime.freeMemory()) + \" bytes\");\n        retBuffer.append(\"\\nAvailable processors:            \" + runtime.availableProcessors());\n        retBuffer.append(\"\\n\\nEnvironment:\\n\");\n        TreeSet envKeys = new TreeSet(System.getProperties().keySet());\n        String key = null;\n        for (Iterator it = envKeys.iterator(); it.hasNext(); ) {\n            key = (String) it.next();\n            retBuffer.append(\"\\n\" + key + \"=\" + System.getProperty(key));\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Demands the stop of a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a started background receiver\").toString();\n            }\n            manager.demandStopReceiverThread(system);\n            return \"Stop for background receiver \" + system + \" demanded\";\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Starts a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String startBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getAllSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a configured configured background receiver\").toString();\n            }\n            if (manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is already started\").toString();\n            }\n            manager.startReceiverThread(system);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        return \"Background receiver \" + system + \" started\";\n    }\n\n    /**\n     * Reads the filenames that are currently in the Deleted Message Store.\n     *\n     * @return the filenames that are currently in the Deleted Message Store\n     */\n    public String getDeletedMessageFilenames() {\n        try {\n            String[] filenames = DeletedMessageStore.getDeletedMessageFilenames();\n            StringBuffer retBuffer = new StringBuffer();\n            for (int i = 0; i < filenames.length; i++) {\n                retBuffer.append(filenames[i]).append(Constants.LINE_SEPERATOR);\n            }\n            return retBuffer.toString();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Resends a message from the Deleted Message Store\n     *\n     * @param filename the filename of the deleted message\n     * @return a message of success or failure\n     */\n    public String resendDeletedMessage(String filename) {\n        return DeletedMessageStore.resendDeletedMessage(filename);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename the name of the file including the directory\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    private String readFile(String filename, int maxLength) {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        try {\n            BufferedReader buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n            buffReader.close();\n        } catch (IOException e) {\n            return XException.getExceptionInformation();\n        }\n        if (maxLength > 0) {\n            int bufferLength = retBuffer.length();\n            int endLength = bufferLength - maxLength * 1024;\n            retBuffer.delete(0, endLength);\n        }\n        // if (expectedLength > 0)\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/AdministratorTest4.java",
		"test_prompt": "// AdministratorTest4.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#stopReceiverService()} method.\n*/\nclass AdministratorTest4 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator {\n\n    /**\n     * Reads a file from <code>XBUS_HOME/etc</code>.\n     *\n     * @param filename the name of the file to read\n     * @return the content of the file or an error message\n     */\n    public String readEtc(String filename) {\n        if (filename == null) {\n            return (\"Filename must not be null.\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename.\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"Filename must not start with / or \\\\.\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_ETC + filename, 0);\n    }\n\n    /**\n     * Reads a file from <code>XBUS_HOME/log</code>.\n     *\n     * @param filename the name of the file\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    public String readLog(String filename, int maxLength) {\n        if (filename == null) {\n            return (\"Filename must not be null\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"filename must not start with / or \\\\\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_LOG + filename, maxLength);\n    }\n\n    /**\n     * Explains an errorcode.\n     *\n     * @param key the errorcode to explain\n     * @return the message of the errorcode\n     */\n    public String explainErrorcode(String key) {\n        if (key == null) {\n            return (\"Key must not be null.\");\n        }\n        String basename = \"errors\";\n        // get the decompose key\n        ASCIITokenizer test = new ASCIITokenizer(key, \"_\");\n        String Location = test.nextToken();\n        String Layer = test.nextToken();\n        String Package = test.nextToken();\n        String Number = test.nextToken();\n        // get the Message\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessageOptional(key, null);\n        // get the Location\n        String LocationInformation = null;\n        if (Location.equals(\"I\")) {\n            LocationInformation = \"Intern\";\n        } else // if (Location.equals(\"I\"))\n        if (Location.equals(\"E\")) {\n            LocationInformation = \"Extern\";\n        } else // if (Location.equals(\"E\"))\n        {\n            return \"Wrong Location\";\n        }\n        // get the Layer\n        String LayerInformation = msg.getMessageOptional(Layer, null);\n        // get the Package\n        String PackageInformation = msg.getMessageOptional(Layer + \"_\" + Package, null);\n        String informations = new StringBuffer(Location).append(\" = \").append(LocationInformation).append(Constants.LINE_SEPERATOR).append(Layer).append(\" = \").append(LayerInformation).append(Constants.LINE_SEPERATOR).append(Package).append(\" = \").append(PackageInformation).append(Constants.LINE_SEPERATOR).append(\"Number\").append(\" = \").append(Number).append(Constants.LINE_SEPERATOR).append(\"Message text\").append(\" = \").append(messageText).toString();\n        return informations;\n    }\n\n    /**\n     * Stopping all background services, refreshes the configuration and starts\n     * the background services again.\n     *\n     * @return the confirmation or an error message\n     */\n    public String restartReceiverService() {\n        try {\n            /*\n\t\t\t * Stop background receivers\n\t\t\t */\n            ReceiverService.getInstance().stopAllSystems();\n            /*\n\t\t\t * Initialize all configurations\n\t\t\t */\n            Configuration.refresh(\"standard\");\n            Configuration.refresh(\"xbus\");\n            Configuration.refresh(\"mapping\");\n            /*\n\t\t\t * Initialize XException, Trace and Journal\n\t\t\t */\n            XException.clearExceptionInformation();\n            Trace.initialize();\n            Journal.initialize();\n            /*\n\t\t\t * Clear all connections\n\t\t\t */\n            DBConnection.clear();\n            AS400Connection.clear();\n            MQConnection.clear();\n            TAManager.clear();\n            /*\n\t\t\t * Start background receivers again\n\t\t\t */\n            ReceiverService.getInstance().startAllSystems();\n            ReceiverThreadManager.getInstance().clearStoppedHTTPReceivers();\n            HTTPReceiver.initializeAmountErrorsCompletely();\n            return \"ReceiverService has been restarted and configuration has been refreshed.\";\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n    }\n\n    /**\n     * Stops the ReceiverService completely, including the JMX server.\n     *\n     * @return the confirmation or an error message\n     */\n    public String stopReceiverService() {\n        try {\n            if (!ReceiverService.getInstance().stop()) {\n                return \"ReceiverService can not be stopped\";\n            }\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n        return \"ReceiverService has been stopped\";\n    }\n\n    /**\n     * Returns lists of running, stopped and killed ReceiverThreads.\n     *\n     * @return lists of running, stopped and killed ReceiverThreads\n     */\n    public String getReceiverServiceStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        /*\n\t\t * Retrieving state of ReveiverThreads\n\t\t */\n        ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n        Set runningSystems;\n        Set allSystems;\n        try {\n            allSystems = manager.getAllSystems();\n            runningSystems = manager.getRunningSystems();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        Set stoppedSystems = manager.getStoppedSystems();\n        StringBuffer tmpBuffer = new StringBuffer();\n        retBuffer.append(\"Running Background Receivers:\\n\");\n        for (Iterator it = runningSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        retBuffer.append(\"\\n\\nStopped Background Receivers:\\n\");\n        for (Iterator it = stoppedSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        String system = null;\n        retBuffer.append(\"\\n\\nKilled Background Receivers:\\n\");\n        for (Iterator it = allSystems.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            if ((!runningSystems.contains(system)) && (!stoppedSystems.contains(system))) {\n                tmpBuffer.append(\"\\n\").append(it.next());\n            }\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        if (ReceiverService.getInstance().isWatchdogRunning()) {\n            retBuffer.append(\"\\n\\nWatchdog is running\");\n        } else {\n            retBuffer.append(\"\\n\\nWatchdog is NOT running !!!\");\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Returns some information about the state of the Java Virtual Machine,\n     * containing memory consumption and information about the environment.\n     *\n     * @return some information about the state of the Java Virtual Machine\n     */\n    public String getJVMStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        retBuffer.append(\"Resources:\");\n        Runtime runtime = Runtime.getRuntime();\n        runtime.gc();\n        retBuffer.append(\"\\n\\nMaximum memory available:        \" + NumberFormat.getInstance().format(runtime.maxMemory()) + \" bytes\");\n        retBuffer.append(\"\\nMemory currently used:           \" + NumberFormat.getInstance().format(runtime.totalMemory()) + \" bytes\");\n        retBuffer.append(\"\\nFree memory currently available: \" + NumberFormat.getInstance().format(runtime.freeMemory()) + \" bytes\");\n        retBuffer.append(\"\\nAvailable processors:            \" + runtime.availableProcessors());\n        retBuffer.append(\"\\n\\nEnvironment:\\n\");\n        TreeSet envKeys = new TreeSet(System.getProperties().keySet());\n        String key = null;\n        for (Iterator it = envKeys.iterator(); it.hasNext(); ) {\n            key = (String) it.next();\n            retBuffer.append(\"\\n\" + key + \"=\" + System.getProperty(key));\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Demands the stop of a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a started background receiver\").toString();\n            }\n            manager.demandStopReceiverThread(system);\n            return \"Stop for background receiver \" + system + \" demanded\";\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Starts a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String startBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getAllSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a configured configured background receiver\").toString();\n            }\n            if (manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is already started\").toString();\n            }\n            manager.startReceiverThread(system);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        return \"Background receiver \" + system + \" started\";\n    }\n\n    /**\n     * Reads the filenames that are currently in the Deleted Message Store.\n     *\n     * @return the filenames that are currently in the Deleted Message Store\n     */\n    public String getDeletedMessageFilenames() {\n        try {\n            String[] filenames = DeletedMessageStore.getDeletedMessageFilenames();\n            StringBuffer retBuffer = new StringBuffer();\n            for (int i = 0; i < filenames.length; i++) {\n                retBuffer.append(filenames[i]).append(Constants.LINE_SEPERATOR);\n            }\n            return retBuffer.toString();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Resends a message from the Deleted Message Store\n     *\n     * @param filename the filename of the deleted message\n     * @return a message of success or failure\n     */\n    public String resendDeletedMessage(String filename) {\n        return DeletedMessageStore.resendDeletedMessage(filename);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename the name of the file including the directory\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    private String readFile(String filename, int maxLength) {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        try {\n            BufferedReader buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n            buffReader.close();\n        } catch (IOException e) {\n            return XException.getExceptionInformation();\n        }\n        if (maxLength > 0) {\n            int bufferLength = retBuffer.length();\n            int endLength = bufferLength - maxLength * 1024;\n            retBuffer.delete(0, endLength);\n        }\n        // if (expectedLength > 0)\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/AdministratorTest5.java",
		"test_prompt": "// AdministratorTest5.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#demandStopBackgroundReceiver(String)} method.\n*/\nclass AdministratorTest5 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator {\n\n    /**\n     * Reads a file from <code>XBUS_HOME/etc</code>.\n     *\n     * @param filename the name of the file to read\n     * @return the content of the file or an error message\n     */\n    public String readEtc(String filename) {\n        if (filename == null) {\n            return (\"Filename must not be null.\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename.\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"Filename must not start with / or \\\\.\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_ETC + filename, 0);\n    }\n\n    /**\n     * Reads a file from <code>XBUS_HOME/log</code>.\n     *\n     * @param filename the name of the file\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    public String readLog(String filename, int maxLength) {\n        if (filename == null) {\n            return (\"Filename must not be null\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"filename must not start with / or \\\\\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_LOG + filename, maxLength);\n    }\n\n    /**\n     * Explains an errorcode.\n     *\n     * @param key the errorcode to explain\n     * @return the message of the errorcode\n     */\n    public String explainErrorcode(String key) {\n        if (key == null) {\n            return (\"Key must not be null.\");\n        }\n        String basename = \"errors\";\n        // get the decompose key\n        ASCIITokenizer test = new ASCIITokenizer(key, \"_\");\n        String Location = test.nextToken();\n        String Layer = test.nextToken();\n        String Package = test.nextToken();\n        String Number = test.nextToken();\n        // get the Message\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessageOptional(key, null);\n        // get the Location\n        String LocationInformation = null;\n        if (Location.equals(\"I\")) {\n            LocationInformation = \"Intern\";\n        } else // if (Location.equals(\"I\"))\n        if (Location.equals(\"E\")) {\n            LocationInformation = \"Extern\";\n        } else // if (Location.equals(\"E\"))\n        {\n            return \"Wrong Location\";\n        }\n        // get the Layer\n        String LayerInformation = msg.getMessageOptional(Layer, null);\n        // get the Package\n        String PackageInformation = msg.getMessageOptional(Layer + \"_\" + Package, null);\n        String informations = new StringBuffer(Location).append(\" = \").append(LocationInformation).append(Constants.LINE_SEPERATOR).append(Layer).append(\" = \").append(LayerInformation).append(Constants.LINE_SEPERATOR).append(Package).append(\" = \").append(PackageInformation).append(Constants.LINE_SEPERATOR).append(\"Number\").append(\" = \").append(Number).append(Constants.LINE_SEPERATOR).append(\"Message text\").append(\" = \").append(messageText).toString();\n        return informations;\n    }\n\n    /**\n     * Stopping all background services, refreshes the configuration and starts\n     * the background services again.\n     *\n     * @return the confirmation or an error message\n     */\n    public String restartReceiverService() {\n        try {\n            /*\n\t\t\t * Stop background receivers\n\t\t\t */\n            ReceiverService.getInstance().stopAllSystems();\n            /*\n\t\t\t * Initialize all configurations\n\t\t\t */\n            Configuration.refresh(\"standard\");\n            Configuration.refresh(\"xbus\");\n            Configuration.refresh(\"mapping\");\n            /*\n\t\t\t * Initialize XException, Trace and Journal\n\t\t\t */\n            XException.clearExceptionInformation();\n            Trace.initialize();\n            Journal.initialize();\n            /*\n\t\t\t * Clear all connections\n\t\t\t */\n            DBConnection.clear();\n            AS400Connection.clear();\n            MQConnection.clear();\n            TAManager.clear();\n            /*\n\t\t\t * Start background receivers again\n\t\t\t */\n            ReceiverService.getInstance().startAllSystems();\n            ReceiverThreadManager.getInstance().clearStoppedHTTPReceivers();\n            HTTPReceiver.initializeAmountErrorsCompletely();\n            return \"ReceiverService has been restarted and configuration has been refreshed.\";\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n    }\n\n    /**\n     * Stops the ReceiverService completely, including the JMX server.\n     *\n     * @return the confirmation or an error message\n     */\n    public String stopReceiverService() {\n        try {\n            if (!ReceiverService.getInstance().stop()) {\n                return \"ReceiverService can not be stopped\";\n            }\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n        return \"ReceiverService has been stopped\";\n    }\n\n    /**\n     * Returns lists of running, stopped and killed ReceiverThreads.\n     *\n     * @return lists of running, stopped and killed ReceiverThreads\n     */\n    public String getReceiverServiceStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        /*\n\t\t * Retrieving state of ReveiverThreads\n\t\t */\n        ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n        Set runningSystems;\n        Set allSystems;\n        try {\n            allSystems = manager.getAllSystems();\n            runningSystems = manager.getRunningSystems();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        Set stoppedSystems = manager.getStoppedSystems();\n        StringBuffer tmpBuffer = new StringBuffer();\n        retBuffer.append(\"Running Background Receivers:\\n\");\n        for (Iterator it = runningSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        retBuffer.append(\"\\n\\nStopped Background Receivers:\\n\");\n        for (Iterator it = stoppedSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        String system = null;\n        retBuffer.append(\"\\n\\nKilled Background Receivers:\\n\");\n        for (Iterator it = allSystems.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            if ((!runningSystems.contains(system)) && (!stoppedSystems.contains(system))) {\n                tmpBuffer.append(\"\\n\").append(it.next());\n            }\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        if (ReceiverService.getInstance().isWatchdogRunning()) {\n            retBuffer.append(\"\\n\\nWatchdog is running\");\n        } else {\n            retBuffer.append(\"\\n\\nWatchdog is NOT running !!!\");\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Returns some information about the state of the Java Virtual Machine,\n     * containing memory consumption and information about the environment.\n     *\n     * @return some information about the state of the Java Virtual Machine\n     */\n    public String getJVMStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        retBuffer.append(\"Resources:\");\n        Runtime runtime = Runtime.getRuntime();\n        runtime.gc();\n        retBuffer.append(\"\\n\\nMaximum memory available:        \" + NumberFormat.getInstance().format(runtime.maxMemory()) + \" bytes\");\n        retBuffer.append(\"\\nMemory currently used:           \" + NumberFormat.getInstance().format(runtime.totalMemory()) + \" bytes\");\n        retBuffer.append(\"\\nFree memory currently available: \" + NumberFormat.getInstance().format(runtime.freeMemory()) + \" bytes\");\n        retBuffer.append(\"\\nAvailable processors:            \" + runtime.availableProcessors());\n        retBuffer.append(\"\\n\\nEnvironment:\\n\");\n        TreeSet envKeys = new TreeSet(System.getProperties().keySet());\n        String key = null;\n        for (Iterator it = envKeys.iterator(); it.hasNext(); ) {\n            key = (String) it.next();\n            retBuffer.append(\"\\n\" + key + \"=\" + System.getProperty(key));\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Demands the stop of a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a started background receiver\").toString();\n            }\n            manager.demandStopReceiverThread(system);\n            return \"Stop for background receiver \" + system + \" demanded\";\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Starts a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String startBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getAllSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a configured configured background receiver\").toString();\n            }\n            if (manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is already started\").toString();\n            }\n            manager.startReceiverThread(system);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        return \"Background receiver \" + system + \" started\";\n    }\n\n    /**\n     * Reads the filenames that are currently in the Deleted Message Store.\n     *\n     * @return the filenames that are currently in the Deleted Message Store\n     */\n    public String getDeletedMessageFilenames() {\n        try {\n            String[] filenames = DeletedMessageStore.getDeletedMessageFilenames();\n            StringBuffer retBuffer = new StringBuffer();\n            for (int i = 0; i < filenames.length; i++) {\n                retBuffer.append(filenames[i]).append(Constants.LINE_SEPERATOR);\n            }\n            return retBuffer.toString();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Resends a message from the Deleted Message Store\n     *\n     * @param filename the filename of the deleted message\n     * @return a message of success or failure\n     */\n    public String resendDeletedMessage(String filename) {\n        return DeletedMessageStore.resendDeletedMessage(filename);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename the name of the file including the directory\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    private String readFile(String filename, int maxLength) {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        try {\n            BufferedReader buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n            buffReader.close();\n        } catch (IOException e) {\n            return XException.getExceptionInformation();\n        }\n        if (maxLength > 0) {\n            int bufferLength = retBuffer.length();\n            int endLength = bufferLength - maxLength * 1024;\n            retBuffer.delete(0, endLength);\n        }\n        // if (expectedLength > 0)\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/AdministratorTest6.java",
		"test_prompt": "// AdministratorTest6.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#startBackgroundReceiver(String)} method.\n*/\nclass AdministratorTest6 {"
	},
	{
		"original_code": "// Administrator.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\n\n/**\n * Provides several services to administrate the xBus.\n */\npublic class Administrator {\n\n    /**\n     * Reads a file from <code>XBUS_HOME/etc</code>.\n     *\n     * @param filename the name of the file to read\n     * @return the content of the file or an error message\n     */\n    public String readEtc(String filename) {\n        if (filename == null) {\n            return (\"Filename must not be null.\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename.\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"Filename must not start with / or \\\\.\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_ETC + filename, 0);\n    }\n\n    /**\n     * Reads a file from <code>XBUS_HOME/log</code>.\n     *\n     * @param filename the name of the file\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    public String readLog(String filename, int maxLength) {\n        if (filename == null) {\n            return (\"Filename must not be null\");\n        } else // if (source == null)\n        if (filename.startsWith(\"..\") || (filename.indexOf(\"..\") > 0)) {\n            return (\".. is not allowed in filename\");\n        } else // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        if (filename.startsWith(\"/\") || (filename.startsWith(\"\\\\\"))) {\n            return (\"filename must not start with / or \\\\\");\n        }\n        // if (source.startsWith(\"..\") || (source.indexOf(\"..\") > 0))\n        return readFile(Constants.XBUS_LOG + filename, maxLength);\n    }\n\n    /**\n     * Explains an errorcode.\n     *\n     * @param key the errorcode to explain\n     * @return the message of the errorcode\n     */\n    public String explainErrorcode(String key) {\n        if (key == null) {\n            return (\"Key must not be null.\");\n        }\n        String basename = \"errors\";\n        // get the decompose key\n        ASCIITokenizer test = new ASCIITokenizer(key, \"_\");\n        String Location = test.nextToken();\n        String Layer = test.nextToken();\n        String Package = test.nextToken();\n        String Number = test.nextToken();\n        // get the Message\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessageOptional(key, null);\n        // get the Location\n        String LocationInformation = null;\n        if (Location.equals(\"I\")) {\n            LocationInformation = \"Intern\";\n        } else // if (Location.equals(\"I\"))\n        if (Location.equals(\"E\")) {\n            LocationInformation = \"Extern\";\n        } else // if (Location.equals(\"E\"))\n        {\n            return \"Wrong Location\";\n        }\n        // get the Layer\n        String LayerInformation = msg.getMessageOptional(Layer, null);\n        // get the Package\n        String PackageInformation = msg.getMessageOptional(Layer + \"_\" + Package, null);\n        String informations = new StringBuffer(Location).append(\" = \").append(LocationInformation).append(Constants.LINE_SEPERATOR).append(Layer).append(\" = \").append(LayerInformation).append(Constants.LINE_SEPERATOR).append(Package).append(\" = \").append(PackageInformation).append(Constants.LINE_SEPERATOR).append(\"Number\").append(\" = \").append(Number).append(Constants.LINE_SEPERATOR).append(\"Message text\").append(\" = \").append(messageText).toString();\n        return informations;\n    }\n\n    /**\n     * Stopping all background services, refreshes the configuration and starts\n     * the background services again.\n     *\n     * @return the confirmation or an error message\n     */\n    public String restartReceiverService() {\n        try {\n            /*\n\t\t\t * Stop background receivers\n\t\t\t */\n            ReceiverService.getInstance().stopAllSystems();\n            /*\n\t\t\t * Initialize all configurations\n\t\t\t */\n            Configuration.refresh(\"standard\");\n            Configuration.refresh(\"xbus\");\n            Configuration.refresh(\"mapping\");\n            /*\n\t\t\t * Initialize XException, Trace and Journal\n\t\t\t */\n            XException.clearExceptionInformation();\n            Trace.initialize();\n            Journal.initialize();\n            /*\n\t\t\t * Clear all connections\n\t\t\t */\n            DBConnection.clear();\n            AS400Connection.clear();\n            MQConnection.clear();\n            TAManager.clear();\n            /*\n\t\t\t * Start background receivers again\n\t\t\t */\n            ReceiverService.getInstance().startAllSystems();\n            ReceiverThreadManager.getInstance().clearStoppedHTTPReceivers();\n            HTTPReceiver.initializeAmountErrorsCompletely();\n            return \"ReceiverService has been restarted and configuration has been refreshed.\";\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n    }\n\n    /**\n     * Stops the ReceiverService completely, including the JMX server.\n     *\n     * @return the confirmation or an error message\n     */\n    public String stopReceiverService() {\n        try {\n            if (!ReceiverService.getInstance().stop()) {\n                return \"ReceiverService can not be stopped\";\n            }\n        } catch (XException e) {\n            return XException.getExceptionInformation();\n        }\n        return \"ReceiverService has been stopped\";\n    }\n\n    /**\n     * Returns lists of running, stopped and killed ReceiverThreads.\n     *\n     * @return lists of running, stopped and killed ReceiverThreads\n     */\n    public String getReceiverServiceStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        /*\n\t\t * Retrieving state of ReveiverThreads\n\t\t */\n        ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n        Set runningSystems;\n        Set allSystems;\n        try {\n            allSystems = manager.getAllSystems();\n            runningSystems = manager.getRunningSystems();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        Set stoppedSystems = manager.getStoppedSystems();\n        StringBuffer tmpBuffer = new StringBuffer();\n        retBuffer.append(\"Running Background Receivers:\\n\");\n        for (Iterator it = runningSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        retBuffer.append(\"\\n\\nStopped Background Receivers:\\n\");\n        for (Iterator it = stoppedSystems.iterator(); it.hasNext(); ) {\n            tmpBuffer.append(\"\\n\").append(it.next());\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        tmpBuffer = new StringBuffer();\n        String system = null;\n        retBuffer.append(\"\\n\\nKilled Background Receivers:\\n\");\n        for (Iterator it = allSystems.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            if ((!runningSystems.contains(system)) && (!stoppedSystems.contains(system))) {\n                tmpBuffer.append(\"\\n\").append(it.next());\n            }\n        }\n        if (tmpBuffer.length() == 0) {\n            retBuffer.append(\"-\");\n        } else {\n            retBuffer.append(tmpBuffer);\n        }\n        if (ReceiverService.getInstance().isWatchdogRunning()) {\n            retBuffer.append(\"\\n\\nWatchdog is running\");\n        } else {\n            retBuffer.append(\"\\n\\nWatchdog is NOT running !!!\");\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Returns some information about the state of the Java Virtual Machine,\n     * containing memory consumption and information about the environment.\n     *\n     * @return some information about the state of the Java Virtual Machine\n     */\n    public String getJVMStatus() {\n        StringBuffer retBuffer = new StringBuffer();\n        retBuffer.append(\"Resources:\");\n        Runtime runtime = Runtime.getRuntime();\n        runtime.gc();\n        retBuffer.append(\"\\n\\nMaximum memory available:        \" + NumberFormat.getInstance().format(runtime.maxMemory()) + \" bytes\");\n        retBuffer.append(\"\\nMemory currently used:           \" + NumberFormat.getInstance().format(runtime.totalMemory()) + \" bytes\");\n        retBuffer.append(\"\\nFree memory currently available: \" + NumberFormat.getInstance().format(runtime.freeMemory()) + \" bytes\");\n        retBuffer.append(\"\\nAvailable processors:            \" + runtime.availableProcessors());\n        retBuffer.append(\"\\n\\nEnvironment:\\n\");\n        TreeSet envKeys = new TreeSet(System.getProperties().keySet());\n        String key = null;\n        for (Iterator it = envKeys.iterator(); it.hasNext(); ) {\n            key = (String) it.next();\n            retBuffer.append(\"\\n\" + key + \"=\" + System.getProperty(key));\n        }\n        return retBuffer.toString();\n    }\n\n    /**\n     * Demands the stop of a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String demandStopBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a started background receiver\").toString();\n            }\n            manager.demandStopReceiverThread(system);\n            return \"Stop for background receiver \" + system + \" demanded\";\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Starts a background receiver.\n     *\n     * @param system the name of the system\n     * @return a confirmation or an error message\n     */\n    public String startBackgroundReceiver(String system) {\n        try {\n            ReceiverThreadManager manager = ReceiverThreadManager.getInstance();\n            if (!manager.getAllSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is not a configured configured background receiver\").toString();\n            }\n            if (manager.getRunningSystems().contains(system)) {\n                return new StringBuffer(system).append(\" is already started\").toString();\n            }\n            manager.startReceiverThread(system);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n        return \"Background receiver \" + system + \" started\";\n    }\n\n    /**\n     * Reads the filenames that are currently in the Deleted Message Store.\n     *\n     * @return the filenames that are currently in the Deleted Message Store\n     */\n    public String getDeletedMessageFilenames() {\n        try {\n            String[] filenames = DeletedMessageStore.getDeletedMessageFilenames();\n            StringBuffer retBuffer = new StringBuffer();\n            for (int i = 0; i < filenames.length; i++) {\n                retBuffer.append(filenames[i]).append(Constants.LINE_SEPERATOR);\n            }\n            return retBuffer.toString();\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    /**\n     * Resends a message from the Deleted Message Store\n     *\n     * @param filename the filename of the deleted message\n     * @return a message of success or failure\n     */\n    public String resendDeletedMessage(String filename) {\n        return DeletedMessageStore.resendDeletedMessage(filename);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename the name of the file including the directory\n     * @param maxLength maximum length to read in kbyte.\n     * @return the content of the file or an error message\n     */\n    private String readFile(String filename, int maxLength) {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        try {\n            BufferedReader buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n            buffReader.close();\n        } catch (IOException e) {\n            return XException.getExceptionInformation();\n        }\n        if (maxLength > 0) {\n            int bufferLength = retBuffer.length();\n            int endLength = bufferLength - maxLength * 1024;\n            retBuffer.delete(0, endLength);\n        }\n        // if (expectedLength > 0)\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/admin/AdministratorTest7.java",
		"test_prompt": "// AdministratorTest7.java\npackage net.sf.xbus.admin;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.text.NumberFormat;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport net.sf.xbus.base.core.ASCIITokenizer;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.MessageHandler;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.journal.Journal;\nimport net.sf.xbus.technical.ReceiverService;\nimport net.sf.xbus.technical.ReceiverThreadManager;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.database.DBConnection;\nimport net.sf.xbus.technical.http.HTTPReceiver;\nimport net.sf.xbus.technical.mq.MQConnection;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Administrator}.\n* It contains ten unit test cases for the {@link Administrator#resendDeletedMessage(String)} method.\n*/\nclass AdministratorTest7 {"
	},
	{
		"original_code": "// MessageFactory.java\npackage net.sf.xbus.protocol;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.w3c.dom.Document;\n\n/**\n * The class <code>MessageFactory</code> is used to dynamically create\n * messages. It implements the <b>Factory </b> Design-Pattern.\n * <p>\n */\npublic class MessageFactory {\n\n    public static final int TRANSFORM_FROM_REQUEST = 0;\n\n    public static final int TRANSFORM_FROM_RESPONSE = 1;\n\n    /**\n     * The appropriate <code>Message</code> -object for the given source will\n     * be created. The name of the appropriate <code>Message</code> class is\n     * read from the {@link net.sf.xbus.base.core.config.Configuration}.\n     *\n     * @param source the name of the system, from which the message was received\n     */\n    public static Message createApplicationMessage(XBUSSystem source) throws XException {\n        Configuration config = Configuration.getInstance();\n        String messageClassShortname = config.getValue(Constants.CHAPTER_SYSTEM, source.getName(), \"Message\");\n        String messageClass = Configuration.getClass(\"Message\", messageClassShortname);\n        Class[] conArgsClass = new Class[] { ReflectionSupport.classForName(\"net.sf.xbus.base.xbussystem.XBUSSystem\") };\n        Object[] conArgs = new Object[] { source };\n        return (Message) ReflectionSupport.createObject(messageClass, conArgsClass, conArgs);\n    }\n\n    /**\n     * Transforms the response of a source message to the response of a\n     * destination message.\n     *\n     * @param source the system name where the response of the source message is\n     *            coming from\n     * @param destination the system name where the response of the destination\n     *            message shall be sent to\n     * @param sourceMessage the <code>Message</code> from which the response\n     *            to transform is taken.\n     * @param destinationMessage the <code>Message</code> whose response is\n     *            filled\n     */\n    static public void transformResponse2Response(XBUSSystem source, XBUSSystem destination, Message sourceMessage, Message destinationMessage) throws XException {\n        String receiverType = Configuration.getInstance().getValueOptional(\"TransformInput\", source.getName(), destination.getName());\n        if (receiverType == null) {\n            if (sourceMessage instanceof XMLMessage) {\n                receiverType = Constants.TYPE_XML;\n            } else if (sourceMessage instanceof ObjectMessage) {\n                receiverType = Constants.TYPE_OBJECT;\n            } else if (sourceMessage instanceof TextMessage) {\n                receiverType = Constants.TYPE_TEXT;\n            } else {\n                List params = new Vector(1);\n                params.add(sourceMessage.getShortname());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_PROTOCOL, \"9\", params);\n            }\n        }\n        // if (receiverType==null) - no specific type declared for system\n        Object input = null;\n        Object output = null;\n        if (receiverType.equals(Constants.TYPE_XML)) {\n            input = ((XMLMessage) sourceMessage).getResponseDocument();\n        } else if (receiverType.equals(Constants.TYPE_OBJECT)) {\n            // the message content is serialised due to the structure\n            // description attached to the source system\n            input = ((ObjectMessage) sourceMessage).getResponseObject();\n        } else {\n            // the message content is serialised due to the structure\n            // description attached to the source system\n            input = ((TextMessage) sourceMessage).getResponseText();\n        }\n        Transformer transformer = TransformerFactory.createTransformer(source, destination, sourceMessage, destinationMessage);\n        output = transformer.transform(input, source, destination, destinationMessage);\n        // The transformation result is a string.\n        if (output instanceof String) {\n            ((TextMessage) destinationMessage).setResponseText((String) output, destination);\n        } else // then (output.getClass().getName().equals(\"java.lang.String\"))\n        if (output instanceof Document) {\n            // The transformation result is a DOM tree.\n            ((XMLMessage) destinationMessage).setResponseDocument((Document) output, destination);\n        } else // then (doc.isInstance(output))\n        {\n            // The transformation result is anything else than a string or a\n            // DOM tree.\n            ((ObjectMessage) destinationMessage).setResponseObject(output, destination);\n        }\n        // else (output.getClass().getName().equals(\"java.lang.String\"))\n    }\n\n    /**\n     * The appropriate <code>Message</code> object which is needed to send a\n     * message to the given destination will be created. At this point either\n     * the request or the response of the incoming <code>Message</code> will\n     * be converted to the request of the outgoing <code>Message</code>.\n     *\n     * @param destination the name of the system where the message will be send\n     *            to\n     * @param sourceMessage the <code>Message</code> from which the new\n     *            <code>Message</code> will be initialized\n     * @param convertFrom flag wether the request or the response of the\n     *            sourceMessage is used to fill the request of the new\n     *            <code>Message</code>\n     */\n    public static Message createSenderMessage(XBUSSystem destination, Message sourceMessage, int convertFrom) throws XException {\n        if ((convertFrom != TRANSFORM_FROM_REQUEST) && (convertFrom != TRANSFORM_FROM_RESPONSE)) {\n            List params = new Vector();\n            params.add(String.valueOf(convertFrom));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_PROTOCOL, \"7\", params);\n        }\n        Message destinationMessage = createMessage(sourceMessage, destination);\n        XBUSSystem source = sourceMessage.getSource();\n        String receiverType = Configuration.getInstance().getValueOptional(\"TransformInput\", source.getName(), destination.getName());\n        if (receiverType == null) {\n            if (sourceMessage instanceof XMLMessage) {\n                receiverType = Constants.TYPE_XML;\n            } else if (sourceMessage instanceof ObjectMessage) {\n                receiverType = Constants.TYPE_OBJECT;\n            } else if (sourceMessage instanceof TextMessage) {\n                receiverType = Constants.TYPE_TEXT;\n            } else {\n                List params = new Vector(1);\n                params.add(sourceMessage.getShortname());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_PROTOCOL, \"9\", params);\n            }\n        }\n        // if (receiverType==null) - no specific type declared for system\n        Object input = null;\n        Object output = null;\n        switch(convertFrom) {\n            case TRANSFORM_FROM_REQUEST:\n                if (receiverType.equals(Constants.TYPE_XML)) {\n                    input = ((XMLMessage) sourceMessage).getRequestDocument(source);\n                } else if (receiverType.equals(Constants.TYPE_OBJECT)) {\n                    // the message content is serialised due to the structure\n                    // description attached to the source system\n                    input = ((ObjectMessage) sourceMessage).getRequestObject(source);\n                } else if (receiverType.equals(Constants.TYPE_TEXT)) {\n                    // the message content is serialised due to the structure\n                    // description attached to the source system\n                    input = ((TextMessage) sourceMessage).getRequestText(source);\n                }\n                break;\n            case TRANSFORM_FROM_RESPONSE:\n                if (receiverType.equals(Constants.TYPE_XML)) {\n                    input = ((XMLMessage) sourceMessage).getResponseDocument();\n                } else if (receiverType.equals(Constants.TYPE_OBJECT)) {\n                    // the message content is serialised due to the structure\n                    // description attached to the source system\n                    input = ((ObjectMessage) sourceMessage).getResponseObject();\n                } else if (receiverType.equals(Constants.TYPE_TEXT)) {\n                    // the message content is serialised due to the structure\n                    // description attached to the source system\n                    input = ((TextMessage) sourceMessage).getResponseText();\n                }\n                break;\n        }\n        Transformer transformer = TransformerFactory.createTransformer(source, destination, sourceMessage, destinationMessage);\n        output = transformer.transform(input, source, destination, destinationMessage);\n        if (output != null) {\n            if (output instanceof String) {\n                ((TextMessage) destinationMessage).setRequestText(output.toString(), destination);\n            } else if (output instanceof Document) {\n                ((XMLMessage) destinationMessage).setRequestDocument((Document) output, destination);\n            } else {\n                ((ObjectMessage) destinationMessage).setRequestObject(output, destination);\n            }\n        }\n        return destinationMessage;\n    }\n\n    static private Message createMessage(Message source, XBUSSystem destination) throws XException {\n        /*\n\t\t * Constructing the parameters for the constructor.\n\t\t */\n        Class[] conArgsClass = new Class[] { ReflectionSupport.classForName(\"java.lang.String\"), ReflectionSupport.classForName(\"net.sf.xbus.base.xbussystem.XBUSSystem\"), ReflectionSupport.classForName(\"java.lang.String\") };\n        Object[] conArgs = new Object[] { source.getFunction(), source.getSource(), source.getId() };\n        /*\n\t\t * Getting the type of Message that must be created\n\t\t */\n        Configuration config = Configuration.getInstance();\n        String newMessageShortname = config.getValue(Constants.CHAPTER_SYSTEM, destination.getName(), \"Message\");\n        String newMessageName = Configuration.getClass(\"Message\", newMessageShortname);\n        /*\n\t\t * Instanciating the new Message\n\t\t */\n        return (Message) ReflectionSupport.createObject(newMessageName, conArgsClass, conArgs);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/MessageFactoryTest0.java",
		"test_prompt": "// MessageFactoryTest0.java\npackage net.sf.xbus.protocol;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createApplicationMessage(XBUSSystem)} method.\n*/\nclass MessageFactoryTest0 {"
	},
	{
		"original_code": "// MessageFactory.java\npackage net.sf.xbus.protocol;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.w3c.dom.Document;\n\n/**\n * The class <code>MessageFactory</code> is used to dynamically create\n * messages. It implements the <b>Factory </b> Design-Pattern.\n * <p>\n */\npublic class MessageFactory {\n\n    public static final int TRANSFORM_FROM_REQUEST = 0;\n\n    public static final int TRANSFORM_FROM_RESPONSE = 1;\n\n    /**\n     * The appropriate <code>Message</code> -object for the given source will\n     * be created. The name of the appropriate <code>Message</code> class is\n     * read from the {@link net.sf.xbus.base.core.config.Configuration}.\n     *\n     * @param source the name of the system, from which the message was received\n     */\n    public static Message createApplicationMessage(XBUSSystem source) throws XException {\n        Configuration config = Configuration.getInstance();\n        String messageClassShortname = config.getValue(Constants.CHAPTER_SYSTEM, source.getName(), \"Message\");\n        String messageClass = Configuration.getClass(\"Message\", messageClassShortname);\n        Class[] conArgsClass = new Class[] { ReflectionSupport.classForName(\"net.sf.xbus.base.xbussystem.XBUSSystem\") };\n        Object[] conArgs = new Object[] { source };\n        return (Message) ReflectionSupport.createObject(messageClass, conArgsClass, conArgs);\n    }\n\n    /**\n     * Transforms the response of a source message to the response of a\n     * destination message.\n     *\n     * @param source the system name where the response of the source message is\n     *            coming from\n     * @param destination the system name where the response of the destination\n     *            message shall be sent to\n     * @param sourceMessage the <code>Message</code> from which the response\n     *            to transform is taken.\n     * @param destinationMessage the <code>Message</code> whose response is\n     *            filled\n     */\n    static public void transformResponse2Response(XBUSSystem source, XBUSSystem destination, Message sourceMessage, Message destinationMessage) throws XException {\n        String receiverType = Configuration.getInstance().getValueOptional(\"TransformInput\", source.getName(), destination.getName());\n        if (receiverType == null) {\n            if (sourceMessage instanceof XMLMessage) {\n                receiverType = Constants.TYPE_XML;\n            } else if (sourceMessage instanceof ObjectMessage) {\n                receiverType = Constants.TYPE_OBJECT;\n            } else if (sourceMessage instanceof TextMessage) {\n                receiverType = Constants.TYPE_TEXT;\n            } else {\n                List params = new Vector(1);\n                params.add(sourceMessage.getShortname());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_PROTOCOL, \"9\", params);\n            }\n        }\n        // if (receiverType==null) - no specific type declared for system\n        Object input = null;\n        Object output = null;\n        if (receiverType.equals(Constants.TYPE_XML)) {\n            input = ((XMLMessage) sourceMessage).getResponseDocument();\n        } else if (receiverType.equals(Constants.TYPE_OBJECT)) {\n            // the message content is serialised due to the structure\n            // description attached to the source system\n            input = ((ObjectMessage) sourceMessage).getResponseObject();\n        } else {\n            // the message content is serialised due to the structure\n            // description attached to the source system\n            input = ((TextMessage) sourceMessage).getResponseText();\n        }\n        Transformer transformer = TransformerFactory.createTransformer(source, destination, sourceMessage, destinationMessage);\n        output = transformer.transform(input, source, destination, destinationMessage);\n        // The transformation result is a string.\n        if (output instanceof String) {\n            ((TextMessage) destinationMessage).setResponseText((String) output, destination);\n        } else // then (output.getClass().getName().equals(\"java.lang.String\"))\n        if (output instanceof Document) {\n            // The transformation result is a DOM tree.\n            ((XMLMessage) destinationMessage).setResponseDocument((Document) output, destination);\n        } else // then (doc.isInstance(output))\n        {\n            // The transformation result is anything else than a string or a\n            // DOM tree.\n            ((ObjectMessage) destinationMessage).setResponseObject(output, destination);\n        }\n        // else (output.getClass().getName().equals(\"java.lang.String\"))\n    }\n\n    /**\n     * The appropriate <code>Message</code> object which is needed to send a\n     * message to the given destination will be created. At this point either\n     * the request or the response of the incoming <code>Message</code> will\n     * be converted to the request of the outgoing <code>Message</code>.\n     *\n     * @param destination the name of the system where the message will be send\n     *            to\n     * @param sourceMessage the <code>Message</code> from which the new\n     *            <code>Message</code> will be initialized\n     * @param convertFrom flag wether the request or the response of the\n     *            sourceMessage is used to fill the request of the new\n     *            <code>Message</code>\n     */\n    public static Message createSenderMessage(XBUSSystem destination, Message sourceMessage, int convertFrom) throws XException {\n        if ((convertFrom != TRANSFORM_FROM_REQUEST) && (convertFrom != TRANSFORM_FROM_RESPONSE)) {\n            List params = new Vector();\n            params.add(String.valueOf(convertFrom));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_PROTOCOL, \"7\", params);\n        }\n        Message destinationMessage = createMessage(sourceMessage, destination);\n        XBUSSystem source = sourceMessage.getSource();\n        String receiverType = Configuration.getInstance().getValueOptional(\"TransformInput\", source.getName(), destination.getName());\n        if (receiverType == null) {\n            if (sourceMessage instanceof XMLMessage) {\n                receiverType = Constants.TYPE_XML;\n            } else if (sourceMessage instanceof ObjectMessage) {\n                receiverType = Constants.TYPE_OBJECT;\n            } else if (sourceMessage instanceof TextMessage) {\n                receiverType = Constants.TYPE_TEXT;\n            } else {\n                List params = new Vector(1);\n                params.add(sourceMessage.getShortname());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_PROTOCOL, \"9\", params);\n            }\n        }\n        // if (receiverType==null) - no specific type declared for system\n        Object input = null;\n        Object output = null;\n        switch(convertFrom) {\n            case TRANSFORM_FROM_REQUEST:\n                if (receiverType.equals(Constants.TYPE_XML)) {\n                    input = ((XMLMessage) sourceMessage).getRequestDocument(source);\n                } else if (receiverType.equals(Constants.TYPE_OBJECT)) {\n                    // the message content is serialised due to the structure\n                    // description attached to the source system\n                    input = ((ObjectMessage) sourceMessage).getRequestObject(source);\n                } else if (receiverType.equals(Constants.TYPE_TEXT)) {\n                    // the message content is serialised due to the structure\n                    // description attached to the source system\n                    input = ((TextMessage) sourceMessage).getRequestText(source);\n                }\n                break;\n            case TRANSFORM_FROM_RESPONSE:\n                if (receiverType.equals(Constants.TYPE_XML)) {\n                    input = ((XMLMessage) sourceMessage).getResponseDocument();\n                } else if (receiverType.equals(Constants.TYPE_OBJECT)) {\n                    // the message content is serialised due to the structure\n                    // description attached to the source system\n                    input = ((ObjectMessage) sourceMessage).getResponseObject();\n                } else if (receiverType.equals(Constants.TYPE_TEXT)) {\n                    // the message content is serialised due to the structure\n                    // description attached to the source system\n                    input = ((TextMessage) sourceMessage).getResponseText();\n                }\n                break;\n        }\n        Transformer transformer = TransformerFactory.createTransformer(source, destination, sourceMessage, destinationMessage);\n        output = transformer.transform(input, source, destination, destinationMessage);\n        if (output != null) {\n            if (output instanceof String) {\n                ((TextMessage) destinationMessage).setRequestText(output.toString(), destination);\n            } else if (output instanceof Document) {\n                ((XMLMessage) destinationMessage).setRequestDocument((Document) output, destination);\n            } else {\n                ((ObjectMessage) destinationMessage).setRequestObject(output, destination);\n            }\n        }\n        return destinationMessage;\n    }\n\n    static private Message createMessage(Message source, XBUSSystem destination) throws XException {\n        /*\n\t\t * Constructing the parameters for the constructor.\n\t\t */\n        Class[] conArgsClass = new Class[] { ReflectionSupport.classForName(\"java.lang.String\"), ReflectionSupport.classForName(\"net.sf.xbus.base.xbussystem.XBUSSystem\"), ReflectionSupport.classForName(\"java.lang.String\") };\n        Object[] conArgs = new Object[] { source.getFunction(), source.getSource(), source.getId() };\n        /*\n\t\t * Getting the type of Message that must be created\n\t\t */\n        Configuration config = Configuration.getInstance();\n        String newMessageShortname = config.getValue(Constants.CHAPTER_SYSTEM, destination.getName(), \"Message\");\n        String newMessageName = Configuration.getClass(\"Message\", newMessageShortname);\n        /*\n\t\t * Instanciating the new Message\n\t\t */\n        return (Message) ReflectionSupport.createObject(newMessageName, conArgsClass, conArgs);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/MessageFactoryTest1.java",
		"test_prompt": "// MessageFactoryTest1.java\npackage net.sf.xbus.protocol;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageFactory}.\n* It contains ten unit test cases for the {@link MessageFactory#createSenderMessage(XBUSSystem, Message, int)} method.\n*/\nclass MessageFactoryTest1 {"
	},
	{
		"original_code": "// RecordTypeTransformer.java\npackage net.sf.xbus.protocol.records;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport net.sf.xbus.protocol.xml.XSLTTransformer;\nimport org.w3c.dom.Document;\n\n/**\n * <code>RecordTypeTransformer</code> transforms one\n * {@link net.sf.xbus.protocol.records.RecordTypeMessage RecordTypeMessage} into\n * another one - according to a xsl transformation description. The class is\n * pretty like the\n * {@link net.sf.xbus.protocol.xml.XSLTTransformer XSLTTransformer}. The only\n * difference is a whitespace cleaning after the transformation.\n */\npublic class RecordTypeTransformer extends XSLTTransformer implements Transformer {\n\n    /**\n     * The <code>transform</code> method is automatically called by the xBus\n     * during the routing of messages.\n     *\n     * @param inObject either the request or response that shall be transformed\n     *            to another format\n     * @param source the <code>XBUSSystem</code> of the message of the\n     *            <code>inObject</code>\n     * @param destination the <code>XBUSSystem</code> of the target message\n     * @param destinationMessage the target message eventually contains more\n     *            information necessary for transforming\n     * @return the transformed <code>Object</code>, written to either the\n     *         request or response of the target message\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        Document doc = (Document) super.transform(inObject, source, destination, destinationMessage);\n        try // for casting to XException\n        {\n            XDomSupport.deleteWhitespaceTextInElementNodes(doc);\n        }// try\n         catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return doc;\n    }\n\n    /**\n     * @param inDoc\n     * @param xsltStylesheet\n     * @return ???\n     */\n    public Document transformSingleRecord(Document inDoc, String xsltStylesheet) throws XException {\n        String xslFile = new StringBuffer(XSL_LOCATION).append(xsltStylesheet).toString();\n        return transformXML(inDoc, xslFile, null);\n    }\n}\n// RecordTypeTransformer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeTransformerTest0.java",
		"test_prompt": "// RecordTypeTransformerTest0.java\npackage net.sf.xbus.protocol.records;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport net.sf.xbus.protocol.xml.XSLTTransformer;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeTransformer}.\n* It contains ten unit test cases for the {@link RecordTypeTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass RecordTypeTransformerTest0 {"
	},
	{
		"original_code": "// RecordTypeTransformer.java\npackage net.sf.xbus.protocol.records;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport net.sf.xbus.protocol.xml.XSLTTransformer;\nimport org.w3c.dom.Document;\n\n/**\n * <code>RecordTypeTransformer</code> transforms one\n * {@link net.sf.xbus.protocol.records.RecordTypeMessage RecordTypeMessage} into\n * another one - according to a xsl transformation description. The class is\n * pretty like the\n * {@link net.sf.xbus.protocol.xml.XSLTTransformer XSLTTransformer}. The only\n * difference is a whitespace cleaning after the transformation.\n */\npublic class RecordTypeTransformer extends XSLTTransformer implements Transformer {\n\n    /**\n     * The <code>transform</code> method is automatically called by the xBus\n     * during the routing of messages.\n     *\n     * @param inObject either the request or response that shall be transformed\n     *            to another format\n     * @param source the <code>XBUSSystem</code> of the message of the\n     *            <code>inObject</code>\n     * @param destination the <code>XBUSSystem</code> of the target message\n     * @param destinationMessage the target message eventually contains more\n     *            information necessary for transforming\n     * @return the transformed <code>Object</code>, written to either the\n     *         request or response of the target message\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        Document doc = (Document) super.transform(inObject, source, destination, destinationMessage);\n        try // for casting to XException\n        {\n            XDomSupport.deleteWhitespaceTextInElementNodes(doc);\n        }// try\n         catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return doc;\n    }\n\n    /**\n     * @param inDoc\n     * @param xsltStylesheet\n     * @return ???\n     */\n    public Document transformSingleRecord(Document inDoc, String xsltStylesheet) throws XException {\n        String xslFile = new StringBuffer(XSL_LOCATION).append(xsltStylesheet).toString();\n        return transformXML(inDoc, xslFile, null);\n    }\n}\n// RecordTypeTransformer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeTransformerTest1.java",
		"test_prompt": "// RecordTypeTransformerTest1.java\npackage net.sf.xbus.protocol.records;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport net.sf.xbus.protocol.xml.XSLTTransformer;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeTransformer}.\n* It contains ten unit test cases for the {@link RecordTypeTransformer#transformSingleRecord(Document, String)} method.\n*/\nclass RecordTypeTransformerTest1 {"
	},
	{
		"original_code": "// RecordTypeDescriptionChecker.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>RecordTypeDescriptionChecker</code> checks the xml description of a\n * record type interface. This description explains the structure of the used\n * interface files.\n *\n * @author Stephan D�wel\n */\nclass RecordTypeDescriptionChecker {\n\n    /**\n     * <code>instances</code> stores the instances of the checker by thread.\n     */\n    private static Hashtable instances = new Hashtable();\n\n    /**\n     * <code>getInstance</code> returns a\n     * <code>RecordTypeDescriptionChecker</code> to work with.\n     *\n     * @return a checker instance\n     */\n    public static RecordTypeDescriptionChecker getInstance() {\n        // Instances are stored by thread.\n        RecordTypeDescriptionChecker instance = (RecordTypeDescriptionChecker) instances.get(Thread.currentThread().getName());\n        if (instance == null) {\n            // No checker initialised yet\n            instance = new RecordTypeDescriptionChecker();\n            instances.put(Thread.currentThread().getName(), instance);\n        }\n        // if (instance==null)\n        return instance;\n    }\n\n    // getInstance()\n    // ///////////////////////////////////////////////////\n    // Checking the structrue description top level\n    // ///////////////////////////////////////////////////\n    /**\n     * <code>checkHeaderSpecification</code> checks the consistency of the\n     * file header desription.\n     *\n     * @param headerSpec\n     *            the structure description for the header\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException -\n     *             in case of a inconsistency\n     */\n    public void checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean validated) throws XException {\n        if (!validated && headerSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"1\");\n        }\n        // Now the single fields in the header\n        checkFieldsAndGroupRefs(headerSpec, groupsSpec, null, validated);\n    }\n\n    // checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean\n    // validated)\n    /**\n     * <code>checkLinesSpecification</code> checks the consistency of the\n     * lines section. The lines section lists all record types, declares their\n     * order in the file and specifies how to identify them in the file.\n     * Furthermore is fills the <code>recordTypeNames</code> and\n     * <code>existanceIndicators</code> arrays to prepare checking the\n     * consistency + of the record type declarations and the specifications\n     * afterwards.\n     *\n     * @param linesSpec\n     *            the lines section of the structure description\n     * @param validated\n     *            Is the xml already validated?\n     * @return an array with 2 elements, the first is the array of all record\n     *         type names, the second is an array of existance indicators (<code>null</code>\n     *         if record identification method is \"TypeIdentifier\")\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public Object[] checkLinesSpecification(Element linesSpec, boolean validated) throws XException {\n        // In which order to find the records\n        String recOrder = linesSpec.getAttribute(\"RecordOrder\");\n        if (!validated) {\n            // Errors in the xml?\n            if (recOrder.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"2\");\n            }\n            if (!recOrder.equals(\"Arbitrary\") && !recOrder.equals(\"Ordered\") && !recOrder.equals(\"Structured\")) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"3\");\n            }\n        }\n        // if (!validated)\n        // How to identify the records\n        String recIdentMethod = linesSpec.getAttribute(\"RecordIdentification\");\n        if (!validated) {\n            // Errors in the xml?\n            if (recIdentMethod.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"4\");\n            }\n            if (!recIdentMethod.equals(\"TypeIdentifier\") && !recIdentMethod.equals(\"RecordOrder\")) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"5\");\n            }\n        }\n        // if (!validated)\n        if (recOrder.equals(\"Arbitrary\") && !recIdentMethod.equals(\"TypeIdentifier\")) {\n            // forbidden combination\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"6\");\n        }\n        // the record type declarations or ...\n        // ... the list of record groups, if <recOrder>=\"Structured\"\n        NodeList recordTypes = linesSpec.getChildNodes();\n        int numOfRecordTypes = recordTypes.getLength();\n        // only ok if <recOrder>!=\"Structured\" because otherwise this computes\n        // the number of record groups!!!!!!!!!\n        if (recordTypes.getLength() == 0) {\n            // Extension if no prior DTD validating\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"7\");\n        }\n        // Loop will run over record types, but the identification of record\n        // record groups above is important, as well.\n        // If <recOrder>!=\"Structured\", the parent node is just the Lines node.\n        Node recordGroup = linesSpec;\n        // Now some corrections to the setting so far if record groups must be\n        // treated.\n        if (recOrder.equals(\"Structured\")) {\n            if (!recIdentMethod.equals(\"TypeIdentifier\") && recordTypes.getLength() > 1) {\n                // Several record groups are only allowed if the record types\n                // can\n                // be identiifed by type identifiers.\n                // Attention: <recordTypes> contains the record groups - not the\n                // types!\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"8\");\n            }\n            numOfRecordTypes = 0;\n            // For counting the record types a loop over the record groups is\n            // necessary.\n            for (int i = 0; i < recordTypes.getLength(); i++) {\n                // loop over record groups\n                if (!recordTypes.item(i).getNodeName().equals(\"RecordGroup\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"9\");\n                }\n                numOfRecordTypes += recordTypes.item(i).getChildNodes().getLength();\n                // the number of records in that group\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n            recordGroup = recordTypes.item(0);\n            // for loop over record groups\n            recordTypes = recordGroup.getChildNodes();\n            // the record types one level deeper now, thus really to record\n            // types\n        }\n        // if (recOrder.equals(\"Structured\"))\n        TreeMap[] existanceIndicators = null;\n        // for record types which's occurrence depends on a certain value in the\n        // record before\n        if (recIdentMethod.equals(\"TypeIdentifier\")) {\n            // type identification by type identifier is easy but needs some\n            // values\n            // where to find the identifier within the records\n            String idPos = linesSpec.getAttribute(\"IdentifierPos\");\n            // Where does the identifier start in the record string?\n            if (idPos.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"10\");\n            }\n            String idLength = linesSpec.getAttribute(\"IdentifierLength\");\n            // How long is the type identifier?\n            if (idLength.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"11\");\n            }\n            try {\n                // The position must be a positive integer.\n                int num = Integer.parseInt(idPos);\n                if (num < 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"12\");\n                }\n                // The length as well must be positive integer.\n                // Length 0 is permitted for having a simple handling of files\n                // with\n                // only one record type.\n                num = Integer.parseInt(idLength);\n                if (num < 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"13\");\n                }\n            }// try\n             catch (ClassCastException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n            }\n            // catch\n        } else // then (recIdentMethod.equals(\"TypeIdentifier\"))\n        // Without type identifiers everything gets more complicated ...\n        // ... but the primary value are already set.\n        {\n            // Indicators for successors may be important.\n            existanceIndicators = new TreeMap[numOfRecordTypes];\n            for (int i = 0; i < existanceIndicators.length; i++) existanceIndicators[i] = null;\n            // Will be filled when going through the single record type\n            // declarations.\n        }\n        // else (recIdentMethod.equals(\"TypeIdentifier\"))\n        String[] recordTypeNames = new String[numOfRecordTypes];\n        // Storing the names for consistency check gainst the record type\n        // specification section.\n        LinkedList typeIds = new LinkedList();\n        LinkedList typeIdIntervals = new LinkedList();\n        // Record type identifier may be single values or intervals.\n        // They are stored to check their unique reference to a record type.\n        int recordTypesCount = recordTypes.getLength();\n        // the number of record types in the current record group or at all\n        // (wihtout grouping) - at least if no bad nodes are included in a\n        // errorprone specification\n        int recordTypesBefore = 0;\n        // number of record type declarations checked in other record groups\n        // before - used as offset to datermine the position in the record type\n        // array\n        while (recordGroup != null) {\n            // loop over record groups\n            // - only one loop if <recOrder>!=\"Structured\" because of missing\n            // record groups\n            for (int i = 0; i < recordTypesCount; i++) {\n                // Loop over all record type declarations of the record group\n                Node rType = recordTypes.item(i);\n                // Extension if no DTD validating\n                if (rType.getNodeType() != Node.ELEMENT_NODE || !rType.getNodeName().equals(\"RecordType\")) {\n                    List params = new Vector();\n                    params.add(rType.getNodeName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"15\", params);\n                }\n                // Check the consistency of this single record type declaration.\n                // If its occurrence depends on values in the prececeeding\n                // record\n                // the information about this value is stored in\n                // <dependenceOnPredecessor>.\n                String[] dependenceOnPredecessor = checkRecordTypeDeclaration(rType, recordTypesCount, recordTypesBefore + i, recIdentMethod, recOrder, recordTypeNames, typeIds, typeIdIntervals, existanceIndicators);\n                if (existanceIndicators != null && dependenceOnPredecessor != null) {\n                    // Existance records are expected in general and an\n                    // existance\n                    // indicator is defined for the last cheched record type.\n                    // To ensure that the identification via existance\n                    // indicators\n                    // is possible, the information about them is analysed the\n                    // other\n                    // way round. Originally the information was attached as\n                    // <dependenceOnPredecessor> to the dependent record type.\n                    // Now it will be attached as <existanceIndicators> to its\n                    // possible predecessors.\n                    String occurrences = ((Element) recordTypes.item(i)).getAttribute(\"Occurrences\");\n                    // Cardinality of the record type.\n                    boolean isOptional = CardinalityStrings.isCardinalityInterval(occurrences, true) && CardinalityStrings.getCardinalityLow(occurrences, true) == 0;\n                    for (int j = i - 1; j > -1 && isOptional; j++) {\n                        // Backwards loop to the beginning of the record types\n                        // starting at the predecessor of the examined record\n                        // type.\n                        // As long as a record type is optional, its predecessor\n                        // is\n                        // added to the list of possible predecessors for the\n                        // originally\n                        // checked record type.\n                        // Stops at the first record type because this one may\n                        // not be optional.\n                        // Now information attached to the predecessor.\n                        if (existanceIndicators[j] == null) {\n                            // The predecessor does not yet have identified\n                            // successor\n                            // which depend on an existnace indicator.\n                            existanceIndicators[j] = new TreeMap();\n                            existanceIndicators[j].put(dependenceOnPredecessor[0], dependenceOnPredecessor[1]);\n                        } else // then (existanceIndicators[j]==null)\n                        {\n                            // The predecessor already has information about\n                            // successors.\n                            // Existance indicator value for the existance\n                            // indicator\n                            // field stated in the examined record type, but\n                            // used for\n                            // another record type !?\n                            String value = (String) existanceIndicators[j].get(dependenceOnPredecessor[0]);\n                            if (value != null)\n                                // Existance indicator values in the same field\n                                // for different record types.\n                                if (value.length() != dependenceOnPredecessor[1].length()) {\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"16\");\n                                } else\n                                    // No other use of the existance indicator\n                                    // field yet.\n                                    // Store the new value.\n                                    existanceIndicators[j].put(dependenceOnPredecessor[0], dependenceOnPredecessor[1]);\n                        }\n                        // else (existanceIndicators[j]==null)\n                        occurrences = ((Element) recordTypes.item(j)).getAttribute(\"Occurrences\");\n                        // Cardinality of the last checked record type\n                        isOptional = CardinalityStrings.isCardinalityInterval(occurrences, true) && CardinalityStrings.getCardinalityLow(occurrences, true) == 0;\n                    }\n                    // for (int j=i-1; j>-1 && isOptional; j++)\n                }\n                // if (existanceIndicators!=null &&\n                // dependenceOnPredecessor!=null)\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n            recordTypesBefore += recordTypesCount;\n            // Correct the number of checked record types in the so far\n            // examined record groups\n            if (recordGroup.getNodeName().equals(\"RecordGroup\")) {\n                // record groups really present\n                recordGroup = recordGroup.getNextSibling();\n                // Choose next record group\n                if (recordGroup != null) {\n                    // there is a next record group\n                    recordTypes = recordGroup.getChildNodes();\n                    recordTypesCount = recordTypes.getLength();\n                    // Next check the record types in the new group\n                }\n                // if (recordGroup != null)\n            } else\n                // if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // no real record group loop but record declarations directly\n                // in lines section, terminate loop by setting ...\n                recordGroup = null;\n        }\n        // while (recordGroup!=null) - record group loop\n        // Check record type names for uniqueness.\n        for (int i = 0; i < recordTypeNames.length; i++) for (int j = i + 1; j < recordTypeNames.length; j++) if (recordTypeNames[i].equals(recordTypeNames[j])) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"17\");\n        }\n        // Checks on the type identifier\n        // First check their length\n        // If the record type identification is not done by type identifiers,\n        // the two type id lists are empty.\n        int identifierLength = 0;\n        if (typeIds.size() > 0)\n            // Some single value id's\n            identifierLength = ((String) typeIds.get(0)).length();\n        else if (typeIdIntervals.size() > 0)\n            // No single value id but some id intervals\n            identifierLength = ((String[]) typeIdIntervals.get(0))[0].length();\n        // All id's must have the same length.\n        // First the single value id's\n        for (int i = 1; i < typeIds.size(); i++) if (((String) typeIds.get(0)).length() != identifierLength) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"18\");\n        }\n        // Second the id intervals\n        for (int i = 1; i < typeIdIntervals.size(); i++) // Attention: two values!\n        if (((String[]) typeIdIntervals.get(0))[0].length() != identifierLength || ((String[]) typeIdIntervals.get(0))[1].length() != identifierLength) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"18\");\n        }\n        // Second, check the id uniqueness in sense of identification of only\n        // one\n        // record type\n        if (!typeIdsAreUnique(typeIds, typeIdIntervals)) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"20\");\n        }\n        // Return the found record type names and existance indicators.\n        Object[] checkInfos = new Object[2];\n        checkInfos[0] = recordTypeNames;\n        checkInfos[1] = existanceIndicators;\n        return checkInfos;\n    }\n\n    // checkLinesSpecification(Element linesSpec, boolean validated)\n    /**\n     * <code>checkRecordTypesSpecification</code> checks the section of record\n     * type specifications for consistency. In particular it checks for\n     * existance of the record types and fields named in the lines section.\n     *\n     * @param recordTypesSpec\n     *            the record type specifications section\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param checkInfos\n     *            record type names and existance indicators found in the lines\n     *            section\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec, Object[] checkInfos, boolean validated) throws XException {\n        try // for casting to XException\n        {\n            NodeList recordTypes = recordTypesSpec.getChildNodes();\n            // Here we have no record groups!\n            for (int i = 0; i < recordTypes.getLength(); i++) {\n                // loop over record type specifications\n                Element recordType = (Element) recordTypes.item(i);\n                // Extension if no prior validating\n                if (!recordType.getNodeName().equals(\"RecordTypeSpec\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"21\");\n                }\n                String recTypeName = recordType.getAttribute(\"Name\");\n                // Extension if no prior validating\n                if (recTypeName == null || !XDomSupport.isValidTagName(recTypeName)) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"22\");\n                }\n                // Search record type name in the name array from\n                // the record type (Lines) section.\n                boolean nameSearched = true;\n                // Still searching?\n                int pos = 0;\n                for (; pos < ((String[]) checkInfos[0]).length && nameSearched; pos++) // loop over record type names from the lines section\n                if (recTypeName.equals(((String[]) checkInfos[0])[pos])) {\n                    // name found\n                    ((String[]) checkInfos[0])[pos] = null;\n                    // deleted for avoiding more hits\n                    nameSearched = false;\n                    // search loop ended for this record type\n                }\n                // if\n                // (recTypeName.equals(((String[])checkInfos[0])[pos]))\n                if (nameSearched) {\n                    // Record type not declared in lines section\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"23\");\n                }\n                // Now the single fields in the record type\n                TreeMap existanceIndicators = null;\n                // With the found position in the checkInfos array\n                // the correct existance indicator map is retrieved ...\n                if (checkInfos[1] != null)\n                    // Because pos was augmented once to much in the for loop,\n                    // now\n                    // use pos-1.\n                    existanceIndicators = ((TreeMap[]) checkInfos[1])[pos - 1];\n                // ... and feeded to field checking\n                checkFieldsAndGroupRefs(recordType, groupsSpec, existanceIndicators, validated);\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec,\n    // Object[] checkInfos, boolean validated)\n    /**\n     * <code>checkTrailerSpecification</code> checks the consistency of the\n     * file trailer desription.\n     *\n     * @param trailerSpec\n     *            the structure description for the trailer\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of a inconsistency\n     */\n    public void checkTrailerSpecification(Element trailerSpec, Node groupsSpec, boolean validated) throws XException {\n        // Extension if no prior DTD validating\n        if (trailerSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"1\");\n        }\n        // Now the single fields in the header\n        checkFieldsAndGroupRefs(trailerSpec, groupsSpec, null, validated);\n    }\n\n    // checkTrailerSpecification(Element trailerSpec, Node groupsSpec,\n    // boolean validated)\n    /**\n     * <code>checkGroupsSpecification</code> checks the consistency of each\n     * field group specification.\n     *\n     * @param groupsSpec\n     *            the list of field group specifications\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupsSpecification(Node groupsSpec, boolean validated) throws XException {\n        NodeList groups = groupsSpec.getChildNodes();\n        if (!validated) {\n            // Extension if no prior DTD validating\n            try // for casting to XException\n            {\n                for (int i = 0; i < groups.getLength(); i++) // consistency check on each single group specification\n                // (redundant to validating against DTD)\n                checkGroupSpecification((Element) groups.item(i));\n            }// try\n             catch (ClassCastException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n            }\n            // catch\n        }\n        // if (!validated)\n        // Check for the uniqueness of group names\n        for (int i = 0; i < groups.getLength() - 1; i++) {\n            String groupName = ((Element) groups.item(i)).getAttribute(\"Name\");\n            for (int j = i + 1; j < groups.getLength(); j++) if (groupName.equals(((Element) groups.item(j)).getAttribute(\"Name\"))) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"27\");\n            }\n        }\n        // for (int i=0; i<groups.getLength()-1; i++)\n    }\n\n    // checkGroupsSpecification(Node groupsSpec, boolean validated)\n    // //////////////////////////////////////////////\n    // Structrue checking on some deeper level\n    // //////////////////////////////////////////////\n    /**\n     * <code>checkRecordTypeDeclaration</code> checks a record type\n     * declaration for consistency. Furthermore is fills the\n     * <code>recordTypeNames</code> and <code>existanceIndicators</code> to\n     * check consistency with the record type specifications afterwards.\n     *\n     * @param recTypeDecl\n     *            the DOM node of the declaration\n     * @param recordTypesCount\n     *            the number of record types in the actual record group or the\n     *            whole file (wihtout grouping)\n     * @param pos\n     *            the position in the list of declarations (starts at 0)\n     * @param recIdentMethod\n     *            the method to identify record types\n     * @param recOrder\n     *            the order of records in the file\n     * @param recordTypeNames\n     *            array of record type names, filled at position\n     *            <code>pos</code> right here\n     * @param typeIds\n     *            the list of single-value type id's, a found id will be added\n     * @param typeIdIntervals\n     *            the list of type id intervals, a found interval will be added\n     * @param existanceIndicators\n     *            array of existance indicator maps, potentially filled with\n     *            self reference at position <code>pos</code> right here\n     * @return field/value pair for an existance indicator in the record type\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public String[] checkRecordTypeDeclaration(Node recTypeDecl, int recordTypesCount, int pos, String recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators) throws XException {\n        String[] precedingIndicator = null;\n        // for returning exstistance indicator information for predecessors\n        try // for casting to XException\n        {\n            if (recIdentMethod.equals(\"TypeIdentifier\")) {\n                // Record types are identified by an id\n                String id = ((Element) recTypeDecl).getAttribute(\"Identifier\");\n                // a single-value id\n                String[] idLoHi = new String[2];\n                idLoHi[0] = ((Element) recTypeDecl).getAttribute(\"IdentifierLow\");\n                idLoHi[1] = ((Element) recTypeDecl).getAttribute(\"IdentifierHigh\");\n                // an id interval\n                if (id.length() == 0) {\n                    // No single-value id\n                    if (idLoHi[0].length() == 0 || idLoHi[1].length() == 0) {\n                        // Something must be specified: single value or\n                        // interval.\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"28\");\n                    }\n                    typeIdIntervals.add(idLoHi);\n                } else // then (id.length()==0)\n                {\n                    // Single-value id found\n                    if (idLoHi[0].length() > 0 || idLoHi[1].length() > 0) {\n                        // Any interval specification conflicts.\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"28\");\n                    }\n                    typeIds.add(id);\n                }\n                // else (id.length()==0)\n            }\n            // if (recIdentMethod.equals(\"TypeIdentifier\"))\n            recordTypeNames[pos] = XDomSupport.getTrimedNodeText(recTypeDecl);\n            // the record type name\n            if (!XDomSupport.isValidTagName(recordTypeNames[pos])) {\n                // It must be a legal xml tag name.\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"30\");\n            }\n            // Now look for record identification features, in particular the\n            // cardinality\n            // and existance indicator\n            if (recOrder.equals(\"Ordered\") || recOrder.equals(\"Structured\")) {\n                // Records are listed in the record type order or in groups.\n                // The cardinality must be specified.\n                String occurrences = ((Element) recTypeDecl).getAttribute(\"Occurrences\");\n                if (occurrences.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"31\");\n                }\n                if (!CardinalityStrings.isCardinalityValid(occurrences)) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"32\");\n                }\n                // The first record in a record group must have cardinality 1.\n                if (recOrder.equals(\"Structured\") && pos == 0) {\n                    try {\n                        int occurrNum = Integer.parseInt(occurrences);\n                        if (occurrNum != 1) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"33\");\n                        }\n                    }// try\n                     catch (NumberFormatException e) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"33\");\n                    }\n                    // catch\n                }\n                // if (recOrder.equals(\"Structured\") && pos==0)\n                // If the record type is not given by an id but the cardinality\n                // is specified as an\n                // interval and there are also other record types, there must be\n                // an existance indicator\n                // refering the preceding record.\n                if (recordTypesCount > 1 && !recIdentMethod.equals(\"TypeIdentifier\") && CardinalityStrings.isCardinalityInterval(occurrences, true)) {\n                    String existIndField = ((Element) recTypeDecl).getAttribute(\"ExistIndicatorField\");\n                    // Indicator field specified by name\n                    if (existIndField.length() == 0) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"35\");\n                    }\n                    String existIndValue = ((Element) recTypeDecl).getAttribute(\"ExistIndicatorValue\");\n                    if (existIndValue.length() == 0) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"36\");\n                    }\n                    precedingIndicator = new String[2];\n                    precedingIndicator[0] = existIndField;\n                    precedingIndicator[1] = existIndValue;\n                    // If the record type may occurr more than once, it may be\n                    // its\n                    // predecessor itself.\n                    if (CardinalityStrings.getCardinalityHigh(occurrences, true) > 1) {\n                        existanceIndicators[pos] = new TreeMap();\n                        existanceIndicators[pos].put(precedingIndicator[0], precedingIndicator[1]);\n                    }\n                    // if (getCardinalityHigh(occurrences,true)>1)\n                }\n                // if (!recIdentMethod.equals(\"TypeIdentifier\") &&\n                // isCardinalityInterval(occurrences,true))\n            }\n            // if (recOrder.equals(\"Ordered\") ||\n            // recOrder.equals(\"Structured\"))\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return precedingIndicator;\n        // Group starting record type found?\n    }\n\n    // checkRecordTypeDeclaration(Node recTypeDecl, int pos, String\n    // recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList\n    // typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators)\n    /**\n     * <code>checkFieldsAndGroupRefs</code> checks the fields and group\n     * references within an record type (including header and trailer) for\n     * consistency.\n     *\n     * @param parent\n     *            the record type specification node\n     * @param groupsSpec\n     *            the list of field group specifications\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to fields will be marked\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    private void checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap existanceIndicators, boolean validated) throws XException {\n        try // try-catch block for casting standard exceptions to XException\n        {\n            NodeList fieldSpecs = parent.getChildNodes();\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                // Two alternatives: field or group\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    checkFieldSpecification(fieldSpec, existanceIndicators, validated);\n                else if (fieldSpec.getNodeName().equals(\"Group\"))\n                    checkGroupReference(fieldSpec, groupsSpec, existanceIndicators);\n                else // Extension if no prior DTD validating\n                {\n                    List params = new Vector();\n                    params.add(fieldSpec.getNodeName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"38\", params);\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap\n    // existanceIndicators)\n    /**\n     * <code>checkGroupReference</code> checks the consistency of a reference\n     * to a field group.\n     *\n     * @param groupRef\n     *            the DOM node for the group reference\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to group fields will be marked\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupReference(Element groupRef, Node groupsSpec, TreeMap existanceIndicators) throws XException {\n        try {\n            String groupName = groupRef.getAttribute(\"Name\");\n            // Extension if no prior DTD validating\n            if (groupName.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"40\");\n            }\n            // Search for the group specification.\n            if (groupsSpec == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"41\");\n            }\n            List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec, \"Name\", groupName, \"GroupSpec\");\n            if (groups == null || groups.size() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"42\");\n            }\n            if (groups.size() > 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"43\");\n            }\n            // Group specification found\n            // some existance indicators to search for\n            if (existanceIndicators != null) {\n                NodeList fields = ((Node) groups.get(0)).getChildNodes();\n                for (int i = 0; i < fields.getLength(); i++) {\n                    String name = ((Element) fields.item(i)).getAttribute(\"Name\");\n                    String value = (String) existanceIndicators.get(name);\n                    if (value != null) {\n                        if (value.equals(\"Found\")) {\n                            // Will always occurr if a record type contains more\n                            // than one instance of\n                            // a group. Thus, existance indicators in group\n                            // should not occurr.\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"44\");\n                        }\n                        int length = Integer.parseInt(((Element) fields.item(i)).getAttribute(\"Length\"));\n                        if (value.length() != length) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"45\");\n                        }\n                        // Mark as found.\n                        existanceIndicators.put(name, \"Found\");\n                    }\n                    // if (value!=null)\n                }\n                // for (int i=0; i<fields.getLength(); i++)\n            }\n            // if (existanceIndicators!=null)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n    }\n\n    // checkGroupReference(Element groupRef, Node groupsSpec, TreeMap\n    // existanceIndicators)\n    /**\n     * <code>checkFieldSpecification</code> checks the consistency of a field\n     * specification.\n     *\n     * @param fieldSpec\n     *            the DOM node for the field specification\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to field will be marked\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    private void checkFieldSpecification(Element fieldSpec, TreeMap existanceIndicators, boolean validated) throws XException {\n        try {\n            // Field name\n            String name = fieldSpec.getAttribute(\"Name\");\n            // Field length\n            String length = fieldSpec.getAttribute(\"Length\");\n            // Field format\n            String format = fieldSpec.getAttribute(\"Format\");\n            if (!validated) {\n                // Extension if no prior DTD validating\n                if (name.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"48\");\n                }\n                if (length.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"49\");\n                }\n                if (format.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"50\");\n                }\n            }\n            // if (!validated)\n            // For dates further format infoamtion is mandatory.\n            if (format.equals(\"date\") && fieldSpec.getAttribute(\"DateFormat\").length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"51\");\n            }\n            // The length must be an strictly positive integer\n            int lengthNum = Integer.parseInt(length);\n            if (lengthNum < 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"52\");\n            }\n            // Constant values must be bound to a value.\n            if (format.equals(\"const\")) {\n                String value = fieldSpec.getAttribute(\"Value\");\n                if (value.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"53\");\n                } else if (value.length() != lengthNum) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"54\");\n                }\n            }\n            // if (fieldSpec.getAttribute(\"Format\").equals(\"const\"))\n            // some existance indicators to search for\n            if (existanceIndicators != null) {\n                String value = (String) existanceIndicators.get(name);\n                if (value != null) {\n                    // existance indicator defined for this field\n                    if (value.equals(\"Found\")) {\n                        // Already found for other field\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"44\");\n                    }\n                    if (value.length() != lengthNum) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"45\");\n                    }\n                    // Mark as found.\n                    existanceIndicators.put(name, \"Found\");\n                }\n                // if (value!=null)\n            }\n            // if (existanceIndicators!=null)\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }// catch\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkFieldSpecification(Element fieldSpec, TreeMap\n    // existanceIndicators, boolean validated)\n    /**\n     * <code>checkGroupSpecification</code> checks the consistency of a single\n     * field group specification. Extension if no prior DTD validating because\n     * otherwise completely redundant.\n     *\n     * @param groupSpec\n     *            the group specification to check as DOM node\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupSpecification(Element groupSpec) throws XException {\n        if (groupSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"59\");\n        }\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = groupSpec.getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all group fields\n                if (!((Element) fieldSpecs.item(i)).getNodeName().equals(\"Field\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"60\");\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkGroupSpecification(Node groupSpec)\n    // ///////////////////////\n    // Auxiliary functions\n    // ///////////////////////\n    /**\n     * <code>typeIdsAreUnique</code> checks if each declared record type id\n     * refers uniquely to only one record type.\n     *\n     * @param typeIds\n     *            single-value id's as found in the record type declarations\n     * @param typeIdIntervals\n     *            intervals of id's (used as counters) as found in the record\n     *            type declarations\n     * @return <code>true</code> if all id's are unique, false if an id refers\n     *         to two record types\n     */\n    public boolean typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals) {\n        boolean result = true;\n        for (int i = 0; i < typeIds.size() && result; i++) {\n            // Loop over all single-value id's\n            for (int j = i + 1; j < typeIds.size() && result; j++) // Loop over rest of single-value id's\n            result = !((String) typeIds.get(i)).equals((typeIds.get(j)));\n            // Repeated id?\n            for (int j = 0; j < typeIdIntervals.size() && result; j++) // Loop over all id intervals\n            result = (((String) typeIds.get(i)).compareTo(((String[]) typeIdIntervals.get(j))[0]) < 0) || (((String) typeIds.get(i)).compareTo(((String[]) typeIdIntervals.get(j))[1]) > 0);\n            // Or member of one of the intervals?\n        }\n        // for (int i=0; i<typeIds.size() && result; i++)\n        for (int i = 0; i < typeIdIntervals.size() && result; i++) // Loop over all id intervals\n        for (int j = i + 1; j < typeIdIntervals.size() && result; j++) // Loop over rest of intervals\n        result = (((String[]) typeIdIntervals.get(i))[0].compareTo(((String[]) typeIdIntervals.get(j))[1]) > 0) || (((String[]) typeIdIntervals.get(i))[1].compareTo(((String[]) typeIdIntervals.get(j))[0]) < 0);\n        // Do the two intervals intersect?\n        return result;\n    }\n\n    // typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals)\n    /**\n     * <code>computeRecordLength</code> calculates the string length for a\n     * record type - including header and trailer.\n     *\n     * @param spec\n     *            the record type specification\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the total length including filler\n     * @throws XException\n     *             in case of a mal-specified length\n     */\n    protected static int computeRecordLength(Node spec, Node groupsSpec) throws XException {\n        int fieldLengthSum = 0;\n        // for the result\n        NodeList fieldSpecs = spec.getChildNodes();\n        try // to cast to XException\n        {\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    fieldLengthSum += Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n                else if (fieldSpec.getNodeName().equals(\"Group\"))\n                    fieldLengthSum += computeGroupLength(fieldSpec, groupsSpec);\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        return fieldLengthSum;\n    }\n\n    // computeRecordLength(Element spec)\n    /**\n     * <code>computeGroupLength</code> calculates the string length for a\n     * field group.\n     *\n     * @param groupRef\n     *            a refernce to the group\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the total length including filler\n     * @throws XException\n     *             in case of a mal-specified length or missing group\n     *             specification\n     */\n    protected static int computeGroupLength(Element groupRef, Node groupsSpec) throws XException {\n        int groupLengthSum = 0;\n        // for the result\n        NodeList fieldSpecs = getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n        // the group specification\n        try // for casting to XException\n        {\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    groupLengthSum += Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n                else {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"63\");\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return groupLengthSum;\n    }\n\n    // computeGroupLength(Element groupRef, Node groupsSpec)\n    /**\n     * <code>getGroupSpec</code> selects the group specification node by the\n     * group name.\n     *\n     * @param groupName\n     *            the name of the field group\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the group specification node\n     * @throws XException\n     *             in case that the group specification cannot be retrieved\n     */\n    protected static Node getGroupSpec(String groupName, Node groupsSpec) throws XException {\n        Node result = null;\n        try // for casting to XException\n        {\n            List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec, \"Name\", groupName, \"GroupSpec\");\n            if (groups.size() != 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"65\");\n            }\n            result = (Node) groups.get(0);\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return result;\n    }\n    // getGroupSpec(String groupName, Node groupsSpec)\n}\n// RecordTypeDescriptionChecker\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeDescriptionCheckerTest0.java",
		"test_prompt": "// RecordTypeDescriptionCheckerTest0.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeDescriptionChecker}.\n* It contains ten unit test cases for the {@link RecordTypeDescriptionChecker#getInstance()} method.\n*/\nclass RecordTypeDescriptionCheckerTest0 {"
	},
	{
		"original_code": "// RecordTypeDescriptionChecker.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>RecordTypeDescriptionChecker</code> checks the xml description of a\n * record type interface. This description explains the structure of the used\n * interface files.\n *\n * @author Stephan D�wel\n */\nclass RecordTypeDescriptionChecker {\n\n    /**\n     * <code>instances</code> stores the instances of the checker by thread.\n     */\n    private static Hashtable instances = new Hashtable();\n\n    /**\n     * <code>getInstance</code> returns a\n     * <code>RecordTypeDescriptionChecker</code> to work with.\n     *\n     * @return a checker instance\n     */\n    public static RecordTypeDescriptionChecker getInstance() {\n        // Instances are stored by thread.\n        RecordTypeDescriptionChecker instance = (RecordTypeDescriptionChecker) instances.get(Thread.currentThread().getName());\n        if (instance == null) {\n            // No checker initialised yet\n            instance = new RecordTypeDescriptionChecker();\n            instances.put(Thread.currentThread().getName(), instance);\n        }\n        // if (instance==null)\n        return instance;\n    }\n\n    // getInstance()\n    // ///////////////////////////////////////////////////\n    // Checking the structrue description top level\n    // ///////////////////////////////////////////////////\n    /**\n     * <code>checkHeaderSpecification</code> checks the consistency of the\n     * file header desription.\n     *\n     * @param headerSpec\n     *            the structure description for the header\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException -\n     *             in case of a inconsistency\n     */\n    public void checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean validated) throws XException {\n        if (!validated && headerSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"1\");\n        }\n        // Now the single fields in the header\n        checkFieldsAndGroupRefs(headerSpec, groupsSpec, null, validated);\n    }\n\n    // checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean\n    // validated)\n    /**\n     * <code>checkLinesSpecification</code> checks the consistency of the\n     * lines section. The lines section lists all record types, declares their\n     * order in the file and specifies how to identify them in the file.\n     * Furthermore is fills the <code>recordTypeNames</code> and\n     * <code>existanceIndicators</code> arrays to prepare checking the\n     * consistency + of the record type declarations and the specifications\n     * afterwards.\n     *\n     * @param linesSpec\n     *            the lines section of the structure description\n     * @param validated\n     *            Is the xml already validated?\n     * @return an array with 2 elements, the first is the array of all record\n     *         type names, the second is an array of existance indicators (<code>null</code>\n     *         if record identification method is \"TypeIdentifier\")\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public Object[] checkLinesSpecification(Element linesSpec, boolean validated) throws XException {\n        // In which order to find the records\n        String recOrder = linesSpec.getAttribute(\"RecordOrder\");\n        if (!validated) {\n            // Errors in the xml?\n            if (recOrder.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"2\");\n            }\n            if (!recOrder.equals(\"Arbitrary\") && !recOrder.equals(\"Ordered\") && !recOrder.equals(\"Structured\")) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"3\");\n            }\n        }\n        // if (!validated)\n        // How to identify the records\n        String recIdentMethod = linesSpec.getAttribute(\"RecordIdentification\");\n        if (!validated) {\n            // Errors in the xml?\n            if (recIdentMethod.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"4\");\n            }\n            if (!recIdentMethod.equals(\"TypeIdentifier\") && !recIdentMethod.equals(\"RecordOrder\")) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"5\");\n            }\n        }\n        // if (!validated)\n        if (recOrder.equals(\"Arbitrary\") && !recIdentMethod.equals(\"TypeIdentifier\")) {\n            // forbidden combination\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"6\");\n        }\n        // the record type declarations or ...\n        // ... the list of record groups, if <recOrder>=\"Structured\"\n        NodeList recordTypes = linesSpec.getChildNodes();\n        int numOfRecordTypes = recordTypes.getLength();\n        // only ok if <recOrder>!=\"Structured\" because otherwise this computes\n        // the number of record groups!!!!!!!!!\n        if (recordTypes.getLength() == 0) {\n            // Extension if no prior DTD validating\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"7\");\n        }\n        // Loop will run over record types, but the identification of record\n        // record groups above is important, as well.\n        // If <recOrder>!=\"Structured\", the parent node is just the Lines node.\n        Node recordGroup = linesSpec;\n        // Now some corrections to the setting so far if record groups must be\n        // treated.\n        if (recOrder.equals(\"Structured\")) {\n            if (!recIdentMethod.equals(\"TypeIdentifier\") && recordTypes.getLength() > 1) {\n                // Several record groups are only allowed if the record types\n                // can\n                // be identiifed by type identifiers.\n                // Attention: <recordTypes> contains the record groups - not the\n                // types!\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"8\");\n            }\n            numOfRecordTypes = 0;\n            // For counting the record types a loop over the record groups is\n            // necessary.\n            for (int i = 0; i < recordTypes.getLength(); i++) {\n                // loop over record groups\n                if (!recordTypes.item(i).getNodeName().equals(\"RecordGroup\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"9\");\n                }\n                numOfRecordTypes += recordTypes.item(i).getChildNodes().getLength();\n                // the number of records in that group\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n            recordGroup = recordTypes.item(0);\n            // for loop over record groups\n            recordTypes = recordGroup.getChildNodes();\n            // the record types one level deeper now, thus really to record\n            // types\n        }\n        // if (recOrder.equals(\"Structured\"))\n        TreeMap[] existanceIndicators = null;\n        // for record types which's occurrence depends on a certain value in the\n        // record before\n        if (recIdentMethod.equals(\"TypeIdentifier\")) {\n            // type identification by type identifier is easy but needs some\n            // values\n            // where to find the identifier within the records\n            String idPos = linesSpec.getAttribute(\"IdentifierPos\");\n            // Where does the identifier start in the record string?\n            if (idPos.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"10\");\n            }\n            String idLength = linesSpec.getAttribute(\"IdentifierLength\");\n            // How long is the type identifier?\n            if (idLength.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"11\");\n            }\n            try {\n                // The position must be a positive integer.\n                int num = Integer.parseInt(idPos);\n                if (num < 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"12\");\n                }\n                // The length as well must be positive integer.\n                // Length 0 is permitted for having a simple handling of files\n                // with\n                // only one record type.\n                num = Integer.parseInt(idLength);\n                if (num < 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"13\");\n                }\n            }// try\n             catch (ClassCastException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n            }\n            // catch\n        } else // then (recIdentMethod.equals(\"TypeIdentifier\"))\n        // Without type identifiers everything gets more complicated ...\n        // ... but the primary value are already set.\n        {\n            // Indicators for successors may be important.\n            existanceIndicators = new TreeMap[numOfRecordTypes];\n            for (int i = 0; i < existanceIndicators.length; i++) existanceIndicators[i] = null;\n            // Will be filled when going through the single record type\n            // declarations.\n        }\n        // else (recIdentMethod.equals(\"TypeIdentifier\"))\n        String[] recordTypeNames = new String[numOfRecordTypes];\n        // Storing the names for consistency check gainst the record type\n        // specification section.\n        LinkedList typeIds = new LinkedList();\n        LinkedList typeIdIntervals = new LinkedList();\n        // Record type identifier may be single values or intervals.\n        // They are stored to check their unique reference to a record type.\n        int recordTypesCount = recordTypes.getLength();\n        // the number of record types in the current record group or at all\n        // (wihtout grouping) - at least if no bad nodes are included in a\n        // errorprone specification\n        int recordTypesBefore = 0;\n        // number of record type declarations checked in other record groups\n        // before - used as offset to datermine the position in the record type\n        // array\n        while (recordGroup != null) {\n            // loop over record groups\n            // - only one loop if <recOrder>!=\"Structured\" because of missing\n            // record groups\n            for (int i = 0; i < recordTypesCount; i++) {\n                // Loop over all record type declarations of the record group\n                Node rType = recordTypes.item(i);\n                // Extension if no DTD validating\n                if (rType.getNodeType() != Node.ELEMENT_NODE || !rType.getNodeName().equals(\"RecordType\")) {\n                    List params = new Vector();\n                    params.add(rType.getNodeName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"15\", params);\n                }\n                // Check the consistency of this single record type declaration.\n                // If its occurrence depends on values in the prececeeding\n                // record\n                // the information about this value is stored in\n                // <dependenceOnPredecessor>.\n                String[] dependenceOnPredecessor = checkRecordTypeDeclaration(rType, recordTypesCount, recordTypesBefore + i, recIdentMethod, recOrder, recordTypeNames, typeIds, typeIdIntervals, existanceIndicators);\n                if (existanceIndicators != null && dependenceOnPredecessor != null) {\n                    // Existance records are expected in general and an\n                    // existance\n                    // indicator is defined for the last cheched record type.\n                    // To ensure that the identification via existance\n                    // indicators\n                    // is possible, the information about them is analysed the\n                    // other\n                    // way round. Originally the information was attached as\n                    // <dependenceOnPredecessor> to the dependent record type.\n                    // Now it will be attached as <existanceIndicators> to its\n                    // possible predecessors.\n                    String occurrences = ((Element) recordTypes.item(i)).getAttribute(\"Occurrences\");\n                    // Cardinality of the record type.\n                    boolean isOptional = CardinalityStrings.isCardinalityInterval(occurrences, true) && CardinalityStrings.getCardinalityLow(occurrences, true) == 0;\n                    for (int j = i - 1; j > -1 && isOptional; j++) {\n                        // Backwards loop to the beginning of the record types\n                        // starting at the predecessor of the examined record\n                        // type.\n                        // As long as a record type is optional, its predecessor\n                        // is\n                        // added to the list of possible predecessors for the\n                        // originally\n                        // checked record type.\n                        // Stops at the first record type because this one may\n                        // not be optional.\n                        // Now information attached to the predecessor.\n                        if (existanceIndicators[j] == null) {\n                            // The predecessor does not yet have identified\n                            // successor\n                            // which depend on an existnace indicator.\n                            existanceIndicators[j] = new TreeMap();\n                            existanceIndicators[j].put(dependenceOnPredecessor[0], dependenceOnPredecessor[1]);\n                        } else // then (existanceIndicators[j]==null)\n                        {\n                            // The predecessor already has information about\n                            // successors.\n                            // Existance indicator value for the existance\n                            // indicator\n                            // field stated in the examined record type, but\n                            // used for\n                            // another record type !?\n                            String value = (String) existanceIndicators[j].get(dependenceOnPredecessor[0]);\n                            if (value != null)\n                                // Existance indicator values in the same field\n                                // for different record types.\n                                if (value.length() != dependenceOnPredecessor[1].length()) {\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"16\");\n                                } else\n                                    // No other use of the existance indicator\n                                    // field yet.\n                                    // Store the new value.\n                                    existanceIndicators[j].put(dependenceOnPredecessor[0], dependenceOnPredecessor[1]);\n                        }\n                        // else (existanceIndicators[j]==null)\n                        occurrences = ((Element) recordTypes.item(j)).getAttribute(\"Occurrences\");\n                        // Cardinality of the last checked record type\n                        isOptional = CardinalityStrings.isCardinalityInterval(occurrences, true) && CardinalityStrings.getCardinalityLow(occurrences, true) == 0;\n                    }\n                    // for (int j=i-1; j>-1 && isOptional; j++)\n                }\n                // if (existanceIndicators!=null &&\n                // dependenceOnPredecessor!=null)\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n            recordTypesBefore += recordTypesCount;\n            // Correct the number of checked record types in the so far\n            // examined record groups\n            if (recordGroup.getNodeName().equals(\"RecordGroup\")) {\n                // record groups really present\n                recordGroup = recordGroup.getNextSibling();\n                // Choose next record group\n                if (recordGroup != null) {\n                    // there is a next record group\n                    recordTypes = recordGroup.getChildNodes();\n                    recordTypesCount = recordTypes.getLength();\n                    // Next check the record types in the new group\n                }\n                // if (recordGroup != null)\n            } else\n                // if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // no real record group loop but record declarations directly\n                // in lines section, terminate loop by setting ...\n                recordGroup = null;\n        }\n        // while (recordGroup!=null) - record group loop\n        // Check record type names for uniqueness.\n        for (int i = 0; i < recordTypeNames.length; i++) for (int j = i + 1; j < recordTypeNames.length; j++) if (recordTypeNames[i].equals(recordTypeNames[j])) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"17\");\n        }\n        // Checks on the type identifier\n        // First check their length\n        // If the record type identification is not done by type identifiers,\n        // the two type id lists are empty.\n        int identifierLength = 0;\n        if (typeIds.size() > 0)\n            // Some single value id's\n            identifierLength = ((String) typeIds.get(0)).length();\n        else if (typeIdIntervals.size() > 0)\n            // No single value id but some id intervals\n            identifierLength = ((String[]) typeIdIntervals.get(0))[0].length();\n        // All id's must have the same length.\n        // First the single value id's\n        for (int i = 1; i < typeIds.size(); i++) if (((String) typeIds.get(0)).length() != identifierLength) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"18\");\n        }\n        // Second the id intervals\n        for (int i = 1; i < typeIdIntervals.size(); i++) // Attention: two values!\n        if (((String[]) typeIdIntervals.get(0))[0].length() != identifierLength || ((String[]) typeIdIntervals.get(0))[1].length() != identifierLength) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"18\");\n        }\n        // Second, check the id uniqueness in sense of identification of only\n        // one\n        // record type\n        if (!typeIdsAreUnique(typeIds, typeIdIntervals)) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"20\");\n        }\n        // Return the found record type names and existance indicators.\n        Object[] checkInfos = new Object[2];\n        checkInfos[0] = recordTypeNames;\n        checkInfos[1] = existanceIndicators;\n        return checkInfos;\n    }\n\n    // checkLinesSpecification(Element linesSpec, boolean validated)\n    /**\n     * <code>checkRecordTypesSpecification</code> checks the section of record\n     * type specifications for consistency. In particular it checks for\n     * existance of the record types and fields named in the lines section.\n     *\n     * @param recordTypesSpec\n     *            the record type specifications section\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param checkInfos\n     *            record type names and existance indicators found in the lines\n     *            section\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec, Object[] checkInfos, boolean validated) throws XException {\n        try // for casting to XException\n        {\n            NodeList recordTypes = recordTypesSpec.getChildNodes();\n            // Here we have no record groups!\n            for (int i = 0; i < recordTypes.getLength(); i++) {\n                // loop over record type specifications\n                Element recordType = (Element) recordTypes.item(i);\n                // Extension if no prior validating\n                if (!recordType.getNodeName().equals(\"RecordTypeSpec\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"21\");\n                }\n                String recTypeName = recordType.getAttribute(\"Name\");\n                // Extension if no prior validating\n                if (recTypeName == null || !XDomSupport.isValidTagName(recTypeName)) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"22\");\n                }\n                // Search record type name in the name array from\n                // the record type (Lines) section.\n                boolean nameSearched = true;\n                // Still searching?\n                int pos = 0;\n                for (; pos < ((String[]) checkInfos[0]).length && nameSearched; pos++) // loop over record type names from the lines section\n                if (recTypeName.equals(((String[]) checkInfos[0])[pos])) {\n                    // name found\n                    ((String[]) checkInfos[0])[pos] = null;\n                    // deleted for avoiding more hits\n                    nameSearched = false;\n                    // search loop ended for this record type\n                }\n                // if\n                // (recTypeName.equals(((String[])checkInfos[0])[pos]))\n                if (nameSearched) {\n                    // Record type not declared in lines section\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"23\");\n                }\n                // Now the single fields in the record type\n                TreeMap existanceIndicators = null;\n                // With the found position in the checkInfos array\n                // the correct existance indicator map is retrieved ...\n                if (checkInfos[1] != null)\n                    // Because pos was augmented once to much in the for loop,\n                    // now\n                    // use pos-1.\n                    existanceIndicators = ((TreeMap[]) checkInfos[1])[pos - 1];\n                // ... and feeded to field checking\n                checkFieldsAndGroupRefs(recordType, groupsSpec, existanceIndicators, validated);\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec,\n    // Object[] checkInfos, boolean validated)\n    /**\n     * <code>checkTrailerSpecification</code> checks the consistency of the\n     * file trailer desription.\n     *\n     * @param trailerSpec\n     *            the structure description for the trailer\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of a inconsistency\n     */\n    public void checkTrailerSpecification(Element trailerSpec, Node groupsSpec, boolean validated) throws XException {\n        // Extension if no prior DTD validating\n        if (trailerSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"1\");\n        }\n        // Now the single fields in the header\n        checkFieldsAndGroupRefs(trailerSpec, groupsSpec, null, validated);\n    }\n\n    // checkTrailerSpecification(Element trailerSpec, Node groupsSpec,\n    // boolean validated)\n    /**\n     * <code>checkGroupsSpecification</code> checks the consistency of each\n     * field group specification.\n     *\n     * @param groupsSpec\n     *            the list of field group specifications\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupsSpecification(Node groupsSpec, boolean validated) throws XException {\n        NodeList groups = groupsSpec.getChildNodes();\n        if (!validated) {\n            // Extension if no prior DTD validating\n            try // for casting to XException\n            {\n                for (int i = 0; i < groups.getLength(); i++) // consistency check on each single group specification\n                // (redundant to validating against DTD)\n                checkGroupSpecification((Element) groups.item(i));\n            }// try\n             catch (ClassCastException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n            }\n            // catch\n        }\n        // if (!validated)\n        // Check for the uniqueness of group names\n        for (int i = 0; i < groups.getLength() - 1; i++) {\n            String groupName = ((Element) groups.item(i)).getAttribute(\"Name\");\n            for (int j = i + 1; j < groups.getLength(); j++) if (groupName.equals(((Element) groups.item(j)).getAttribute(\"Name\"))) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"27\");\n            }\n        }\n        // for (int i=0; i<groups.getLength()-1; i++)\n    }\n\n    // checkGroupsSpecification(Node groupsSpec, boolean validated)\n    // //////////////////////////////////////////////\n    // Structrue checking on some deeper level\n    // //////////////////////////////////////////////\n    /**\n     * <code>checkRecordTypeDeclaration</code> checks a record type\n     * declaration for consistency. Furthermore is fills the\n     * <code>recordTypeNames</code> and <code>existanceIndicators</code> to\n     * check consistency with the record type specifications afterwards.\n     *\n     * @param recTypeDecl\n     *            the DOM node of the declaration\n     * @param recordTypesCount\n     *            the number of record types in the actual record group or the\n     *            whole file (wihtout grouping)\n     * @param pos\n     *            the position in the list of declarations (starts at 0)\n     * @param recIdentMethod\n     *            the method to identify record types\n     * @param recOrder\n     *            the order of records in the file\n     * @param recordTypeNames\n     *            array of record type names, filled at position\n     *            <code>pos</code> right here\n     * @param typeIds\n     *            the list of single-value type id's, a found id will be added\n     * @param typeIdIntervals\n     *            the list of type id intervals, a found interval will be added\n     * @param existanceIndicators\n     *            array of existance indicator maps, potentially filled with\n     *            self reference at position <code>pos</code> right here\n     * @return field/value pair for an existance indicator in the record type\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public String[] checkRecordTypeDeclaration(Node recTypeDecl, int recordTypesCount, int pos, String recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators) throws XException {\n        String[] precedingIndicator = null;\n        // for returning exstistance indicator information for predecessors\n        try // for casting to XException\n        {\n            if (recIdentMethod.equals(\"TypeIdentifier\")) {\n                // Record types are identified by an id\n                String id = ((Element) recTypeDecl).getAttribute(\"Identifier\");\n                // a single-value id\n                String[] idLoHi = new String[2];\n                idLoHi[0] = ((Element) recTypeDecl).getAttribute(\"IdentifierLow\");\n                idLoHi[1] = ((Element) recTypeDecl).getAttribute(\"IdentifierHigh\");\n                // an id interval\n                if (id.length() == 0) {\n                    // No single-value id\n                    if (idLoHi[0].length() == 0 || idLoHi[1].length() == 0) {\n                        // Something must be specified: single value or\n                        // interval.\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"28\");\n                    }\n                    typeIdIntervals.add(idLoHi);\n                } else // then (id.length()==0)\n                {\n                    // Single-value id found\n                    if (idLoHi[0].length() > 0 || idLoHi[1].length() > 0) {\n                        // Any interval specification conflicts.\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"28\");\n                    }\n                    typeIds.add(id);\n                }\n                // else (id.length()==0)\n            }\n            // if (recIdentMethod.equals(\"TypeIdentifier\"))\n            recordTypeNames[pos] = XDomSupport.getTrimedNodeText(recTypeDecl);\n            // the record type name\n            if (!XDomSupport.isValidTagName(recordTypeNames[pos])) {\n                // It must be a legal xml tag name.\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"30\");\n            }\n            // Now look for record identification features, in particular the\n            // cardinality\n            // and existance indicator\n            if (recOrder.equals(\"Ordered\") || recOrder.equals(\"Structured\")) {\n                // Records are listed in the record type order or in groups.\n                // The cardinality must be specified.\n                String occurrences = ((Element) recTypeDecl).getAttribute(\"Occurrences\");\n                if (occurrences.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"31\");\n                }\n                if (!CardinalityStrings.isCardinalityValid(occurrences)) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"32\");\n                }\n                // The first record in a record group must have cardinality 1.\n                if (recOrder.equals(\"Structured\") && pos == 0) {\n                    try {\n                        int occurrNum = Integer.parseInt(occurrences);\n                        if (occurrNum != 1) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"33\");\n                        }\n                    }// try\n                     catch (NumberFormatException e) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"33\");\n                    }\n                    // catch\n                }\n                // if (recOrder.equals(\"Structured\") && pos==0)\n                // If the record type is not given by an id but the cardinality\n                // is specified as an\n                // interval and there are also other record types, there must be\n                // an existance indicator\n                // refering the preceding record.\n                if (recordTypesCount > 1 && !recIdentMethod.equals(\"TypeIdentifier\") && CardinalityStrings.isCardinalityInterval(occurrences, true)) {\n                    String existIndField = ((Element) recTypeDecl).getAttribute(\"ExistIndicatorField\");\n                    // Indicator field specified by name\n                    if (existIndField.length() == 0) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"35\");\n                    }\n                    String existIndValue = ((Element) recTypeDecl).getAttribute(\"ExistIndicatorValue\");\n                    if (existIndValue.length() == 0) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"36\");\n                    }\n                    precedingIndicator = new String[2];\n                    precedingIndicator[0] = existIndField;\n                    precedingIndicator[1] = existIndValue;\n                    // If the record type may occurr more than once, it may be\n                    // its\n                    // predecessor itself.\n                    if (CardinalityStrings.getCardinalityHigh(occurrences, true) > 1) {\n                        existanceIndicators[pos] = new TreeMap();\n                        existanceIndicators[pos].put(precedingIndicator[0], precedingIndicator[1]);\n                    }\n                    // if (getCardinalityHigh(occurrences,true)>1)\n                }\n                // if (!recIdentMethod.equals(\"TypeIdentifier\") &&\n                // isCardinalityInterval(occurrences,true))\n            }\n            // if (recOrder.equals(\"Ordered\") ||\n            // recOrder.equals(\"Structured\"))\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return precedingIndicator;\n        // Group starting record type found?\n    }\n\n    // checkRecordTypeDeclaration(Node recTypeDecl, int pos, String\n    // recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList\n    // typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators)\n    /**\n     * <code>checkFieldsAndGroupRefs</code> checks the fields and group\n     * references within an record type (including header and trailer) for\n     * consistency.\n     *\n     * @param parent\n     *            the record type specification node\n     * @param groupsSpec\n     *            the list of field group specifications\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to fields will be marked\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    private void checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap existanceIndicators, boolean validated) throws XException {\n        try // try-catch block for casting standard exceptions to XException\n        {\n            NodeList fieldSpecs = parent.getChildNodes();\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                // Two alternatives: field or group\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    checkFieldSpecification(fieldSpec, existanceIndicators, validated);\n                else if (fieldSpec.getNodeName().equals(\"Group\"))\n                    checkGroupReference(fieldSpec, groupsSpec, existanceIndicators);\n                else // Extension if no prior DTD validating\n                {\n                    List params = new Vector();\n                    params.add(fieldSpec.getNodeName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"38\", params);\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap\n    // existanceIndicators)\n    /**\n     * <code>checkGroupReference</code> checks the consistency of a reference\n     * to a field group.\n     *\n     * @param groupRef\n     *            the DOM node for the group reference\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to group fields will be marked\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupReference(Element groupRef, Node groupsSpec, TreeMap existanceIndicators) throws XException {\n        try {\n            String groupName = groupRef.getAttribute(\"Name\");\n            // Extension if no prior DTD validating\n            if (groupName.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"40\");\n            }\n            // Search for the group specification.\n            if (groupsSpec == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"41\");\n            }\n            List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec, \"Name\", groupName, \"GroupSpec\");\n            if (groups == null || groups.size() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"42\");\n            }\n            if (groups.size() > 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"43\");\n            }\n            // Group specification found\n            // some existance indicators to search for\n            if (existanceIndicators != null) {\n                NodeList fields = ((Node) groups.get(0)).getChildNodes();\n                for (int i = 0; i < fields.getLength(); i++) {\n                    String name = ((Element) fields.item(i)).getAttribute(\"Name\");\n                    String value = (String) existanceIndicators.get(name);\n                    if (value != null) {\n                        if (value.equals(\"Found\")) {\n                            // Will always occurr if a record type contains more\n                            // than one instance of\n                            // a group. Thus, existance indicators in group\n                            // should not occurr.\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"44\");\n                        }\n                        int length = Integer.parseInt(((Element) fields.item(i)).getAttribute(\"Length\"));\n                        if (value.length() != length) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"45\");\n                        }\n                        // Mark as found.\n                        existanceIndicators.put(name, \"Found\");\n                    }\n                    // if (value!=null)\n                }\n                // for (int i=0; i<fields.getLength(); i++)\n            }\n            // if (existanceIndicators!=null)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n    }\n\n    // checkGroupReference(Element groupRef, Node groupsSpec, TreeMap\n    // existanceIndicators)\n    /**\n     * <code>checkFieldSpecification</code> checks the consistency of a field\n     * specification.\n     *\n     * @param fieldSpec\n     *            the DOM node for the field specification\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to field will be marked\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    private void checkFieldSpecification(Element fieldSpec, TreeMap existanceIndicators, boolean validated) throws XException {\n        try {\n            // Field name\n            String name = fieldSpec.getAttribute(\"Name\");\n            // Field length\n            String length = fieldSpec.getAttribute(\"Length\");\n            // Field format\n            String format = fieldSpec.getAttribute(\"Format\");\n            if (!validated) {\n                // Extension if no prior DTD validating\n                if (name.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"48\");\n                }\n                if (length.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"49\");\n                }\n                if (format.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"50\");\n                }\n            }\n            // if (!validated)\n            // For dates further format infoamtion is mandatory.\n            if (format.equals(\"date\") && fieldSpec.getAttribute(\"DateFormat\").length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"51\");\n            }\n            // The length must be an strictly positive integer\n            int lengthNum = Integer.parseInt(length);\n            if (lengthNum < 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"52\");\n            }\n            // Constant values must be bound to a value.\n            if (format.equals(\"const\")) {\n                String value = fieldSpec.getAttribute(\"Value\");\n                if (value.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"53\");\n                } else if (value.length() != lengthNum) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"54\");\n                }\n            }\n            // if (fieldSpec.getAttribute(\"Format\").equals(\"const\"))\n            // some existance indicators to search for\n            if (existanceIndicators != null) {\n                String value = (String) existanceIndicators.get(name);\n                if (value != null) {\n                    // existance indicator defined for this field\n                    if (value.equals(\"Found\")) {\n                        // Already found for other field\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"44\");\n                    }\n                    if (value.length() != lengthNum) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"45\");\n                    }\n                    // Mark as found.\n                    existanceIndicators.put(name, \"Found\");\n                }\n                // if (value!=null)\n            }\n            // if (existanceIndicators!=null)\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }// catch\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkFieldSpecification(Element fieldSpec, TreeMap\n    // existanceIndicators, boolean validated)\n    /**\n     * <code>checkGroupSpecification</code> checks the consistency of a single\n     * field group specification. Extension if no prior DTD validating because\n     * otherwise completely redundant.\n     *\n     * @param groupSpec\n     *            the group specification to check as DOM node\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupSpecification(Element groupSpec) throws XException {\n        if (groupSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"59\");\n        }\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = groupSpec.getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all group fields\n                if (!((Element) fieldSpecs.item(i)).getNodeName().equals(\"Field\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"60\");\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkGroupSpecification(Node groupSpec)\n    // ///////////////////////\n    // Auxiliary functions\n    // ///////////////////////\n    /**\n     * <code>typeIdsAreUnique</code> checks if each declared record type id\n     * refers uniquely to only one record type.\n     *\n     * @param typeIds\n     *            single-value id's as found in the record type declarations\n     * @param typeIdIntervals\n     *            intervals of id's (used as counters) as found in the record\n     *            type declarations\n     * @return <code>true</code> if all id's are unique, false if an id refers\n     *         to two record types\n     */\n    public boolean typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals) {\n        boolean result = true;\n        for (int i = 0; i < typeIds.size() && result; i++) {\n            // Loop over all single-value id's\n            for (int j = i + 1; j < typeIds.size() && result; j++) // Loop over rest of single-value id's\n            result = !((String) typeIds.get(i)).equals((typeIds.get(j)));\n            // Repeated id?\n            for (int j = 0; j < typeIdIntervals.size() && result; j++) // Loop over all id intervals\n            result = (((String) typeIds.get(i)).compareTo(((String[]) typeIdIntervals.get(j))[0]) < 0) || (((String) typeIds.get(i)).compareTo(((String[]) typeIdIntervals.get(j))[1]) > 0);\n            // Or member of one of the intervals?\n        }\n        // for (int i=0; i<typeIds.size() && result; i++)\n        for (int i = 0; i < typeIdIntervals.size() && result; i++) // Loop over all id intervals\n        for (int j = i + 1; j < typeIdIntervals.size() && result; j++) // Loop over rest of intervals\n        result = (((String[]) typeIdIntervals.get(i))[0].compareTo(((String[]) typeIdIntervals.get(j))[1]) > 0) || (((String[]) typeIdIntervals.get(i))[1].compareTo(((String[]) typeIdIntervals.get(j))[0]) < 0);\n        // Do the two intervals intersect?\n        return result;\n    }\n\n    // typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals)\n    /**\n     * <code>computeRecordLength</code> calculates the string length for a\n     * record type - including header and trailer.\n     *\n     * @param spec\n     *            the record type specification\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the total length including filler\n     * @throws XException\n     *             in case of a mal-specified length\n     */\n    protected static int computeRecordLength(Node spec, Node groupsSpec) throws XException {\n        int fieldLengthSum = 0;\n        // for the result\n        NodeList fieldSpecs = spec.getChildNodes();\n        try // to cast to XException\n        {\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    fieldLengthSum += Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n                else if (fieldSpec.getNodeName().equals(\"Group\"))\n                    fieldLengthSum += computeGroupLength(fieldSpec, groupsSpec);\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        return fieldLengthSum;\n    }\n\n    // computeRecordLength(Element spec)\n    /**\n     * <code>computeGroupLength</code> calculates the string length for a\n     * field group.\n     *\n     * @param groupRef\n     *            a refernce to the group\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the total length including filler\n     * @throws XException\n     *             in case of a mal-specified length or missing group\n     *             specification\n     */\n    protected static int computeGroupLength(Element groupRef, Node groupsSpec) throws XException {\n        int groupLengthSum = 0;\n        // for the result\n        NodeList fieldSpecs = getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n        // the group specification\n        try // for casting to XException\n        {\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    groupLengthSum += Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n                else {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"63\");\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return groupLengthSum;\n    }\n\n    // computeGroupLength(Element groupRef, Node groupsSpec)\n    /**\n     * <code>getGroupSpec</code> selects the group specification node by the\n     * group name.\n     *\n     * @param groupName\n     *            the name of the field group\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the group specification node\n     * @throws XException\n     *             in case that the group specification cannot be retrieved\n     */\n    protected static Node getGroupSpec(String groupName, Node groupsSpec) throws XException {\n        Node result = null;\n        try // for casting to XException\n        {\n            List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec, \"Name\", groupName, \"GroupSpec\");\n            if (groups.size() != 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"65\");\n            }\n            result = (Node) groups.get(0);\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return result;\n    }\n    // getGroupSpec(String groupName, Node groupsSpec)\n}\n// RecordTypeDescriptionChecker\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeDescriptionCheckerTest1.java",
		"test_prompt": "// RecordTypeDescriptionCheckerTest1.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeDescriptionChecker}.\n* It contains ten unit test cases for the {@link RecordTypeDescriptionChecker#checkLinesSpecification(Element, boolean)} method.\n*/\nclass RecordTypeDescriptionCheckerTest1 {"
	},
	{
		"original_code": "// RecordTypeDescriptionChecker.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>RecordTypeDescriptionChecker</code> checks the xml description of a\n * record type interface. This description explains the structure of the used\n * interface files.\n *\n * @author Stephan D�wel\n */\nclass RecordTypeDescriptionChecker {\n\n    /**\n     * <code>instances</code> stores the instances of the checker by thread.\n     */\n    private static Hashtable instances = new Hashtable();\n\n    /**\n     * <code>getInstance</code> returns a\n     * <code>RecordTypeDescriptionChecker</code> to work with.\n     *\n     * @return a checker instance\n     */\n    public static RecordTypeDescriptionChecker getInstance() {\n        // Instances are stored by thread.\n        RecordTypeDescriptionChecker instance = (RecordTypeDescriptionChecker) instances.get(Thread.currentThread().getName());\n        if (instance == null) {\n            // No checker initialised yet\n            instance = new RecordTypeDescriptionChecker();\n            instances.put(Thread.currentThread().getName(), instance);\n        }\n        // if (instance==null)\n        return instance;\n    }\n\n    // getInstance()\n    // ///////////////////////////////////////////////////\n    // Checking the structrue description top level\n    // ///////////////////////////////////////////////////\n    /**\n     * <code>checkHeaderSpecification</code> checks the consistency of the\n     * file header desription.\n     *\n     * @param headerSpec\n     *            the structure description for the header\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException -\n     *             in case of a inconsistency\n     */\n    public void checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean validated) throws XException {\n        if (!validated && headerSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"1\");\n        }\n        // Now the single fields in the header\n        checkFieldsAndGroupRefs(headerSpec, groupsSpec, null, validated);\n    }\n\n    // checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean\n    // validated)\n    /**\n     * <code>checkLinesSpecification</code> checks the consistency of the\n     * lines section. The lines section lists all record types, declares their\n     * order in the file and specifies how to identify them in the file.\n     * Furthermore is fills the <code>recordTypeNames</code> and\n     * <code>existanceIndicators</code> arrays to prepare checking the\n     * consistency + of the record type declarations and the specifications\n     * afterwards.\n     *\n     * @param linesSpec\n     *            the lines section of the structure description\n     * @param validated\n     *            Is the xml already validated?\n     * @return an array with 2 elements, the first is the array of all record\n     *         type names, the second is an array of existance indicators (<code>null</code>\n     *         if record identification method is \"TypeIdentifier\")\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public Object[] checkLinesSpecification(Element linesSpec, boolean validated) throws XException {\n        // In which order to find the records\n        String recOrder = linesSpec.getAttribute(\"RecordOrder\");\n        if (!validated) {\n            // Errors in the xml?\n            if (recOrder.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"2\");\n            }\n            if (!recOrder.equals(\"Arbitrary\") && !recOrder.equals(\"Ordered\") && !recOrder.equals(\"Structured\")) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"3\");\n            }\n        }\n        // if (!validated)\n        // How to identify the records\n        String recIdentMethod = linesSpec.getAttribute(\"RecordIdentification\");\n        if (!validated) {\n            // Errors in the xml?\n            if (recIdentMethod.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"4\");\n            }\n            if (!recIdentMethod.equals(\"TypeIdentifier\") && !recIdentMethod.equals(\"RecordOrder\")) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"5\");\n            }\n        }\n        // if (!validated)\n        if (recOrder.equals(\"Arbitrary\") && !recIdentMethod.equals(\"TypeIdentifier\")) {\n            // forbidden combination\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"6\");\n        }\n        // the record type declarations or ...\n        // ... the list of record groups, if <recOrder>=\"Structured\"\n        NodeList recordTypes = linesSpec.getChildNodes();\n        int numOfRecordTypes = recordTypes.getLength();\n        // only ok if <recOrder>!=\"Structured\" because otherwise this computes\n        // the number of record groups!!!!!!!!!\n        if (recordTypes.getLength() == 0) {\n            // Extension if no prior DTD validating\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"7\");\n        }\n        // Loop will run over record types, but the identification of record\n        // record groups above is important, as well.\n        // If <recOrder>!=\"Structured\", the parent node is just the Lines node.\n        Node recordGroup = linesSpec;\n        // Now some corrections to the setting so far if record groups must be\n        // treated.\n        if (recOrder.equals(\"Structured\")) {\n            if (!recIdentMethod.equals(\"TypeIdentifier\") && recordTypes.getLength() > 1) {\n                // Several record groups are only allowed if the record types\n                // can\n                // be identiifed by type identifiers.\n                // Attention: <recordTypes> contains the record groups - not the\n                // types!\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"8\");\n            }\n            numOfRecordTypes = 0;\n            // For counting the record types a loop over the record groups is\n            // necessary.\n            for (int i = 0; i < recordTypes.getLength(); i++) {\n                // loop over record groups\n                if (!recordTypes.item(i).getNodeName().equals(\"RecordGroup\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"9\");\n                }\n                numOfRecordTypes += recordTypes.item(i).getChildNodes().getLength();\n                // the number of records in that group\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n            recordGroup = recordTypes.item(0);\n            // for loop over record groups\n            recordTypes = recordGroup.getChildNodes();\n            // the record types one level deeper now, thus really to record\n            // types\n        }\n        // if (recOrder.equals(\"Structured\"))\n        TreeMap[] existanceIndicators = null;\n        // for record types which's occurrence depends on a certain value in the\n        // record before\n        if (recIdentMethod.equals(\"TypeIdentifier\")) {\n            // type identification by type identifier is easy but needs some\n            // values\n            // where to find the identifier within the records\n            String idPos = linesSpec.getAttribute(\"IdentifierPos\");\n            // Where does the identifier start in the record string?\n            if (idPos.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"10\");\n            }\n            String idLength = linesSpec.getAttribute(\"IdentifierLength\");\n            // How long is the type identifier?\n            if (idLength.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"11\");\n            }\n            try {\n                // The position must be a positive integer.\n                int num = Integer.parseInt(idPos);\n                if (num < 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"12\");\n                }\n                // The length as well must be positive integer.\n                // Length 0 is permitted for having a simple handling of files\n                // with\n                // only one record type.\n                num = Integer.parseInt(idLength);\n                if (num < 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"13\");\n                }\n            }// try\n             catch (ClassCastException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n            }\n            // catch\n        } else // then (recIdentMethod.equals(\"TypeIdentifier\"))\n        // Without type identifiers everything gets more complicated ...\n        // ... but the primary value are already set.\n        {\n            // Indicators for successors may be important.\n            existanceIndicators = new TreeMap[numOfRecordTypes];\n            for (int i = 0; i < existanceIndicators.length; i++) existanceIndicators[i] = null;\n            // Will be filled when going through the single record type\n            // declarations.\n        }\n        // else (recIdentMethod.equals(\"TypeIdentifier\"))\n        String[] recordTypeNames = new String[numOfRecordTypes];\n        // Storing the names for consistency check gainst the record type\n        // specification section.\n        LinkedList typeIds = new LinkedList();\n        LinkedList typeIdIntervals = new LinkedList();\n        // Record type identifier may be single values or intervals.\n        // They are stored to check their unique reference to a record type.\n        int recordTypesCount = recordTypes.getLength();\n        // the number of record types in the current record group or at all\n        // (wihtout grouping) - at least if no bad nodes are included in a\n        // errorprone specification\n        int recordTypesBefore = 0;\n        // number of record type declarations checked in other record groups\n        // before - used as offset to datermine the position in the record type\n        // array\n        while (recordGroup != null) {\n            // loop over record groups\n            // - only one loop if <recOrder>!=\"Structured\" because of missing\n            // record groups\n            for (int i = 0; i < recordTypesCount; i++) {\n                // Loop over all record type declarations of the record group\n                Node rType = recordTypes.item(i);\n                // Extension if no DTD validating\n                if (rType.getNodeType() != Node.ELEMENT_NODE || !rType.getNodeName().equals(\"RecordType\")) {\n                    List params = new Vector();\n                    params.add(rType.getNodeName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"15\", params);\n                }\n                // Check the consistency of this single record type declaration.\n                // If its occurrence depends on values in the prececeeding\n                // record\n                // the information about this value is stored in\n                // <dependenceOnPredecessor>.\n                String[] dependenceOnPredecessor = checkRecordTypeDeclaration(rType, recordTypesCount, recordTypesBefore + i, recIdentMethod, recOrder, recordTypeNames, typeIds, typeIdIntervals, existanceIndicators);\n                if (existanceIndicators != null && dependenceOnPredecessor != null) {\n                    // Existance records are expected in general and an\n                    // existance\n                    // indicator is defined for the last cheched record type.\n                    // To ensure that the identification via existance\n                    // indicators\n                    // is possible, the information about them is analysed the\n                    // other\n                    // way round. Originally the information was attached as\n                    // <dependenceOnPredecessor> to the dependent record type.\n                    // Now it will be attached as <existanceIndicators> to its\n                    // possible predecessors.\n                    String occurrences = ((Element) recordTypes.item(i)).getAttribute(\"Occurrences\");\n                    // Cardinality of the record type.\n                    boolean isOptional = CardinalityStrings.isCardinalityInterval(occurrences, true) && CardinalityStrings.getCardinalityLow(occurrences, true) == 0;\n                    for (int j = i - 1; j > -1 && isOptional; j++) {\n                        // Backwards loop to the beginning of the record types\n                        // starting at the predecessor of the examined record\n                        // type.\n                        // As long as a record type is optional, its predecessor\n                        // is\n                        // added to the list of possible predecessors for the\n                        // originally\n                        // checked record type.\n                        // Stops at the first record type because this one may\n                        // not be optional.\n                        // Now information attached to the predecessor.\n                        if (existanceIndicators[j] == null) {\n                            // The predecessor does not yet have identified\n                            // successor\n                            // which depend on an existnace indicator.\n                            existanceIndicators[j] = new TreeMap();\n                            existanceIndicators[j].put(dependenceOnPredecessor[0], dependenceOnPredecessor[1]);\n                        } else // then (existanceIndicators[j]==null)\n                        {\n                            // The predecessor already has information about\n                            // successors.\n                            // Existance indicator value for the existance\n                            // indicator\n                            // field stated in the examined record type, but\n                            // used for\n                            // another record type !?\n                            String value = (String) existanceIndicators[j].get(dependenceOnPredecessor[0]);\n                            if (value != null)\n                                // Existance indicator values in the same field\n                                // for different record types.\n                                if (value.length() != dependenceOnPredecessor[1].length()) {\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"16\");\n                                } else\n                                    // No other use of the existance indicator\n                                    // field yet.\n                                    // Store the new value.\n                                    existanceIndicators[j].put(dependenceOnPredecessor[0], dependenceOnPredecessor[1]);\n                        }\n                        // else (existanceIndicators[j]==null)\n                        occurrences = ((Element) recordTypes.item(j)).getAttribute(\"Occurrences\");\n                        // Cardinality of the last checked record type\n                        isOptional = CardinalityStrings.isCardinalityInterval(occurrences, true) && CardinalityStrings.getCardinalityLow(occurrences, true) == 0;\n                    }\n                    // for (int j=i-1; j>-1 && isOptional; j++)\n                }\n                // if (existanceIndicators!=null &&\n                // dependenceOnPredecessor!=null)\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n            recordTypesBefore += recordTypesCount;\n            // Correct the number of checked record types in the so far\n            // examined record groups\n            if (recordGroup.getNodeName().equals(\"RecordGroup\")) {\n                // record groups really present\n                recordGroup = recordGroup.getNextSibling();\n                // Choose next record group\n                if (recordGroup != null) {\n                    // there is a next record group\n                    recordTypes = recordGroup.getChildNodes();\n                    recordTypesCount = recordTypes.getLength();\n                    // Next check the record types in the new group\n                }\n                // if (recordGroup != null)\n            } else\n                // if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // no real record group loop but record declarations directly\n                // in lines section, terminate loop by setting ...\n                recordGroup = null;\n        }\n        // while (recordGroup!=null) - record group loop\n        // Check record type names for uniqueness.\n        for (int i = 0; i < recordTypeNames.length; i++) for (int j = i + 1; j < recordTypeNames.length; j++) if (recordTypeNames[i].equals(recordTypeNames[j])) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"17\");\n        }\n        // Checks on the type identifier\n        // First check their length\n        // If the record type identification is not done by type identifiers,\n        // the two type id lists are empty.\n        int identifierLength = 0;\n        if (typeIds.size() > 0)\n            // Some single value id's\n            identifierLength = ((String) typeIds.get(0)).length();\n        else if (typeIdIntervals.size() > 0)\n            // No single value id but some id intervals\n            identifierLength = ((String[]) typeIdIntervals.get(0))[0].length();\n        // All id's must have the same length.\n        // First the single value id's\n        for (int i = 1; i < typeIds.size(); i++) if (((String) typeIds.get(0)).length() != identifierLength) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"18\");\n        }\n        // Second the id intervals\n        for (int i = 1; i < typeIdIntervals.size(); i++) // Attention: two values!\n        if (((String[]) typeIdIntervals.get(0))[0].length() != identifierLength || ((String[]) typeIdIntervals.get(0))[1].length() != identifierLength) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"18\");\n        }\n        // Second, check the id uniqueness in sense of identification of only\n        // one\n        // record type\n        if (!typeIdsAreUnique(typeIds, typeIdIntervals)) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"20\");\n        }\n        // Return the found record type names and existance indicators.\n        Object[] checkInfos = new Object[2];\n        checkInfos[0] = recordTypeNames;\n        checkInfos[1] = existanceIndicators;\n        return checkInfos;\n    }\n\n    // checkLinesSpecification(Element linesSpec, boolean validated)\n    /**\n     * <code>checkRecordTypesSpecification</code> checks the section of record\n     * type specifications for consistency. In particular it checks for\n     * existance of the record types and fields named in the lines section.\n     *\n     * @param recordTypesSpec\n     *            the record type specifications section\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param checkInfos\n     *            record type names and existance indicators found in the lines\n     *            section\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec, Object[] checkInfos, boolean validated) throws XException {\n        try // for casting to XException\n        {\n            NodeList recordTypes = recordTypesSpec.getChildNodes();\n            // Here we have no record groups!\n            for (int i = 0; i < recordTypes.getLength(); i++) {\n                // loop over record type specifications\n                Element recordType = (Element) recordTypes.item(i);\n                // Extension if no prior validating\n                if (!recordType.getNodeName().equals(\"RecordTypeSpec\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"21\");\n                }\n                String recTypeName = recordType.getAttribute(\"Name\");\n                // Extension if no prior validating\n                if (recTypeName == null || !XDomSupport.isValidTagName(recTypeName)) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"22\");\n                }\n                // Search record type name in the name array from\n                // the record type (Lines) section.\n                boolean nameSearched = true;\n                // Still searching?\n                int pos = 0;\n                for (; pos < ((String[]) checkInfos[0]).length && nameSearched; pos++) // loop over record type names from the lines section\n                if (recTypeName.equals(((String[]) checkInfos[0])[pos])) {\n                    // name found\n                    ((String[]) checkInfos[0])[pos] = null;\n                    // deleted for avoiding more hits\n                    nameSearched = false;\n                    // search loop ended for this record type\n                }\n                // if\n                // (recTypeName.equals(((String[])checkInfos[0])[pos]))\n                if (nameSearched) {\n                    // Record type not declared in lines section\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"23\");\n                }\n                // Now the single fields in the record type\n                TreeMap existanceIndicators = null;\n                // With the found position in the checkInfos array\n                // the correct existance indicator map is retrieved ...\n                if (checkInfos[1] != null)\n                    // Because pos was augmented once to much in the for loop,\n                    // now\n                    // use pos-1.\n                    existanceIndicators = ((TreeMap[]) checkInfos[1])[pos - 1];\n                // ... and feeded to field checking\n                checkFieldsAndGroupRefs(recordType, groupsSpec, existanceIndicators, validated);\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec,\n    // Object[] checkInfos, boolean validated)\n    /**\n     * <code>checkTrailerSpecification</code> checks the consistency of the\n     * file trailer desription.\n     *\n     * @param trailerSpec\n     *            the structure description for the trailer\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of a inconsistency\n     */\n    public void checkTrailerSpecification(Element trailerSpec, Node groupsSpec, boolean validated) throws XException {\n        // Extension if no prior DTD validating\n        if (trailerSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"1\");\n        }\n        // Now the single fields in the header\n        checkFieldsAndGroupRefs(trailerSpec, groupsSpec, null, validated);\n    }\n\n    // checkTrailerSpecification(Element trailerSpec, Node groupsSpec,\n    // boolean validated)\n    /**\n     * <code>checkGroupsSpecification</code> checks the consistency of each\n     * field group specification.\n     *\n     * @param groupsSpec\n     *            the list of field group specifications\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupsSpecification(Node groupsSpec, boolean validated) throws XException {\n        NodeList groups = groupsSpec.getChildNodes();\n        if (!validated) {\n            // Extension if no prior DTD validating\n            try // for casting to XException\n            {\n                for (int i = 0; i < groups.getLength(); i++) // consistency check on each single group specification\n                // (redundant to validating against DTD)\n                checkGroupSpecification((Element) groups.item(i));\n            }// try\n             catch (ClassCastException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n            }\n            // catch\n        }\n        // if (!validated)\n        // Check for the uniqueness of group names\n        for (int i = 0; i < groups.getLength() - 1; i++) {\n            String groupName = ((Element) groups.item(i)).getAttribute(\"Name\");\n            for (int j = i + 1; j < groups.getLength(); j++) if (groupName.equals(((Element) groups.item(j)).getAttribute(\"Name\"))) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"27\");\n            }\n        }\n        // for (int i=0; i<groups.getLength()-1; i++)\n    }\n\n    // checkGroupsSpecification(Node groupsSpec, boolean validated)\n    // //////////////////////////////////////////////\n    // Structrue checking on some deeper level\n    // //////////////////////////////////////////////\n    /**\n     * <code>checkRecordTypeDeclaration</code> checks a record type\n     * declaration for consistency. Furthermore is fills the\n     * <code>recordTypeNames</code> and <code>existanceIndicators</code> to\n     * check consistency with the record type specifications afterwards.\n     *\n     * @param recTypeDecl\n     *            the DOM node of the declaration\n     * @param recordTypesCount\n     *            the number of record types in the actual record group or the\n     *            whole file (wihtout grouping)\n     * @param pos\n     *            the position in the list of declarations (starts at 0)\n     * @param recIdentMethod\n     *            the method to identify record types\n     * @param recOrder\n     *            the order of records in the file\n     * @param recordTypeNames\n     *            array of record type names, filled at position\n     *            <code>pos</code> right here\n     * @param typeIds\n     *            the list of single-value type id's, a found id will be added\n     * @param typeIdIntervals\n     *            the list of type id intervals, a found interval will be added\n     * @param existanceIndicators\n     *            array of existance indicator maps, potentially filled with\n     *            self reference at position <code>pos</code> right here\n     * @return field/value pair for an existance indicator in the record type\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public String[] checkRecordTypeDeclaration(Node recTypeDecl, int recordTypesCount, int pos, String recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators) throws XException {\n        String[] precedingIndicator = null;\n        // for returning exstistance indicator information for predecessors\n        try // for casting to XException\n        {\n            if (recIdentMethod.equals(\"TypeIdentifier\")) {\n                // Record types are identified by an id\n                String id = ((Element) recTypeDecl).getAttribute(\"Identifier\");\n                // a single-value id\n                String[] idLoHi = new String[2];\n                idLoHi[0] = ((Element) recTypeDecl).getAttribute(\"IdentifierLow\");\n                idLoHi[1] = ((Element) recTypeDecl).getAttribute(\"IdentifierHigh\");\n                // an id interval\n                if (id.length() == 0) {\n                    // No single-value id\n                    if (idLoHi[0].length() == 0 || idLoHi[1].length() == 0) {\n                        // Something must be specified: single value or\n                        // interval.\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"28\");\n                    }\n                    typeIdIntervals.add(idLoHi);\n                } else // then (id.length()==0)\n                {\n                    // Single-value id found\n                    if (idLoHi[0].length() > 0 || idLoHi[1].length() > 0) {\n                        // Any interval specification conflicts.\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"28\");\n                    }\n                    typeIds.add(id);\n                }\n                // else (id.length()==0)\n            }\n            // if (recIdentMethod.equals(\"TypeIdentifier\"))\n            recordTypeNames[pos] = XDomSupport.getTrimedNodeText(recTypeDecl);\n            // the record type name\n            if (!XDomSupport.isValidTagName(recordTypeNames[pos])) {\n                // It must be a legal xml tag name.\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"30\");\n            }\n            // Now look for record identification features, in particular the\n            // cardinality\n            // and existance indicator\n            if (recOrder.equals(\"Ordered\") || recOrder.equals(\"Structured\")) {\n                // Records are listed in the record type order or in groups.\n                // The cardinality must be specified.\n                String occurrences = ((Element) recTypeDecl).getAttribute(\"Occurrences\");\n                if (occurrences.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"31\");\n                }\n                if (!CardinalityStrings.isCardinalityValid(occurrences)) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"32\");\n                }\n                // The first record in a record group must have cardinality 1.\n                if (recOrder.equals(\"Structured\") && pos == 0) {\n                    try {\n                        int occurrNum = Integer.parseInt(occurrences);\n                        if (occurrNum != 1) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"33\");\n                        }\n                    }// try\n                     catch (NumberFormatException e) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"33\");\n                    }\n                    // catch\n                }\n                // if (recOrder.equals(\"Structured\") && pos==0)\n                // If the record type is not given by an id but the cardinality\n                // is specified as an\n                // interval and there are also other record types, there must be\n                // an existance indicator\n                // refering the preceding record.\n                if (recordTypesCount > 1 && !recIdentMethod.equals(\"TypeIdentifier\") && CardinalityStrings.isCardinalityInterval(occurrences, true)) {\n                    String existIndField = ((Element) recTypeDecl).getAttribute(\"ExistIndicatorField\");\n                    // Indicator field specified by name\n                    if (existIndField.length() == 0) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"35\");\n                    }\n                    String existIndValue = ((Element) recTypeDecl).getAttribute(\"ExistIndicatorValue\");\n                    if (existIndValue.length() == 0) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"36\");\n                    }\n                    precedingIndicator = new String[2];\n                    precedingIndicator[0] = existIndField;\n                    precedingIndicator[1] = existIndValue;\n                    // If the record type may occurr more than once, it may be\n                    // its\n                    // predecessor itself.\n                    if (CardinalityStrings.getCardinalityHigh(occurrences, true) > 1) {\n                        existanceIndicators[pos] = new TreeMap();\n                        existanceIndicators[pos].put(precedingIndicator[0], precedingIndicator[1]);\n                    }\n                    // if (getCardinalityHigh(occurrences,true)>1)\n                }\n                // if (!recIdentMethod.equals(\"TypeIdentifier\") &&\n                // isCardinalityInterval(occurrences,true))\n            }\n            // if (recOrder.equals(\"Ordered\") ||\n            // recOrder.equals(\"Structured\"))\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return precedingIndicator;\n        // Group starting record type found?\n    }\n\n    // checkRecordTypeDeclaration(Node recTypeDecl, int pos, String\n    // recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList\n    // typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators)\n    /**\n     * <code>checkFieldsAndGroupRefs</code> checks the fields and group\n     * references within an record type (including header and trailer) for\n     * consistency.\n     *\n     * @param parent\n     *            the record type specification node\n     * @param groupsSpec\n     *            the list of field group specifications\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to fields will be marked\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    private void checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap existanceIndicators, boolean validated) throws XException {\n        try // try-catch block for casting standard exceptions to XException\n        {\n            NodeList fieldSpecs = parent.getChildNodes();\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                // Two alternatives: field or group\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    checkFieldSpecification(fieldSpec, existanceIndicators, validated);\n                else if (fieldSpec.getNodeName().equals(\"Group\"))\n                    checkGroupReference(fieldSpec, groupsSpec, existanceIndicators);\n                else // Extension if no prior DTD validating\n                {\n                    List params = new Vector();\n                    params.add(fieldSpec.getNodeName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"38\", params);\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap\n    // existanceIndicators)\n    /**\n     * <code>checkGroupReference</code> checks the consistency of a reference\n     * to a field group.\n     *\n     * @param groupRef\n     *            the DOM node for the group reference\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to group fields will be marked\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupReference(Element groupRef, Node groupsSpec, TreeMap existanceIndicators) throws XException {\n        try {\n            String groupName = groupRef.getAttribute(\"Name\");\n            // Extension if no prior DTD validating\n            if (groupName.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"40\");\n            }\n            // Search for the group specification.\n            if (groupsSpec == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"41\");\n            }\n            List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec, \"Name\", groupName, \"GroupSpec\");\n            if (groups == null || groups.size() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"42\");\n            }\n            if (groups.size() > 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"43\");\n            }\n            // Group specification found\n            // some existance indicators to search for\n            if (existanceIndicators != null) {\n                NodeList fields = ((Node) groups.get(0)).getChildNodes();\n                for (int i = 0; i < fields.getLength(); i++) {\n                    String name = ((Element) fields.item(i)).getAttribute(\"Name\");\n                    String value = (String) existanceIndicators.get(name);\n                    if (value != null) {\n                        if (value.equals(\"Found\")) {\n                            // Will always occurr if a record type contains more\n                            // than one instance of\n                            // a group. Thus, existance indicators in group\n                            // should not occurr.\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"44\");\n                        }\n                        int length = Integer.parseInt(((Element) fields.item(i)).getAttribute(\"Length\"));\n                        if (value.length() != length) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"45\");\n                        }\n                        // Mark as found.\n                        existanceIndicators.put(name, \"Found\");\n                    }\n                    // if (value!=null)\n                }\n                // for (int i=0; i<fields.getLength(); i++)\n            }\n            // if (existanceIndicators!=null)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n    }\n\n    // checkGroupReference(Element groupRef, Node groupsSpec, TreeMap\n    // existanceIndicators)\n    /**\n     * <code>checkFieldSpecification</code> checks the consistency of a field\n     * specification.\n     *\n     * @param fieldSpec\n     *            the DOM node for the field specification\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to field will be marked\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    private void checkFieldSpecification(Element fieldSpec, TreeMap existanceIndicators, boolean validated) throws XException {\n        try {\n            // Field name\n            String name = fieldSpec.getAttribute(\"Name\");\n            // Field length\n            String length = fieldSpec.getAttribute(\"Length\");\n            // Field format\n            String format = fieldSpec.getAttribute(\"Format\");\n            if (!validated) {\n                // Extension if no prior DTD validating\n                if (name.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"48\");\n                }\n                if (length.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"49\");\n                }\n                if (format.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"50\");\n                }\n            }\n            // if (!validated)\n            // For dates further format infoamtion is mandatory.\n            if (format.equals(\"date\") && fieldSpec.getAttribute(\"DateFormat\").length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"51\");\n            }\n            // The length must be an strictly positive integer\n            int lengthNum = Integer.parseInt(length);\n            if (lengthNum < 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"52\");\n            }\n            // Constant values must be bound to a value.\n            if (format.equals(\"const\")) {\n                String value = fieldSpec.getAttribute(\"Value\");\n                if (value.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"53\");\n                } else if (value.length() != lengthNum) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"54\");\n                }\n            }\n            // if (fieldSpec.getAttribute(\"Format\").equals(\"const\"))\n            // some existance indicators to search for\n            if (existanceIndicators != null) {\n                String value = (String) existanceIndicators.get(name);\n                if (value != null) {\n                    // existance indicator defined for this field\n                    if (value.equals(\"Found\")) {\n                        // Already found for other field\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"44\");\n                    }\n                    if (value.length() != lengthNum) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"45\");\n                    }\n                    // Mark as found.\n                    existanceIndicators.put(name, \"Found\");\n                }\n                // if (value!=null)\n            }\n            // if (existanceIndicators!=null)\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }// catch\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkFieldSpecification(Element fieldSpec, TreeMap\n    // existanceIndicators, boolean validated)\n    /**\n     * <code>checkGroupSpecification</code> checks the consistency of a single\n     * field group specification. Extension if no prior DTD validating because\n     * otherwise completely redundant.\n     *\n     * @param groupSpec\n     *            the group specification to check as DOM node\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupSpecification(Element groupSpec) throws XException {\n        if (groupSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"59\");\n        }\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = groupSpec.getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all group fields\n                if (!((Element) fieldSpecs.item(i)).getNodeName().equals(\"Field\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"60\");\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkGroupSpecification(Node groupSpec)\n    // ///////////////////////\n    // Auxiliary functions\n    // ///////////////////////\n    /**\n     * <code>typeIdsAreUnique</code> checks if each declared record type id\n     * refers uniquely to only one record type.\n     *\n     * @param typeIds\n     *            single-value id's as found in the record type declarations\n     * @param typeIdIntervals\n     *            intervals of id's (used as counters) as found in the record\n     *            type declarations\n     * @return <code>true</code> if all id's are unique, false if an id refers\n     *         to two record types\n     */\n    public boolean typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals) {\n        boolean result = true;\n        for (int i = 0; i < typeIds.size() && result; i++) {\n            // Loop over all single-value id's\n            for (int j = i + 1; j < typeIds.size() && result; j++) // Loop over rest of single-value id's\n            result = !((String) typeIds.get(i)).equals((typeIds.get(j)));\n            // Repeated id?\n            for (int j = 0; j < typeIdIntervals.size() && result; j++) // Loop over all id intervals\n            result = (((String) typeIds.get(i)).compareTo(((String[]) typeIdIntervals.get(j))[0]) < 0) || (((String) typeIds.get(i)).compareTo(((String[]) typeIdIntervals.get(j))[1]) > 0);\n            // Or member of one of the intervals?\n        }\n        // for (int i=0; i<typeIds.size() && result; i++)\n        for (int i = 0; i < typeIdIntervals.size() && result; i++) // Loop over all id intervals\n        for (int j = i + 1; j < typeIdIntervals.size() && result; j++) // Loop over rest of intervals\n        result = (((String[]) typeIdIntervals.get(i))[0].compareTo(((String[]) typeIdIntervals.get(j))[1]) > 0) || (((String[]) typeIdIntervals.get(i))[1].compareTo(((String[]) typeIdIntervals.get(j))[0]) < 0);\n        // Do the two intervals intersect?\n        return result;\n    }\n\n    // typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals)\n    /**\n     * <code>computeRecordLength</code> calculates the string length for a\n     * record type - including header and trailer.\n     *\n     * @param spec\n     *            the record type specification\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the total length including filler\n     * @throws XException\n     *             in case of a mal-specified length\n     */\n    protected static int computeRecordLength(Node spec, Node groupsSpec) throws XException {\n        int fieldLengthSum = 0;\n        // for the result\n        NodeList fieldSpecs = spec.getChildNodes();\n        try // to cast to XException\n        {\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    fieldLengthSum += Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n                else if (fieldSpec.getNodeName().equals(\"Group\"))\n                    fieldLengthSum += computeGroupLength(fieldSpec, groupsSpec);\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        return fieldLengthSum;\n    }\n\n    // computeRecordLength(Element spec)\n    /**\n     * <code>computeGroupLength</code> calculates the string length for a\n     * field group.\n     *\n     * @param groupRef\n     *            a refernce to the group\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the total length including filler\n     * @throws XException\n     *             in case of a mal-specified length or missing group\n     *             specification\n     */\n    protected static int computeGroupLength(Element groupRef, Node groupsSpec) throws XException {\n        int groupLengthSum = 0;\n        // for the result\n        NodeList fieldSpecs = getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n        // the group specification\n        try // for casting to XException\n        {\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    groupLengthSum += Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n                else {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"63\");\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return groupLengthSum;\n    }\n\n    // computeGroupLength(Element groupRef, Node groupsSpec)\n    /**\n     * <code>getGroupSpec</code> selects the group specification node by the\n     * group name.\n     *\n     * @param groupName\n     *            the name of the field group\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the group specification node\n     * @throws XException\n     *             in case that the group specification cannot be retrieved\n     */\n    protected static Node getGroupSpec(String groupName, Node groupsSpec) throws XException {\n        Node result = null;\n        try // for casting to XException\n        {\n            List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec, \"Name\", groupName, \"GroupSpec\");\n            if (groups.size() != 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"65\");\n            }\n            result = (Node) groups.get(0);\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return result;\n    }\n    // getGroupSpec(String groupName, Node groupsSpec)\n}\n// RecordTypeDescriptionChecker\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeDescriptionCheckerTest2.java",
		"test_prompt": "// RecordTypeDescriptionCheckerTest2.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeDescriptionChecker}.\n* It contains ten unit test cases for the {@link RecordTypeDescriptionChecker#checkRecordTypeDeclaration(Node, int, int, String, String, String[], LinkedList, LinkedList, TreeMap[])} method.\n*/\nclass RecordTypeDescriptionCheckerTest2 {"
	},
	{
		"original_code": "// RecordTypeDescriptionChecker.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>RecordTypeDescriptionChecker</code> checks the xml description of a\n * record type interface. This description explains the structure of the used\n * interface files.\n *\n * @author Stephan D�wel\n */\nclass RecordTypeDescriptionChecker {\n\n    /**\n     * <code>instances</code> stores the instances of the checker by thread.\n     */\n    private static Hashtable instances = new Hashtable();\n\n    /**\n     * <code>getInstance</code> returns a\n     * <code>RecordTypeDescriptionChecker</code> to work with.\n     *\n     * @return a checker instance\n     */\n    public static RecordTypeDescriptionChecker getInstance() {\n        // Instances are stored by thread.\n        RecordTypeDescriptionChecker instance = (RecordTypeDescriptionChecker) instances.get(Thread.currentThread().getName());\n        if (instance == null) {\n            // No checker initialised yet\n            instance = new RecordTypeDescriptionChecker();\n            instances.put(Thread.currentThread().getName(), instance);\n        }\n        // if (instance==null)\n        return instance;\n    }\n\n    // getInstance()\n    // ///////////////////////////////////////////////////\n    // Checking the structrue description top level\n    // ///////////////////////////////////////////////////\n    /**\n     * <code>checkHeaderSpecification</code> checks the consistency of the\n     * file header desription.\n     *\n     * @param headerSpec\n     *            the structure description for the header\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException -\n     *             in case of a inconsistency\n     */\n    public void checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean validated) throws XException {\n        if (!validated && headerSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"1\");\n        }\n        // Now the single fields in the header\n        checkFieldsAndGroupRefs(headerSpec, groupsSpec, null, validated);\n    }\n\n    // checkHeaderSpecification(Element headerSpec, Node groupsSpec, boolean\n    // validated)\n    /**\n     * <code>checkLinesSpecification</code> checks the consistency of the\n     * lines section. The lines section lists all record types, declares their\n     * order in the file and specifies how to identify them in the file.\n     * Furthermore is fills the <code>recordTypeNames</code> and\n     * <code>existanceIndicators</code> arrays to prepare checking the\n     * consistency + of the record type declarations and the specifications\n     * afterwards.\n     *\n     * @param linesSpec\n     *            the lines section of the structure description\n     * @param validated\n     *            Is the xml already validated?\n     * @return an array with 2 elements, the first is the array of all record\n     *         type names, the second is an array of existance indicators (<code>null</code>\n     *         if record identification method is \"TypeIdentifier\")\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public Object[] checkLinesSpecification(Element linesSpec, boolean validated) throws XException {\n        // In which order to find the records\n        String recOrder = linesSpec.getAttribute(\"RecordOrder\");\n        if (!validated) {\n            // Errors in the xml?\n            if (recOrder.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"2\");\n            }\n            if (!recOrder.equals(\"Arbitrary\") && !recOrder.equals(\"Ordered\") && !recOrder.equals(\"Structured\")) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"3\");\n            }\n        }\n        // if (!validated)\n        // How to identify the records\n        String recIdentMethod = linesSpec.getAttribute(\"RecordIdentification\");\n        if (!validated) {\n            // Errors in the xml?\n            if (recIdentMethod.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"4\");\n            }\n            if (!recIdentMethod.equals(\"TypeIdentifier\") && !recIdentMethod.equals(\"RecordOrder\")) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"5\");\n            }\n        }\n        // if (!validated)\n        if (recOrder.equals(\"Arbitrary\") && !recIdentMethod.equals(\"TypeIdentifier\")) {\n            // forbidden combination\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"6\");\n        }\n        // the record type declarations or ...\n        // ... the list of record groups, if <recOrder>=\"Structured\"\n        NodeList recordTypes = linesSpec.getChildNodes();\n        int numOfRecordTypes = recordTypes.getLength();\n        // only ok if <recOrder>!=\"Structured\" because otherwise this computes\n        // the number of record groups!!!!!!!!!\n        if (recordTypes.getLength() == 0) {\n            // Extension if no prior DTD validating\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"7\");\n        }\n        // Loop will run over record types, but the identification of record\n        // record groups above is important, as well.\n        // If <recOrder>!=\"Structured\", the parent node is just the Lines node.\n        Node recordGroup = linesSpec;\n        // Now some corrections to the setting so far if record groups must be\n        // treated.\n        if (recOrder.equals(\"Structured\")) {\n            if (!recIdentMethod.equals(\"TypeIdentifier\") && recordTypes.getLength() > 1) {\n                // Several record groups are only allowed if the record types\n                // can\n                // be identiifed by type identifiers.\n                // Attention: <recordTypes> contains the record groups - not the\n                // types!\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"8\");\n            }\n            numOfRecordTypes = 0;\n            // For counting the record types a loop over the record groups is\n            // necessary.\n            for (int i = 0; i < recordTypes.getLength(); i++) {\n                // loop over record groups\n                if (!recordTypes.item(i).getNodeName().equals(\"RecordGroup\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"9\");\n                }\n                numOfRecordTypes += recordTypes.item(i).getChildNodes().getLength();\n                // the number of records in that group\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n            recordGroup = recordTypes.item(0);\n            // for loop over record groups\n            recordTypes = recordGroup.getChildNodes();\n            // the record types one level deeper now, thus really to record\n            // types\n        }\n        // if (recOrder.equals(\"Structured\"))\n        TreeMap[] existanceIndicators = null;\n        // for record types which's occurrence depends on a certain value in the\n        // record before\n        if (recIdentMethod.equals(\"TypeIdentifier\")) {\n            // type identification by type identifier is easy but needs some\n            // values\n            // where to find the identifier within the records\n            String idPos = linesSpec.getAttribute(\"IdentifierPos\");\n            // Where does the identifier start in the record string?\n            if (idPos.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"10\");\n            }\n            String idLength = linesSpec.getAttribute(\"IdentifierLength\");\n            // How long is the type identifier?\n            if (idLength.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"11\");\n            }\n            try {\n                // The position must be a positive integer.\n                int num = Integer.parseInt(idPos);\n                if (num < 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"12\");\n                }\n                // The length as well must be positive integer.\n                // Length 0 is permitted for having a simple handling of files\n                // with\n                // only one record type.\n                num = Integer.parseInt(idLength);\n                if (num < 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"13\");\n                }\n            }// try\n             catch (ClassCastException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n            }\n            // catch\n        } else // then (recIdentMethod.equals(\"TypeIdentifier\"))\n        // Without type identifiers everything gets more complicated ...\n        // ... but the primary value are already set.\n        {\n            // Indicators for successors may be important.\n            existanceIndicators = new TreeMap[numOfRecordTypes];\n            for (int i = 0; i < existanceIndicators.length; i++) existanceIndicators[i] = null;\n            // Will be filled when going through the single record type\n            // declarations.\n        }\n        // else (recIdentMethod.equals(\"TypeIdentifier\"))\n        String[] recordTypeNames = new String[numOfRecordTypes];\n        // Storing the names for consistency check gainst the record type\n        // specification section.\n        LinkedList typeIds = new LinkedList();\n        LinkedList typeIdIntervals = new LinkedList();\n        // Record type identifier may be single values or intervals.\n        // They are stored to check their unique reference to a record type.\n        int recordTypesCount = recordTypes.getLength();\n        // the number of record types in the current record group or at all\n        // (wihtout grouping) - at least if no bad nodes are included in a\n        // errorprone specification\n        int recordTypesBefore = 0;\n        // number of record type declarations checked in other record groups\n        // before - used as offset to datermine the position in the record type\n        // array\n        while (recordGroup != null) {\n            // loop over record groups\n            // - only one loop if <recOrder>!=\"Structured\" because of missing\n            // record groups\n            for (int i = 0; i < recordTypesCount; i++) {\n                // Loop over all record type declarations of the record group\n                Node rType = recordTypes.item(i);\n                // Extension if no DTD validating\n                if (rType.getNodeType() != Node.ELEMENT_NODE || !rType.getNodeName().equals(\"RecordType\")) {\n                    List params = new Vector();\n                    params.add(rType.getNodeName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"15\", params);\n                }\n                // Check the consistency of this single record type declaration.\n                // If its occurrence depends on values in the prececeeding\n                // record\n                // the information about this value is stored in\n                // <dependenceOnPredecessor>.\n                String[] dependenceOnPredecessor = checkRecordTypeDeclaration(rType, recordTypesCount, recordTypesBefore + i, recIdentMethod, recOrder, recordTypeNames, typeIds, typeIdIntervals, existanceIndicators);\n                if (existanceIndicators != null && dependenceOnPredecessor != null) {\n                    // Existance records are expected in general and an\n                    // existance\n                    // indicator is defined for the last cheched record type.\n                    // To ensure that the identification via existance\n                    // indicators\n                    // is possible, the information about them is analysed the\n                    // other\n                    // way round. Originally the information was attached as\n                    // <dependenceOnPredecessor> to the dependent record type.\n                    // Now it will be attached as <existanceIndicators> to its\n                    // possible predecessors.\n                    String occurrences = ((Element) recordTypes.item(i)).getAttribute(\"Occurrences\");\n                    // Cardinality of the record type.\n                    boolean isOptional = CardinalityStrings.isCardinalityInterval(occurrences, true) && CardinalityStrings.getCardinalityLow(occurrences, true) == 0;\n                    for (int j = i - 1; j > -1 && isOptional; j++) {\n                        // Backwards loop to the beginning of the record types\n                        // starting at the predecessor of the examined record\n                        // type.\n                        // As long as a record type is optional, its predecessor\n                        // is\n                        // added to the list of possible predecessors for the\n                        // originally\n                        // checked record type.\n                        // Stops at the first record type because this one may\n                        // not be optional.\n                        // Now information attached to the predecessor.\n                        if (existanceIndicators[j] == null) {\n                            // The predecessor does not yet have identified\n                            // successor\n                            // which depend on an existnace indicator.\n                            existanceIndicators[j] = new TreeMap();\n                            existanceIndicators[j].put(dependenceOnPredecessor[0], dependenceOnPredecessor[1]);\n                        } else // then (existanceIndicators[j]==null)\n                        {\n                            // The predecessor already has information about\n                            // successors.\n                            // Existance indicator value for the existance\n                            // indicator\n                            // field stated in the examined record type, but\n                            // used for\n                            // another record type !?\n                            String value = (String) existanceIndicators[j].get(dependenceOnPredecessor[0]);\n                            if (value != null)\n                                // Existance indicator values in the same field\n                                // for different record types.\n                                if (value.length() != dependenceOnPredecessor[1].length()) {\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"16\");\n                                } else\n                                    // No other use of the existance indicator\n                                    // field yet.\n                                    // Store the new value.\n                                    existanceIndicators[j].put(dependenceOnPredecessor[0], dependenceOnPredecessor[1]);\n                        }\n                        // else (existanceIndicators[j]==null)\n                        occurrences = ((Element) recordTypes.item(j)).getAttribute(\"Occurrences\");\n                        // Cardinality of the last checked record type\n                        isOptional = CardinalityStrings.isCardinalityInterval(occurrences, true) && CardinalityStrings.getCardinalityLow(occurrences, true) == 0;\n                    }\n                    // for (int j=i-1; j>-1 && isOptional; j++)\n                }\n                // if (existanceIndicators!=null &&\n                // dependenceOnPredecessor!=null)\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n            recordTypesBefore += recordTypesCount;\n            // Correct the number of checked record types in the so far\n            // examined record groups\n            if (recordGroup.getNodeName().equals(\"RecordGroup\")) {\n                // record groups really present\n                recordGroup = recordGroup.getNextSibling();\n                // Choose next record group\n                if (recordGroup != null) {\n                    // there is a next record group\n                    recordTypes = recordGroup.getChildNodes();\n                    recordTypesCount = recordTypes.getLength();\n                    // Next check the record types in the new group\n                }\n                // if (recordGroup != null)\n            } else\n                // if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // no real record group loop but record declarations directly\n                // in lines section, terminate loop by setting ...\n                recordGroup = null;\n        }\n        // while (recordGroup!=null) - record group loop\n        // Check record type names for uniqueness.\n        for (int i = 0; i < recordTypeNames.length; i++) for (int j = i + 1; j < recordTypeNames.length; j++) if (recordTypeNames[i].equals(recordTypeNames[j])) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"17\");\n        }\n        // Checks on the type identifier\n        // First check their length\n        // If the record type identification is not done by type identifiers,\n        // the two type id lists are empty.\n        int identifierLength = 0;\n        if (typeIds.size() > 0)\n            // Some single value id's\n            identifierLength = ((String) typeIds.get(0)).length();\n        else if (typeIdIntervals.size() > 0)\n            // No single value id but some id intervals\n            identifierLength = ((String[]) typeIdIntervals.get(0))[0].length();\n        // All id's must have the same length.\n        // First the single value id's\n        for (int i = 1; i < typeIds.size(); i++) if (((String) typeIds.get(0)).length() != identifierLength) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"18\");\n        }\n        // Second the id intervals\n        for (int i = 1; i < typeIdIntervals.size(); i++) // Attention: two values!\n        if (((String[]) typeIdIntervals.get(0))[0].length() != identifierLength || ((String[]) typeIdIntervals.get(0))[1].length() != identifierLength) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"18\");\n        }\n        // Second, check the id uniqueness in sense of identification of only\n        // one\n        // record type\n        if (!typeIdsAreUnique(typeIds, typeIdIntervals)) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"20\");\n        }\n        // Return the found record type names and existance indicators.\n        Object[] checkInfos = new Object[2];\n        checkInfos[0] = recordTypeNames;\n        checkInfos[1] = existanceIndicators;\n        return checkInfos;\n    }\n\n    // checkLinesSpecification(Element linesSpec, boolean validated)\n    /**\n     * <code>checkRecordTypesSpecification</code> checks the section of record\n     * type specifications for consistency. In particular it checks for\n     * existance of the record types and fields named in the lines section.\n     *\n     * @param recordTypesSpec\n     *            the record type specifications section\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param checkInfos\n     *            record type names and existance indicators found in the lines\n     *            section\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec, Object[] checkInfos, boolean validated) throws XException {\n        try // for casting to XException\n        {\n            NodeList recordTypes = recordTypesSpec.getChildNodes();\n            // Here we have no record groups!\n            for (int i = 0; i < recordTypes.getLength(); i++) {\n                // loop over record type specifications\n                Element recordType = (Element) recordTypes.item(i);\n                // Extension if no prior validating\n                if (!recordType.getNodeName().equals(\"RecordTypeSpec\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"21\");\n                }\n                String recTypeName = recordType.getAttribute(\"Name\");\n                // Extension if no prior validating\n                if (recTypeName == null || !XDomSupport.isValidTagName(recTypeName)) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"22\");\n                }\n                // Search record type name in the name array from\n                // the record type (Lines) section.\n                boolean nameSearched = true;\n                // Still searching?\n                int pos = 0;\n                for (; pos < ((String[]) checkInfos[0]).length && nameSearched; pos++) // loop over record type names from the lines section\n                if (recTypeName.equals(((String[]) checkInfos[0])[pos])) {\n                    // name found\n                    ((String[]) checkInfos[0])[pos] = null;\n                    // deleted for avoiding more hits\n                    nameSearched = false;\n                    // search loop ended for this record type\n                }\n                // if\n                // (recTypeName.equals(((String[])checkInfos[0])[pos]))\n                if (nameSearched) {\n                    // Record type not declared in lines section\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"23\");\n                }\n                // Now the single fields in the record type\n                TreeMap existanceIndicators = null;\n                // With the found position in the checkInfos array\n                // the correct existance indicator map is retrieved ...\n                if (checkInfos[1] != null)\n                    // Because pos was augmented once to much in the for loop,\n                    // now\n                    // use pos-1.\n                    existanceIndicators = ((TreeMap[]) checkInfos[1])[pos - 1];\n                // ... and feeded to field checking\n                checkFieldsAndGroupRefs(recordType, groupsSpec, existanceIndicators, validated);\n            }\n            // for (int i=0; i<recordTypes.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkRecordTypesSpecification(Node recordTypesSpec, Node groupsSpec,\n    // Object[] checkInfos, boolean validated)\n    /**\n     * <code>checkTrailerSpecification</code> checks the consistency of the\n     * file trailer desription.\n     *\n     * @param trailerSpec\n     *            the structure description for the trailer\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of a inconsistency\n     */\n    public void checkTrailerSpecification(Element trailerSpec, Node groupsSpec, boolean validated) throws XException {\n        // Extension if no prior DTD validating\n        if (trailerSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"1\");\n        }\n        // Now the single fields in the header\n        checkFieldsAndGroupRefs(trailerSpec, groupsSpec, null, validated);\n    }\n\n    // checkTrailerSpecification(Element trailerSpec, Node groupsSpec,\n    // boolean validated)\n    /**\n     * <code>checkGroupsSpecification</code> checks the consistency of each\n     * field group specification.\n     *\n     * @param groupsSpec\n     *            the list of field group specifications\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupsSpecification(Node groupsSpec, boolean validated) throws XException {\n        NodeList groups = groupsSpec.getChildNodes();\n        if (!validated) {\n            // Extension if no prior DTD validating\n            try // for casting to XException\n            {\n                for (int i = 0; i < groups.getLength(); i++) // consistency check on each single group specification\n                // (redundant to validating against DTD)\n                checkGroupSpecification((Element) groups.item(i));\n            }// try\n             catch (ClassCastException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n            }\n            // catch\n        }\n        // if (!validated)\n        // Check for the uniqueness of group names\n        for (int i = 0; i < groups.getLength() - 1; i++) {\n            String groupName = ((Element) groups.item(i)).getAttribute(\"Name\");\n            for (int j = i + 1; j < groups.getLength(); j++) if (groupName.equals(((Element) groups.item(j)).getAttribute(\"Name\"))) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"27\");\n            }\n        }\n        // for (int i=0; i<groups.getLength()-1; i++)\n    }\n\n    // checkGroupsSpecification(Node groupsSpec, boolean validated)\n    // //////////////////////////////////////////////\n    // Structrue checking on some deeper level\n    // //////////////////////////////////////////////\n    /**\n     * <code>checkRecordTypeDeclaration</code> checks a record type\n     * declaration for consistency. Furthermore is fills the\n     * <code>recordTypeNames</code> and <code>existanceIndicators</code> to\n     * check consistency with the record type specifications afterwards.\n     *\n     * @param recTypeDecl\n     *            the DOM node of the declaration\n     * @param recordTypesCount\n     *            the number of record types in the actual record group or the\n     *            whole file (wihtout grouping)\n     * @param pos\n     *            the position in the list of declarations (starts at 0)\n     * @param recIdentMethod\n     *            the method to identify record types\n     * @param recOrder\n     *            the order of records in the file\n     * @param recordTypeNames\n     *            array of record type names, filled at position\n     *            <code>pos</code> right here\n     * @param typeIds\n     *            the list of single-value type id's, a found id will be added\n     * @param typeIdIntervals\n     *            the list of type id intervals, a found interval will be added\n     * @param existanceIndicators\n     *            array of existance indicator maps, potentially filled with\n     *            self reference at position <code>pos</code> right here\n     * @return field/value pair for an existance indicator in the record type\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public String[] checkRecordTypeDeclaration(Node recTypeDecl, int recordTypesCount, int pos, String recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators) throws XException {\n        String[] precedingIndicator = null;\n        // for returning exstistance indicator information for predecessors\n        try // for casting to XException\n        {\n            if (recIdentMethod.equals(\"TypeIdentifier\")) {\n                // Record types are identified by an id\n                String id = ((Element) recTypeDecl).getAttribute(\"Identifier\");\n                // a single-value id\n                String[] idLoHi = new String[2];\n                idLoHi[0] = ((Element) recTypeDecl).getAttribute(\"IdentifierLow\");\n                idLoHi[1] = ((Element) recTypeDecl).getAttribute(\"IdentifierHigh\");\n                // an id interval\n                if (id.length() == 0) {\n                    // No single-value id\n                    if (idLoHi[0].length() == 0 || idLoHi[1].length() == 0) {\n                        // Something must be specified: single value or\n                        // interval.\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"28\");\n                    }\n                    typeIdIntervals.add(idLoHi);\n                } else // then (id.length()==0)\n                {\n                    // Single-value id found\n                    if (idLoHi[0].length() > 0 || idLoHi[1].length() > 0) {\n                        // Any interval specification conflicts.\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"28\");\n                    }\n                    typeIds.add(id);\n                }\n                // else (id.length()==0)\n            }\n            // if (recIdentMethod.equals(\"TypeIdentifier\"))\n            recordTypeNames[pos] = XDomSupport.getTrimedNodeText(recTypeDecl);\n            // the record type name\n            if (!XDomSupport.isValidTagName(recordTypeNames[pos])) {\n                // It must be a legal xml tag name.\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"30\");\n            }\n            // Now look for record identification features, in particular the\n            // cardinality\n            // and existance indicator\n            if (recOrder.equals(\"Ordered\") || recOrder.equals(\"Structured\")) {\n                // Records are listed in the record type order or in groups.\n                // The cardinality must be specified.\n                String occurrences = ((Element) recTypeDecl).getAttribute(\"Occurrences\");\n                if (occurrences.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"31\");\n                }\n                if (!CardinalityStrings.isCardinalityValid(occurrences)) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"32\");\n                }\n                // The first record in a record group must have cardinality 1.\n                if (recOrder.equals(\"Structured\") && pos == 0) {\n                    try {\n                        int occurrNum = Integer.parseInt(occurrences);\n                        if (occurrNum != 1) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"33\");\n                        }\n                    }// try\n                     catch (NumberFormatException e) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"33\");\n                    }\n                    // catch\n                }\n                // if (recOrder.equals(\"Structured\") && pos==0)\n                // If the record type is not given by an id but the cardinality\n                // is specified as an\n                // interval and there are also other record types, there must be\n                // an existance indicator\n                // refering the preceding record.\n                if (recordTypesCount > 1 && !recIdentMethod.equals(\"TypeIdentifier\") && CardinalityStrings.isCardinalityInterval(occurrences, true)) {\n                    String existIndField = ((Element) recTypeDecl).getAttribute(\"ExistIndicatorField\");\n                    // Indicator field specified by name\n                    if (existIndField.length() == 0) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"35\");\n                    }\n                    String existIndValue = ((Element) recTypeDecl).getAttribute(\"ExistIndicatorValue\");\n                    if (existIndValue.length() == 0) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"36\");\n                    }\n                    precedingIndicator = new String[2];\n                    precedingIndicator[0] = existIndField;\n                    precedingIndicator[1] = existIndValue;\n                    // If the record type may occurr more than once, it may be\n                    // its\n                    // predecessor itself.\n                    if (CardinalityStrings.getCardinalityHigh(occurrences, true) > 1) {\n                        existanceIndicators[pos] = new TreeMap();\n                        existanceIndicators[pos].put(precedingIndicator[0], precedingIndicator[1]);\n                    }\n                    // if (getCardinalityHigh(occurrences,true)>1)\n                }\n                // if (!recIdentMethod.equals(\"TypeIdentifier\") &&\n                // isCardinalityInterval(occurrences,true))\n            }\n            // if (recOrder.equals(\"Ordered\") ||\n            // recOrder.equals(\"Structured\"))\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return precedingIndicator;\n        // Group starting record type found?\n    }\n\n    // checkRecordTypeDeclaration(Node recTypeDecl, int pos, String\n    // recIdentMethod, String recOrder, String[] recordTypeNames, LinkedList\n    // typeIds, LinkedList typeIdIntervals, TreeMap[] existanceIndicators)\n    /**\n     * <code>checkFieldsAndGroupRefs</code> checks the fields and group\n     * references within an record type (including header and trailer) for\n     * consistency.\n     *\n     * @param parent\n     *            the record type specification node\n     * @param groupsSpec\n     *            the list of field group specifications\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to fields will be marked\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    private void checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap existanceIndicators, boolean validated) throws XException {\n        try // try-catch block for casting standard exceptions to XException\n        {\n            NodeList fieldSpecs = parent.getChildNodes();\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                // Two alternatives: field or group\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    checkFieldSpecification(fieldSpec, existanceIndicators, validated);\n                else if (fieldSpec.getNodeName().equals(\"Group\"))\n                    checkGroupReference(fieldSpec, groupsSpec, existanceIndicators);\n                else // Extension if no prior DTD validating\n                {\n                    List params = new Vector();\n                    params.add(fieldSpec.getNodeName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"38\", params);\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkFieldsAndGroupRefs(Node parent, Node groupsSpec, TreeMap\n    // existanceIndicators)\n    /**\n     * <code>checkGroupReference</code> checks the consistency of a reference\n     * to a field group.\n     *\n     * @param groupRef\n     *            the DOM node for the group reference\n     * @param groupsSpec\n     *            the list of field group specifications to check group\n     *            references\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to group fields will be marked\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupReference(Element groupRef, Node groupsSpec, TreeMap existanceIndicators) throws XException {\n        try {\n            String groupName = groupRef.getAttribute(\"Name\");\n            // Extension if no prior DTD validating\n            if (groupName.length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"40\");\n            }\n            // Search for the group specification.\n            if (groupsSpec == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"41\");\n            }\n            List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec, \"Name\", groupName, \"GroupSpec\");\n            if (groups == null || groups.size() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"42\");\n            }\n            if (groups.size() > 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"43\");\n            }\n            // Group specification found\n            // some existance indicators to search for\n            if (existanceIndicators != null) {\n                NodeList fields = ((Node) groups.get(0)).getChildNodes();\n                for (int i = 0; i < fields.getLength(); i++) {\n                    String name = ((Element) fields.item(i)).getAttribute(\"Name\");\n                    String value = (String) existanceIndicators.get(name);\n                    if (value != null) {\n                        if (value.equals(\"Found\")) {\n                            // Will always occurr if a record type contains more\n                            // than one instance of\n                            // a group. Thus, existance indicators in group\n                            // should not occurr.\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"44\");\n                        }\n                        int length = Integer.parseInt(((Element) fields.item(i)).getAttribute(\"Length\"));\n                        if (value.length() != length) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"45\");\n                        }\n                        // Mark as found.\n                        existanceIndicators.put(name, \"Found\");\n                    }\n                    // if (value!=null)\n                }\n                // for (int i=0; i<fields.getLength(); i++)\n            }\n            // if (existanceIndicators!=null)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n    }\n\n    // checkGroupReference(Element groupRef, Node groupsSpec, TreeMap\n    // existanceIndicators)\n    /**\n     * <code>checkFieldSpecification</code> checks the consistency of a field\n     * specification.\n     *\n     * @param fieldSpec\n     *            the DOM node for the field specification\n     * @param existanceIndicators\n     *            existance indicator map for the surrounding record type,\n     *            references to field will be marked\n     * @param validated\n     *            Is the xml already validated?\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    private void checkFieldSpecification(Element fieldSpec, TreeMap existanceIndicators, boolean validated) throws XException {\n        try {\n            // Field name\n            String name = fieldSpec.getAttribute(\"Name\");\n            // Field length\n            String length = fieldSpec.getAttribute(\"Length\");\n            // Field format\n            String format = fieldSpec.getAttribute(\"Format\");\n            if (!validated) {\n                // Extension if no prior DTD validating\n                if (name.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"48\");\n                }\n                if (length.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"49\");\n                }\n                if (format.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"50\");\n                }\n            }\n            // if (!validated)\n            // For dates further format infoamtion is mandatory.\n            if (format.equals(\"date\") && fieldSpec.getAttribute(\"DateFormat\").length() == 0) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"51\");\n            }\n            // The length must be an strictly positive integer\n            int lengthNum = Integer.parseInt(length);\n            if (lengthNum < 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"52\");\n            }\n            // Constant values must be bound to a value.\n            if (format.equals(\"const\")) {\n                String value = fieldSpec.getAttribute(\"Value\");\n                if (value.length() == 0) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"53\");\n                } else if (value.length() != lengthNum) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"54\");\n                }\n            }\n            // if (fieldSpec.getAttribute(\"Format\").equals(\"const\"))\n            // some existance indicators to search for\n            if (existanceIndicators != null) {\n                String value = (String) existanceIndicators.get(name);\n                if (value != null) {\n                    // existance indicator defined for this field\n                    if (value.equals(\"Found\")) {\n                        // Already found for other field\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"44\");\n                    }\n                    if (value.length() != lengthNum) {\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"45\");\n                    }\n                    // Mark as found.\n                    existanceIndicators.put(name, \"Found\");\n                }\n                // if (value!=null)\n            }\n            // if (existanceIndicators!=null)\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }// catch\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkFieldSpecification(Element fieldSpec, TreeMap\n    // existanceIndicators, boolean validated)\n    /**\n     * <code>checkGroupSpecification</code> checks the consistency of a single\n     * field group specification. Extension if no prior DTD validating because\n     * otherwise completely redundant.\n     *\n     * @param groupSpec\n     *            the group specification to check as DOM node\n     * @throws XException\n     *             in case of an inconsistency\n     */\n    public void checkGroupSpecification(Element groupSpec) throws XException {\n        if (groupSpec.getAttribute(\"Name\").length() == 0) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"59\");\n        }\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = groupSpec.getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all group fields\n                if (!((Element) fieldSpecs.item(i)).getNodeName().equals(\"Field\")) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"60\");\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // checkGroupSpecification(Node groupSpec)\n    // ///////////////////////\n    // Auxiliary functions\n    // ///////////////////////\n    /**\n     * <code>typeIdsAreUnique</code> checks if each declared record type id\n     * refers uniquely to only one record type.\n     *\n     * @param typeIds\n     *            single-value id's as found in the record type declarations\n     * @param typeIdIntervals\n     *            intervals of id's (used as counters) as found in the record\n     *            type declarations\n     * @return <code>true</code> if all id's are unique, false if an id refers\n     *         to two record types\n     */\n    public boolean typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals) {\n        boolean result = true;\n        for (int i = 0; i < typeIds.size() && result; i++) {\n            // Loop over all single-value id's\n            for (int j = i + 1; j < typeIds.size() && result; j++) // Loop over rest of single-value id's\n            result = !((String) typeIds.get(i)).equals((typeIds.get(j)));\n            // Repeated id?\n            for (int j = 0; j < typeIdIntervals.size() && result; j++) // Loop over all id intervals\n            result = (((String) typeIds.get(i)).compareTo(((String[]) typeIdIntervals.get(j))[0]) < 0) || (((String) typeIds.get(i)).compareTo(((String[]) typeIdIntervals.get(j))[1]) > 0);\n            // Or member of one of the intervals?\n        }\n        // for (int i=0; i<typeIds.size() && result; i++)\n        for (int i = 0; i < typeIdIntervals.size() && result; i++) // Loop over all id intervals\n        for (int j = i + 1; j < typeIdIntervals.size() && result; j++) // Loop over rest of intervals\n        result = (((String[]) typeIdIntervals.get(i))[0].compareTo(((String[]) typeIdIntervals.get(j))[1]) > 0) || (((String[]) typeIdIntervals.get(i))[1].compareTo(((String[]) typeIdIntervals.get(j))[0]) < 0);\n        // Do the two intervals intersect?\n        return result;\n    }\n\n    // typeIdsAreUnique(LinkedList typeIds, LinkedList typeIdIntervals)\n    /**\n     * <code>computeRecordLength</code> calculates the string length for a\n     * record type - including header and trailer.\n     *\n     * @param spec\n     *            the record type specification\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the total length including filler\n     * @throws XException\n     *             in case of a mal-specified length\n     */\n    protected static int computeRecordLength(Node spec, Node groupsSpec) throws XException {\n        int fieldLengthSum = 0;\n        // for the result\n        NodeList fieldSpecs = spec.getChildNodes();\n        try // to cast to XException\n        {\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    fieldLengthSum += Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n                else if (fieldSpec.getNodeName().equals(\"Group\"))\n                    fieldLengthSum += computeGroupLength(fieldSpec, groupsSpec);\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        return fieldLengthSum;\n    }\n\n    // computeRecordLength(Element spec)\n    /**\n     * <code>computeGroupLength</code> calculates the string length for a\n     * field group.\n     *\n     * @param groupRef\n     *            a refernce to the group\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the total length including filler\n     * @throws XException\n     *             in case of a mal-specified length or missing group\n     *             specification\n     */\n    protected static int computeGroupLength(Element groupRef, Node groupsSpec) throws XException {\n        int groupLengthSum = 0;\n        // for the result\n        NodeList fieldSpecs = getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n        // the group specification\n        try // for casting to XException\n        {\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    groupLengthSum += Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n                else {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"63\");\n                }\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return groupLengthSum;\n    }\n\n    // computeGroupLength(Element groupRef, Node groupsSpec)\n    /**\n     * <code>getGroupSpec</code> selects the group specification node by the\n     * group name.\n     *\n     * @param groupName\n     *            the name of the field group\n     * @param groupsSpec\n     *            the list of group specifications\n     * @return the group specification node\n     * @throws XException\n     *             in case that the group specification cannot be retrieved\n     */\n    protected static Node getGroupSpec(String groupName, Node groupsSpec) throws XException {\n        Node result = null;\n        try // for casting to XException\n        {\n            List groups = XDomSupport.getChildNodesByAttrValue(groupsSpec, \"Name\", groupName, \"GroupSpec\");\n            if (groups.size() != 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"65\");\n            }\n            result = (Node) groups.get(0);\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return result;\n    }\n    // getGroupSpec(String groupName, Node groupsSpec)\n}\n// RecordTypeDescriptionChecker\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeDescriptionCheckerTest3.java",
		"test_prompt": "// RecordTypeDescriptionCheckerTest3.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeDescriptionChecker}.\n* It contains ten unit test cases for the {@link RecordTypeDescriptionChecker#typeIdsAreUnique(LinkedList, LinkedList)} method.\n*/\nclass RecordTypeDescriptionCheckerTest3 {"
	},
	{
		"original_code": "// RecordTypeSerializer.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>RecordTypeSerializer</code> serves for serializing records stored in\n * a DOM tree according to a record type structure.\n * <p>\n * The DOM tree structure is described in the\n * {@link net.sf.xbus.protocol.records.RecordTypeParser RecordTypeParser}\n * documentation.\n * </p>\n * <p>\n * The serialization result is a String. <br>\n * The string structure is described by a xml file - in particular the contained\n * record types. Such describing files are of document type\n * <code>InterfaceSpec</code> declared in \"InterfaceSpec.dtd\". The structure\n * of the internal DOM tree to serialise is described on the\n * {@link net.sf.xbus.protocol.records.RecordTypeParser RecordTypeParser}\n * documentation page.\n * </p>\n *\n * @author Lars Me�ner, Stehan D�wel\n */\npublic class RecordTypeSerializer extends RecordTypeManipulator {\n\n    // //////////////////////\n    // Static fields\n    // //////////////////////\n    /**\n     * <code>instances</code> stores the instances by thread and the interface\n     * type.\n     */\n    private static Hashtable instances = new Hashtable();\n\n    private static final Object classLock = RecordTypeSerializer.class;\n\n    // //////////////////////\n    // Constructors\n    // //////////////////////\n    /**\n     * Just the standard constructor.\n     */\n    private RecordTypeSerializer() throws XException {\n        super();\n    }\n\n    // RecordTypeParser()\n    // //////////////////////\n    // Static methods\n    // //////////////////////\n    /**\n     * <code>getInstance()</code> retrieves the an instance of\n     * <code>RecordTypeSerializer</code>.\n     *\n     * @param sourceType the name for the parsed structure as it is derived from\n     *            the DOM tree with the interface content\n     * @throws XException in case of missing <code>sourceType</code>\n     */\n    public static RecordTypeSerializer getInstance(String sourceType, int interfaceContentClass) throws XException {\n        synchronized (classLock) {\n            if (sourceType == null || sourceType.length() == 0)\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"68\");\n            RecordTypeSerializer instance = (RecordTypeSerializer) instances.get(Thread.currentThread().getName() + sourceType + interfaceContentClass);\n            if (instance == null) {\n                // no suitable instance available yet\n                instance = new RecordTypeSerializer();\n                instances.put(Thread.currentThread().getName() + sourceType + interfaceContentClass, instance);\n            }\n            // if (instance==null)\n            return instance;\n        }\n    }\n\n    // getInstance(String sourceType)\n    /**\n     * Method getByteArrayConverter.\n     *\n     * @return ByteArrayConverter\n     */\n    protected ByteArrayConverter getByteArrayConverter() throws XException {\n        return ByteArrayConverterFactory.getConverter(sourceType);\n    }\n\n    // /////////////////////////////////////////\n    // Serializing the contents\n    // /////////////////////////////////////////\n    /**\n     * <code>serialize</code> serializes the specified DOM tree due to the\n     * record type definition.\n     *\n     * @param docContent the DOM tree with the interface content\n     * @return the serialized string\n     * @throws XException in case of an unexpected value\n     */\n    public Object serialize(Document docContent) throws XException {\n        if (interfaceStructure == null)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"99\");\n        // The root element has the content type as xml tag.\n        Element root = docContent.getDocumentElement();\n        if (contentType == null || !contentType.equals(root.getNodeName()))\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"120\");\n        Node node = root.getFirstChild();\n        Object result = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n            result = \"\";\n        } else if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n            result = new ByteArrayList();\n        } else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"100\");\n        }\n        if (node == null) {\n            return result;\n        }\n        if (!node.getNodeName().equals(\"Records\")) {\n            // not the records section - thus a header\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                result = serializeHeader(node) + Constants.LINE_SEPERATOR;\n            else\n                ((ByteArrayList) result).add((byte[]) serializeHeader(node));\n            // Go to the records section\n            node = node.getNextSibling();\n        }\n        // if (!node.getNodeName().equals(\"Records\"))\n        // Now the records section\n        if (node == null || !node.getNodeName().equals(\"Records\")) {\n            List params = new Vector();\n            params.add(\"Records expected\");\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"122\", params);\n        }\n        // if (node == null || !node.getNodeName().equals(\"Records\"))\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            result = result + (String) serializeRecords(node);\n        else\n            ((ByteArrayList) result).addAll((ByteArrayList) serializeRecords(node));\n        // Go to trailer or end\n        node = node.getNextSibling();\n        if (node != null) {\n            // trailer found\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                result = result + (String) serializeTrailer(node);\n            else\n                ((ByteArrayList) result).add((byte[]) serializeTrailer(node));\n            // Go to end\n            node = node.getNextSibling();\n        } else // if (node!=null)\n        if (result != null && interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) result).length() > 0)\n            // no trailer\n            // Cut off the line separator after the last record.\n            result = ((String) result).substring(0, ((String) result).length() - Constants.LINE_SEPERATOR.length());\n        // Must be the end.\n        if (node != null) {\n            List params = new Vector();\n            params.add(node.getNodeName());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"123\", params);\n        }\n        // if (node != null)\n        return result;\n    }\n\n    // serialize(Document docContent)\n    /**\n     * <code>serializeHeader</code> parses the header.\n     *\n     * @param headerNode the header in the content DOM tree\n     * @return the serialized header as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeHeader(Node headerNode) throws XException {\n        // Easy: no record type identification necessary\n        // Jump directly to contained fields.\n        return serializeFieldsAndGroups(headerNode, headerSpec);\n    }\n\n    // serializeHeader(Node headerNode)\n    /**\n     * <code>serializeRecords</code> serializes the records section.\n     *\n     * @param recordsNode\n     * @return String\n     */\n    private Object serializeRecords(Node recordsNode) throws XException {\n        String tag = recordsNode.getNodeName();\n        if (tag == null || !tag.equals(\"Records\")) {\n            List params = new Vector();\n            params.add(\"Records expected\");\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"122\", params);\n        }\n        // if (tag == null || !tag.equals(\"Records\"))\n        Object result = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            result = \"\";\n        else\n            result = new ByteArrayList();\n        Node recordGroup = recordsNode.getFirstChild();\n        while (recordGroup != null) {\n            // Loop over the record groups or just a dummy loop\n            // Two possibilities: directly first record or first record group\n            Node record = recordGroup;\n            if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // In case of a record group go one level deeper to the first\n                // record of the group\n                record = recordGroup.getFirstChild();\n            while (record != null) {\n                // loop over the records in the group - or all if no record\n                // groups are present\n                // The record type is identified by the xml tag.\n                // Get it and jum to the contained fields.\n                if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                    result = result + (String) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName())) + Constants.LINE_SEPERATOR;\n                else\n                    ((ByteArrayList) result).add((byte[]) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName())));\n                // Go to next record\n                record = record.getNextSibling();\n            }\n            // while (record!=null)\n            if (recordGroup.getNodeName().equals(\"RecordGroup\")) {\n                // Go to next record group\n                recordGroup = recordGroup.getNextSibling();\n            } else\n                // if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // no record groups, simply end the loop\n                recordGroup = null;\n        }\n        // while (recordGroup!=null)\n        return result;\n    }\n\n    // serializeRecords(Node recordsNode)\n    /**\n     * <code>serializeTrailer</code> parses the header.\n     *\n     * @param trailerNode the trailer in the content DOM tree\n     * @return the serialized trailer as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeTrailer(Node trailerNode) throws XException {\n        // Easy: no record type identification necessary\n        // Jump directly to contained fields.\n        return serializeFieldsAndGroups(trailerNode, trailerSpec);\n    }\n\n    // serializeTrailer(Node trailerNode)\n    /**\n     * <code>serializeFieldsAndGroups</code> serializes the fields and group\n     * references within a record type - including header and trailer.\n     *\n     * @param recordNode the record node in the result DOM tree\n     * @param recordType the record type specification node in the structure\n     *            descrition to get the field specs from\n     * @return the serialized records as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeFieldsAndGroups(Node recordNode, Node recordType) throws XException {\n        // To avoid permanent string manipulations, a StringBuffer is used.\n        int length = RecordTypeDescriptionChecker.computeRecordLength(recordType, groupsSpec);\n        // Length for the buffer.\n        int pos = 0;\n        // Position in the buffer to put the next field.\n        Object buffer = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            buffer = new StringBuffer(length);\n        else\n            buffer = new byte[length];\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = recordType.getChildNodes();\n            // The next available field node in the content DOM tree.\n            // array for call by reference\n            Node[] fieldNode = new Node[1];\n            // the first field\n            fieldNode[0] = recordNode.getFirstChild();\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all fields and group references in the sturcture\n                // description\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    // a single field\n                    pos = serializeField(fieldSpec, buffer, pos, fieldNode);\n                else // May have moved the actual field node in the content DOM tree\n                if (fieldSpec.getNodeName().equals(\"Group\"))\n                    // a field group\n                    pos = serializeGroup(fieldSpec, buffer, pos, fieldNode);\n                // May have moved the actual field node in the content DOM tree\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n            // All record fields in the content DOM tree should be serialized.\n            if (fieldNode[0] != null) {\n                List params = new Vector();\n                params.add(fieldNode[0].getNodeName());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"125\", params);\n            }\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            return new String((StringBuffer) buffer);\n        else\n            return buffer;\n    }\n\n    // serializeFieldsAndGroups(Node recordNode, Node recordType)\n    /**\n     * <code>serializeGroup</code> serializes the fields of a field group\n     * defined in the interface structure description.\n     *\n     * @param groupRef the group reference in the structure description\n     * @param buffer the buffer to fill with the serialized field contents\n     * @param pos the position in the buffer to start the filling\n     * @param fieldNode the next available field node in the content DOM tree -\n     *            array for call by reference\n     * @return the buffer position to start the next filling at\n     * @throws XException in case of an unexpected value\n     */\n    private int serializeGroup(Element groupRef, Object buffer, int pos, Node[] fieldNode) throws XException {\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = RecordTypeDescriptionChecker.getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) pos = serializeField((Element) fieldSpecs.item(i), buffer, pos, fieldNode);\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return pos;\n    }\n\n    // serializeGroup(Element groupRef,StringBuffer buffer,int pos,Node[]\n    // fieldNode)\n    /**\n     * <code>serializeField</code> serializes the fields of a field group\n     * defined in the interface structure description.\n     *\n     * @param fieldSpec the field specification in the structure description\n     * @param buffer the buffer to fill with the serialized field contents\n     * @param pos the position in the buffer to start the filling\n     * @param fieldNode the next available field node in the content DOM tree -\n     *            array for call by reference\n     * @return the buffer position to start the next filling at\n     * @throws XException in case of an unexpected value\n     */\n    private int serializeField(Element fieldSpec, Object buffer, int pos, Node[] fieldNode) throws XException {\n        try // for casting to XException\n        {\n            String fieldFormat = fieldSpec.getAttribute(\"Format\");\n            if (fieldFormat == null || fieldFormat.length() == 0) {\n                List params = new Vector();\n                params.add(\"Format\");\n                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                params.add(fieldSpec.toString());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"82\", params);\n            }\n            // How many characters?\n            int length = Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n            if (fieldFormat.equals(\"blank\")) {\n                // only filler - no corresponding node in the content DOM tree\n                if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                    for (int i = 0; i < length; i++) ((StringBuffer) buffer).insert(pos + i, ' ');\n                else\n                    fillByteArray((byte[]) buffer, pos, length, \"\");\n            } else // then (fieldFormat.equals(\"blank\"))\n            {\n                // Not just filler\n                String fieldName = fieldSpec.getAttribute(\"Name\");\n                String nodeName = null;\n                if (fieldNode[0] != null)\n                    nodeName = fieldNode[0].getNodeName();\n                if (fieldName == null) {\n                    List params = new Vector();\n                    params.add(\"Name\");\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.toString());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"82\", params);\n                }\n                // if (fieldName == null)\n                // The field value may be stored in the content DOM tree or\n                // a standard value may be used.\n                String value = \"\";\n                // standard for alphanumeric fields\n                if (fieldFormat.equals(\"num\"))\n                    value = \"0\";\n                // standard for numeric fields\n                if (fieldName.equals(nodeName)) {\n                    // The value is given in the content DOM tree.\n                    value = XDomSupport.getNodeText(fieldNode[0]);\n                    // Set the next available field in the content DOM tree one\n                    // further\n                    fieldNode[0] = fieldNode[0].getNextSibling();\n                }\n                // if (fieldName.equals(nodeName))\n                // Now a value - read from the content DOM tree or standard - is\n                // given.\n                if (fieldFormat.equals(\"const\")) {\n                    String constValue = fieldSpec.getAttribute(\"Value\");\n                    // value specified in the interface description\n                    byte[] constValueBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        constValueBytes = byteArrayConverter.stringToByteArray(constValue);\n                    }\n                    // if (interfaceContentClass ==\n                    // Constants.IFCONTENTCLASS_BYTEARRAYLIST)\n                    if (!constValue.equals(value)) {\n                        // The interface description must specify a value of\n                        // correct\n                        // length.\n                        // If the content DOM tree has a value, they must be\n                        // identical (after triming).\n                        List params = new Vector();\n                        params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                        params.add(fieldSpec.getAttribute(\"Name\"));\n                        params.add(\"?\");\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"106\", params);\n                    }\n                    // if (constValue == null || constValueLength != length\n                    // ||\n                    // value.length() > 0 && !constTrimed.equals(value))\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                        ((StringBuffer) buffer).insert(pos, constValue);\n                    else\n                        for (int i = 0; i < length; i++) ((byte[]) buffer)[pos + i] = constValueBytes[i];\n                } else // then (fieldFormat.equals(\"const\"))\n                if (fieldFormat.equals(\"alpha\")) {\n                    int valueLength = value.length();\n                    byte[] valueBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        valueBytes = byteArrayConverter.stringToByteArray(value);\n                        valueLength = valueBytes.length;\n                    }\n                    if (length < valueLength) {\n                        value = value.trim();\n                        valueLength = value.length();\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                            valueBytes = byteArrayConverter.stringToByteArray(value);\n                            valueLength = valueBytes.length;\n                        }\n                        if (length < valueLength) {\n                            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(value);\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                            } else // if (interfaceContentClass ==\n                            // Constants.IFCONTENTCLASS_STRING)\n                            {\n                                valueBytes = byteArrayConverter.stringToByteArray(value, length);\n                                valueLength = valueBytes.length;\n                            }\n                        }\n                    }\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                        ((StringBuffer) buffer).insert(pos, value);\n                        // Fill in blanks if the value is to short.\n                        for (int i = 0; i < length - value.length(); i++) ((StringBuffer) buffer).insert(pos + value.length() + i, ' ');\n                    } else\n                        fillByteArray((byte[]) buffer, pos, length, value);\n                } else // then (fieldFormat.equals(\"alpha\"))\n                if (fieldFormat.equals(\"num\")) {\n                    // First look for a leading sign\n                    int start = 0;\n                    if (value.length() > 0) {\n                        char sign = value.charAt(0);\n                        if (sign == '+' || sign == '-') {\n                            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                                ((StringBuffer) buffer).insert(pos, sign);\n                                start = 1;\n                            } else {\n                                byte[] signBytes = byteArrayConverter.stringToByteArray(\"\" + sign);\n                                start = signBytes.length;\n                                for (int i = 0; i < start; i++) ((byte[]) buffer)[pos + i] = signBytes[i];\n                            }\n                            value = value.substring(1).trim();\n                        }\n                        // if (sign=='+' || sign=='-')\n                    }\n                    // if (value.length()>0)\n                    // Look for a decimal point\n                    String decimalPoint = fieldSpec.getAttribute(\"DecimalPoint\");\n                    int decPointPos = -1;\n                    if (decimalPoint != null && decimalPoint.length() > 0) {\n                        char decimalP = '.';\n                        if (decimalPoint.equals(\"comma\"))\n                            decimalP = ',';\n                        else if (!decimalPoint.equals(\"dot\")) {\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"107\", params);\n                        }\n                        // if (!decimalPoint.equals(\"dot\"))\n                        decPointPos = value.indexOf(decimalP);\n                    }\n                    // if (decimalPoint!=null && decimalPoint.length()>0)\n                    // Check digits\n                    int zeroBegin = -1;\n                    int zeroEnd = value.length();\n                    boolean onlyZeros = true;\n                    if (decPointPos > -1) {\n                        // Check digits before decimal point\n                        for (int i = 0; i < decPointPos; i++) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroBegin = i;\n                            else\n                                onlyZeros = false;\n                        }\n                        // for (int i=0; i<decPointPos; i++)\n                        // Check digits behind decimal point\n                        onlyZeros = true;\n                        for (int i = value.length() - 1; i > decPointPos; i--) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroEnd = i;\n                            else\n                                onlyZeros = false;\n                        }\n                        // for (int i=valueWithoutSign.length()-1;\n                        // i>decPointPos; i--)\n                    } else\n                        // then (decPointPos>-1)\n                        // no decimal point\n                        for (int i = 0; i < value.length(); i++) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                params.add(value);\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroBegin = i;\n                            else\n                                onlyZeros = false;\n                        }\n                    // for (int i=0; i<valueWithoutSign.length(); i++)\n                    String valueWithoutSignZeros = value.substring(zeroBegin + 1, zeroEnd);\n                    int valueWithoutSignZerosLength = valueWithoutSignZeros.length();\n                    byte[] valueWithoutSignZerosBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        valueWithoutSignZerosBytes = byteArrayConverter.stringToByteArray(value);\n                        valueWithoutSignZerosLength = valueWithoutSignZerosBytes.length;\n                        if (valueWithoutSignZerosLength > length - start) {\n                            // Too long - even if zeros are deleted.\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                        }\n                        // if (valueWithoutSignZerosLength > length - start)\n                        byte[] zero = byteArrayConverter.stringToByteArray(\"0\");\n                        if (decPointPos > -1) {\n                            int offset = pos + start;\n                            for (int i = 0; i < valueWithoutSignZerosLength; i++) ((byte[]) buffer)[offset + i] = valueWithoutSignZerosBytes[i];\n                            offset += valueWithoutSignZerosLength;\n                            for (int i = 0; i < (length - start - valueWithoutSignZerosLength) / zero.length; i++) {\n                                for (int j = 0; j < zero.length; j++) ((byte[]) buffer)[offset + j] = zero[j];\n                                offset += zero.length;\n                            }\n                            for (int i = offset; i < length; i++) ((byte[]) buffer)[i] = 0;\n                        } else {\n                            int offset = pos + start;\n                            for (int i = 0; i < (length - start - valueWithoutSignZerosLength) / zero.length; i++) {\n                                for (int j = 0; j < zero.length; j++) ((byte[]) buffer)[offset + j] = zero[j];\n                                offset += zero.length;\n                            }\n                            for (int i = 0; i < valueWithoutSignZerosLength; i++) ((byte[]) buffer)[offset + i] = valueWithoutSignZerosBytes[i];\n                            offset += valueWithoutSignZerosLength;\n                            for (int i = offset; i < length; i++) ((byte[]) buffer)[i] = 0;\n                        }\n                    } else {\n                        if (zeroEnd - zeroBegin - 1 > length - start) {\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                        }\n                        // if (zeroEnd - zeroBegin - 1 > length - start)\n                        if (length - start + zeroBegin + 1 < value.length())\n                            // Delete zeros at the end after the decimal point\n                            // but only to that extend that the necessary length\n                            // is achieved by delelting leading zeros.\n                            value = value.substring(0, length - start + zeroBegin + 1);\n                        if (zeroBegin > -1)\n                            // Delete zeros at beginning\n                            value = value.substring(zeroBegin + 1);\n                        // Fill in zeros at beginning if necessary\n                        for (int i = 0; i < length - value.length() - start; i++) ((StringBuffer) buffer).insert(pos + start + i, '0');\n                        // Put value into buffer - sign is already there.\n                        ((StringBuffer) buffer).insert(pos + length - value.length(), value);\n                    }\n                } else // (fieldFormat.equals(\"num\"))\n                if (fieldFormat.equals(\"date\")) {\n                    if (value.length() == 0)\n                        // Blanks allowed.\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                            for (int i = 0; i < length; i++) ((StringBuffer) buffer).insert(pos + i, ' ');\n                        else\n                            fillByteArray((byte[]) buffer, pos, length, \"\");\n                    else {\n                        int valueLength = value.length();\n                        byte[] valueBytes = null;\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                            valueBytes = byteArrayConverter.stringToByteArray(value);\n                            valueLength = valueBytes.length;\n                        }\n                        if (length != valueLength) {\n                            // Otherwise length must be correct.\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"138\", params);\n                        }\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                            ((StringBuffer) buffer).insert(pos, value);\n                        else\n                            for (int i = 0; i < length; i++) ((byte[]) buffer)[pos + i] = valueBytes[i];\n                    }\n                } else // then (fieldFormat.equals(\"date\"))\n                {\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldFormat);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"139\", params);\n                }\n                // else (fieldFormat.equals(\"date\"))\n            }\n            // else (fieldFormat.equals(\"blank\"))\n            return pos + length;\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // serializeField(Element fieldSpec,StringBuffer buffer,int pos,Node[]\n    // fieldNode)\n    /**\n     * Method fillByteArray.\n     *\n     * @param b\n     * @param pos\n     * @param length\n     * @param constValue\n     */\n    private void fillByteArray(byte[] arr, int pos, int length, String value) throws XException {\n        byte[] fill = byteArrayConverter.stringToByteArray(value, length);\n        for (int i = 0; i < length; i++) arr[pos + i] = fill[i];\n    }\n\n    /**\n     * Serializes one record.\n     *\n     * @param doc\n     * @return a byte array containing one record\n     */\n    public byte[] serializeSingleRecord(Document doc) throws XException {\n        Element record = doc.getDocumentElement();\n        return (byte[]) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName()));\n    }\n}\n// RecordTypeSerializer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeSerializerTest0.java",
		"test_prompt": "// RecordTypeSerializerTest0.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeSerializer}.\n* It contains ten unit test cases for the {@link RecordTypeSerializer#getInstance(String, int)} method.\n*/\nclass RecordTypeSerializerTest0 {"
	},
	{
		"original_code": "// RecordTypeSerializer.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>RecordTypeSerializer</code> serves for serializing records stored in\n * a DOM tree according to a record type structure.\n * <p>\n * The DOM tree structure is described in the\n * {@link net.sf.xbus.protocol.records.RecordTypeParser RecordTypeParser}\n * documentation.\n * </p>\n * <p>\n * The serialization result is a String. <br>\n * The string structure is described by a xml file - in particular the contained\n * record types. Such describing files are of document type\n * <code>InterfaceSpec</code> declared in \"InterfaceSpec.dtd\". The structure\n * of the internal DOM tree to serialise is described on the\n * {@link net.sf.xbus.protocol.records.RecordTypeParser RecordTypeParser}\n * documentation page.\n * </p>\n *\n * @author Lars Me�ner, Stehan D�wel\n */\npublic class RecordTypeSerializer extends RecordTypeManipulator {\n\n    // //////////////////////\n    // Static fields\n    // //////////////////////\n    /**\n     * <code>instances</code> stores the instances by thread and the interface\n     * type.\n     */\n    private static Hashtable instances = new Hashtable();\n\n    private static final Object classLock = RecordTypeSerializer.class;\n\n    // //////////////////////\n    // Constructors\n    // //////////////////////\n    /**\n     * Just the standard constructor.\n     */\n    private RecordTypeSerializer() throws XException {\n        super();\n    }\n\n    // RecordTypeParser()\n    // //////////////////////\n    // Static methods\n    // //////////////////////\n    /**\n     * <code>getInstance()</code> retrieves the an instance of\n     * <code>RecordTypeSerializer</code>.\n     *\n     * @param sourceType the name for the parsed structure as it is derived from\n     *            the DOM tree with the interface content\n     * @throws XException in case of missing <code>sourceType</code>\n     */\n    public static RecordTypeSerializer getInstance(String sourceType, int interfaceContentClass) throws XException {\n        synchronized (classLock) {\n            if (sourceType == null || sourceType.length() == 0)\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"68\");\n            RecordTypeSerializer instance = (RecordTypeSerializer) instances.get(Thread.currentThread().getName() + sourceType + interfaceContentClass);\n            if (instance == null) {\n                // no suitable instance available yet\n                instance = new RecordTypeSerializer();\n                instances.put(Thread.currentThread().getName() + sourceType + interfaceContentClass, instance);\n            }\n            // if (instance==null)\n            return instance;\n        }\n    }\n\n    // getInstance(String sourceType)\n    /**\n     * Method getByteArrayConverter.\n     *\n     * @return ByteArrayConverter\n     */\n    protected ByteArrayConverter getByteArrayConverter() throws XException {\n        return ByteArrayConverterFactory.getConverter(sourceType);\n    }\n\n    // /////////////////////////////////////////\n    // Serializing the contents\n    // /////////////////////////////////////////\n    /**\n     * <code>serialize</code> serializes the specified DOM tree due to the\n     * record type definition.\n     *\n     * @param docContent the DOM tree with the interface content\n     * @return the serialized string\n     * @throws XException in case of an unexpected value\n     */\n    public Object serialize(Document docContent) throws XException {\n        if (interfaceStructure == null)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"99\");\n        // The root element has the content type as xml tag.\n        Element root = docContent.getDocumentElement();\n        if (contentType == null || !contentType.equals(root.getNodeName()))\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"120\");\n        Node node = root.getFirstChild();\n        Object result = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n            result = \"\";\n        } else if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n            result = new ByteArrayList();\n        } else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"100\");\n        }\n        if (node == null) {\n            return result;\n        }\n        if (!node.getNodeName().equals(\"Records\")) {\n            // not the records section - thus a header\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                result = serializeHeader(node) + Constants.LINE_SEPERATOR;\n            else\n                ((ByteArrayList) result).add((byte[]) serializeHeader(node));\n            // Go to the records section\n            node = node.getNextSibling();\n        }\n        // if (!node.getNodeName().equals(\"Records\"))\n        // Now the records section\n        if (node == null || !node.getNodeName().equals(\"Records\")) {\n            List params = new Vector();\n            params.add(\"Records expected\");\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"122\", params);\n        }\n        // if (node == null || !node.getNodeName().equals(\"Records\"))\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            result = result + (String) serializeRecords(node);\n        else\n            ((ByteArrayList) result).addAll((ByteArrayList) serializeRecords(node));\n        // Go to trailer or end\n        node = node.getNextSibling();\n        if (node != null) {\n            // trailer found\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                result = result + (String) serializeTrailer(node);\n            else\n                ((ByteArrayList) result).add((byte[]) serializeTrailer(node));\n            // Go to end\n            node = node.getNextSibling();\n        } else // if (node!=null)\n        if (result != null && interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) result).length() > 0)\n            // no trailer\n            // Cut off the line separator after the last record.\n            result = ((String) result).substring(0, ((String) result).length() - Constants.LINE_SEPERATOR.length());\n        // Must be the end.\n        if (node != null) {\n            List params = new Vector();\n            params.add(node.getNodeName());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"123\", params);\n        }\n        // if (node != null)\n        return result;\n    }\n\n    // serialize(Document docContent)\n    /**\n     * <code>serializeHeader</code> parses the header.\n     *\n     * @param headerNode the header in the content DOM tree\n     * @return the serialized header as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeHeader(Node headerNode) throws XException {\n        // Easy: no record type identification necessary\n        // Jump directly to contained fields.\n        return serializeFieldsAndGroups(headerNode, headerSpec);\n    }\n\n    // serializeHeader(Node headerNode)\n    /**\n     * <code>serializeRecords</code> serializes the records section.\n     *\n     * @param recordsNode\n     * @return String\n     */\n    private Object serializeRecords(Node recordsNode) throws XException {\n        String tag = recordsNode.getNodeName();\n        if (tag == null || !tag.equals(\"Records\")) {\n            List params = new Vector();\n            params.add(\"Records expected\");\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"122\", params);\n        }\n        // if (tag == null || !tag.equals(\"Records\"))\n        Object result = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            result = \"\";\n        else\n            result = new ByteArrayList();\n        Node recordGroup = recordsNode.getFirstChild();\n        while (recordGroup != null) {\n            // Loop over the record groups or just a dummy loop\n            // Two possibilities: directly first record or first record group\n            Node record = recordGroup;\n            if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // In case of a record group go one level deeper to the first\n                // record of the group\n                record = recordGroup.getFirstChild();\n            while (record != null) {\n                // loop over the records in the group - or all if no record\n                // groups are present\n                // The record type is identified by the xml tag.\n                // Get it and jum to the contained fields.\n                if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                    result = result + (String) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName())) + Constants.LINE_SEPERATOR;\n                else\n                    ((ByteArrayList) result).add((byte[]) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName())));\n                // Go to next record\n                record = record.getNextSibling();\n            }\n            // while (record!=null)\n            if (recordGroup.getNodeName().equals(\"RecordGroup\")) {\n                // Go to next record group\n                recordGroup = recordGroup.getNextSibling();\n            } else\n                // if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // no record groups, simply end the loop\n                recordGroup = null;\n        }\n        // while (recordGroup!=null)\n        return result;\n    }\n\n    // serializeRecords(Node recordsNode)\n    /**\n     * <code>serializeTrailer</code> parses the header.\n     *\n     * @param trailerNode the trailer in the content DOM tree\n     * @return the serialized trailer as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeTrailer(Node trailerNode) throws XException {\n        // Easy: no record type identification necessary\n        // Jump directly to contained fields.\n        return serializeFieldsAndGroups(trailerNode, trailerSpec);\n    }\n\n    // serializeTrailer(Node trailerNode)\n    /**\n     * <code>serializeFieldsAndGroups</code> serializes the fields and group\n     * references within a record type - including header and trailer.\n     *\n     * @param recordNode the record node in the result DOM tree\n     * @param recordType the record type specification node in the structure\n     *            descrition to get the field specs from\n     * @return the serialized records as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeFieldsAndGroups(Node recordNode, Node recordType) throws XException {\n        // To avoid permanent string manipulations, a StringBuffer is used.\n        int length = RecordTypeDescriptionChecker.computeRecordLength(recordType, groupsSpec);\n        // Length for the buffer.\n        int pos = 0;\n        // Position in the buffer to put the next field.\n        Object buffer = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            buffer = new StringBuffer(length);\n        else\n            buffer = new byte[length];\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = recordType.getChildNodes();\n            // The next available field node in the content DOM tree.\n            // array for call by reference\n            Node[] fieldNode = new Node[1];\n            // the first field\n            fieldNode[0] = recordNode.getFirstChild();\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all fields and group references in the sturcture\n                // description\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    // a single field\n                    pos = serializeField(fieldSpec, buffer, pos, fieldNode);\n                else // May have moved the actual field node in the content DOM tree\n                if (fieldSpec.getNodeName().equals(\"Group\"))\n                    // a field group\n                    pos = serializeGroup(fieldSpec, buffer, pos, fieldNode);\n                // May have moved the actual field node in the content DOM tree\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n            // All record fields in the content DOM tree should be serialized.\n            if (fieldNode[0] != null) {\n                List params = new Vector();\n                params.add(fieldNode[0].getNodeName());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"125\", params);\n            }\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            return new String((StringBuffer) buffer);\n        else\n            return buffer;\n    }\n\n    // serializeFieldsAndGroups(Node recordNode, Node recordType)\n    /**\n     * <code>serializeGroup</code> serializes the fields of a field group\n     * defined in the interface structure description.\n     *\n     * @param groupRef the group reference in the structure description\n     * @param buffer the buffer to fill with the serialized field contents\n     * @param pos the position in the buffer to start the filling\n     * @param fieldNode the next available field node in the content DOM tree -\n     *            array for call by reference\n     * @return the buffer position to start the next filling at\n     * @throws XException in case of an unexpected value\n     */\n    private int serializeGroup(Element groupRef, Object buffer, int pos, Node[] fieldNode) throws XException {\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = RecordTypeDescriptionChecker.getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) pos = serializeField((Element) fieldSpecs.item(i), buffer, pos, fieldNode);\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return pos;\n    }\n\n    // serializeGroup(Element groupRef,StringBuffer buffer,int pos,Node[]\n    // fieldNode)\n    /**\n     * <code>serializeField</code> serializes the fields of a field group\n     * defined in the interface structure description.\n     *\n     * @param fieldSpec the field specification in the structure description\n     * @param buffer the buffer to fill with the serialized field contents\n     * @param pos the position in the buffer to start the filling\n     * @param fieldNode the next available field node in the content DOM tree -\n     *            array for call by reference\n     * @return the buffer position to start the next filling at\n     * @throws XException in case of an unexpected value\n     */\n    private int serializeField(Element fieldSpec, Object buffer, int pos, Node[] fieldNode) throws XException {\n        try // for casting to XException\n        {\n            String fieldFormat = fieldSpec.getAttribute(\"Format\");\n            if (fieldFormat == null || fieldFormat.length() == 0) {\n                List params = new Vector();\n                params.add(\"Format\");\n                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                params.add(fieldSpec.toString());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"82\", params);\n            }\n            // How many characters?\n            int length = Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n            if (fieldFormat.equals(\"blank\")) {\n                // only filler - no corresponding node in the content DOM tree\n                if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                    for (int i = 0; i < length; i++) ((StringBuffer) buffer).insert(pos + i, ' ');\n                else\n                    fillByteArray((byte[]) buffer, pos, length, \"\");\n            } else // then (fieldFormat.equals(\"blank\"))\n            {\n                // Not just filler\n                String fieldName = fieldSpec.getAttribute(\"Name\");\n                String nodeName = null;\n                if (fieldNode[0] != null)\n                    nodeName = fieldNode[0].getNodeName();\n                if (fieldName == null) {\n                    List params = new Vector();\n                    params.add(\"Name\");\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.toString());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"82\", params);\n                }\n                // if (fieldName == null)\n                // The field value may be stored in the content DOM tree or\n                // a standard value may be used.\n                String value = \"\";\n                // standard for alphanumeric fields\n                if (fieldFormat.equals(\"num\"))\n                    value = \"0\";\n                // standard for numeric fields\n                if (fieldName.equals(nodeName)) {\n                    // The value is given in the content DOM tree.\n                    value = XDomSupport.getNodeText(fieldNode[0]);\n                    // Set the next available field in the content DOM tree one\n                    // further\n                    fieldNode[0] = fieldNode[0].getNextSibling();\n                }\n                // if (fieldName.equals(nodeName))\n                // Now a value - read from the content DOM tree or standard - is\n                // given.\n                if (fieldFormat.equals(\"const\")) {\n                    String constValue = fieldSpec.getAttribute(\"Value\");\n                    // value specified in the interface description\n                    byte[] constValueBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        constValueBytes = byteArrayConverter.stringToByteArray(constValue);\n                    }\n                    // if (interfaceContentClass ==\n                    // Constants.IFCONTENTCLASS_BYTEARRAYLIST)\n                    if (!constValue.equals(value)) {\n                        // The interface description must specify a value of\n                        // correct\n                        // length.\n                        // If the content DOM tree has a value, they must be\n                        // identical (after triming).\n                        List params = new Vector();\n                        params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                        params.add(fieldSpec.getAttribute(\"Name\"));\n                        params.add(\"?\");\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"106\", params);\n                    }\n                    // if (constValue == null || constValueLength != length\n                    // ||\n                    // value.length() > 0 && !constTrimed.equals(value))\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                        ((StringBuffer) buffer).insert(pos, constValue);\n                    else\n                        for (int i = 0; i < length; i++) ((byte[]) buffer)[pos + i] = constValueBytes[i];\n                } else // then (fieldFormat.equals(\"const\"))\n                if (fieldFormat.equals(\"alpha\")) {\n                    int valueLength = value.length();\n                    byte[] valueBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        valueBytes = byteArrayConverter.stringToByteArray(value);\n                        valueLength = valueBytes.length;\n                    }\n                    if (length < valueLength) {\n                        value = value.trim();\n                        valueLength = value.length();\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                            valueBytes = byteArrayConverter.stringToByteArray(value);\n                            valueLength = valueBytes.length;\n                        }\n                        if (length < valueLength) {\n                            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(value);\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                            } else // if (interfaceContentClass ==\n                            // Constants.IFCONTENTCLASS_STRING)\n                            {\n                                valueBytes = byteArrayConverter.stringToByteArray(value, length);\n                                valueLength = valueBytes.length;\n                            }\n                        }\n                    }\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                        ((StringBuffer) buffer).insert(pos, value);\n                        // Fill in blanks if the value is to short.\n                        for (int i = 0; i < length - value.length(); i++) ((StringBuffer) buffer).insert(pos + value.length() + i, ' ');\n                    } else\n                        fillByteArray((byte[]) buffer, pos, length, value);\n                } else // then (fieldFormat.equals(\"alpha\"))\n                if (fieldFormat.equals(\"num\")) {\n                    // First look for a leading sign\n                    int start = 0;\n                    if (value.length() > 0) {\n                        char sign = value.charAt(0);\n                        if (sign == '+' || sign == '-') {\n                            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                                ((StringBuffer) buffer).insert(pos, sign);\n                                start = 1;\n                            } else {\n                                byte[] signBytes = byteArrayConverter.stringToByteArray(\"\" + sign);\n                                start = signBytes.length;\n                                for (int i = 0; i < start; i++) ((byte[]) buffer)[pos + i] = signBytes[i];\n                            }\n                            value = value.substring(1).trim();\n                        }\n                        // if (sign=='+' || sign=='-')\n                    }\n                    // if (value.length()>0)\n                    // Look for a decimal point\n                    String decimalPoint = fieldSpec.getAttribute(\"DecimalPoint\");\n                    int decPointPos = -1;\n                    if (decimalPoint != null && decimalPoint.length() > 0) {\n                        char decimalP = '.';\n                        if (decimalPoint.equals(\"comma\"))\n                            decimalP = ',';\n                        else if (!decimalPoint.equals(\"dot\")) {\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"107\", params);\n                        }\n                        // if (!decimalPoint.equals(\"dot\"))\n                        decPointPos = value.indexOf(decimalP);\n                    }\n                    // if (decimalPoint!=null && decimalPoint.length()>0)\n                    // Check digits\n                    int zeroBegin = -1;\n                    int zeroEnd = value.length();\n                    boolean onlyZeros = true;\n                    if (decPointPos > -1) {\n                        // Check digits before decimal point\n                        for (int i = 0; i < decPointPos; i++) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroBegin = i;\n                            else\n                                onlyZeros = false;\n                        }\n                        // for (int i=0; i<decPointPos; i++)\n                        // Check digits behind decimal point\n                        onlyZeros = true;\n                        for (int i = value.length() - 1; i > decPointPos; i--) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroEnd = i;\n                            else\n                                onlyZeros = false;\n                        }\n                        // for (int i=valueWithoutSign.length()-1;\n                        // i>decPointPos; i--)\n                    } else\n                        // then (decPointPos>-1)\n                        // no decimal point\n                        for (int i = 0; i < value.length(); i++) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                params.add(value);\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroBegin = i;\n                            else\n                                onlyZeros = false;\n                        }\n                    // for (int i=0; i<valueWithoutSign.length(); i++)\n                    String valueWithoutSignZeros = value.substring(zeroBegin + 1, zeroEnd);\n                    int valueWithoutSignZerosLength = valueWithoutSignZeros.length();\n                    byte[] valueWithoutSignZerosBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        valueWithoutSignZerosBytes = byteArrayConverter.stringToByteArray(value);\n                        valueWithoutSignZerosLength = valueWithoutSignZerosBytes.length;\n                        if (valueWithoutSignZerosLength > length - start) {\n                            // Too long - even if zeros are deleted.\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                        }\n                        // if (valueWithoutSignZerosLength > length - start)\n                        byte[] zero = byteArrayConverter.stringToByteArray(\"0\");\n                        if (decPointPos > -1) {\n                            int offset = pos + start;\n                            for (int i = 0; i < valueWithoutSignZerosLength; i++) ((byte[]) buffer)[offset + i] = valueWithoutSignZerosBytes[i];\n                            offset += valueWithoutSignZerosLength;\n                            for (int i = 0; i < (length - start - valueWithoutSignZerosLength) / zero.length; i++) {\n                                for (int j = 0; j < zero.length; j++) ((byte[]) buffer)[offset + j] = zero[j];\n                                offset += zero.length;\n                            }\n                            for (int i = offset; i < length; i++) ((byte[]) buffer)[i] = 0;\n                        } else {\n                            int offset = pos + start;\n                            for (int i = 0; i < (length - start - valueWithoutSignZerosLength) / zero.length; i++) {\n                                for (int j = 0; j < zero.length; j++) ((byte[]) buffer)[offset + j] = zero[j];\n                                offset += zero.length;\n                            }\n                            for (int i = 0; i < valueWithoutSignZerosLength; i++) ((byte[]) buffer)[offset + i] = valueWithoutSignZerosBytes[i];\n                            offset += valueWithoutSignZerosLength;\n                            for (int i = offset; i < length; i++) ((byte[]) buffer)[i] = 0;\n                        }\n                    } else {\n                        if (zeroEnd - zeroBegin - 1 > length - start) {\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                        }\n                        // if (zeroEnd - zeroBegin - 1 > length - start)\n                        if (length - start + zeroBegin + 1 < value.length())\n                            // Delete zeros at the end after the decimal point\n                            // but only to that extend that the necessary length\n                            // is achieved by delelting leading zeros.\n                            value = value.substring(0, length - start + zeroBegin + 1);\n                        if (zeroBegin > -1)\n                            // Delete zeros at beginning\n                            value = value.substring(zeroBegin + 1);\n                        // Fill in zeros at beginning if necessary\n                        for (int i = 0; i < length - value.length() - start; i++) ((StringBuffer) buffer).insert(pos + start + i, '0');\n                        // Put value into buffer - sign is already there.\n                        ((StringBuffer) buffer).insert(pos + length - value.length(), value);\n                    }\n                } else // (fieldFormat.equals(\"num\"))\n                if (fieldFormat.equals(\"date\")) {\n                    if (value.length() == 0)\n                        // Blanks allowed.\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                            for (int i = 0; i < length; i++) ((StringBuffer) buffer).insert(pos + i, ' ');\n                        else\n                            fillByteArray((byte[]) buffer, pos, length, \"\");\n                    else {\n                        int valueLength = value.length();\n                        byte[] valueBytes = null;\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                            valueBytes = byteArrayConverter.stringToByteArray(value);\n                            valueLength = valueBytes.length;\n                        }\n                        if (length != valueLength) {\n                            // Otherwise length must be correct.\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"138\", params);\n                        }\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                            ((StringBuffer) buffer).insert(pos, value);\n                        else\n                            for (int i = 0; i < length; i++) ((byte[]) buffer)[pos + i] = valueBytes[i];\n                    }\n                } else // then (fieldFormat.equals(\"date\"))\n                {\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldFormat);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"139\", params);\n                }\n                // else (fieldFormat.equals(\"date\"))\n            }\n            // else (fieldFormat.equals(\"blank\"))\n            return pos + length;\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // serializeField(Element fieldSpec,StringBuffer buffer,int pos,Node[]\n    // fieldNode)\n    /**\n     * Method fillByteArray.\n     *\n     * @param b\n     * @param pos\n     * @param length\n     * @param constValue\n     */\n    private void fillByteArray(byte[] arr, int pos, int length, String value) throws XException {\n        byte[] fill = byteArrayConverter.stringToByteArray(value, length);\n        for (int i = 0; i < length; i++) arr[pos + i] = fill[i];\n    }\n\n    /**\n     * Serializes one record.\n     *\n     * @param doc\n     * @return a byte array containing one record\n     */\n    public byte[] serializeSingleRecord(Document doc) throws XException {\n        Element record = doc.getDocumentElement();\n        return (byte[]) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName()));\n    }\n}\n// RecordTypeSerializer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeSerializerTest1.java",
		"test_prompt": "// RecordTypeSerializerTest1.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeSerializer}.\n* It contains ten unit test cases for the {@link RecordTypeSerializer#serialize(Document)} method.\n*/\nclass RecordTypeSerializerTest1 {"
	},
	{
		"original_code": "// RecordTypeSerializer.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>RecordTypeSerializer</code> serves for serializing records stored in\n * a DOM tree according to a record type structure.\n * <p>\n * The DOM tree structure is described in the\n * {@link net.sf.xbus.protocol.records.RecordTypeParser RecordTypeParser}\n * documentation.\n * </p>\n * <p>\n * The serialization result is a String. <br>\n * The string structure is described by a xml file - in particular the contained\n * record types. Such describing files are of document type\n * <code>InterfaceSpec</code> declared in \"InterfaceSpec.dtd\". The structure\n * of the internal DOM tree to serialise is described on the\n * {@link net.sf.xbus.protocol.records.RecordTypeParser RecordTypeParser}\n * documentation page.\n * </p>\n *\n * @author Lars Me�ner, Stehan D�wel\n */\npublic class RecordTypeSerializer extends RecordTypeManipulator {\n\n    // //////////////////////\n    // Static fields\n    // //////////////////////\n    /**\n     * <code>instances</code> stores the instances by thread and the interface\n     * type.\n     */\n    private static Hashtable instances = new Hashtable();\n\n    private static final Object classLock = RecordTypeSerializer.class;\n\n    // //////////////////////\n    // Constructors\n    // //////////////////////\n    /**\n     * Just the standard constructor.\n     */\n    private RecordTypeSerializer() throws XException {\n        super();\n    }\n\n    // RecordTypeParser()\n    // //////////////////////\n    // Static methods\n    // //////////////////////\n    /**\n     * <code>getInstance()</code> retrieves the an instance of\n     * <code>RecordTypeSerializer</code>.\n     *\n     * @param sourceType the name for the parsed structure as it is derived from\n     *            the DOM tree with the interface content\n     * @throws XException in case of missing <code>sourceType</code>\n     */\n    public static RecordTypeSerializer getInstance(String sourceType, int interfaceContentClass) throws XException {\n        synchronized (classLock) {\n            if (sourceType == null || sourceType.length() == 0)\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"68\");\n            RecordTypeSerializer instance = (RecordTypeSerializer) instances.get(Thread.currentThread().getName() + sourceType + interfaceContentClass);\n            if (instance == null) {\n                // no suitable instance available yet\n                instance = new RecordTypeSerializer();\n                instances.put(Thread.currentThread().getName() + sourceType + interfaceContentClass, instance);\n            }\n            // if (instance==null)\n            return instance;\n        }\n    }\n\n    // getInstance(String sourceType)\n    /**\n     * Method getByteArrayConverter.\n     *\n     * @return ByteArrayConverter\n     */\n    protected ByteArrayConverter getByteArrayConverter() throws XException {\n        return ByteArrayConverterFactory.getConverter(sourceType);\n    }\n\n    // /////////////////////////////////////////\n    // Serializing the contents\n    // /////////////////////////////////////////\n    /**\n     * <code>serialize</code> serializes the specified DOM tree due to the\n     * record type definition.\n     *\n     * @param docContent the DOM tree with the interface content\n     * @return the serialized string\n     * @throws XException in case of an unexpected value\n     */\n    public Object serialize(Document docContent) throws XException {\n        if (interfaceStructure == null)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"99\");\n        // The root element has the content type as xml tag.\n        Element root = docContent.getDocumentElement();\n        if (contentType == null || !contentType.equals(root.getNodeName()))\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"120\");\n        Node node = root.getFirstChild();\n        Object result = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n            result = \"\";\n        } else if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n            result = new ByteArrayList();\n        } else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"100\");\n        }\n        if (node == null) {\n            return result;\n        }\n        if (!node.getNodeName().equals(\"Records\")) {\n            // not the records section - thus a header\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                result = serializeHeader(node) + Constants.LINE_SEPERATOR;\n            else\n                ((ByteArrayList) result).add((byte[]) serializeHeader(node));\n            // Go to the records section\n            node = node.getNextSibling();\n        }\n        // if (!node.getNodeName().equals(\"Records\"))\n        // Now the records section\n        if (node == null || !node.getNodeName().equals(\"Records\")) {\n            List params = new Vector();\n            params.add(\"Records expected\");\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"122\", params);\n        }\n        // if (node == null || !node.getNodeName().equals(\"Records\"))\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            result = result + (String) serializeRecords(node);\n        else\n            ((ByteArrayList) result).addAll((ByteArrayList) serializeRecords(node));\n        // Go to trailer or end\n        node = node.getNextSibling();\n        if (node != null) {\n            // trailer found\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                result = result + (String) serializeTrailer(node);\n            else\n                ((ByteArrayList) result).add((byte[]) serializeTrailer(node));\n            // Go to end\n            node = node.getNextSibling();\n        } else // if (node!=null)\n        if (result != null && interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) result).length() > 0)\n            // no trailer\n            // Cut off the line separator after the last record.\n            result = ((String) result).substring(0, ((String) result).length() - Constants.LINE_SEPERATOR.length());\n        // Must be the end.\n        if (node != null) {\n            List params = new Vector();\n            params.add(node.getNodeName());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"123\", params);\n        }\n        // if (node != null)\n        return result;\n    }\n\n    // serialize(Document docContent)\n    /**\n     * <code>serializeHeader</code> parses the header.\n     *\n     * @param headerNode the header in the content DOM tree\n     * @return the serialized header as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeHeader(Node headerNode) throws XException {\n        // Easy: no record type identification necessary\n        // Jump directly to contained fields.\n        return serializeFieldsAndGroups(headerNode, headerSpec);\n    }\n\n    // serializeHeader(Node headerNode)\n    /**\n     * <code>serializeRecords</code> serializes the records section.\n     *\n     * @param recordsNode\n     * @return String\n     */\n    private Object serializeRecords(Node recordsNode) throws XException {\n        String tag = recordsNode.getNodeName();\n        if (tag == null || !tag.equals(\"Records\")) {\n            List params = new Vector();\n            params.add(\"Records expected\");\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"122\", params);\n        }\n        // if (tag == null || !tag.equals(\"Records\"))\n        Object result = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            result = \"\";\n        else\n            result = new ByteArrayList();\n        Node recordGroup = recordsNode.getFirstChild();\n        while (recordGroup != null) {\n            // Loop over the record groups or just a dummy loop\n            // Two possibilities: directly first record or first record group\n            Node record = recordGroup;\n            if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // In case of a record group go one level deeper to the first\n                // record of the group\n                record = recordGroup.getFirstChild();\n            while (record != null) {\n                // loop over the records in the group - or all if no record\n                // groups are present\n                // The record type is identified by the xml tag.\n                // Get it and jum to the contained fields.\n                if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                    result = result + (String) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName())) + Constants.LINE_SEPERATOR;\n                else\n                    ((ByteArrayList) result).add((byte[]) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName())));\n                // Go to next record\n                record = record.getNextSibling();\n            }\n            // while (record!=null)\n            if (recordGroup.getNodeName().equals(\"RecordGroup\")) {\n                // Go to next record group\n                recordGroup = recordGroup.getNextSibling();\n            } else\n                // if (recordGroup.getNodeName().equals(\"RecordGroup\"))\n                // no record groups, simply end the loop\n                recordGroup = null;\n        }\n        // while (recordGroup!=null)\n        return result;\n    }\n\n    // serializeRecords(Node recordsNode)\n    /**\n     * <code>serializeTrailer</code> parses the header.\n     *\n     * @param trailerNode the trailer in the content DOM tree\n     * @return the serialized trailer as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeTrailer(Node trailerNode) throws XException {\n        // Easy: no record type identification necessary\n        // Jump directly to contained fields.\n        return serializeFieldsAndGroups(trailerNode, trailerSpec);\n    }\n\n    // serializeTrailer(Node trailerNode)\n    /**\n     * <code>serializeFieldsAndGroups</code> serializes the fields and group\n     * references within a record type - including header and trailer.\n     *\n     * @param recordNode the record node in the result DOM tree\n     * @param recordType the record type specification node in the structure\n     *            descrition to get the field specs from\n     * @return the serialized records as {@link java.lang.String string}\n     * @throws XException in case of an unexpected value\n     */\n    private Object serializeFieldsAndGroups(Node recordNode, Node recordType) throws XException {\n        // To avoid permanent string manipulations, a StringBuffer is used.\n        int length = RecordTypeDescriptionChecker.computeRecordLength(recordType, groupsSpec);\n        // Length for the buffer.\n        int pos = 0;\n        // Position in the buffer to put the next field.\n        Object buffer = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            buffer = new StringBuffer(length);\n        else\n            buffer = new byte[length];\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = recordType.getChildNodes();\n            // The next available field node in the content DOM tree.\n            // array for call by reference\n            Node[] fieldNode = new Node[1];\n            // the first field\n            fieldNode[0] = recordNode.getFirstChild();\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all fields and group references in the sturcture\n                // description\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                if (fieldSpec.getNodeName().equals(\"Field\"))\n                    // a single field\n                    pos = serializeField(fieldSpec, buffer, pos, fieldNode);\n                else // May have moved the actual field node in the content DOM tree\n                if (fieldSpec.getNodeName().equals(\"Group\"))\n                    // a field group\n                    pos = serializeGroup(fieldSpec, buffer, pos, fieldNode);\n                // May have moved the actual field node in the content DOM tree\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n            // All record fields in the content DOM tree should be serialized.\n            if (fieldNode[0] != null) {\n                List params = new Vector();\n                params.add(fieldNode[0].getNodeName());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"125\", params);\n            }\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            return new String((StringBuffer) buffer);\n        else\n            return buffer;\n    }\n\n    // serializeFieldsAndGroups(Node recordNode, Node recordType)\n    /**\n     * <code>serializeGroup</code> serializes the fields of a field group\n     * defined in the interface structure description.\n     *\n     * @param groupRef the group reference in the structure description\n     * @param buffer the buffer to fill with the serialized field contents\n     * @param pos the position in the buffer to start the filling\n     * @param fieldNode the next available field node in the content DOM tree -\n     *            array for call by reference\n     * @return the buffer position to start the next filling at\n     * @throws XException in case of an unexpected value\n     */\n    private int serializeGroup(Element groupRef, Object buffer, int pos, Node[] fieldNode) throws XException {\n        try // for casting to XException\n        {\n            NodeList fieldSpecs = RecordTypeDescriptionChecker.getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) pos = serializeField((Element) fieldSpecs.item(i), buffer, pos, fieldNode);\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return pos;\n    }\n\n    // serializeGroup(Element groupRef,StringBuffer buffer,int pos,Node[]\n    // fieldNode)\n    /**\n     * <code>serializeField</code> serializes the fields of a field group\n     * defined in the interface structure description.\n     *\n     * @param fieldSpec the field specification in the structure description\n     * @param buffer the buffer to fill with the serialized field contents\n     * @param pos the position in the buffer to start the filling\n     * @param fieldNode the next available field node in the content DOM tree -\n     *            array for call by reference\n     * @return the buffer position to start the next filling at\n     * @throws XException in case of an unexpected value\n     */\n    private int serializeField(Element fieldSpec, Object buffer, int pos, Node[] fieldNode) throws XException {\n        try // for casting to XException\n        {\n            String fieldFormat = fieldSpec.getAttribute(\"Format\");\n            if (fieldFormat == null || fieldFormat.length() == 0) {\n                List params = new Vector();\n                params.add(\"Format\");\n                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                params.add(fieldSpec.toString());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"82\", params);\n            }\n            // How many characters?\n            int length = Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n            if (fieldFormat.equals(\"blank\")) {\n                // only filler - no corresponding node in the content DOM tree\n                if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                    for (int i = 0; i < length; i++) ((StringBuffer) buffer).insert(pos + i, ' ');\n                else\n                    fillByteArray((byte[]) buffer, pos, length, \"\");\n            } else // then (fieldFormat.equals(\"blank\"))\n            {\n                // Not just filler\n                String fieldName = fieldSpec.getAttribute(\"Name\");\n                String nodeName = null;\n                if (fieldNode[0] != null)\n                    nodeName = fieldNode[0].getNodeName();\n                if (fieldName == null) {\n                    List params = new Vector();\n                    params.add(\"Name\");\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.toString());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"82\", params);\n                }\n                // if (fieldName == null)\n                // The field value may be stored in the content DOM tree or\n                // a standard value may be used.\n                String value = \"\";\n                // standard for alphanumeric fields\n                if (fieldFormat.equals(\"num\"))\n                    value = \"0\";\n                // standard for numeric fields\n                if (fieldName.equals(nodeName)) {\n                    // The value is given in the content DOM tree.\n                    value = XDomSupport.getNodeText(fieldNode[0]);\n                    // Set the next available field in the content DOM tree one\n                    // further\n                    fieldNode[0] = fieldNode[0].getNextSibling();\n                }\n                // if (fieldName.equals(nodeName))\n                // Now a value - read from the content DOM tree or standard - is\n                // given.\n                if (fieldFormat.equals(\"const\")) {\n                    String constValue = fieldSpec.getAttribute(\"Value\");\n                    // value specified in the interface description\n                    byte[] constValueBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        constValueBytes = byteArrayConverter.stringToByteArray(constValue);\n                    }\n                    // if (interfaceContentClass ==\n                    // Constants.IFCONTENTCLASS_BYTEARRAYLIST)\n                    if (!constValue.equals(value)) {\n                        // The interface description must specify a value of\n                        // correct\n                        // length.\n                        // If the content DOM tree has a value, they must be\n                        // identical (after triming).\n                        List params = new Vector();\n                        params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                        params.add(fieldSpec.getAttribute(\"Name\"));\n                        params.add(\"?\");\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"106\", params);\n                    }\n                    // if (constValue == null || constValueLength != length\n                    // ||\n                    // value.length() > 0 && !constTrimed.equals(value))\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                        ((StringBuffer) buffer).insert(pos, constValue);\n                    else\n                        for (int i = 0; i < length; i++) ((byte[]) buffer)[pos + i] = constValueBytes[i];\n                } else // then (fieldFormat.equals(\"const\"))\n                if (fieldFormat.equals(\"alpha\")) {\n                    int valueLength = value.length();\n                    byte[] valueBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        valueBytes = byteArrayConverter.stringToByteArray(value);\n                        valueLength = valueBytes.length;\n                    }\n                    if (length < valueLength) {\n                        value = value.trim();\n                        valueLength = value.length();\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                            valueBytes = byteArrayConverter.stringToByteArray(value);\n                            valueLength = valueBytes.length;\n                        }\n                        if (length < valueLength) {\n                            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(value);\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                            } else // if (interfaceContentClass ==\n                            // Constants.IFCONTENTCLASS_STRING)\n                            {\n                                valueBytes = byteArrayConverter.stringToByteArray(value, length);\n                                valueLength = valueBytes.length;\n                            }\n                        }\n                    }\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                        ((StringBuffer) buffer).insert(pos, value);\n                        // Fill in blanks if the value is to short.\n                        for (int i = 0; i < length - value.length(); i++) ((StringBuffer) buffer).insert(pos + value.length() + i, ' ');\n                    } else\n                        fillByteArray((byte[]) buffer, pos, length, value);\n                } else // then (fieldFormat.equals(\"alpha\"))\n                if (fieldFormat.equals(\"num\")) {\n                    // First look for a leading sign\n                    int start = 0;\n                    if (value.length() > 0) {\n                        char sign = value.charAt(0);\n                        if (sign == '+' || sign == '-') {\n                            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n                                ((StringBuffer) buffer).insert(pos, sign);\n                                start = 1;\n                            } else {\n                                byte[] signBytes = byteArrayConverter.stringToByteArray(\"\" + sign);\n                                start = signBytes.length;\n                                for (int i = 0; i < start; i++) ((byte[]) buffer)[pos + i] = signBytes[i];\n                            }\n                            value = value.substring(1).trim();\n                        }\n                        // if (sign=='+' || sign=='-')\n                    }\n                    // if (value.length()>0)\n                    // Look for a decimal point\n                    String decimalPoint = fieldSpec.getAttribute(\"DecimalPoint\");\n                    int decPointPos = -1;\n                    if (decimalPoint != null && decimalPoint.length() > 0) {\n                        char decimalP = '.';\n                        if (decimalPoint.equals(\"comma\"))\n                            decimalP = ',';\n                        else if (!decimalPoint.equals(\"dot\")) {\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"107\", params);\n                        }\n                        // if (!decimalPoint.equals(\"dot\"))\n                        decPointPos = value.indexOf(decimalP);\n                    }\n                    // if (decimalPoint!=null && decimalPoint.length()>0)\n                    // Check digits\n                    int zeroBegin = -1;\n                    int zeroEnd = value.length();\n                    boolean onlyZeros = true;\n                    if (decPointPos > -1) {\n                        // Check digits before decimal point\n                        for (int i = 0; i < decPointPos; i++) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroBegin = i;\n                            else\n                                onlyZeros = false;\n                        }\n                        // for (int i=0; i<decPointPos; i++)\n                        // Check digits behind decimal point\n                        onlyZeros = true;\n                        for (int i = value.length() - 1; i > decPointPos; i--) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroEnd = i;\n                            else\n                                onlyZeros = false;\n                        }\n                        // for (int i=valueWithoutSign.length()-1;\n                        // i>decPointPos; i--)\n                    } else\n                        // then (decPointPos>-1)\n                        // no decimal point\n                        for (int i = 0; i < value.length(); i++) {\n                            if (!Character.isDigit(value.charAt(i))) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                params.add(\"?\");\n                                params.add(value);\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                            }\n                            // if\n                            // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                            if (onlyZeros && value.charAt(i) == '0')\n                                zeroBegin = i;\n                            else\n                                onlyZeros = false;\n                        }\n                    // for (int i=0; i<valueWithoutSign.length(); i++)\n                    String valueWithoutSignZeros = value.substring(zeroBegin + 1, zeroEnd);\n                    int valueWithoutSignZerosLength = valueWithoutSignZeros.length();\n                    byte[] valueWithoutSignZerosBytes = null;\n                    if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                        valueWithoutSignZerosBytes = byteArrayConverter.stringToByteArray(value);\n                        valueWithoutSignZerosLength = valueWithoutSignZerosBytes.length;\n                        if (valueWithoutSignZerosLength > length - start) {\n                            // Too long - even if zeros are deleted.\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                        }\n                        // if (valueWithoutSignZerosLength > length - start)\n                        byte[] zero = byteArrayConverter.stringToByteArray(\"0\");\n                        if (decPointPos > -1) {\n                            int offset = pos + start;\n                            for (int i = 0; i < valueWithoutSignZerosLength; i++) ((byte[]) buffer)[offset + i] = valueWithoutSignZerosBytes[i];\n                            offset += valueWithoutSignZerosLength;\n                            for (int i = 0; i < (length - start - valueWithoutSignZerosLength) / zero.length; i++) {\n                                for (int j = 0; j < zero.length; j++) ((byte[]) buffer)[offset + j] = zero[j];\n                                offset += zero.length;\n                            }\n                            for (int i = offset; i < length; i++) ((byte[]) buffer)[i] = 0;\n                        } else {\n                            int offset = pos + start;\n                            for (int i = 0; i < (length - start - valueWithoutSignZerosLength) / zero.length; i++) {\n                                for (int j = 0; j < zero.length; j++) ((byte[]) buffer)[offset + j] = zero[j];\n                                offset += zero.length;\n                            }\n                            for (int i = 0; i < valueWithoutSignZerosLength; i++) ((byte[]) buffer)[offset + i] = valueWithoutSignZerosBytes[i];\n                            offset += valueWithoutSignZerosLength;\n                            for (int i = offset; i < length; i++) ((byte[]) buffer)[i] = 0;\n                        }\n                    } else {\n                        if (zeroEnd - zeroBegin - 1 > length - start) {\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"131\", params);\n                        }\n                        // if (zeroEnd - zeroBegin - 1 > length - start)\n                        if (length - start + zeroBegin + 1 < value.length())\n                            // Delete zeros at the end after the decimal point\n                            // but only to that extend that the necessary length\n                            // is achieved by delelting leading zeros.\n                            value = value.substring(0, length - start + zeroBegin + 1);\n                        if (zeroBegin > -1)\n                            // Delete zeros at beginning\n                            value = value.substring(zeroBegin + 1);\n                        // Fill in zeros at beginning if necessary\n                        for (int i = 0; i < length - value.length() - start; i++) ((StringBuffer) buffer).insert(pos + start + i, '0');\n                        // Put value into buffer - sign is already there.\n                        ((StringBuffer) buffer).insert(pos + length - value.length(), value);\n                    }\n                } else // (fieldFormat.equals(\"num\"))\n                if (fieldFormat.equals(\"date\")) {\n                    if (value.length() == 0)\n                        // Blanks allowed.\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                            for (int i = 0; i < length; i++) ((StringBuffer) buffer).insert(pos + i, ' ');\n                        else\n                            fillByteArray((byte[]) buffer, pos, length, \"\");\n                    else {\n                        int valueLength = value.length();\n                        byte[] valueBytes = null;\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST) {\n                            valueBytes = byteArrayConverter.stringToByteArray(value);\n                            valueLength = valueBytes.length;\n                        }\n                        if (length != valueLength) {\n                            // Otherwise length must be correct.\n                            List params = new Vector();\n                            params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                            params.add(fieldSpec.getAttribute(\"Name\"));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"138\", params);\n                        }\n                        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                            ((StringBuffer) buffer).insert(pos, value);\n                        else\n                            for (int i = 0; i < length; i++) ((byte[]) buffer)[pos + i] = valueBytes[i];\n                    }\n                } else // then (fieldFormat.equals(\"date\"))\n                {\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldFormat);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"139\", params);\n                }\n                // else (fieldFormat.equals(\"date\"))\n            }\n            // else (fieldFormat.equals(\"blank\"))\n            return pos + length;\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n    }\n\n    // serializeField(Element fieldSpec,StringBuffer buffer,int pos,Node[]\n    // fieldNode)\n    /**\n     * Method fillByteArray.\n     *\n     * @param b\n     * @param pos\n     * @param length\n     * @param constValue\n     */\n    private void fillByteArray(byte[] arr, int pos, int length, String value) throws XException {\n        byte[] fill = byteArrayConverter.stringToByteArray(value, length);\n        for (int i = 0; i < length; i++) arr[pos + i] = fill[i];\n    }\n\n    /**\n     * Serializes one record.\n     *\n     * @param doc\n     * @return a byte array containing one record\n     */\n    public byte[] serializeSingleRecord(Document doc) throws XException {\n        Element record = doc.getDocumentElement();\n        return (byte[]) serializeFieldsAndGroups(record, getRecordTypeSpec(record.getNodeName()));\n    }\n}\n// RecordTypeSerializer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeSerializerTest2.java",
		"test_prompt": "// RecordTypeSerializerTest2.java\npackage net.sf.xbus.protocol.records;\n\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeSerializer}.\n* It contains ten unit test cases for the {@link RecordTypeSerializer#serializeSingleRecord(Document)} method.\n*/\nclass RecordTypeSerializerTest2 {"
	},
	{
		"original_code": "// RecordTypeParser.java\npackage net.sf.xbus.protocol.records;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * The class <code>RecordTypeParser</code> implements parsing records from a\n * string or a list of byte arrays.\n * <p>\n * The parsed structure is described by a xml file - in particular the contained\n * record types, their order within the string and how to identify them during\n * parsing. Such describing files are of document type\n * <code>InterfaceSpec</code> declared in \"InterfaceSpec.dtd\".\n * </p>\n * <p>\n * The parsing result is a DOM tree with the following structure:\n * </p>\n * <p>\n * &lt;+ <i>InterfaceName </i>+&gt; <dir>&lt;+ <i>HeaderName </i>+&gt;\n * <dir>&lt;+ <i>FieldName </i>+&gt;+ <b>FieldValue </b>+&lt;/+ <i>FieldName\n * </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>HeaderName </i>+&gt; <br>\n * &lt;Records&gt; <dir>&lt;RecordGroup&gt; <dir>&lt;+ <i>RecordType </i>+&gt;\n * <dir>&lt;+ <i>FieldName </i>+&gt;+ <b>FieldValue </b>+&lt;/+ <i>FieldName\n * </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>RecordType </i>+&gt; <br>\n * ... </dir> &lt;/RecordGroup&gt; <br>\n * ... </dir> &lt;/Records&gt; <br>\n * &lt;+ <i>TrailerName </i>+&gt; <dir>&lt;+ <i>FieldName </i>+&gt;+\n * <b>FieldValue </b>+&lt;/+ <i>FieldName </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>TrailerName </i>+&gt; </dir> &lt;/+ <i>InterfaceName\n * </i>+&gt;\n * </p>\n * <p>\n * Header and trailer are optional. <br>\n * The &lt;RecordGroup&gt; structure is only used if records of different types\n * are grouped together in the string (RecordOrder=Structured for the\n * &lt;Lines&gt; specification in the structure description). Otherwise records\n * are listed immediately below the &lt;Records&gt; level.\n * </p>\n * <p>\n * There is no DTD for the parsing result since the used tags depend on the\n * document structure of the parsed file (tags indicated by +'s above). But it\n * can be derived from the structure description taking the name attributes for\n * interface type, header, record types, fields and trailer as tags.\n * </p>\n * <p>\n * The \"ordinary\" working mode is parsing records from a string. But due to\n * special problems with some character encoding and line breaks within record\n * fields, byte-array-oriented parsing is available, too. In this case each\n * record is stored in its own byte array.\n * </p>\n *\n * @author Stephan D�wel\n */\npublic class RecordTypeParser extends RecordTypeManipulator {\n\n    // //////////////////////\n    // Static fields\n    // //////////////////////\n    /**\n     * <code>instances</code> stores the instances by thread, the interface\n     * name and the representation type (<code>String</code> or\n     * {@link net.sf.xbus.base.bytearraylist.ByteArrayList}).\n     */\n    private static Hashtable instances = new Hashtable();\n\n    private static final Object classLock = RecordTypeParser.class;\n\n    // //////////////////////\n    // Member fields\n    // //////////////////////\n    /**\n     * Flag if record lines are cut off after the last non-whitespace character.\n     */\n    private boolean lineCutting = false;\n\n    // //////////////////////\n    // Constructors\n    // //////////////////////\n    /**\n     * Just the standard constructor.\n     */\n    private RecordTypeParser() throws XException {\n        super();\n    }\n\n    // RecordTypeParser()\n    // //////////////////////\n    // Static methods\n    // //////////////////////\n    /**\n     * <code>getInstance()</code> retrieves the an instance of\n     * <code>RecordTypeParser</code>.\n     *\n     * @param sourceType the name for the parsed structure as it is derived from\n     *            a\n     *            {@link net.sf.xbus.protocol.records.RecordTypeMessage RecordTypeMessage}\n     * @param interfaceContentClass Working mode: sting or byte array list\n     * @throws XException in case of missing <code>sourceType</code>\n     */\n    public static RecordTypeParser getInstance(String sourceType, int interfaceContentClass) throws XException {\n        synchronized (classLock) {\n            if (sourceType == null || sourceType.length() == 0)\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"98\");\n            RecordTypeParser instance = (RecordTypeParser) instances.get(Thread.currentThread().getName() + sourceType + interfaceContentClass);\n            if (instance == null) {\n                // no suitable instance available yet\n                instance = new RecordTypeParser();\n                instances.put(Thread.currentThread().getName() + sourceType + interfaceContentClass, instance);\n            }\n            // if (instance==null)\n            return instance;\n        }\n        // synchronized (classLock)\n    }\n\n    // getInstance(String sourceType, int interfaceContentClass)\n    /**\n     * <code>getByteArrayConverter</code> retrieves a byte array converter\n     * object which is convenient for the interface from which the records are\n     * to parse.\n     *\n     * @return an appropriate converter object\n     */\n    protected ByteArrayConverter getByteArrayConverter() throws XException {\n        // Get the byte the byte array converter for the interface specified\n        // in the underlying message.\n        return ByteArrayConverterFactory.getConverter(sourceType);\n    }\n\n    // getByteArrayConverter()\n    // /////////////////////////////////////////\n    // Parsing the contents\n    // /////////////////////////////////////////\n    /**\n     * <code>parse</code> parses a string due to the record type definition.\n     *\n     * @param interfaceContent the string to parse\n     * @param resultDoc The parsing result - an empty DOM tree which will be\n     *            filled.\n     * @throws XException in case that the interface structure description is\n     *             not loaded or in case of an unexpected value or end of\n     *             string/byte array/byte array list\n     */\n    public void parse(Object interfaceContent, Document resultDoc) throws XException {\n        if (interfaceStructure == null)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"99\");\n        // May ending white spaces in the record lines be ommitted?\n        lineCutting = Configuration.getInstance().getValueAsBooleanOptional(\"System\", sourceType, \"LineCutting\");\n        // The root element has the content type as xml tag.\n        Element root = resultDoc.createElement(contentType);\n        resultDoc.appendChild(root);\n        // Parsing position\n        int stringPos = 0;\n        // Position in string or in the complete byte array list (byte count)\n        int[] line = { 0 };\n        // Index of list element in a byte array list, array for call by\n        // reference\n        try // for casting to XException\n        {\n            // Determine the length of content to parse ...\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                // ... as number of characters for a parsed string\n                interfaceContentLength = ((String) interfaceContent).length();\n            else if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST)\n                // ... as number of bytes in case of a parsed byte array list\n                interfaceContentLength = ((ByteArrayList) interfaceContent).length();\n            else\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"100\");\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch (ClassCastException e)\n        Element[] headerNode = { null };\n        // for building up the header node (array for call by reference)\n        if (headerSpec != null)\n            stringPos = parseHeader(interfaceContent, stringPos, line, resultDoc, headerNode);\n        if (headerNode.length == 1 && headerNode[0] != null && headerNode[0].hasChildNodes())\n            // header successfully parsed\n            root.appendChild(headerNode[0]);\n        Element[] recordsNode = { null };\n        // for building up the records section (array for call by reference)\n        stringPos = parseRecords(interfaceContent, stringPos, line, resultDoc, recordsNode);\n        if (recordsNode.length == 1 && recordsNode[0] != null && recordsNode[0].hasChildNodes())\n            // records successfully parsed\n            root.appendChild(recordsNode[0]);\n        Element[] trailerNode = { null };\n        // For building up the trailer node (array for call by reference)\n        if (trailerSpec != null)\n            stringPos = parseTrailer(interfaceContent, stringPos, line, resultDoc, trailerNode);\n        if (trailerNode.length == 1 && trailerNode[0] != null && trailerNode[0].hasChildNodes())\n            // trailer successfully parsed\n            root.appendChild(trailerNode[0]);\n    }\n\n    // parse(String interfaceContent, Document resultDoc)\n    /**\n     * <code>parseHeader</code> parses the header.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param headerNode the resulting header node (array to have call by\n     *            reference)\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseHeader(Object interfaceContent, int stringPos, int[] line, Document doc, Element[] headerNode) throws XException {\n        if (stringPos < interfaceContentLength) {\n            // There is some content to parse\n            headerNode[0] = doc.createElement(headerSpec.getAttribute(\"Name\"));\n            // The header owns its specific name to use as tag.\n            // The contained fields and groups\n            stringPos = parseFieldsAndGroups(interfaceContent, stringPos, line, doc, headerNode[0], headerSpec);\n            // Jump over line break if necessary\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) interfaceContent).startsWith(Constants.LINE_SEPERATOR, stringPos))\n                stringPos += Constants.LINE_SEPERATOR.length();\n            // Next line (Value is always incremented because in case of string\n            // parsing it is ignoed anyway.)\n            line[0]++;\n        }\n        // if (stringPos<interfaceContent.length())\n        return stringPos;\n    }\n\n    // parseHeader(Object interfaceContent, int stringPos, int[] line,\n    // Document doc, Element[] headerNode)\n    /**\n     * <code>parseRecords</code> parses the record types.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param recordsNode the resulting Record Types node (array to have call by\n     *            reference)\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseRecords(Object interfaceContent, int stringPos, int[] line, Document doc, Element[] recordsNode) throws XException {\n        // Determine end of record parsing\n        int recordsSectionEnd = interfaceContentLength;\n        if (trailerSpec != null)\n            // If there is a trailer, record parsing must already end before the\n            // string end.\n            recordsSectionEnd -= RecordTypeDescriptionChecker.computeRecordLength(trailerSpec, groupsSpec);\n        if (stringPos < recordsSectionEnd)\n            // something to parse left\n            recordsNode[0] = doc.createElement(\"Records\");\n        Element insertionNode = recordsNode[0];\n        // node to insert the records below - <Records> or <RecordType>\n        Element recordType = null;\n        int recordCount = 0;\n        // counter for subsequent records of the same type\n        Element nextRecord = null;\n        // To create record nodes.\n        // The last created is used to determine the next record type.\n        while (stringPos < recordsSectionEnd) {\n            // loop over content string\n            // Determining the next record type really drives the loop.\n            Element nextRecordType = determineNextRecordType(interfaceContent, stringPos, line, recordType, recordCount, nextRecord);\n            if (recordType == null || !XDomSupport.getTrimedNodeText(nextRecordType).equals(XDomSupport.getTrimedNodeText(recordType))) {\n                // First record type or record type change.\n                recordCount = 0;\n                recordType = nextRecordType;\n            }\n            // if (recordType==null ||\n            // !XDomSupport.getTrimedElementValue(nextRecordType).equals(XDomSupport.getTrimedElementValue(recordType)))\n            if (recOrder.equals(\"Structured\") && getRecordTypePositionInLines(nextRecordType) == 0) {\n                // first record in a group\n                insertionNode = doc.createElement(\"RecordGroup\");\n                recordsNode[0].appendChild(insertionNode);\n            }\n            // if (recOrder.equals(\"Structured\") && nextRecordTypePos==0)\n            String nextRecordTypeName = XDomSupport.getTrimedNodeText(nextRecordType);\n            nextRecord = doc.createElement(nextRecordTypeName);\n            // the record node\n            // Search for the record type specification.\n            List nextRecordTypeSpecCandidates = XDomSupport.getChildNodesByAttrValue(recordTypesSpec, \"Name\", nextRecordTypeName, \"RecordTypeSpec\");\n            if (nextRecordTypeSpecCandidates.size() != 1) {\n                List params = new Vector();\n                params.add(nextRecordTypeName);\n                params.add(new Integer(line[0] + 1));\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"102\", params);\n            }\n            // if (nextRecordTypeSpecCandidates.size() != 1)\n            // Parse the record content: the fields\n            stringPos = parseFieldsAndGroups(interfaceContent, stringPos, line, doc, nextRecord, (Node) nextRecordTypeSpecCandidates.get(0));\n            if (nextRecord.hasChildNodes()) {\n                // some content found\n                insertionNode.appendChild(nextRecord);\n                // insert record into tree\n                recordCount++;\n            }\n            // if (nextRecord.hasChildNodes())\n            // Jump over line break if necessary\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) interfaceContent).startsWith(Constants.LINE_SEPERATOR, stringPos))\n                stringPos += Constants.LINE_SEPERATOR.length();\n            // Next line (Value is always incremented because in case of string\n            // parsing it is ignored anyway.)\n            line[0]++;\n        }\n        // while (stringPos<recordsSectionEnd)\n        return stringPos;\n    }\n\n    // parseRecords(Object interfaceContent, int stringPos, int[] line,\n    // Document doc, Element[] recordsNode)\n    /**\n     * <code>parseTrailer</code> parses the trailer.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param trailerNode the resulting header node (array to have call by\n     *            reference)\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseTrailer(Object interfaceContent, int stringPos, int[] line, Document doc, Element[] trailerNode) throws XException {\n        if (stringPos < interfaceContentLength) {\n            // There is some content to parse\n            trailerNode[0] = doc.createElement(trailerSpec.getAttribute(\"Name\"));\n            // The trailer has its specific name to use as tag.\n            // The contained fields and groups\n            stringPos = parseFieldsAndGroups(interfaceContent, stringPos, line, doc, trailerNode[0], trailerSpec);\n            // Jump over line break if necessary\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) interfaceContent).startsWith(Constants.LINE_SEPERATOR, stringPos))\n                stringPos += Constants.LINE_SEPERATOR.length();\n            // Next line (Value is always incremented because in case of string\n            // parsing it is ignored anyway.)\n            line[0]++;\n        }\n        // if (stringPos<interfaceContent.length())\n        return stringPos;\n    }\n\n    // parseTrailer(Object interfaceContent, int stringPos, int[] line,\n    // Document doc, Element[] trailerNode)\n    /**\n     * <code>parseFieldsAndGroups</code> parses the fields and group\n     * references within a record type - including header and trailer.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param parent the record node in the result DOM tree to attach the field\n     *            nodes to\n     * @param parentSpec the record type node in the structure descrition to get\n     *            the field specs from\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseFieldsAndGroups(Object interfaceContent, int stringPos, int[] line, Document doc, Node parent, Node parentSpec) throws XException {\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            stringPos = parseFieldsAndGroupsSingleByteArray(interfaceContent, stringPos, line, doc, parent, parentSpec);\n        else\n            stringPos = parseFieldsAndGroupsSingleByteArray(((ByteArrayList) interfaceContent).get(line[0]), stringPos, line, doc, parent, parentSpec);\n        return stringPos;\n    }\n\n    // parseFieldsAndGroups(Object interfaceContent, int stringPos, int[]\n    // line, Document doc, Node parent, Node parentSpec)\n    /**\n     * @param interfaceContent\n     * @param stringPos\n     * @param line\n     * @param doc\n     * @param lastRecord\n     * @param parentSpec\n     * @return\n     */\n    private int parseFieldsAndGroupsSingleByteArray(Object interfaceContent, int stringPos, int[] line, Document doc, Node parent, Node parentSpec) throws XException {\n        int lineEnd = 0;\n        // Calculate line length\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n            lineEnd = ((String) interfaceContent).indexOf(Constants.LINE_SEPERATOR, stringPos);\n            if (lineEnd == -1)\n                lineEnd = interfaceContentLength;\n        } else\n            // then (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            lineEnd = stringPos + ((byte[]) interfaceContent).length;\n        NodeList fieldSpecs = parentSpec.getChildNodes();\n        int[] linePos = { 0 };\n        // position in the actual byte array, ignored during string parsing\n        for (int i = 0; i < fieldSpecs.getLength(); i++) {\n            // Loop over all fields and group references\n            Element fieldSpec = (Element) fieldSpecs.item(i);\n            LinkedList fields = new LinkedList();\n            // For the result of field parsing (multiple fields in case of a\n            // group)\n            if (fieldSpec.getNodeName().equals(\"Field\"))\n                // a single field\n                stringPos = parseField(interfaceContent, stringPos, line, lineEnd, linePos, doc, fields, fieldSpec);\n            else if (fieldSpec.getNodeName().equals(\"Group\"))\n                // a field group\n                stringPos = parseGroup(interfaceContent, stringPos, line, lineEnd, linePos, doc, fields, fieldSpec);\n            // Now append the result to the record node.\n            for (int j = 0; j < fields.size(); j++) parent.appendChild((Node) fields.get(j));\n        }\n        // for (int i=0; i<fieldSpecs.getLength(); i++)\n        return stringPos;\n    }\n\n    /**\n     * <code>parseGroup</code> parses a group when a group reference was\n     * found.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param lineEnd the ending position of the current line\n     * @param linePos position in the actual byte array, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param fields the parsing result - similar to\n     *            {@link #parseField(Object, int, int[], int, int[], Document, LinkedList, Element) parseField})\n     * @param groupRef the found group reference\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseGroup(Object interfaceContent, int stringPos, int[] line, int lineEnd, int[] linePos, Document doc, LinkedList fields, Element groupRef) throws XException {\n        try // for casting to XException\n        {\n            // Get the specification of included fields\n            NodeList fieldSpecs = RecordTypeDescriptionChecker.getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all group fields\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                LinkedList field = new LinkedList();\n                // For the result of field parsing (list for call by reference)\n                // the single field\n                stringPos = parseField(interfaceContent, stringPos, line, lineEnd, linePos, doc, field, fieldSpec);\n                if (field.size() == 1)\n                    fields.add(field.get(0));\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return stringPos;\n    }\n\n    // parseGroup(Object interfaceContent, int stringPos, int[] line, int\n    // lineEnd, int[] linePos, Document doc, LinkedList fields, Element\n    // groupRef)\n    /**\n     * <code>parseField</code> parses a single field.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param lineEnd the ending position of the current line\n     * @param linePos position in the actual byte array, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param fields the parsing result (list for call by reference - similar to\n     *            {@link #parseGroup(Object, int, int[], int, int[], Document, LinkedList, Element) parseGroup})\n     * @param fieldSpec the field specification as DOM node\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseField(Object interfaceContent, int stringPos, int[] line, int lineEnd, int[] linePos, Document doc, LinkedList fields, Element fieldSpec) throws XException {\n        try // for casting to XException\n        {\n            int length = Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n            // How many characters?\n            if (stringPos + length > lineEnd) {\n                if (lineCutting)\n                    length = lineEnd - stringPos;\n                else {\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.getAttribute(\"Name\"));\n                    params.add(new Integer(line[0] + 1));\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"104\", params);\n                }\n                // else (lineCutting)\n            }\n            // if (stringPos + length > lineEnd)\n            // Extract the value ...\n            String value = null;\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                // ... from string\n                value = ((String) interfaceContent).substring(stringPos, stringPos + length);\n            else\n                // ... from byte array\n                value = extractSubString((byte[]) interfaceContent, linePos[0], length);\n            if (fieldSpec.getAttribute(\"Format\").equals(\"blank\")) {\n                // A filler may only contain blanks.\n                boolean onlyBlanks = true;\n                for (int i = 0; i < value.length() && onlyBlanks; i++) onlyBlanks = (value.charAt(i) == ' ');\n                if (!onlyBlanks) {\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.getAttribute(\"Name\"));\n                    params.add(new Integer(line[0] + 1));\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"105\", params);\n                }\n                // if (!onlyBlanks)\n            } else // then (fieldSpec.getAttribute(\"Format\").equals(\"blank\"))\n            {\n                // not just a blank filler\n                if (fieldSpec.getAttribute(\"Format\").equals(\"const\") && !value.equals(fieldSpec.getAttribute(\"Value\"))) {\n                    // constant fields must have the specified value\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.getAttribute(\"Name\"));\n                    params.add(new Integer(line[0] + 1));\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"106\", params);\n                } else // then (fieldSpec.getAttribute(\"Format\").equals(\"const\") &&\n                // !value.equals(fieldSpec.getAttribute(\"Value\")))\n                if (fieldSpec.getAttribute(\"Format\").equals(\"num\")) {\n                    // Numeric fields must contain a number\n                    // First character may be '+' or '-'\n                    value = value.trim();\n                    // blanks permitted\n                    if (value.length() > 0) {\n                        // First look for a leading sign\n                        String valueWithoutSign = value;\n                        String sign = \"\";\n                        if (value.charAt(0) == '+' || value.charAt(0) == '-') {\n                            valueWithoutSign = value.substring(1);\n                            sign = value.substring(0, 1).trim();\n                        }\n                        // if (value.charAt(0)=='+' || value.charAt(0)=='-')\n                        // Is an decimal point allowed, if yes which one?\n                        String decimalPoint = fieldSpec.getAttribute(\"DecimalPoint\");\n                        int decPointPos = -1;\n                        char decimalP = '.';\n                        if (decimalPoint != null && decimalPoint.length() > 0) {\n                            // decimal point expected\n                            // which character - '.' or ','?\n                            if (decimalPoint.equals(\"comma\"))\n                                decimalP = ',';\n                            else if (!decimalPoint.equals(\"dot\")) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"107\", params);\n                            }\n                            // if (!decimalPoint.equals(\"dot\"))\n                            // decimal point position\n                            decPointPos = valueWithoutSign.indexOf(decimalP);\n                        }\n                        // if (decimalPoint!=null &&\n                        // decimalPoint.length()>0)\n                        // Check digits\n                        int zeroBegin = -1;\n                        int zeroEnd = valueWithoutSign.length();\n                        boolean onlyZeros = true;\n                        if (decPointPos > -1) {\n                            // Check digits before decimal point\n                            for (int i = 0; i < decPointPos; i++) {\n                                if (!Character.isDigit(valueWithoutSign.charAt(i))) {\n                                    List params = new Vector();\n                                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                    params.add(fieldSpec.getAttribute(\"Name\"));\n                                    params.add(new Integer(line[0] + 1));\n                                    params.add(value);\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                                }\n                                // if\n                                // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                                if (onlyZeros && valueWithoutSign.charAt(i) == '0')\n                                    zeroBegin = i;\n                                else\n                                    onlyZeros = false;\n                            }\n                            // for (int i=0; i<decPointPos; i++)\n                            // Check digits behind decimal point\n                            onlyZeros = true;\n                            for (int i = valueWithoutSign.length() - 1; i > decPointPos; i--) {\n                                if (!Character.isDigit(valueWithoutSign.charAt(i))) {\n                                    List params = new Vector();\n                                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                    params.add(fieldSpec.getAttribute(\"Name\"));\n                                    params.add(new Integer(line[0] + 1));\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                                }\n                                // if\n                                // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                                if (onlyZeros && valueWithoutSign.charAt(i) == '0')\n                                    zeroEnd = i;\n                                else\n                                    onlyZeros = false;\n                            }\n                            // for (int i=valueWithoutSign.length()-1;\n                            // i>decPointPos; i--)\n                        } else\n                            // then (decPointPos>-1)\n                            // no decimal point\n                            for (int i = 0; i < valueWithoutSign.length(); i++) {\n                                if (!Character.isDigit(valueWithoutSign.charAt(i))) {\n                                    List params = new Vector();\n                                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                    params.add(fieldSpec.getAttribute(\"Name\"));\n                                    params.add(new Integer(line[0] + 1));\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                                }\n                                // if\n                                // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                                if (onlyZeros && valueWithoutSign.charAt(i) == '0')\n                                    zeroBegin = i;\n                                else\n                                    onlyZeros = false;\n                            }\n                        // for (int i=0; i<valueWithoutSign.length();\n                        // i++)\n                        if (zeroEnd < valueWithoutSign.length())\n                            valueWithoutSign = valueWithoutSign.substring(0, zeroEnd);\n                        if (zeroBegin > -1)\n                            valueWithoutSign = valueWithoutSign.substring(zeroBegin + 1);\n                        if (valueWithoutSign.length() == 0 || valueWithoutSign.length() == 1 && valueWithoutSign.charAt(0) == decimalP)\n                            value = \"0\";\n                        else\n                            value = sign + valueWithoutSign;\n                    }\n                    // if (value.length()>0)\n                } else // then (fieldSpec.getAttribute(\"Format\").equals(\"num\"))\n                if (fieldSpec.getAttribute(\"Format\").equals(\"date\")) {\n                    value = value.trim();\n                    if (value.length() > 0) {\n                        // a date given\n                        try {\n                            SimpleDateFormat sdf = new SimpleDateFormat(fieldSpec.getAttribute(\"DateFormat\"));\n                            sdf.parse(value);\n                        }// try\n                         catch (Exception e) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n                        }\n                        // catch\n                    }\n                    // if (value.trim().length()>0)\n                }\n                // if (fieldSpec.getAttribute(\"Format\").equals(\"date\"))\n                // Everthing ok, thus create a node.\n                Element field = doc.createElement(fieldSpec.getAttribute(\"Name\"));\n                field.appendChild(doc.createTextNode(value));\n                fields.add(field);\n            }\n            // else (fieldSpec.getAttribute(\"Format\").equals(\"blank\"))\n            // Update position in actual byte array\n            linePos[0] += length;\n            // New global position\n            return stringPos + length;\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // parseField(Object interfaceContent, int stringPos, int[] line, int\n    // lineEnd, int[] linePos, Document doc, LinkedList fields, Element\n    // fieldSpec)\n    /**\n     * <code>determineNextRecordType</code> computes the nexet record type due\n     * to the actual position in the parsed string, the interface structure\n     * description, the last record type and the last record.\n     *\n     * @param interfaceContent interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing the next record from in\n     *            the string or in the complete byte array list (byte count)\n     * @param line index of the next byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param recordType the last record type as its declaration node in the\n     *            interface structure description -<code>null</code> if no\n     *            record was parsed before\n     * @param recordCount the number of subsequent records of the last type\n     * @param lastRecord the last parsed record as node in the result DOM tree -\n     *            <code>null</code> if no record was parsed before\n     * @return the next record type as declaration node in the lines section of\n     *         the interface structure description\n     */\n    private Element determineNextRecordType(Object interfaceContent, int stringPos, int[] line, Element recordType, int recordCount, Element lastRecord) throws XException {\n        Element nextRecordType = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            nextRecordType = determineNextRecordTypeSingleByteArray(interfaceContent, stringPos, line, recordType, recordCount, lastRecord);\n        else\n            nextRecordType = determineNextRecordTypeSingleByteArray(((ByteArrayList) interfaceContent).get(line[0]), stringPos, line, recordType, recordCount, lastRecord);\n        return nextRecordType;\n    }\n\n    // determineNextRecordType(Object interfaceContent, int stringPos, int[]\n    // line, Element recordType, int recordCount, Element lastRecord)\n    /**\n     * @param interfaceContent\n     * @param stringPos\n     * @param line\n     * @param recordType\n     * @param recordCount\n     * @param lastRecord\n     * @return\n     */\n    private Element determineNextRecordTypeSingleByteArray(Object interfaceContent, int stringPos, int[] line, Element recordType, int recordCount, Element lastRecord) throws XException {\n        Element nextRecordType = null;\n        // for the result\n        try // for casting to XException\n        {\n            if (recIdentMethod.equals(\"TypeIdentifier\")) {\n                // With a type identifier the next record type is simply derived\n                // from the interface content, just read the correct substring\n                // to get its id.\n                int idPos = Integer.parseInt(linesSpec.getAttribute(\"IdentifierPos\"));\n                int idLength = Integer.parseInt(linesSpec.getAttribute(\"IdentifierLength\"));\n                // Get the declaration by the id.\n                if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                    // ... from string\n                    nextRecordType = getRecordTypeById(((String) interfaceContent).substring(stringPos + idPos, stringPos + idPos + idLength));\n                else\n                    // ... from byte array\n                    nextRecordType = getRecordTypeById(extractSubString((byte[]) interfaceContent, idPos, idPos + idLength));\n            } else // if (recIdentMethod.equals(\"TypeIdentifier\")\n            if (recordType == null)\n                // First record.\n                if (recOrder.equals(\"Structured\"))\n                    // Get the first record type of the first record group\n                    nextRecordType = (Element) linesSpec.getFirstChild().getFirstChild();\n                else\n                    // Just get the first record type - there are no record\n                    // groups.\n                    nextRecordType = (Element) linesSpec.getFirstChild();\n            else {\n                // Not the first record and no type identifier.\n                boolean lookAtNext = true;\n                // Still searching?\n                nextRecordType = recordType;\n                // Start with the last record type.\n                while (lookAtNext && nextRecordType != null) {\n                    // loop until found or end of record type list reached\n                    String card = nextRecordType.getAttribute(\"Occurrences\");\n                    int cardNum = -1;\n                    int cardLow = -1;\n                    int cardHigh = -1;\n                    if (CardinalityStrings.isCardinalityInterval(card, true)) {\n                        // The cardinality is specified as an interval.\n                        cardLow = CardinalityStrings.getCardinalityLow(card, true);\n                        cardHigh = CardinalityStrings.getCardinalityHigh(card, true);\n                        if (recordCount < cardLow)\n                            // minimal cardinality not yet reached, thus take\n                            // this record type.\n                            lookAtNext = false;\n                        else {\n                            // minimal cardinality already reached before\n                            if (cardHigh > recordCount) {\n                                // maximal cardinality not yet reached\n                                if (linesSpec.getChildNodes().getLength() == 1) {\n                                    // only one record type\n                                    lookAtNext = false;\n                                } else // then\n                                // (linesSpec.getChildNodes().getLength()==1)\n                                {\n                                    // Look for the existance indicator.\n                                    String existanceIndField = nextRecordType.getAttribute(\"ExistIndicatorField\");\n                                    String existanceIndValue = nextRecordType.getAttribute(\"ExistIndicatorValue\");\n                                    // Find the field in the last record.\n                                    NodeList existInds = lastRecord.getElementsByTagName(existanceIndField);\n                                    if (existInds.getLength() != 1) {\n                                        List params = new Vector();\n                                        params.add(XDomSupport.getTrimedNodeText(nextRecordType));\n                                        params.add(existanceIndField);\n                                        params.add(XDomSupport.getTrimedNodeText(recordType));\n                                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"113\", params);\n                                    }\n                                    // if (existInds.getLength() != 1)\n                                    // The existance indicator is set in the\n                                    // last record, the next record type is\n                                    // found.\n                                    if (existanceIndValue.equals(XDomSupport.getTrimedNodeText(existInds.item(0))))\n                                        lookAtNext = false;\n                                }\n                                // else\n                                // (linesSpec.getChildNodes().getLength()==1)\n                            }\n                            // if (cardHigh>recordCount)\n                        }\n                        // else (cardLow<recordCount)\n                    } else // then (isCardinalityInterval(card,true))\n                    {\n                        // Cardinality is just a single value.\n                        cardNum = Integer.parseInt(card);\n                        // Cardinality already reached?\n                        if (cardNum < recordCount)\n                            lookAtNext = false;\n                    }\n                    // else (isCardinalityInterval(card,true))\n                    if (lookAtNext) {\n                        // Still searching\n                        nextRecordType = (Element) nextRecordType.getNextSibling();\n                        recordCount = 0;\n                    }\n                    // if (lookAtNext)\n                }\n                // while (lookAtNext && nextRecordType!=null)\n                if (lookAtNext)\n                    // At the end of record type list next record type not\n                    // found.\n                    if (recOrder.equals(\"Structured\"))\n                        // In case of grouped records, just a new group starts.\n                        nextRecordType = (Element) linesSpec.getFirstChild().getFirstChild();\n                    else // Take the first record type of the first record group\n                    // because there is only one\n                    // (recIdentMethod!=\"TypeIdentifier\").\n                    {\n                        List params = new Vector();\n                        params.add(XDomSupport.getTrimedNodeText(recordType));\n                        params.add(new Integer(line[0] + 1));\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"114\", params);\n                    }\n            }\n            // else (recordType==null)\n        }// try\n         catch (IndexOutOfBoundsException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }// catch (IndexOutOfBoundsException e)\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }// catch (NumberFormatException e)\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch (ClassCastException e)\n        return nextRecordType;\n    }\n\n    /**\n     * @param inRecord\n     * @param doc\n     */\n    public int parseSingleRecord(byte[] inRecord, Document doc, Element[] recordType, int recordCount) throws XException {\n        int[] line = { 0 };\n        Element lastRecord = null;\n        if (doc.hasChildNodes())\n            lastRecord = doc.getDocumentElement();\n        Element nextRecordType = determineNextRecordTypeSingleByteArray(inRecord, 0, line, recordType[0], recordCount, lastRecord);\n        if (recordType[0] == null || !XDomSupport.getTrimedNodeText(nextRecordType).equals(XDomSupport.getTrimedNodeText(recordType[0]))) {\n            // First record type or record type change.\n            recordCount = 0;\n            recordType[0] = nextRecordType;\n        }\n        // if (recordType==null ||\n        // !XDomSupport.getTrimedElementValue(nextRecordType).equals(XDomSupport.getTrimedElementValue(recordType)))\n        String nextRecordTypeName = XDomSupport.getTrimedNodeText(nextRecordType);\n        Element nextRecord = doc.createElement(nextRecordTypeName);\n        // the record node\n        // Search for the record type specification.\n        List nextRecordTypeSpecCandidates = XDomSupport.getChildNodesByAttrValue(recordTypesSpec, \"Name\", nextRecordTypeName, \"RecordTypeSpec\");\n        if (nextRecordTypeSpecCandidates.size() != 1) {\n            List params = new Vector();\n            params.add(nextRecordTypeName);\n            params.add(new Integer(line[0] + 1));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"102\", params);\n        }\n        // if (nextRecordTypeSpecCandidates.size() != 1)\n        // Parse the record content: the fields\n        parseFieldsAndGroupsSingleByteArray(inRecord, 0, line, doc, nextRecord, (Node) nextRecordTypeSpecCandidates.get(0));\n        if (nextRecord.hasChildNodes()) {\n            // some content found\n            if (doc.hasChildNodes())\n                doc.removeChild(doc.getFirstChild());\n            doc.appendChild(nextRecord);\n            // insert record into tree\n            recordCount++;\n        }\n        // if (nextRecord.hasChildNodes())\n        return recordCount;\n    }\n\n    /**\n     * <code>extractSubString</code> extracts a field value as string from a\n     * specific position in a byte array. The extraction is done in two steps:\n     * <ol>\n     * <li>Extraction of bytes due to position and length</li>\n     * <li>Conversion to string by the preloaded byte array converter</li>\n     * </ol>\n     *\n     * @param array the byte array to extract the field value from\n     * @param pos the field starting position in the array (byte count)\n     * @param length the field length (byte count)\n     * @return the field value converted to a string\n     * @throws XException in case of unpossible <code>pos</code> or\n     *             <code>length</code> values\n     */\n    protected String extractSubString(byte[] array, int pos, int length) throws XException {\n        byte[] subArr = XByteArraySupport.subArray(array, pos, length);\n        return byteArrayConverter.byteArrayToString(subArr);\n    }\n    // extractSubString(byte[] array, int pos, int length)\n}\n// RecordTypeParser\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeParserTest0.java",
		"test_prompt": "// RecordTypeParserTest0.java\npackage net.sf.xbus.protocol.records;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeParser}.\n* It contains ten unit test cases for the {@link RecordTypeParser#getInstance(String, int)} method.\n*/\nclass RecordTypeParserTest0 {"
	},
	{
		"original_code": "// RecordTypeParser.java\npackage net.sf.xbus.protocol.records;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * The class <code>RecordTypeParser</code> implements parsing records from a\n * string or a list of byte arrays.\n * <p>\n * The parsed structure is described by a xml file - in particular the contained\n * record types, their order within the string and how to identify them during\n * parsing. Such describing files are of document type\n * <code>InterfaceSpec</code> declared in \"InterfaceSpec.dtd\".\n * </p>\n * <p>\n * The parsing result is a DOM tree with the following structure:\n * </p>\n * <p>\n * &lt;+ <i>InterfaceName </i>+&gt; <dir>&lt;+ <i>HeaderName </i>+&gt;\n * <dir>&lt;+ <i>FieldName </i>+&gt;+ <b>FieldValue </b>+&lt;/+ <i>FieldName\n * </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>HeaderName </i>+&gt; <br>\n * &lt;Records&gt; <dir>&lt;RecordGroup&gt; <dir>&lt;+ <i>RecordType </i>+&gt;\n * <dir>&lt;+ <i>FieldName </i>+&gt;+ <b>FieldValue </b>+&lt;/+ <i>FieldName\n * </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>RecordType </i>+&gt; <br>\n * ... </dir> &lt;/RecordGroup&gt; <br>\n * ... </dir> &lt;/Records&gt; <br>\n * &lt;+ <i>TrailerName </i>+&gt; <dir>&lt;+ <i>FieldName </i>+&gt;+\n * <b>FieldValue </b>+&lt;/+ <i>FieldName </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>TrailerName </i>+&gt; </dir> &lt;/+ <i>InterfaceName\n * </i>+&gt;\n * </p>\n * <p>\n * Header and trailer are optional. <br>\n * The &lt;RecordGroup&gt; structure is only used if records of different types\n * are grouped together in the string (RecordOrder=Structured for the\n * &lt;Lines&gt; specification in the structure description). Otherwise records\n * are listed immediately below the &lt;Records&gt; level.\n * </p>\n * <p>\n * There is no DTD for the parsing result since the used tags depend on the\n * document structure of the parsed file (tags indicated by +'s above). But it\n * can be derived from the structure description taking the name attributes for\n * interface type, header, record types, fields and trailer as tags.\n * </p>\n * <p>\n * The \"ordinary\" working mode is parsing records from a string. But due to\n * special problems with some character encoding and line breaks within record\n * fields, byte-array-oriented parsing is available, too. In this case each\n * record is stored in its own byte array.\n * </p>\n *\n * @author Stephan D�wel\n */\npublic class RecordTypeParser extends RecordTypeManipulator {\n\n    // //////////////////////\n    // Static fields\n    // //////////////////////\n    /**\n     * <code>instances</code> stores the instances by thread, the interface\n     * name and the representation type (<code>String</code> or\n     * {@link net.sf.xbus.base.bytearraylist.ByteArrayList}).\n     */\n    private static Hashtable instances = new Hashtable();\n\n    private static final Object classLock = RecordTypeParser.class;\n\n    // //////////////////////\n    // Member fields\n    // //////////////////////\n    /**\n     * Flag if record lines are cut off after the last non-whitespace character.\n     */\n    private boolean lineCutting = false;\n\n    // //////////////////////\n    // Constructors\n    // //////////////////////\n    /**\n     * Just the standard constructor.\n     */\n    private RecordTypeParser() throws XException {\n        super();\n    }\n\n    // RecordTypeParser()\n    // //////////////////////\n    // Static methods\n    // //////////////////////\n    /**\n     * <code>getInstance()</code> retrieves the an instance of\n     * <code>RecordTypeParser</code>.\n     *\n     * @param sourceType the name for the parsed structure as it is derived from\n     *            a\n     *            {@link net.sf.xbus.protocol.records.RecordTypeMessage RecordTypeMessage}\n     * @param interfaceContentClass Working mode: sting or byte array list\n     * @throws XException in case of missing <code>sourceType</code>\n     */\n    public static RecordTypeParser getInstance(String sourceType, int interfaceContentClass) throws XException {\n        synchronized (classLock) {\n            if (sourceType == null || sourceType.length() == 0)\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"98\");\n            RecordTypeParser instance = (RecordTypeParser) instances.get(Thread.currentThread().getName() + sourceType + interfaceContentClass);\n            if (instance == null) {\n                // no suitable instance available yet\n                instance = new RecordTypeParser();\n                instances.put(Thread.currentThread().getName() + sourceType + interfaceContentClass, instance);\n            }\n            // if (instance==null)\n            return instance;\n        }\n        // synchronized (classLock)\n    }\n\n    // getInstance(String sourceType, int interfaceContentClass)\n    /**\n     * <code>getByteArrayConverter</code> retrieves a byte array converter\n     * object which is convenient for the interface from which the records are\n     * to parse.\n     *\n     * @return an appropriate converter object\n     */\n    protected ByteArrayConverter getByteArrayConverter() throws XException {\n        // Get the byte the byte array converter for the interface specified\n        // in the underlying message.\n        return ByteArrayConverterFactory.getConverter(sourceType);\n    }\n\n    // getByteArrayConverter()\n    // /////////////////////////////////////////\n    // Parsing the contents\n    // /////////////////////////////////////////\n    /**\n     * <code>parse</code> parses a string due to the record type definition.\n     *\n     * @param interfaceContent the string to parse\n     * @param resultDoc The parsing result - an empty DOM tree which will be\n     *            filled.\n     * @throws XException in case that the interface structure description is\n     *             not loaded or in case of an unexpected value or end of\n     *             string/byte array/byte array list\n     */\n    public void parse(Object interfaceContent, Document resultDoc) throws XException {\n        if (interfaceStructure == null)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"99\");\n        // May ending white spaces in the record lines be ommitted?\n        lineCutting = Configuration.getInstance().getValueAsBooleanOptional(\"System\", sourceType, \"LineCutting\");\n        // The root element has the content type as xml tag.\n        Element root = resultDoc.createElement(contentType);\n        resultDoc.appendChild(root);\n        // Parsing position\n        int stringPos = 0;\n        // Position in string or in the complete byte array list (byte count)\n        int[] line = { 0 };\n        // Index of list element in a byte array list, array for call by\n        // reference\n        try // for casting to XException\n        {\n            // Determine the length of content to parse ...\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                // ... as number of characters for a parsed string\n                interfaceContentLength = ((String) interfaceContent).length();\n            else if (interfaceContentClass == Constants.IFCONTENTCLASS_BYTEARRAYLIST)\n                // ... as number of bytes in case of a parsed byte array list\n                interfaceContentLength = ((ByteArrayList) interfaceContent).length();\n            else\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"100\");\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch (ClassCastException e)\n        Element[] headerNode = { null };\n        // for building up the header node (array for call by reference)\n        if (headerSpec != null)\n            stringPos = parseHeader(interfaceContent, stringPos, line, resultDoc, headerNode);\n        if (headerNode.length == 1 && headerNode[0] != null && headerNode[0].hasChildNodes())\n            // header successfully parsed\n            root.appendChild(headerNode[0]);\n        Element[] recordsNode = { null };\n        // for building up the records section (array for call by reference)\n        stringPos = parseRecords(interfaceContent, stringPos, line, resultDoc, recordsNode);\n        if (recordsNode.length == 1 && recordsNode[0] != null && recordsNode[0].hasChildNodes())\n            // records successfully parsed\n            root.appendChild(recordsNode[0]);\n        Element[] trailerNode = { null };\n        // For building up the trailer node (array for call by reference)\n        if (trailerSpec != null)\n            stringPos = parseTrailer(interfaceContent, stringPos, line, resultDoc, trailerNode);\n        if (trailerNode.length == 1 && trailerNode[0] != null && trailerNode[0].hasChildNodes())\n            // trailer successfully parsed\n            root.appendChild(trailerNode[0]);\n    }\n\n    // parse(String interfaceContent, Document resultDoc)\n    /**\n     * <code>parseHeader</code> parses the header.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param headerNode the resulting header node (array to have call by\n     *            reference)\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseHeader(Object interfaceContent, int stringPos, int[] line, Document doc, Element[] headerNode) throws XException {\n        if (stringPos < interfaceContentLength) {\n            // There is some content to parse\n            headerNode[0] = doc.createElement(headerSpec.getAttribute(\"Name\"));\n            // The header owns its specific name to use as tag.\n            // The contained fields and groups\n            stringPos = parseFieldsAndGroups(interfaceContent, stringPos, line, doc, headerNode[0], headerSpec);\n            // Jump over line break if necessary\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) interfaceContent).startsWith(Constants.LINE_SEPERATOR, stringPos))\n                stringPos += Constants.LINE_SEPERATOR.length();\n            // Next line (Value is always incremented because in case of string\n            // parsing it is ignoed anyway.)\n            line[0]++;\n        }\n        // if (stringPos<interfaceContent.length())\n        return stringPos;\n    }\n\n    // parseHeader(Object interfaceContent, int stringPos, int[] line,\n    // Document doc, Element[] headerNode)\n    /**\n     * <code>parseRecords</code> parses the record types.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param recordsNode the resulting Record Types node (array to have call by\n     *            reference)\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseRecords(Object interfaceContent, int stringPos, int[] line, Document doc, Element[] recordsNode) throws XException {\n        // Determine end of record parsing\n        int recordsSectionEnd = interfaceContentLength;\n        if (trailerSpec != null)\n            // If there is a trailer, record parsing must already end before the\n            // string end.\n            recordsSectionEnd -= RecordTypeDescriptionChecker.computeRecordLength(trailerSpec, groupsSpec);\n        if (stringPos < recordsSectionEnd)\n            // something to parse left\n            recordsNode[0] = doc.createElement(\"Records\");\n        Element insertionNode = recordsNode[0];\n        // node to insert the records below - <Records> or <RecordType>\n        Element recordType = null;\n        int recordCount = 0;\n        // counter for subsequent records of the same type\n        Element nextRecord = null;\n        // To create record nodes.\n        // The last created is used to determine the next record type.\n        while (stringPos < recordsSectionEnd) {\n            // loop over content string\n            // Determining the next record type really drives the loop.\n            Element nextRecordType = determineNextRecordType(interfaceContent, stringPos, line, recordType, recordCount, nextRecord);\n            if (recordType == null || !XDomSupport.getTrimedNodeText(nextRecordType).equals(XDomSupport.getTrimedNodeText(recordType))) {\n                // First record type or record type change.\n                recordCount = 0;\n                recordType = nextRecordType;\n            }\n            // if (recordType==null ||\n            // !XDomSupport.getTrimedElementValue(nextRecordType).equals(XDomSupport.getTrimedElementValue(recordType)))\n            if (recOrder.equals(\"Structured\") && getRecordTypePositionInLines(nextRecordType) == 0) {\n                // first record in a group\n                insertionNode = doc.createElement(\"RecordGroup\");\n                recordsNode[0].appendChild(insertionNode);\n            }\n            // if (recOrder.equals(\"Structured\") && nextRecordTypePos==0)\n            String nextRecordTypeName = XDomSupport.getTrimedNodeText(nextRecordType);\n            nextRecord = doc.createElement(nextRecordTypeName);\n            // the record node\n            // Search for the record type specification.\n            List nextRecordTypeSpecCandidates = XDomSupport.getChildNodesByAttrValue(recordTypesSpec, \"Name\", nextRecordTypeName, \"RecordTypeSpec\");\n            if (nextRecordTypeSpecCandidates.size() != 1) {\n                List params = new Vector();\n                params.add(nextRecordTypeName);\n                params.add(new Integer(line[0] + 1));\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"102\", params);\n            }\n            // if (nextRecordTypeSpecCandidates.size() != 1)\n            // Parse the record content: the fields\n            stringPos = parseFieldsAndGroups(interfaceContent, stringPos, line, doc, nextRecord, (Node) nextRecordTypeSpecCandidates.get(0));\n            if (nextRecord.hasChildNodes()) {\n                // some content found\n                insertionNode.appendChild(nextRecord);\n                // insert record into tree\n                recordCount++;\n            }\n            // if (nextRecord.hasChildNodes())\n            // Jump over line break if necessary\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) interfaceContent).startsWith(Constants.LINE_SEPERATOR, stringPos))\n                stringPos += Constants.LINE_SEPERATOR.length();\n            // Next line (Value is always incremented because in case of string\n            // parsing it is ignored anyway.)\n            line[0]++;\n        }\n        // while (stringPos<recordsSectionEnd)\n        return stringPos;\n    }\n\n    // parseRecords(Object interfaceContent, int stringPos, int[] line,\n    // Document doc, Element[] recordsNode)\n    /**\n     * <code>parseTrailer</code> parses the trailer.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param trailerNode the resulting header node (array to have call by\n     *            reference)\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseTrailer(Object interfaceContent, int stringPos, int[] line, Document doc, Element[] trailerNode) throws XException {\n        if (stringPos < interfaceContentLength) {\n            // There is some content to parse\n            trailerNode[0] = doc.createElement(trailerSpec.getAttribute(\"Name\"));\n            // The trailer has its specific name to use as tag.\n            // The contained fields and groups\n            stringPos = parseFieldsAndGroups(interfaceContent, stringPos, line, doc, trailerNode[0], trailerSpec);\n            // Jump over line break if necessary\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING && ((String) interfaceContent).startsWith(Constants.LINE_SEPERATOR, stringPos))\n                stringPos += Constants.LINE_SEPERATOR.length();\n            // Next line (Value is always incremented because in case of string\n            // parsing it is ignored anyway.)\n            line[0]++;\n        }\n        // if (stringPos<interfaceContent.length())\n        return stringPos;\n    }\n\n    // parseTrailer(Object interfaceContent, int stringPos, int[] line,\n    // Document doc, Element[] trailerNode)\n    /**\n     * <code>parseFieldsAndGroups</code> parses the fields and group\n     * references within a record type - including header and trailer.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param parent the record node in the result DOM tree to attach the field\n     *            nodes to\n     * @param parentSpec the record type node in the structure descrition to get\n     *            the field specs from\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseFieldsAndGroups(Object interfaceContent, int stringPos, int[] line, Document doc, Node parent, Node parentSpec) throws XException {\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            stringPos = parseFieldsAndGroupsSingleByteArray(interfaceContent, stringPos, line, doc, parent, parentSpec);\n        else\n            stringPos = parseFieldsAndGroupsSingleByteArray(((ByteArrayList) interfaceContent).get(line[0]), stringPos, line, doc, parent, parentSpec);\n        return stringPos;\n    }\n\n    // parseFieldsAndGroups(Object interfaceContent, int stringPos, int[]\n    // line, Document doc, Node parent, Node parentSpec)\n    /**\n     * @param interfaceContent\n     * @param stringPos\n     * @param line\n     * @param doc\n     * @param lastRecord\n     * @param parentSpec\n     * @return\n     */\n    private int parseFieldsAndGroupsSingleByteArray(Object interfaceContent, int stringPos, int[] line, Document doc, Node parent, Node parentSpec) throws XException {\n        int lineEnd = 0;\n        // Calculate line length\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING) {\n            lineEnd = ((String) interfaceContent).indexOf(Constants.LINE_SEPERATOR, stringPos);\n            if (lineEnd == -1)\n                lineEnd = interfaceContentLength;\n        } else\n            // then (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            lineEnd = stringPos + ((byte[]) interfaceContent).length;\n        NodeList fieldSpecs = parentSpec.getChildNodes();\n        int[] linePos = { 0 };\n        // position in the actual byte array, ignored during string parsing\n        for (int i = 0; i < fieldSpecs.getLength(); i++) {\n            // Loop over all fields and group references\n            Element fieldSpec = (Element) fieldSpecs.item(i);\n            LinkedList fields = new LinkedList();\n            // For the result of field parsing (multiple fields in case of a\n            // group)\n            if (fieldSpec.getNodeName().equals(\"Field\"))\n                // a single field\n                stringPos = parseField(interfaceContent, stringPos, line, lineEnd, linePos, doc, fields, fieldSpec);\n            else if (fieldSpec.getNodeName().equals(\"Group\"))\n                // a field group\n                stringPos = parseGroup(interfaceContent, stringPos, line, lineEnd, linePos, doc, fields, fieldSpec);\n            // Now append the result to the record node.\n            for (int j = 0; j < fields.size(); j++) parent.appendChild((Node) fields.get(j));\n        }\n        // for (int i=0; i<fieldSpecs.getLength(); i++)\n        return stringPos;\n    }\n\n    /**\n     * <code>parseGroup</code> parses a group when a group reference was\n     * found.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param lineEnd the ending position of the current line\n     * @param linePos position in the actual byte array, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param fields the parsing result - similar to\n     *            {@link #parseField(Object, int, int[], int, int[], Document, LinkedList, Element) parseField})\n     * @param groupRef the found group reference\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseGroup(Object interfaceContent, int stringPos, int[] line, int lineEnd, int[] linePos, Document doc, LinkedList fields, Element groupRef) throws XException {\n        try // for casting to XException\n        {\n            // Get the specification of included fields\n            NodeList fieldSpecs = RecordTypeDescriptionChecker.getGroupSpec(groupRef.getAttribute(\"Name\"), groupsSpec).getChildNodes();\n            // fields in the group\n            for (int i = 0; i < fieldSpecs.getLength(); i++) {\n                // Loop over all group fields\n                Element fieldSpec = (Element) fieldSpecs.item(i);\n                LinkedList field = new LinkedList();\n                // For the result of field parsing (list for call by reference)\n                // the single field\n                stringPos = parseField(interfaceContent, stringPos, line, lineEnd, linePos, doc, field, fieldSpec);\n                if (field.size() == 1)\n                    fields.add(field.get(0));\n            }\n            // for (int i=0; i<fieldSpecs.getLength(); i++)\n        }// try\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch\n        return stringPos;\n    }\n\n    // parseGroup(Object interfaceContent, int stringPos, int[] line, int\n    // lineEnd, int[] linePos, Document doc, LinkedList fields, Element\n    // groupRef)\n    /**\n     * <code>parseField</code> parses a single field.\n     *\n     * @param interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing from in the string or in\n     *            the complete byte array list (byte count)\n     * @param line index of the byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param lineEnd the ending position of the current line\n     * @param linePos position in the actual byte array, ignored when parsing a\n     *            string\n     * @param doc the total result document - necessary for creating nodes\n     * @param fields the parsing result (list for call by reference - similar to\n     *            {@link #parseGroup(Object, int, int[], int, int[], Document, LinkedList, Element) parseGroup})\n     * @param fieldSpec the field specification as DOM node\n     * @return the string or byte array position to start the next part's\n     *         parsing from\n     * @throws XException in case of an unexpected value or end of string\n     */\n    private int parseField(Object interfaceContent, int stringPos, int[] line, int lineEnd, int[] linePos, Document doc, LinkedList fields, Element fieldSpec) throws XException {\n        try // for casting to XException\n        {\n            int length = Integer.parseInt(fieldSpec.getAttribute(\"Length\"));\n            // How many characters?\n            if (stringPos + length > lineEnd) {\n                if (lineCutting)\n                    length = lineEnd - stringPos;\n                else {\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.getAttribute(\"Name\"));\n                    params.add(new Integer(line[0] + 1));\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"104\", params);\n                }\n                // else (lineCutting)\n            }\n            // if (stringPos + length > lineEnd)\n            // Extract the value ...\n            String value = null;\n            if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                // ... from string\n                value = ((String) interfaceContent).substring(stringPos, stringPos + length);\n            else\n                // ... from byte array\n                value = extractSubString((byte[]) interfaceContent, linePos[0], length);\n            if (fieldSpec.getAttribute(\"Format\").equals(\"blank\")) {\n                // A filler may only contain blanks.\n                boolean onlyBlanks = true;\n                for (int i = 0; i < value.length() && onlyBlanks; i++) onlyBlanks = (value.charAt(i) == ' ');\n                if (!onlyBlanks) {\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.getAttribute(\"Name\"));\n                    params.add(new Integer(line[0] + 1));\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"105\", params);\n                }\n                // if (!onlyBlanks)\n            } else // then (fieldSpec.getAttribute(\"Format\").equals(\"blank\"))\n            {\n                // not just a blank filler\n                if (fieldSpec.getAttribute(\"Format\").equals(\"const\") && !value.equals(fieldSpec.getAttribute(\"Value\"))) {\n                    // constant fields must have the specified value\n                    List params = new Vector();\n                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                    params.add(fieldSpec.getAttribute(\"Name\"));\n                    params.add(new Integer(line[0] + 1));\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"106\", params);\n                } else // then (fieldSpec.getAttribute(\"Format\").equals(\"const\") &&\n                // !value.equals(fieldSpec.getAttribute(\"Value\")))\n                if (fieldSpec.getAttribute(\"Format\").equals(\"num\")) {\n                    // Numeric fields must contain a number\n                    // First character may be '+' or '-'\n                    value = value.trim();\n                    // blanks permitted\n                    if (value.length() > 0) {\n                        // First look for a leading sign\n                        String valueWithoutSign = value;\n                        String sign = \"\";\n                        if (value.charAt(0) == '+' || value.charAt(0) == '-') {\n                            valueWithoutSign = value.substring(1);\n                            sign = value.substring(0, 1).trim();\n                        }\n                        // if (value.charAt(0)=='+' || value.charAt(0)=='-')\n                        // Is an decimal point allowed, if yes which one?\n                        String decimalPoint = fieldSpec.getAttribute(\"DecimalPoint\");\n                        int decPointPos = -1;\n                        char decimalP = '.';\n                        if (decimalPoint != null && decimalPoint.length() > 0) {\n                            // decimal point expected\n                            // which character - '.' or ','?\n                            if (decimalPoint.equals(\"comma\"))\n                                decimalP = ',';\n                            else if (!decimalPoint.equals(\"dot\")) {\n                                List params = new Vector();\n                                params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                params.add(fieldSpec.getAttribute(\"Name\"));\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"107\", params);\n                            }\n                            // if (!decimalPoint.equals(\"dot\"))\n                            // decimal point position\n                            decPointPos = valueWithoutSign.indexOf(decimalP);\n                        }\n                        // if (decimalPoint!=null &&\n                        // decimalPoint.length()>0)\n                        // Check digits\n                        int zeroBegin = -1;\n                        int zeroEnd = valueWithoutSign.length();\n                        boolean onlyZeros = true;\n                        if (decPointPos > -1) {\n                            // Check digits before decimal point\n                            for (int i = 0; i < decPointPos; i++) {\n                                if (!Character.isDigit(valueWithoutSign.charAt(i))) {\n                                    List params = new Vector();\n                                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                    params.add(fieldSpec.getAttribute(\"Name\"));\n                                    params.add(new Integer(line[0] + 1));\n                                    params.add(value);\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                                }\n                                // if\n                                // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                                if (onlyZeros && valueWithoutSign.charAt(i) == '0')\n                                    zeroBegin = i;\n                                else\n                                    onlyZeros = false;\n                            }\n                            // for (int i=0; i<decPointPos; i++)\n                            // Check digits behind decimal point\n                            onlyZeros = true;\n                            for (int i = valueWithoutSign.length() - 1; i > decPointPos; i--) {\n                                if (!Character.isDigit(valueWithoutSign.charAt(i))) {\n                                    List params = new Vector();\n                                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                    params.add(fieldSpec.getAttribute(\"Name\"));\n                                    params.add(new Integer(line[0] + 1));\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                                }\n                                // if\n                                // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                                if (onlyZeros && valueWithoutSign.charAt(i) == '0')\n                                    zeroEnd = i;\n                                else\n                                    onlyZeros = false;\n                            }\n                            // for (int i=valueWithoutSign.length()-1;\n                            // i>decPointPos; i--)\n                        } else\n                            // then (decPointPos>-1)\n                            // no decimal point\n                            for (int i = 0; i < valueWithoutSign.length(); i++) {\n                                if (!Character.isDigit(valueWithoutSign.charAt(i))) {\n                                    List params = new Vector();\n                                    params.add(((Element) fieldSpec.getParentNode()).getAttribute(\"Name\"));\n                                    params.add(fieldSpec.getAttribute(\"Name\"));\n                                    params.add(new Integer(line[0] + 1));\n                                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"108\", params);\n                                }\n                                // if\n                                // (!Character.isDigit(valueWithoutSign.charAt(i)))\n                                if (onlyZeros && valueWithoutSign.charAt(i) == '0')\n                                    zeroBegin = i;\n                                else\n                                    onlyZeros = false;\n                            }\n                        // for (int i=0; i<valueWithoutSign.length();\n                        // i++)\n                        if (zeroEnd < valueWithoutSign.length())\n                            valueWithoutSign = valueWithoutSign.substring(0, zeroEnd);\n                        if (zeroBegin > -1)\n                            valueWithoutSign = valueWithoutSign.substring(zeroBegin + 1);\n                        if (valueWithoutSign.length() == 0 || valueWithoutSign.length() == 1 && valueWithoutSign.charAt(0) == decimalP)\n                            value = \"0\";\n                        else\n                            value = sign + valueWithoutSign;\n                    }\n                    // if (value.length()>0)\n                } else // then (fieldSpec.getAttribute(\"Format\").equals(\"num\"))\n                if (fieldSpec.getAttribute(\"Format\").equals(\"date\")) {\n                    value = value.trim();\n                    if (value.length() > 0) {\n                        // a date given\n                        try {\n                            SimpleDateFormat sdf = new SimpleDateFormat(fieldSpec.getAttribute(\"DateFormat\"));\n                            sdf.parse(value);\n                        }// try\n                         catch (Exception e) {\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n                        }\n                        // catch\n                    }\n                    // if (value.trim().length()>0)\n                }\n                // if (fieldSpec.getAttribute(\"Format\").equals(\"date\"))\n                // Everthing ok, thus create a node.\n                Element field = doc.createElement(fieldSpec.getAttribute(\"Name\"));\n                field.appendChild(doc.createTextNode(value));\n                fields.add(field);\n            }\n            // else (fieldSpec.getAttribute(\"Format\").equals(\"blank\"))\n            // Update position in actual byte array\n            linePos[0] += length;\n            // New global position\n            return stringPos + length;\n        }// try\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // parseField(Object interfaceContent, int stringPos, int[] line, int\n    // lineEnd, int[] linePos, Document doc, LinkedList fields, Element\n    // fieldSpec)\n    /**\n     * <code>determineNextRecordType</code> computes the nexet record type due\n     * to the actual position in the parsed string, the interface structure\n     * description, the last record type and the last record.\n     *\n     * @param interfaceContent interfaceContent the (whole) string to parse\n     * @param stringPos the position to start parsing the next record from in\n     *            the string or in the complete byte array list (byte count)\n     * @param line index of the next byte array to parse, array for call by\n     *            reference, because it is augmented, ignored when parsing a\n     *            string\n     * @param recordType the last record type as its declaration node in the\n     *            interface structure description -<code>null</code> if no\n     *            record was parsed before\n     * @param recordCount the number of subsequent records of the last type\n     * @param lastRecord the last parsed record as node in the result DOM tree -\n     *            <code>null</code> if no record was parsed before\n     * @return the next record type as declaration node in the lines section of\n     *         the interface structure description\n     */\n    private Element determineNextRecordType(Object interfaceContent, int stringPos, int[] line, Element recordType, int recordCount, Element lastRecord) throws XException {\n        Element nextRecordType = null;\n        if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n            nextRecordType = determineNextRecordTypeSingleByteArray(interfaceContent, stringPos, line, recordType, recordCount, lastRecord);\n        else\n            nextRecordType = determineNextRecordTypeSingleByteArray(((ByteArrayList) interfaceContent).get(line[0]), stringPos, line, recordType, recordCount, lastRecord);\n        return nextRecordType;\n    }\n\n    // determineNextRecordType(Object interfaceContent, int stringPos, int[]\n    // line, Element recordType, int recordCount, Element lastRecord)\n    /**\n     * @param interfaceContent\n     * @param stringPos\n     * @param line\n     * @param recordType\n     * @param recordCount\n     * @param lastRecord\n     * @return\n     */\n    private Element determineNextRecordTypeSingleByteArray(Object interfaceContent, int stringPos, int[] line, Element recordType, int recordCount, Element lastRecord) throws XException {\n        Element nextRecordType = null;\n        // for the result\n        try // for casting to XException\n        {\n            if (recIdentMethod.equals(\"TypeIdentifier\")) {\n                // With a type identifier the next record type is simply derived\n                // from the interface content, just read the correct substring\n                // to get its id.\n                int idPos = Integer.parseInt(linesSpec.getAttribute(\"IdentifierPos\"));\n                int idLength = Integer.parseInt(linesSpec.getAttribute(\"IdentifierLength\"));\n                // Get the declaration by the id.\n                if (interfaceContentClass == Constants.IFCONTENTCLASS_STRING)\n                    // ... from string\n                    nextRecordType = getRecordTypeById(((String) interfaceContent).substring(stringPos + idPos, stringPos + idPos + idLength));\n                else\n                    // ... from byte array\n                    nextRecordType = getRecordTypeById(extractSubString((byte[]) interfaceContent, idPos, idPos + idLength));\n            } else // if (recIdentMethod.equals(\"TypeIdentifier\")\n            if (recordType == null)\n                // First record.\n                if (recOrder.equals(\"Structured\"))\n                    // Get the first record type of the first record group\n                    nextRecordType = (Element) linesSpec.getFirstChild().getFirstChild();\n                else\n                    // Just get the first record type - there are no record\n                    // groups.\n                    nextRecordType = (Element) linesSpec.getFirstChild();\n            else {\n                // Not the first record and no type identifier.\n                boolean lookAtNext = true;\n                // Still searching?\n                nextRecordType = recordType;\n                // Start with the last record type.\n                while (lookAtNext && nextRecordType != null) {\n                    // loop until found or end of record type list reached\n                    String card = nextRecordType.getAttribute(\"Occurrences\");\n                    int cardNum = -1;\n                    int cardLow = -1;\n                    int cardHigh = -1;\n                    if (CardinalityStrings.isCardinalityInterval(card, true)) {\n                        // The cardinality is specified as an interval.\n                        cardLow = CardinalityStrings.getCardinalityLow(card, true);\n                        cardHigh = CardinalityStrings.getCardinalityHigh(card, true);\n                        if (recordCount < cardLow)\n                            // minimal cardinality not yet reached, thus take\n                            // this record type.\n                            lookAtNext = false;\n                        else {\n                            // minimal cardinality already reached before\n                            if (cardHigh > recordCount) {\n                                // maximal cardinality not yet reached\n                                if (linesSpec.getChildNodes().getLength() == 1) {\n                                    // only one record type\n                                    lookAtNext = false;\n                                } else // then\n                                // (linesSpec.getChildNodes().getLength()==1)\n                                {\n                                    // Look for the existance indicator.\n                                    String existanceIndField = nextRecordType.getAttribute(\"ExistIndicatorField\");\n                                    String existanceIndValue = nextRecordType.getAttribute(\"ExistIndicatorValue\");\n                                    // Find the field in the last record.\n                                    NodeList existInds = lastRecord.getElementsByTagName(existanceIndField);\n                                    if (existInds.getLength() != 1) {\n                                        List params = new Vector();\n                                        params.add(XDomSupport.getTrimedNodeText(nextRecordType));\n                                        params.add(existanceIndField);\n                                        params.add(XDomSupport.getTrimedNodeText(recordType));\n                                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"113\", params);\n                                    }\n                                    // if (existInds.getLength() != 1)\n                                    // The existance indicator is set in the\n                                    // last record, the next record type is\n                                    // found.\n                                    if (existanceIndValue.equals(XDomSupport.getTrimedNodeText(existInds.item(0))))\n                                        lookAtNext = false;\n                                }\n                                // else\n                                // (linesSpec.getChildNodes().getLength()==1)\n                            }\n                            // if (cardHigh>recordCount)\n                        }\n                        // else (cardLow<recordCount)\n                    } else // then (isCardinalityInterval(card,true))\n                    {\n                        // Cardinality is just a single value.\n                        cardNum = Integer.parseInt(card);\n                        // Cardinality already reached?\n                        if (cardNum < recordCount)\n                            lookAtNext = false;\n                    }\n                    // else (isCardinalityInterval(card,true))\n                    if (lookAtNext) {\n                        // Still searching\n                        nextRecordType = (Element) nextRecordType.getNextSibling();\n                        recordCount = 0;\n                    }\n                    // if (lookAtNext)\n                }\n                // while (lookAtNext && nextRecordType!=null)\n                if (lookAtNext)\n                    // At the end of record type list next record type not\n                    // found.\n                    if (recOrder.equals(\"Structured\"))\n                        // In case of grouped records, just a new group starts.\n                        nextRecordType = (Element) linesSpec.getFirstChild().getFirstChild();\n                    else // Take the first record type of the first record group\n                    // because there is only one\n                    // (recIdentMethod!=\"TypeIdentifier\").\n                    {\n                        List params = new Vector();\n                        params.add(XDomSupport.getTrimedNodeText(recordType));\n                        params.add(new Integer(line[0] + 1));\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"114\", params);\n                    }\n            }\n            // else (recordType==null)\n        }// try\n         catch (IndexOutOfBoundsException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }// catch (IndexOutOfBoundsException e)\n         catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }// catch (NumberFormatException e)\n         catch (ClassCastException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"0\", e);\n        }\n        // catch (ClassCastException e)\n        return nextRecordType;\n    }\n\n    /**\n     * @param inRecord\n     * @param doc\n     */\n    public int parseSingleRecord(byte[] inRecord, Document doc, Element[] recordType, int recordCount) throws XException {\n        int[] line = { 0 };\n        Element lastRecord = null;\n        if (doc.hasChildNodes())\n            lastRecord = doc.getDocumentElement();\n        Element nextRecordType = determineNextRecordTypeSingleByteArray(inRecord, 0, line, recordType[0], recordCount, lastRecord);\n        if (recordType[0] == null || !XDomSupport.getTrimedNodeText(nextRecordType).equals(XDomSupport.getTrimedNodeText(recordType[0]))) {\n            // First record type or record type change.\n            recordCount = 0;\n            recordType[0] = nextRecordType;\n        }\n        // if (recordType==null ||\n        // !XDomSupport.getTrimedElementValue(nextRecordType).equals(XDomSupport.getTrimedElementValue(recordType)))\n        String nextRecordTypeName = XDomSupport.getTrimedNodeText(nextRecordType);\n        Element nextRecord = doc.createElement(nextRecordTypeName);\n        // the record node\n        // Search for the record type specification.\n        List nextRecordTypeSpecCandidates = XDomSupport.getChildNodesByAttrValue(recordTypesSpec, \"Name\", nextRecordTypeName, \"RecordTypeSpec\");\n        if (nextRecordTypeSpecCandidates.size() != 1) {\n            List params = new Vector();\n            params.add(nextRecordTypeName);\n            params.add(new Integer(line[0] + 1));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_RECORDS, \"102\", params);\n        }\n        // if (nextRecordTypeSpecCandidates.size() != 1)\n        // Parse the record content: the fields\n        parseFieldsAndGroupsSingleByteArray(inRecord, 0, line, doc, nextRecord, (Node) nextRecordTypeSpecCandidates.get(0));\n        if (nextRecord.hasChildNodes()) {\n            // some content found\n            if (doc.hasChildNodes())\n                doc.removeChild(doc.getFirstChild());\n            doc.appendChild(nextRecord);\n            // insert record into tree\n            recordCount++;\n        }\n        // if (nextRecord.hasChildNodes())\n        return recordCount;\n    }\n\n    /**\n     * <code>extractSubString</code> extracts a field value as string from a\n     * specific position in a byte array. The extraction is done in two steps:\n     * <ol>\n     * <li>Extraction of bytes due to position and length</li>\n     * <li>Conversion to string by the preloaded byte array converter</li>\n     * </ol>\n     *\n     * @param array the byte array to extract the field value from\n     * @param pos the field starting position in the array (byte count)\n     * @param length the field length (byte count)\n     * @return the field value converted to a string\n     * @throws XException in case of unpossible <code>pos</code> or\n     *             <code>length</code> values\n     */\n    protected String extractSubString(byte[] array, int pos, int length) throws XException {\n        byte[] subArr = XByteArraySupport.subArray(array, pos, length);\n        return byteArrayConverter.byteArrayToString(subArr);\n    }\n    // extractSubString(byte[] array, int pos, int length)\n}\n// RecordTypeParser\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/records/RecordTypeParserTest1.java",
		"test_prompt": "// RecordTypeParserTest1.java\npackage net.sf.xbus.protocol.records;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverter;\nimport net.sf.xbus.base.bytearraylist.ByteArrayConverterFactory;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.CardinalityStrings;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link RecordTypeParser}.\n* It contains ten unit test cases for the {@link RecordTypeParser#parseSingleRecord(byte[], Document, Element[], int)} method.\n*/\nclass RecordTypeParserTest1 {"
	},
	{
		"original_code": "// TransformerFactory.java\npackage net.sf.xbus.protocol;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\npublic class TransformerFactory {\n\n    /**\n     * The appropriate {@link net.sf.xbus.protocol.Transformer} object which is\n     * needed to transform the request or response of one {@link Message} to the\n     * request or response of another {@link Message} will be created. First it\n     * is checked whether there is a special transformer configured for the two\n     * systems, if not, the standard transformer from <code>xbus.conf</code>\n     * is used.\n     *\n     * @param source the name of the interface definition of the source message\n     * @param destination the name of the interface definition of the\n     *            destination message\n     * @param sourceMessage the message holding the data to be transformed\n     * @param destinationMessage the message receiving the transformed data\n     * @return the appropriate <code>Transformer</code> object\n     * @throws XException if something goes wrong\n     */\n    public static Transformer createTransformer(XBUSSystem source, XBUSSystem destination, Message sourceMessage, Message destinationMessage) throws XException {\n        /*\n\t\t * First search if there is a special transformer for the two systems.\n\t\t */\n        Configuration config = Configuration.getInstance();\n        String transformerClassShortname = config.getValueOptional(\"Transformer\", source.getName(), destination.getName());\n        if (transformerClassShortname == null) {\n            transformerClassShortname = config.getValueOptional(\"Transformer\", getSection(source, sourceMessage), destination.getName());\n        }\n        /*\n\t\t * If not, take the standard transformer from xbus.conf\n\t\t */\n        config = Configuration.getInstance(\"xbus\");\n        if (transformerClassShortname == null) {\n            transformerClassShortname = config.getValue(\"Transformer\", sourceMessage.getShortname(), destinationMessage.getShortname());\n        }\n        String transformerClass = Configuration.getClass(\"Transformer\", transformerClassShortname);\n        Object transformerObject = ReflectionSupport.createObject(transformerClass);\n        return (Transformer) transformerObject;\n    }\n\n    private static String getSection(XBUSSystem system, Message message) {\n        return new StringBuffer().append(system.getName()).append(\".\").append(message.getFunction()).toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/TransformerFactoryTest.java",
		"test_prompt": "// TransformerFactoryTest.java\npackage net.sf.xbus.protocol;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TransformerFactory}.\n* It contains ten unit test cases for the {@link TransformerFactory#createTransformer(XBUSSystem, XBUSSystem, Message, Message)} method.\n*/\nclass TransformerFactoryTest {"
	},
	{
		"original_code": "// JavaTransformer.java\npackage net.sf.xbus.protocol.java;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\n\n/**\n * The <code>JavaTransformer</code> calls a method of a Java class, to\n * transform the source into the destination format. Which class and which\n * method to be used is read out of the configuration.\n * <p />\n * The signature of the called method must be:\n * <p />\n *\n * <pre>\n *     public Object &lt;i&gt;methodName&lt;/i&gt;(Object inObject) throws XException\n * </pre>\n */\npublic class JavaTransformer implements Transformer {\n\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        String classname = getClassName(source, destination, destinationMessage);\n        String methodname = getMethodName(source, destination, destinationMessage);\n        Object transformerObject = ReflectionSupport.createObject(classname);\n        Class[] parameterTypes = new Class[] { Object.class };\n        Object[] arguments = new Object[] { inObject };\n        Object retObject = ReflectionSupport.callMethod(methodname, transformerObject, parameterTypes, arguments);\n        return retObject;\n    }\n\n    private String getClassName(XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        Configuration config = Configuration.getInstance();\n        String retString = config.getValueOptional(\"Transformer\", getSection(source, destination, destinationMessage), \"Class\");\n        if (retString == null) {\n            retString = config.getValue(\"Transformer\", getSectionWithFunction(source, destination, destinationMessage), \"Class\");\n        }\n        return retString;\n    }\n\n    private String getMethodName(XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        Configuration config = Configuration.getInstance();\n        String retString = config.getValueOptional(\"Transformer\", getSection(source, destination, destinationMessage), \"Method\");\n        if (retString == null) {\n            retString = config.getValue(\"Transformer\", getSectionWithFunction(source, destination, destinationMessage), \"Method\");\n        }\n        return retString;\n    }\n\n    private String getSectionWithFunction(XBUSSystem source, XBUSSystem destination, Message destinationMessage) {\n        return new StringBuffer().append(source.getName()).append(\".\").append(destinationMessage.getFunction()).append(\".\").append(destination.getName()).toString();\n    }\n\n    private String getSection(XBUSSystem source, XBUSSystem destination, Message destinationMessage) {\n        return new StringBuffer().append(source.getName()).append(\".\").append(destination.getName()).toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/java/JavaTransformerTest.java",
		"test_prompt": "// JavaTransformerTest.java\npackage net.sf.xbus.protocol.java;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaTransformer}.\n* It contains ten unit test cases for the {@link JavaTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass JavaTransformerTest {"
	},
	{
		"original_code": "// SOAPMessage.java\npackage net.sf.xbus.protocol.soap;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport net.sf.xbus.protocol.xml.XMLMessageAbstract;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>SOAPMessage</code> represents messages for the Simple Object Access\n * Protocol.\n */\npublic class SOAPMessage extends XMLMessageAbstract implements TextMessage, ObjectMessage {\n\n    public static final String SOAP_DETAIL = \"detail\";\n\n    private static final String SOAP_FAULTSTRING = \"faultstring\";\n\n    public static final String SOAP_FAULTCODE = \"faultcode\";\n\n    public static final String SOAP_FAULT = \"Fault\";\n\n    public static final String SOAP_BODY = \"Body\";\n\n    public static final String SOAP_NAMESPACE = \"http://schemas.xmlsoap.org/soap/envelope/\";\n\n    public static final String SOAPENV_QUALIFIER = \"soapenv\";\n\n    private boolean hasFault = false;\n\n    /**\n     * This constructor stores the <code>source</code>, creates an unique\n     * identifier for the message and initializes the requestTimestamp. It is\n     * used when constructing a new <code>SOAPMessage</code> from the data of\n     * a receiver.\n     */\n    public SOAPMessage(XBUSSystem source) {\n        super(source);\n        setShortname(\"SOAPMessage\");\n    }\n\n    /**\n     * This constructor initializes the new <code>SOAPMessage</code> with the\n     * given parameters. It is used when constructing a new\n     * <code>SOAPMessage</code> by converting it from another\n     * <code>Message</code>.\n     */\n    public SOAPMessage(String function, XBUSSystem source, String id) {\n        super(function, source, id);\n        setShortname(\"SOAPMessage\");\n    }\n\n    /**\n     * Sets the errortext with the given String. Additionally, a\n     * <code>Fault</code> element is added to the SOAP message, if there is\n     * not already one.\n     */\n    public void setErrortext(String text) {\n        super.setErrortext(text);\n        if ((text != null) && (!hasFault)) {\n            try {\n                Document response = getTemplateAsDocument();\n                setResponseDocument(response, null);\n                Node oldBody = getBody(response);\n                Element newBody = response.createElementNS(SOAP_NAMESPACE, SOAPENV_QUALIFIER + \":\" + SOAP_BODY);\n                Element fault = response.createElementNS(SOAP_NAMESPACE, SOAPENV_QUALIFIER + \":\" + SOAP_FAULT);\n                newBody.appendChild(fault);\n                Element faultcode = response.createElement(SOAP_FAULTCODE);\n                faultcode.appendChild(response.createTextNode(\"Server.Exception\"));\n                fault.appendChild(faultcode);\n                Element faultstring = response.createElement(SOAP_FAULTSTRING);\n                faultstring.appendChild(response.createTextNode(text));\n                fault.appendChild(faultstring);\n                String stackTrace = XException.getExceptionInformation();\n                if (stackTrace != null) {\n                    Element detail = response.createElement(SOAP_DETAIL);\n                    detail.appendChild(response.createTextNode(XException.getExceptionInformation()));\n                    fault.appendChild(detail);\n                }\n                Node father = oldBody.getParentNode();\n                father.replaceChild(newBody, oldBody);\n            } catch (XException e) {\n            }\n        }\n    }\n\n    /**\n     * After setting the request data, both <code>setRequestText</code> and\n     * <code>setRequestDocument</code>, the <code>function</code> of the\n     * <code>Message</code> must be set. The name of the first element of the\n     * SOAP body is used as the function.\n     */\n    protected void synchronizeRequestFields(XBUSSystem system) throws XException {\n        NodeList bodyNodes = getBodyNodes(getRequestDocument(system));\n        Node function = null;\n        /*\n\t\t * The function of the SOAP message is the first element child of the\n\t\t * body.\n\t\t */\n        for (int i = 0; i < bodyNodes.getLength(); i++) {\n            function = bodyNodes.item(i);\n            if (function.getNodeType() == Node.ELEMENT_NODE) {\n                break;\n            }\n        }\n        if (function == null) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_SOAP, \"1\");\n        }\n        setFunction(function.getLocalName());\n    }\n\n    /**\n     * After setting the response data, both <code>setResponseText</code> and\n     * <code>setResponseDocument</code>, some fields of the\n     * <code>Message</code> must be synchronized with the response data. When\n     * an error has occured within the called system, a <code>Fault</code>\n     * element must be included in the response. In this case, the\n     * <code>returncode</code> will be set to <code>RC_NOK</code> and the\n     * <code>errortext</code> will be the concatination of\n     * <code>faultcode</code> and <code>faultstring</code>.\n     */\n    protected void synchronizeResponseFields(XBUSSystem system) throws XException {\n        if (getResponseDocument() != null) {\n            NodeList bodyNodes = getBodyNodes(getResponseDocument());\n            Node child = null;\n            for (int i = 0; i < bodyNodes.getLength(); i++) {\n                child = bodyNodes.item(i);\n                if ((child.getNodeType() == Node.ELEMENT_NODE) && (SOAP_NAMESPACE.equals(child.getNamespaceURI())) && (SOAP_FAULT.equals(child.getLocalName()))) {\n                    Node grandChild = null;\n                    hasFault = true;\n                    setReturncode(Constants.RC_NOK);\n                    NodeList grandChildren = child.getChildNodes();\n                    String faultcode = \"\";\n                    String faultstring = \"\";\n                    for (int j = 0; j < grandChildren.getLength(); j++) {\n                        grandChild = grandChildren.item(j);\n                        if ((grandChild.getNodeType() == Node.ELEMENT_NODE) && (SOAP_FAULTCODE.equals(grandChild.getNodeName()))) {\n                            faultcode = XMLHelper.getNodeText(grandChild);\n                        }\n                        if ((grandChild.getNodeType() == Node.ELEMENT_NODE) && (SOAP_FAULTSTRING.equals(grandChild.getNodeName()))) {\n                            faultstring = XMLHelper.getNodeText(grandChild);\n                        }\n                    }\n                    setErrortext(faultcode + \"_\" + faultstring);\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a list of all nodes included in the SOAP body of the given\n     * <code>Document</code>.\n     */\n    private NodeList getBodyNodes(Document doc) throws XException {\n        return getBody(doc).getChildNodes();\n    }\n\n    /**\n     * Returns the SOAP body of the given <code>Document</code>.\n     */\n    private Node getBody(Document doc) throws XException {\n        NodeList bodyList = doc.getElementsByTagNameNS(SOAP_NAMESPACE, SOAP_BODY);\n        if (bodyList.getLength() == 0) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_SOAP, \"2\");\n        }\n        if (bodyList.getLength() > 1) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_SOAP, \"3\");\n        }\n        return bodyList.item(0);\n    }\n\n    /**\n     * Returns a W3C document containing an empty SOAPMessage\n     */\n    public Document getTemplateAsDocument() throws XException {\n        return parseXML(getTemplateAsString(), null);\n    }\n\n    /**\n     * Returns a XML string containing an empty SOAPMessage\n     */\n    static public String getTemplateAsString() throws XException {\n        StringBuffer retString = new StringBuffer();\n        retString.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n        retString.append(Constants.getXMLEncoding());\n        retString.append(\"\\\"?>\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(SOAPENV_QUALIFIER).append(\":Envelope \").append(\"xmlns:\").append(SOAPENV_QUALIFIER).append(\"=\\\"\").append(SOAP_NAMESPACE).append(\"\\\"\").append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(SOAPENV_QUALIFIER).append(\":Body\").append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(\"/\").append(SOAPENV_QUALIFIER).append(\":Body\").append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(\"/\").append(SOAPENV_QUALIFIER).append(\":Envelope\").append(\">\");\n        return retString.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/soap/SOAPMessageTest.java",
		"test_prompt": "// SOAPMessageTest.java\npackage net.sf.xbus.protocol.soap;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport net.sf.xbus.protocol.xml.XMLMessageAbstract;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SOAPMessage}.\n* It contains ten unit test cases for the {@link SOAPMessage#getTemplateAsString()} method.\n*/\nclass SOAPMessageTest {"
	},
	{
		"original_code": "// Stream2TextTransformer.java\npackage net.sf.xbus.protocol.simple;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\n\n/**\n * The <code>Stream2TextTransformer</code> read the content of an\n * <code>InputStream<code> into string.\n */\npublic class Stream2TextTransformer implements Transformer {\n\n    /**\n     * The <code>Stream2TextTransformer</code> read the content of an\n     * <code>InputStream<code> into string.\n     *\n     * @param inObject either the request or response of the source message\n     * @param source not used - from the Transformer interface\n     * @param destination not used - from the Transformer interface\n     * @param destinationMessage not used - from the Transformer interface\n     * @return <code>ByteArrayList</code>\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        // First get stream content as byte array\n        byte[] ba = XByteArraySupport.transformToByteArray(inObject);\n        String text = null;\n        // Individual encoding?\n        String configEncoding = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, source.getName(), Constants.KEY_ENCODING);\n        if (configEncoding == null)\n            text = new String(ba);\n        else {\n            try {\n                text = new String(ba, configEncoding);\n            }// try\n             catch (UnsupportedEncodingException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_SIMPLE, \"0\", e);\n            }\n            // catch\n        }\n        // (configEncoding == null)\n        return text;\n    }\n    // transform(Object inObject,XBUSSystem source,XBUSSystem\n    // destination,Message destinationMessage)\n}\n// Stream2ByteArrayListTransformer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/simple/Stream2TextTransformerTest.java",
		"test_prompt": "// Stream2TextTransformerTest.java\npackage net.sf.xbus.protocol.simple;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Stream2TextTransformer}.\n* It contains ten unit test cases for the {@link Stream2TextTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass Stream2TextTransformerTest {"
	},
	{
		"original_code": "// Text2StreamTransformer.java\npackage net.sf.xbus.protocol.simple;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\n\n/**\n * The <code>Text2StreamTransformer</code> returns a\n * <code>ByteArrayInputStream</code> to read a string content. The class\n * <code>StringBufferInputStream</code> is deprecated: \"This class does not\n * properly convert characters into bytes. As of JDK 1.1, the preferred way to\n * create a stream from a string is via the StringReader class.\"\n */\npublic class Text2StreamTransformer implements Transformer {\n\n    /**\n     * The <code>Text2StreamTransformer</code> returns a\n     * <code>ByteArrayInputStream</code> to read a string content.\n     *\n     * @param inObject either the request or response of the source message\n     * @param source not used\n     * @param destination not used\n     * @param destinationMessage not used\n     * @return <code>ByteArrayInputStream</code>\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        String text = (String) inObject;\n        String configEncoding = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, source.getName(), Constants.KEY_ENCODING);\n        byte[] ba = null;\n        if (configEncoding == null)\n            ba = text.getBytes();\n        else {\n            try {\n                ba = text.getBytes(configEncoding);\n            }// try\n             catch (UnsupportedEncodingException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_SIMPLE, \"0\", e);\n            }\n            // catch\n        }\n        // (configEncoding == null)\n        return new ByteArrayInputStream(ba);\n    }\n    // transform(Object inObject,XBUSSystem source,XBUSSystem\n    // destination,Message destinationMessage)\n}\n// Text2StreamTransformer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/simple/Text2StreamTransformerTest.java",
		"test_prompt": "// Text2StreamTransformerTest.java\npackage net.sf.xbus.protocol.simple;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Text2StreamTransformer}.\n* It contains ten unit test cases for the {@link Text2StreamTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass Text2StreamTransformerTest {"
	},
	{
		"original_code": "// FixedTextTransformer.java\n/*\n * Created on 20.10.2004\n * \n */\npackage net.sf.xbus.protocol.simple;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\n\n/**\n * The <code>FixedTextTransformer</code> serves for sending fix text. The text\n * is written from the configuration.\n *\n * @author Stephan D�wel\n */\npublic class FixedTextTransformer implements Transformer {\n\n    /**\n     * The <code>transform</code> creates a string from the configuration. It\n     * takes any input, ignores it and reads the output string from the\n     * configuration.\n     *\n     * @see net.sf.xbus.protocol.Transformer#transform(java.lang.Object,\n     *      net.sf.xbus.base.xbussystem.XBUSSystem,\n     *      net.sf.xbus.base.xbussystem.XBUSSystem,\n     *      net.sf.xbus.protocol.Message)\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        Configuration config = Configuration.getInstance();\n        // For the linebreak\n        String platform = config.getValueOptional(Constants.CHAPTER_SYSTEM, destination.getName(), \"Platform\");\n        // Standard linebreak from the operating system\n        String lineBreak = Constants.LINE_SEPERATOR;\n        // Using another platform's linebreak in the output?\n        if (platform != null)\n            lineBreak = Constants.getLineSeperator(platform);\n        // For the result.\n        StringBuffer buffer = new StringBuffer();\n        // Read the string line by line form the configuration.\n        String line = config.getValueOptional(Constants.CHAPTER_SYSTEM, destination.getName(), \"TextLine1\");\n        int i = 1;\n        while (line != null) {\n            i++;\n            line = destination.replaceAllMarkers(line)[0];\n            buffer.append(line);\n            buffer.append(lineBreak);\n            line = config.getValueOptional(Constants.CHAPTER_SYSTEM, destination.getName(), \"TextLine\" + i);\n        }\n        // while (line != null)\n        return buffer.toString();\n    }\n    // transform(Object inObject, XBUSSystem source, XBUSSystem destination,\n    // Message destinationMessage)\n}\n// FixedTextTransformer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/simple/FixedTextTransformerTest.java",
		"test_prompt": "// FixedTextTransformerTest.java\npackage net.sf.xbus.protocol.simple;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FixedTextTransformer}.\n* It contains ten unit test cases for the {@link FixedTextTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass FixedTextTransformerTest {"
	},
	{
		"original_code": "// TextXSLTTransformer.java\npackage net.sf.xbus.protocol.simple;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Hashtable;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\n\n/**\n * TODO: Kommentierung\n */\npublic class TextXSLTTransformer implements net.sf.xbus.protocol.Transformer {\n\n    protected static final String XSL_LOCATION = new StringBuffer(Constants.XBUS_ETC).append(\"xsl\").append(Constants.FILE_SEPERATOR).toString();\n\n    private static Hashtable mTransformers = new Hashtable();\n\n    /**\n     * The <code>transform</code> method is automatically called by the xBus\n     * during the routing of messages.\n     *\n     * @param inObject either the request or response that shall be transformed\n     *            to another format\n     * @param source the <code>XBUSSystem</code> of the message of the\n     *            <code>inObject</code>\n     * @param destination the <code>XBUSSystem</code> of the target message\n     * @param destinationMessage the target message eventually contains more\n     *            information necessary for transforming\n     * @return the transformed <code>Object</code>, written to either the\n     *         request or response of the target message\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        Configuration config = Configuration.getInstance();\n        String xslFile = config.getValue(\"XSLTStylesheet\", source.getName(), destination.getName());\n        xslFile = new StringBuffer(XSL_LOCATION).append(xslFile).toString();\n        return transformXML((String) inObject, xslFile, destinationMessage);\n    }\n\n    /**\n     * Transforms the given XML-data with the given XSL-stylesheet. After the\n     * XSL-transformation the so-called XBUS_Stylets are processed.\n     * <p>\n     *\n     * @param xmlOld the source XML-data\n     * @param xslFile the name of the XSL-stylesheet\n     * @param message the destination message\n     * @throws XException if something goes wrong\n     */\n    protected String transformXML(String xmlOld, String xslFile, Message message) throws XException {\n        String xmlNew = null;\n        StringReader source = new StringReader(xmlOld);\n        StreamSource streamSource = new StreamSource(source);\n        StringWriter result = new StringWriter();\n        StreamResult streamResult = new StreamResult(result);\n        try {\n            Transformer transformer = getXSLTransformer(xslFile);\n            transformer.transform(streamSource, streamResult);\n            xmlNew = result.toString();\n            source.close();\n            result.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_XML, \"0\", e);\n        } catch (TransformerConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_XML, \"0\", e);\n        } catch (TransformerException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_XML, \"0\", e);\n        }\n        return xmlNew;\n    }\n\n    /**\n     * Returns a <code>Transformer</code> object needed for the XSLT\n     * processing. The <code>Transformers</code> are cached for every thread\n     * and every XSLT stylesheet.\n     */\n    protected Transformer getXSLTransformer(String xslFile) throws XException {\n        Transformer transformer = null;\n        try {\n            transformer = (Transformer) mTransformers.get(Thread.currentThread().getName() + xslFile);\n            if (transformer == null) {\n                XMLHelper.setTransformerProperties();\n                TransformerFactory tFactory = TransformerFactory.newInstance();\n                transformer = tFactory.newTransformer(new StreamSource(xslFile));\n                mTransformers.put(Thread.currentThread().getName() + xslFile, transformer);\n            }\n        } catch (TransformerConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_XML, \"0\", e);\n        }\n        return transformer;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/simple/TextXSLTTransformerTest.java",
		"test_prompt": "// TextXSLTTransformerTest.java\npackage net.sf.xbus.protocol.simple;\n\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.util.Hashtable;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TextXSLTTransformer}.\n* It contains ten unit test cases for the {@link TextXSLTTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass TextXSLTTransformerTest {"
	},
	{
		"original_code": "// XMLSerializerTransformer.java\npackage net.sf.xbus.protocol.xml;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.w3c.dom.Document;\n\n/**\n * The <code>XMLSerializerTransformer</code> serializes the given\n * <code>org.w3c.Document</code> into a <code>String</code>.\n */\npublic class XMLSerializerTransformer implements Transformer {\n\n    /**\n     * The <code>transform</code> method serializes the given\n     * <code>org.w3c.Document</code> into a <code>String</code>.\n     *\n     * @param inObject either the request or response that shall be wrapped into\n     *            a string. This <code>Object</code> must be of type\n     *            <code>org.w3c.Document</code>.\n     * @param source not used\n     * @param destination not used\n     * @param destinationMessage not used\n     * @return a <code>String</code> containing the serialized\n     *         <code>inObject</code>\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        return XMLHelper.serializeXML((Document) inObject, null);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/xml/XMLSerializerTransformerTest.java",
		"test_prompt": "// XMLSerializerTransformerTest.java\npackage net.sf.xbus.protocol.xml;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLSerializerTransformer}.\n* It contains ten unit test cases for the {@link XMLSerializerTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass XMLSerializerTransformerTest {"
	},
	{
		"original_code": "// XSLTTransformer.java\npackage net.sf.xbus.protocol.xml;\n\nimport java.util.Hashtable;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport org.w3c.dom.Document;\n\n/**\n * This is the base class for all transformation between\n * <code>XMLMessages</code> with XSLT stylesheets.\n * <p>\n *\n * The transformation is done in two steps:\n * <ol>\n * <li>An XSLT stylesheet which name is read from the configuration does the\n * first part of the transformation.\n * <li>The so-called XBUS_Stylets are processed to fill in extra data into the\n * XML data.\n * </ol>\n * <p>\n *\n * <b>XBUS_Stylets:</b>\n * <p>\n * XSLT stylesheets lack the possibilty to fill in data to the transformed XML\n * data which cannot be extracted out of the source XML. To fill this gap some\n * defined tags can be included in the transformed XML when the XSLT\n * transformation is done. These tags are replaced in the second step with\n * defined data. The format for XBUS_Stylets is:\n *\n * <pre>\n *      &lt;XBUS_Stylet Name=&quot;xxx&quot; Tag=&quot;yyy&quot; Key=&quot;zzz&quot;&gt;\n * </pre>\n *\n * The XSLT code to achieve this looks like:\n *\n * <pre>\n *      &lt;xsl:element name=&quot;XBUS_Stylet&quot;&gt;\n *          &lt;xsl:attribute name=&quot;Name&quot;&gt;xxx&lt;/xsl:attribute&gt;\n *          &lt;xsl:attribute name=&quot;Tag&quot;&gt;yyy&lt;/xsl:attribute&gt;\n *          &lt;xsl:attribute name=&quot;Key&quot;&gt;zzz&lt;/xsl:attribute&gt;\n *      &lt;/xsl:element&gt;\n * </pre>\n *\n * The meaning of the attributes is:\n * <ul>\n * <li><b>Name:</b> The name defines what data is inserted. There is a defined\n * set of names which will be explained in the following list.</li>\n * <li><b>Tag:</b> The name of the tag under which the data is inserted.<br>\n * May be omitted if <code>Name=\"Value\"</code> or\n * <code>Name=\"FormatDate\"</code>. In this case only a text node for the\n * value is inserted.</li>\n * <li><b>Section:</b> Optional, only used with the name <code>Value</code>.\n * Specifies the name of the mapping to get a value from.</li>\n * <li><b>Key:</b> Optional, only used with the names <code>Value</code>,\n * <code>CDATA</code> and <code>FormatDate</code>. Values come from two\n * different sources depending on the section attribute.<br>\n * If no section is specified: A key/value pair can be stored before the\n * transformation (see method\n * {@link #putStyletValue(Object, Object) putStyletValue}). The value for the\n * given key is inserted.<br>\n * For a given section: The value is read by the\n * {@link net.sf.xbus.base.core.config.Configuration#getMapping(String, String) getMapping}\n * operation of the Configuration.</li>\n * <li><b>SourceFormat:</b> Optional, only used with the name\n * <code>FormatDate</code>. Describes the actual format of the date given in\n * <code>Key</code>.</li>\n * <li><b>DestinationFormat:</b> Optional, only used with the name\n * <code>FormatDate</code>. Describes the format to apply to the date given\n * in <code>Key</code>.</li>\n * </ul>\n *\n * The values for the attribute <code>Name</code> are defined as follows:\n * <ul>\n * <li><b>Id:</b> The identifier of the new <code>Message</code> is\n * inserted.</li>\n * <li><b>Source:</b> The logical name of the source of the\n * <code>Message</code> is inserted.</li>\n * <li><b>RequestTimestamp:</b> The request timestamp is inserted.</li>\n * <li><b>Value:</b> The value for the given <code>key</code> (see above) is\n * inserted.</li>\n * <li><b>CDATA:</b> The value for the given <code>key</code> (see above) is\n * inserted as a CDATA section.</li>\n * <li><b>FormatDate:</b> The format for the given date in <code>key</code>\n * (see above) is changed. <code>SourceFormat</code> describes the original\n * and <code>DestinationFormat</code> the new format.</li>\n * </ul>\n *\n * If a transformation between <code>XMLMessages</code> can be done directly\n * via a XSLT stylesheet and XBUS_Stylet processing, this class can be used.\n * When extra code is needed for the transformation, it has to be subclassed.\n */\npublic class XSLTTransformer implements net.sf.xbus.protocol.Transformer {\n\n    protected static final String XSL_LOCATION = new StringBuffer(Constants.XBUS_ETC).append(\"xsl\").append(Constants.FILE_SEPERATOR).toString();\n\n    private Hashtable mStyletValues = new Hashtable();\n\n    private static Hashtable mTransformers = new Hashtable();\n\n    /**\n     * The <code>transform</code> method is automatically called by the xBus\n     * during the routing of messages.\n     *\n     * @param inObject either the request or response that shall be transformed\n     *            to another format\n     * @param source the <code>XBUSSystem</code> of the message of the\n     *            <code>inObject</code>\n     * @param destination the <code>XBUSSystem</code> of the target message\n     * @param destinationMessage the target message eventually contains more\n     *            information necessary for transforming\n     * @return the transformed <code>Object</code>, written to either the\n     *         request or response of the target message\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        Configuration config = Configuration.getInstance();\n        // After restructuring the xBus transformation calls, the old\n        // configuration\n        // key \"XslRequestFromRequest\" was no longer meaningful because the\n        // source\n        // and destination systems determine, which style sheet should be used.\n        // The differentiation between transformation from reponse or from\n        // request is\n        // done in net.sf.xbus.application.Router.distributeInternal when\n        // looking\n        // at the incoming response.\n        // The new configuration key is \"XSLTStylesheet\";\n        // The old configuration key \"XslRequestFromRequest\" still works for\n        // upgrade compatibility.\n        String xslFile = config.getValueOptional(\"XslRequestFromRequest\", source.getName(), destination.getName());\n        if (xslFile == null) {\n            xslFile = config.getValue(\"XSLTStylesheet\", source.getName(), destination.getName());\n        }\n        xslFile = new StringBuffer(XSL_LOCATION).append(xslFile).toString();\n        return transformXML((Document) inObject, xslFile, destinationMessage);\n    }\n\n    /**\n     * Stores a key/value pair which is used later in the processing of the\n     * XBUS_Stylets.\n     */\n    public void putStyletValue(Object key, Object value) {\n        mStyletValues.put(key, value);\n    }\n\n    /**\n     * Transforms the given XML-data with the given XSL-stylesheet. After the\n     * XSL-transformation the so-called XBUS_Stylets are processed.\n     * <p>\n     *\n     * @param xmlOld the source XML-data\n     * @param xslFile the name of the XSL-stylesheet\n     * @param message the destination message\n     * @throws XException if something goes wrong\n     */\n    protected Document transformXML(Document xmlOld, String xslFile, Message message) throws XException {\n        Document xmlNew = null;\n        DOMResult domResult = new DOMResult();\n        try {\n            Transformer transformer = getXSLTransformer(xslFile);\n            transformer.transform(new DOMSource(xmlOld), domResult);\n            xmlNew = (Document) domResult.getNode();\n            applyStylets(xmlNew, message);\n        } catch (TransformerConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_XML, \"0\", e);\n        } catch (TransformerException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_XML, \"0\", e);\n        }\n        return xmlNew;\n    }\n\n    /**\n     * Returns a <code>Transformer</code> object needed for the XSLT\n     * processing. The <code>Transformers</code> are cached for every thread\n     * and every XSLT stylesheet.\n     */\n    protected Transformer getXSLTransformer(String xslFile) throws XException {\n        Transformer transformer = null;\n        try {\n            transformer = (Transformer) mTransformers.get(Thread.currentThread().getName() + xslFile);\n            if (transformer == null) {\n                XMLHelper.setTransformerProperties();\n                TransformerFactory tFactory = TransformerFactory.newInstance();\n                transformer = tFactory.newTransformer(new StreamSource(xslFile));\n                mTransformers.put(Thread.currentThread().getName() + xslFile, transformer);\n            }\n        } catch (TransformerConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_XML, \"0\", e);\n        }\n        return transformer;\n    }\n\n    /**\n     * Processes the so-called XBUS-Stylets. See also the JavaDoc for the class.\n     */\n    private void applyStylets(Document xmlNew, Message message) throws XException {\n        IteratedStyletApplication itop = new IteratedStyletApplication(xmlNew, message, mStyletValues);\n        try {\n            XDomSupport.traversePostOrder(xmlNew, itop);\n        } catch (XException e) {\n            throw e;\n        }// catch (XException e)\n         catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_XML, \"0\", e);\n        }\n    }\n\n    // applyStylets(XMLMessage newMessage, Document xmlNew)\n    /**\n     * Creates an object which is suitable for sending data to the given\n     * <code>system</code>. The name of the class is read in the <@link\n     * net.sf.xbus.base.core.Configuration>. The returned class must be a\n     * subclass of <code>XMLMessage</code>.\n     */\n    protected XMLMessageAbstract createMessage(XBUSSystem destination, XMLMessageAbstract source) throws XException {\n        Configuration config = Configuration.getInstance();\n        String newMessageClassShortname = config.getValue(Constants.CHAPTER_SYSTEM, destination.getName(), \"Message\");\n        String newMessageClass = Configuration.getClass(\"Message\", newMessageClassShortname);\n        Class[] conArgsClass = new Class[] { ReflectionSupport.classForName(\"java.lang.String\"), ReflectionSupport.classForName(\"net.sf.xbus.base.xbussystem.XBUSSystem\"), ReflectionSupport.classForName(\"java.lang.String\") };\n        Object[] conArgs = new Object[] { source.getFunction(), source.getSource(), source.getId() };\n        return (XMLMessageAbstract) ReflectionSupport.createObject(newMessageClass, conArgsClass, conArgs);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/xml/XSLTTransformerTest.java",
		"test_prompt": "// XSLTTransformerTest.java\npackage net.sf.xbus.protocol.xml;\n\nimport java.util.Hashtable;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XSLTTransformer}.\n* It contains ten unit test cases for the {@link XSLTTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass XSLTTransformerTest {"
	},
	{
		"original_code": "// XMLParserTransformer.java\npackage net.sf.xbus.protocol.xml;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\n\n/**\n * The <code>XMLParserTransformer</code> parses the given <code>String</code>\n * into an <code>org.w3c.Document</code>.\n */\npublic class XMLParserTransformer implements Transformer {\n\n    /**\n     * The <code>transform</code> method parses the given <code>String</code>\n     * into an <code>org.w3c.Document</code>.\n     *\n     * @param inObject either the request or response that shall be parsed into\n     *            an <code>org.w3c.Document</code>. This <code>Object</code>\n     *            must be of type <code>String</code>.\n     * @param source not used\n     * @param destination where the message shall be sent to\n     * @param destinationMessage the message to send\n     * @return an <code>org.w3c.Document</code> containing the parsed\n     *         <code>inObject</code>\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        return XMLHelper.parseXML((String) inObject, destinationMessage.getShortname(), destination.getName());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/xml/XMLParserTransformerTest.java",
		"test_prompt": "// XMLParserTransformerTest.java\npackage net.sf.xbus.protocol.xml;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLParserTransformer}.\n* It contains ten unit test cases for the {@link XMLParserTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass XMLParserTransformerTest {"
	},
	{
		"original_code": "// XBUSXMLMessage.java\npackage net.sf.xbus.protocol.xml;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport net.sf.xbus.protocol.XMLMessage;\nimport org.w3c.dom.Document;\n\n/**\n * <code>XBUSXMLMessage</code> represents messages in the xBus specific\n * XML-format.\n */\npublic class XBUSXMLMessage extends XMLMessageAbstract implements TextMessage, ObjectMessage, XMLMessage {\n\n    /**\n     * This constructor stores the <code>source</code>, creates an unique\n     * identifier for the call and initializes the requestTimestamp. It is used\n     * when constructing a new <code>XBUSXMLMessage</code> from the data of a\n     * receiver.\n     */\n    public XBUSXMLMessage(XBUSSystem source) {\n        super(source);\n        setShortname(\"XBUSXMLMessage\");\n    }\n\n    /**\n     * This constructor initializes the new <code>XBUSXMLMessage</code> with\n     * the given parameters. It is used when constructing a new\n     * <code>XBUSXMLMessage</code> by converting it from another\n     * <code>Message</code>.\n     */\n    public XBUSXMLMessage(String function, XBUSSystem source, String id) {\n        super(function, source, id);\n        setShortname(\"XBUSXMLMessage\");\n    }\n\n    /**\n     * Returns a XML string containing an empty XBUSXMLMessage\n     */\n    static public String getTemplateAsString() throws XException {\n        StringBuffer retString = new StringBuffer();\n        retString.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n        retString.append(Constants.getXMLEncoding());\n        retString.append(\"\\\"?>\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"    <\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_ID).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_FUNCTION).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_SOURCE).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_ADDRESS).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_TIMESTAMP).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"    </\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"    <\").append(Constants.XBUSXMLMESSAGE_DATA).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"</\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        return retString.toString();\n    }\n\n    /**\n     * Returns a W3C document containing an empty XBUSXMLMessage\n     */\n    static public Document getTemplateAsDocument() throws XException {\n        return XMLHelper.parseXML(getTemplateAsString(), \"XBUSXMLMessage\", null);\n    }\n\n    /**\n     * After setting the request data, both <code>setRequestText</code> and\n     * <code>setRequestDocument</code>, some fields of the\n     * <code>Message</code> must be synchronized with the request data.\n     * <p>\n     * <ul>\n     * <li><b>Id: </b>When the Id is found in the request data, it must be\n     * copied to the <code>Message</code>. When it is not found, the value\n     * from the <code>Message</code> must be copied to the request data.\n     * <li><b>Function: </b>The value for the function must be read from the\n     * request data and must be set in the <code>Message</code>.\n     * <li><b>Source: </b>Must be copied from the <code>Message</code> object\n     * to the request data, to be sure that it is set correct.\n     * <li><b>Request Timestamp: </b>Must be copied from the\n     * <code>Message</code> object to the request data.\n     * </ul>\n     */\n    protected void synchronizeRequestFields(XBUSSystem system) throws XException {\n        String id = XMLHelper.getTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_ID);\n        if ((id != null) && (id.length() > 0)) {\n            setId(id);\n        } else {\n            XMLHelper.setTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_ID, getId());\n        }\n        String newFunction = XMLHelper.getTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_FUNCTION);\n        if ((newFunction != null) && (newFunction.length() != 0)) {\n            setFunction(newFunction);\n        } else {\n            XMLHelper.setTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_FUNCTION, getFunction());\n        }\n        XMLHelper.setTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_SOURCE, getSource().getName());\n        /*\n\t\t * When an address information is contained in the request document,\n\t\t * this address is set in the source of the message. Otherwise the\n\t\t * address of the message will be set in request document.\n\t\t */\n        Hashtable addresses = XMLHelper.getTagTextList(getRequestDocument(system), Constants.XBUSXMLMESSAGE_ADDRESS);\n        if ((addresses != null) && (!addresses.isEmpty())) {\n            String key = null;\n            String value = null;\n            for (Enumeration e = addresses.keys(); e.hasMoreElements(); ) {\n                key = (String) e.nextElement();\n                value = (String) addresses.get(key);\n                if (XBUSSystem.FILENAME_WILDCARD_XML.equals(key)) {\n                    /*\n\t\t\t\t\t * Switching the XML representation of the WILDCARD to the\n\t\t\t\t\t * \"normal\" one.\n\t\t\t\t\t */\n                    key = XBUSSystem.FILENAME_WILDCARD;\n                }\n                getSource().setAddress(key, value);\n            }\n        } else {\n            if (getSource().getAddresses() != null) {\n                /*\n\t\t\t\t * Switching the \"normal\" representation of the WILDCARD to the\n\t\t\t\t * XML representation.\n\t\t\t\t */\n                Hashtable copyAdresses = (Hashtable) getSource().getAddresses().clone();\n                String key = null;\n                String value = null;\n                for (Enumeration e = copyAdresses.keys(); e.hasMoreElements(); ) {\n                    key = (String) e.nextElement();\n                    value = (String) copyAdresses.get(key);\n                    if (XBUSSystem.FILENAME_WILDCARD.equals(key)) {\n                        copyAdresses.remove(key);\n                        copyAdresses.put(XBUSSystem.FILENAME_WILDCARD_XML, value);\n                        break;\n                    }\n                }\n                /*\n\t\t\t\t * Now setting the adresses in the XML document.\n\t\t\t\t */\n                XMLHelper.setTagTextList(getRequestDocument(system), Constants.XBUSXMLMESSAGE_ADDRESS, copyAdresses);\n            }\n        }\n        XMLHelper.setTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_TIMESTAMP, Constants.getDateFormat().format(getRequestTimestamp()));\n    }\n\n    /**\n     * After setting the response data, both <code>setResponseText</code> and\n     * <code>setResponseDocument</code>, some fields of the\n     * <code>Message</code> must be synchronized with the response data.\n     * <p>\n     * <ul>\n     * <li><b>Returncode: </b>The value of the returncode must be extracted out\n     * of the response data.\n     * <li><b>Errorcode: </b>When an error has occured, the value for the\n     * errorcode can be read out of the response data, if it is included there.\n     * <li><b>Errortext: </b>When an error has occured, the value for the\n     * errortext can be read out of the response data, if it is included there.\n     * </ul>\n     */\n    protected void synchronizeResponseFields(XBUSSystem system) {\n        Document doc = getResponseDocument();\n        if (doc != null) {\n            setReturncode(XMLHelper.getTagText(getResponseDocument(), Constants.XBUSXMLMESSAGE_RETURNCODE));\n            try {\n                setErrorcode(Integer.parseInt(XMLHelper.getTagText(getResponseDocument(), Constants.XBUSXMLMESSAGE_ERRORCODE)));\n            } catch (Throwable t) {\n                /*\n\t\t\t\t * The errorcode in the XML document is either <null> or not\n\t\t\t\t * numeric\n\t\t\t\t */\n                setErrorcode(0);\n            }\n            setErrortext(XMLHelper.getTagText(getResponseDocument(), Constants.XBUSXMLMESSAGE_ERRORTEXT));\n        }\n        if ((getReturncode() == null) || (getReturncode().equals(\"\"))) {\n            setReturncode(Constants.RC_OK);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/xml/XBUSXMLMessageTest0.java",
		"test_prompt": "// XBUSXMLMessageTest0.java\npackage net.sf.xbus.protocol.xml;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport net.sf.xbus.protocol.XMLMessage;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XBUSXMLMessage}.\n* It contains ten unit test cases for the {@link XBUSXMLMessage#getTemplateAsString()} method.\n*/\nclass XBUSXMLMessageTest0 {"
	},
	{
		"original_code": "// XBUSXMLMessage.java\npackage net.sf.xbus.protocol.xml;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport net.sf.xbus.protocol.XMLMessage;\nimport org.w3c.dom.Document;\n\n/**\n * <code>XBUSXMLMessage</code> represents messages in the xBus specific\n * XML-format.\n */\npublic class XBUSXMLMessage extends XMLMessageAbstract implements TextMessage, ObjectMessage, XMLMessage {\n\n    /**\n     * This constructor stores the <code>source</code>, creates an unique\n     * identifier for the call and initializes the requestTimestamp. It is used\n     * when constructing a new <code>XBUSXMLMessage</code> from the data of a\n     * receiver.\n     */\n    public XBUSXMLMessage(XBUSSystem source) {\n        super(source);\n        setShortname(\"XBUSXMLMessage\");\n    }\n\n    /**\n     * This constructor initializes the new <code>XBUSXMLMessage</code> with\n     * the given parameters. It is used when constructing a new\n     * <code>XBUSXMLMessage</code> by converting it from another\n     * <code>Message</code>.\n     */\n    public XBUSXMLMessage(String function, XBUSSystem source, String id) {\n        super(function, source, id);\n        setShortname(\"XBUSXMLMessage\");\n    }\n\n    /**\n     * Returns a XML string containing an empty XBUSXMLMessage\n     */\n    static public String getTemplateAsString() throws XException {\n        StringBuffer retString = new StringBuffer();\n        retString.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n        retString.append(Constants.getXMLEncoding());\n        retString.append(\"\\\"?>\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"    <\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_ID).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_FUNCTION).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_SOURCE).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_ADDRESS).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"        <\").append(Constants.XBUSXMLMESSAGE_TIMESTAMP).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"    </\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"    <\").append(Constants.XBUSXMLMESSAGE_DATA).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"</\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        return retString.toString();\n    }\n\n    /**\n     * Returns a W3C document containing an empty XBUSXMLMessage\n     */\n    static public Document getTemplateAsDocument() throws XException {\n        return XMLHelper.parseXML(getTemplateAsString(), \"XBUSXMLMessage\", null);\n    }\n\n    /**\n     * After setting the request data, both <code>setRequestText</code> and\n     * <code>setRequestDocument</code>, some fields of the\n     * <code>Message</code> must be synchronized with the request data.\n     * <p>\n     * <ul>\n     * <li><b>Id: </b>When the Id is found in the request data, it must be\n     * copied to the <code>Message</code>. When it is not found, the value\n     * from the <code>Message</code> must be copied to the request data.\n     * <li><b>Function: </b>The value for the function must be read from the\n     * request data and must be set in the <code>Message</code>.\n     * <li><b>Source: </b>Must be copied from the <code>Message</code> object\n     * to the request data, to be sure that it is set correct.\n     * <li><b>Request Timestamp: </b>Must be copied from the\n     * <code>Message</code> object to the request data.\n     * </ul>\n     */\n    protected void synchronizeRequestFields(XBUSSystem system) throws XException {\n        String id = XMLHelper.getTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_ID);\n        if ((id != null) && (id.length() > 0)) {\n            setId(id);\n        } else {\n            XMLHelper.setTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_ID, getId());\n        }\n        String newFunction = XMLHelper.getTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_FUNCTION);\n        if ((newFunction != null) && (newFunction.length() != 0)) {\n            setFunction(newFunction);\n        } else {\n            XMLHelper.setTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_FUNCTION, getFunction());\n        }\n        XMLHelper.setTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_SOURCE, getSource().getName());\n        /*\n\t\t * When an address information is contained in the request document,\n\t\t * this address is set in the source of the message. Otherwise the\n\t\t * address of the message will be set in request document.\n\t\t */\n        Hashtable addresses = XMLHelper.getTagTextList(getRequestDocument(system), Constants.XBUSXMLMESSAGE_ADDRESS);\n        if ((addresses != null) && (!addresses.isEmpty())) {\n            String key = null;\n            String value = null;\n            for (Enumeration e = addresses.keys(); e.hasMoreElements(); ) {\n                key = (String) e.nextElement();\n                value = (String) addresses.get(key);\n                if (XBUSSystem.FILENAME_WILDCARD_XML.equals(key)) {\n                    /*\n\t\t\t\t\t * Switching the XML representation of the WILDCARD to the\n\t\t\t\t\t * \"normal\" one.\n\t\t\t\t\t */\n                    key = XBUSSystem.FILENAME_WILDCARD;\n                }\n                getSource().setAddress(key, value);\n            }\n        } else {\n            if (getSource().getAddresses() != null) {\n                /*\n\t\t\t\t * Switching the \"normal\" representation of the WILDCARD to the\n\t\t\t\t * XML representation.\n\t\t\t\t */\n                Hashtable copyAdresses = (Hashtable) getSource().getAddresses().clone();\n                String key = null;\n                String value = null;\n                for (Enumeration e = copyAdresses.keys(); e.hasMoreElements(); ) {\n                    key = (String) e.nextElement();\n                    value = (String) copyAdresses.get(key);\n                    if (XBUSSystem.FILENAME_WILDCARD.equals(key)) {\n                        copyAdresses.remove(key);\n                        copyAdresses.put(XBUSSystem.FILENAME_WILDCARD_XML, value);\n                        break;\n                    }\n                }\n                /*\n\t\t\t\t * Now setting the adresses in the XML document.\n\t\t\t\t */\n                XMLHelper.setTagTextList(getRequestDocument(system), Constants.XBUSXMLMESSAGE_ADDRESS, copyAdresses);\n            }\n        }\n        XMLHelper.setTagText(getRequestDocument(system), Constants.XBUSXMLMESSAGE_TIMESTAMP, Constants.getDateFormat().format(getRequestTimestamp()));\n    }\n\n    /**\n     * After setting the response data, both <code>setResponseText</code> and\n     * <code>setResponseDocument</code>, some fields of the\n     * <code>Message</code> must be synchronized with the response data.\n     * <p>\n     * <ul>\n     * <li><b>Returncode: </b>The value of the returncode must be extracted out\n     * of the response data.\n     * <li><b>Errorcode: </b>When an error has occured, the value for the\n     * errorcode can be read out of the response data, if it is included there.\n     * <li><b>Errortext: </b>When an error has occured, the value for the\n     * errortext can be read out of the response data, if it is included there.\n     * </ul>\n     */\n    protected void synchronizeResponseFields(XBUSSystem system) {\n        Document doc = getResponseDocument();\n        if (doc != null) {\n            setReturncode(XMLHelper.getTagText(getResponseDocument(), Constants.XBUSXMLMESSAGE_RETURNCODE));\n            try {\n                setErrorcode(Integer.parseInt(XMLHelper.getTagText(getResponseDocument(), Constants.XBUSXMLMESSAGE_ERRORCODE)));\n            } catch (Throwable t) {\n                /*\n\t\t\t\t * The errorcode in the XML document is either <null> or not\n\t\t\t\t * numeric\n\t\t\t\t */\n                setErrorcode(0);\n            }\n            setErrortext(XMLHelper.getTagText(getResponseDocument(), Constants.XBUSXMLMESSAGE_ERRORTEXT));\n        }\n        if ((getReturncode() == null) || (getReturncode().equals(\"\"))) {\n            setReturncode(Constants.RC_OK);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/xml/XBUSXMLMessageTest1.java",
		"test_prompt": "// XBUSXMLMessageTest1.java\npackage net.sf.xbus.protocol.xml;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport net.sf.xbus.protocol.XMLMessage;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XBUSXMLMessage}.\n* It contains ten unit test cases for the {@link XBUSXMLMessage#getTemplateAsDocument()} method.\n*/\nclass XBUSXMLMessageTest1 {"
	},
	{
		"original_code": "// XMLWrapperTransformer.java\npackage net.sf.xbus.protocol.xml;\n\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.w3c.dom.Document;\n\n/**\n * The <code>XMLWrapperTransformer</code> wraps the given <code>String</code>\n * into a <code>XBUSXMLMessage</code>. The XBUS_Data section of the outcoming\n * XBUSXML document contains the given <code>String</code> as a CDATA element.\n * This makes sure the XML parser will not try to evaluate the\n * <code>String</code>.\n */\npublic class XMLWrapperTransformer implements Transformer {\n\n    /**\n     * The <code>transform</code> method wraps the given <code>Object</code>\n     * into a <code>XBUSXMLMessage</code>.\n     *\n     * @param inObject either the request or response that shall be wrapped into\n     *            a XBUSXMLMessage. This <code>Object</code> must be of type\n     *            <code>String</code>.\n     * @param source not used\n     * @param destination not used\n     * @param destinationMessage not used\n     * @return an <code>org.w3c.Document</code> containing a\n     *         <code>XBUSXMLMessage</code> containing the\n     *         <code>inObject</code> as a CDATA section.\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        Document doc = XBUSXMLMessage.getTemplateAsDocument();\n        String inString = inObject.toString();\n        if (inObject instanceof Document) {\n            inString = XMLHelper.serializeXML((Document) inObject, null);\n        } else if (inObject instanceof ByteArrayList) {\n            // ByteArrayLists must be treated separately to serialise the\n            // content\n            // and not the byte representation as sequence of numbers\n            inString = ((ByteArrayList) inObject).getContentAsString(destination.getName());\n        }\n        // if\n        // (inObject.getClass().getName().equals(\"net.sf.xbus.protocol.bytearraylist.ByteArrayList\"))\n        XMLHelper.setTagCDATA(doc, Constants.XBUSXMLMESSAGE_DATA, inString);\n        return doc;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/xml/XMLWrapperTransformerTest.java",
		"test_prompt": "// XMLWrapperTransformerTest.java\npackage net.sf.xbus.protocol.xml;\n\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLWrapperTransformer}.\n* It contains ten unit test cases for the {@link XMLWrapperTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass XMLWrapperTransformerTest {"
	},
	{
		"original_code": "// XMLUnwrapperTransformer.java\npackage net.sf.xbus.protocol.xml;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.w3c.dom.Document;\n\n/**\n * The <code>XMLUnwrapperTransformer</code> does the inverse transformation of\n * the <code>XMLWrapperTransformer</code>. It awaits a XBUSXML document\n * containing a CDATA section. The content of this CDATA section is given back\n * as a <code>String</code>.\n */\npublic class XMLUnwrapperTransformer implements Transformer {\n\n    /**\n     * The <code>transform</code> method unwraps a <code>String</code> from\n     * the given <code>Object</code>.\n     *\n     * @param inObject either the request or response. It must be an\n     *            <code>org.w3c.Document</code> containing a\n     *            <code>XBUSXMLMessage</code>.\n     * @param source not used\n     * @param destination not used\n     * @param destinationMessage not used\n     * @return an <code>String</code> unwrapped from the CDATA section of the\n     *         given document.\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) {\n        return XMLHelper.getTagCDATA((Document) inObject, Constants.XBUSXMLMESSAGE_DATA);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/xml/XMLUnwrapperTransformerTest.java",
		"test_prompt": "// XMLUnwrapperTransformerTest.java\npackage net.sf.xbus.protocol.xml;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.w3c.dom.Document;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLUnwrapperTransformer}.\n* It contains ten unit test cases for the {@link XMLUnwrapperTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass XMLUnwrapperTransformerTest {"
	},
	{
		"original_code": "// Stream2ByteArrayListTransformer.java\npackage net.sf.xbus.protocol.bytearraylist;\n\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\n\n/**\n * The <code>Stream2ByteArrayListTransformer</code> read the content of an\n * <code>InputStream<code> into a <code>ByteArrayList<code>.\n */\npublic class Stream2ByteArrayListTransformer implements Transformer {\n\n    /**\n     * The <code>Stream2ByteArrayListTransformer</code> read the content of an\n     * <code>InputStream<code> into a <code>ByteArrayList<code>.\n     *\n     * @param inObject either the request or response of the source message\n     * @param source not used - from the Transformer interface\n     * @param destination not used - from the Transformer interface\n     * @param destinationMessage not used - from the Transformer interface\n     * @return <code>ByteArrayList</code>\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) throws XException {\n        byte[] ba = XByteArraySupport.transformToByteArray(inObject);\n        // convert the byte array into a ByteArrayList.\n        return ByteArrayList.createByteArrayList(ba, 0);\n    }\n    // transform(Object inObject,XBUSSystem source,XBUSSystem\n    // destination,Message destinationMessage)\n}\n// Stream2ByteArrayListTransformer\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/bytearraylist/Stream2ByteArrayListTransformerTest.java",
		"test_prompt": "// Stream2ByteArrayListTransformerTest.java\npackage net.sf.xbus.protocol.bytearraylist;\n\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Stream2ByteArrayListTransformer}.\n* It contains ten unit test cases for the {@link Stream2ByteArrayListTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass Stream2ByteArrayListTransformerTest {"
	},
	{
		"original_code": "// ByteArrayList2StreamTransformer.java\npackage net.sf.xbus.protocol.bytearraylist;\n\nimport java.io.ByteArrayInputStream;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\n\n/**\n * The <code>ByteArrayList2StreamTransformer</code> returns a\n * <code>ByteArrayInputStream</code> to read its content.\n */\npublic class ByteArrayList2StreamTransformer implements Transformer {\n\n    /**\n     * The <code>ByteArrayList2StreamTransformer</code> returns a\n     * <code>ByteArrayInputStream</code> to read its content.\n     *\n     * @param inObject either the request or response of the source message\n     * @param source not used\n     * @param destination not used\n     * @param destinationMessage not used\n     * @return <code>ByteArrayInputStream</code>\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) {\n        ByteArrayList bal = (ByteArrayList) inObject;\n        return new ByteArrayInputStream(bal.toByteArray());\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/bytearraylist/ByteArrayList2StreamTransformerTest.java",
		"test_prompt": "// ByteArrayList2StreamTransformerTest.java\npackage net.sf.xbus.protocol.bytearraylist;\n\nimport java.io.ByteArrayInputStream;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.Transformer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayList2StreamTransformer}.\n* It contains ten unit test cases for the {@link ByteArrayList2StreamTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass ByteArrayList2StreamTransformerTest {"
	},
	{
		"original_code": "// CloneTransformer.java\npackage net.sf.xbus.protocol;\n\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * The <code>CloneTransformer</code> simply returns the given\n * <code>Object</code>. It is used when no transformation is necessary.\n */\npublic class CloneTransformer implements Transformer {\n\n    /**\n     * No transformation is done, the given <code>inObject</code> is returned.\n     *\n     * @param inObject either the request or response of the source message\n     * @param source not used\n     * @param destination not used\n     * @param destinationMessage not used\n     * @return reference to the <code>inObject</code>\n     */\n    public Object transform(Object inObject, XBUSSystem source, XBUSSystem destination, Message destinationMessage) {\n        return inObject;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/CloneTransformerTest.java",
		"test_prompt": "// CloneTransformerTest.java\npackage net.sf.xbus.protocol;\n\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CloneTransformer}.\n* It contains ten unit test cases for the {@link CloneTransformer#transform(Object, XBUSSystem, XBUSSystem, Message)} method.\n*/\nclass CloneTransformerTest {"
	},
	{
		"original_code": "// CSVParser.java\n/*\n * Created on 04.10.2004\n */\npackage net.sf.xbus.protocol.csv;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <p>\n * The <code>CSVParser</code> class contains all methods necessary for parsing\n * CSV format into an XML representation.\n * </p>\n * <p>\n * This parser supports all CSV format content which satisfies the rules\n * indicated in <a href=\"http://www.edoceo.com/utilis/csv-file-format.php\">this\n * CSV definition </a>.\n * </p>\n * <p>\n * The parsing result is a DOM tree with the following structure:\n * </p>\n * <p>\n * &lt;InterfaceName&gt; <dir>&lt;+ <i>Header </i>+&gt; <dir>&lt;+ <i>heading\n * </i>+&gt;+ <b>FieldValue </b>+&lt;/+ <i>heading </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>Header </i>+&gt; </dir> <dir>&lt;Records&gt; <dir>&lt;+\n * <i>Record </i>+&gt; <dir>&lt;+ <i>FieldName </i>+&gt;+ <b>FieldValue\n * </b>+&lt;/+ <i>FieldName </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>Record </i>+&gt; <br>\n * ... </dir> &lt;/Records&gt; </dir> &lt;/InterfaceName&gt;\n * </p>\n * <p>\n * The header is optional. For every entry a Record tag structure is created.\n * </p>\n * <p>\n * The information for the names and values of the DOM entities are taken out of\n * the CSV source text and the optional Description file. A description file\n * must be valid (InterfaceSpecCSV.dtd).\n * </p>\n * <p>\n * The following table gives an overview, how the Header information and the\n * names of the entry tags are selected:\n * </p>\n *\n * <table border=\"1\">\n * <tr>\n * <td colspan=\"2\"><b>CSV file </b></td>\n * <td colspan=\"5\"><b>Description file </b></td>\n * <td colspan=\"2\"><b>Result </b></td>\n * </tr>\n * <tr  align=\"center\">\n * <td>has header</td>\n * <td>does not contain header</td>\n * <td>No description file</td>\n * <td>does not contain any information</td>\n * <td>contains only Header information</td>\n * <td>contains only Records information</td>\n * <td>contains Header and Records information</td>\n * <td><b>Header information taken from: </b></td>\n * <td><b>Tag names of entries taken from: </b></td>\n * </tr>\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>CSV header</td>\n * <td>CSV header</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>CSV header</td>\n * <td>CSV header</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>Description file</td>\n * <td>Header information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>CSV header</td>\n * <td>Records information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>Description file</td>\n * <td>Records information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>No header</td>\n * <td>Tag name = &quot;field&quot;</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>No header</td>\n * <td>Tag name = &quot;field&quot;</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>Description file</td>\n * <td>Header information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>No header</td>\n * <td>Records information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>Description file</td>\n * <td>Records information in description file</td>\n * </tr>* </table>\n */\npublic class CSVParser {\n\n    private static Hashtable instances = new Hashtable();\n\n    private static final Object classLock = CSVParser.class;\n\n    private String fieldSeparator;\n\n    private String quoteChar;\n\n    private boolean hasHeader;\n\n    private String lineSeparator;\n\n    private Document descriptionTree = null;\n\n    private Vector fieldNames = null;\n\n    /**\n     * @param quoteChar\n     *            The quoteChar to set.\n     */\n    public void setQuoteChar(String quoteChar) {\n        this.quoteChar = quoteChar;\n    }\n\n    /**\n     * @return Returns the quoteChar.\n     */\n    public String getQuoteChar() {\n        return quoteChar;\n    }\n\n    /**\n     * @return Returns the hasHeader.\n     */\n    public boolean isHasHeader() {\n        return hasHeader;\n    }\n\n    /**\n     * @param hasHeader\n     *            The hasHeader to set.\n     */\n    public void setHasHeader(boolean hasHeader) {\n        this.hasHeader = hasHeader;\n    }\n\n    /**\n     * @param fieldSeparator\n     *            The fieldSeparator to set.\n     */\n    public void setFieldSeparator(String fieldSeparator) {\n        this.fieldSeparator = fieldSeparator;\n    }\n\n    /**\n     * @return Returns the fieldSeparator.\n     */\n    public String getFieldSeparator() {\n        return fieldSeparator;\n    }\n\n    /**\n     * @param lineSeparator\n     *            The lineSeparator to set.\n     */\n    public void setLineSeparator(String lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * @return Returns the lineSeparator.\n     */\n    public String getLineSeparator() {\n        return lineSeparator;\n    }\n\n    /**\n     * @return Returns the descriptionTree.\n     */\n    public Document getDescriptionTree() {\n        return descriptionTree;\n    }\n\n    /**\n     * @param descriptionTree\n     *            The descriptionTree to set.\n     */\n    public void setDescriptionTree(Document descriptionTree) {\n        this.descriptionTree = descriptionTree;\n    }\n\n    /**\n     * @return Returns the headerArray.\n     */\n    public Vector getFieldNames() {\n        return fieldNames;\n    }\n\n    /**\n     * @param fieldNames\n     */\n    public void setFieldNames(Vector fieldNames) {\n        this.fieldNames = fieldNames;\n    }\n\n    /**\n     * Adds a value to the field names. The field names are the names of the\n     * tags of an entry. If the passed name is not a valid tagname,\n     * &quot;field&quot; is added to the list of names instead of the passed\n     * name. Namespace tag names are also not allowed and replaced bz\n     * &quot;field&quot;\n     *\n     * @param fieldName\n     *            The field name to add\n     * @throws XException\n     *             If parser configuration is not valid.\n     */\n    private void addFieldName(String fieldName) throws XException {\n        if (getFieldNames() == null) {\n            setFieldNames(new Vector());\n        }\n        try {\n            DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement(fieldName);\n        } catch (DOMException e) {\n            // if fieldName is not a valid tag name\n            fieldName = \"Field\";\n        } catch (ParserConfigurationException parserException) {\n            Vector error = new Vector();\n            error.add(parserException.toString());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"10\");\n        }\n        // we do not allow : otherwise namespace declaration would be necessary\n        if (fieldName.indexOf(\":\") >= 0) {\n            fieldName = \"Field\";\n        }\n        getFieldNames().add(fieldName);\n    }\n\n    /**\n     * Constructor of the parser. Starts the initialization which loads the\n     * configuration values.\n     *\n     * @param system\n     *            the name of the process\n     * @throws XException\n     */\n    public CSVParser(String system) throws XException {\n        initialize(system);\n    }\n\n    /**\n     * Returns an instance of <code>CSVParser</code>\n     *\n     * @param sourceType\n     *            The name of the process\n     * @return An instance of the CSVSerializer class\n     */\n    protected static CSVParser getInstance(String sourceType) throws XException {\n        synchronized (classLock) {\n            if (sourceType == null || sourceType.length() == 0)\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"1\");\n            CSVParser instance = (CSVParser) instances.get(Thread.currentThread().getName() + sourceType);\n            if (instance == null) {\n                // no suitable instance available yet\n                instance = new CSVParser(sourceType);\n                instances.put(Thread.currentThread().getName() + sourceType, instance);\n            }\n            // if (instance==null)\n            return instance;\n        }\n    }\n\n    /**\n     * Initializes a CSVParser object by reading and setting the configuration.\n     * Parameters of CSVparser are: fieldSeparator, quoteChar, hasHeader,\n     * lineSeparator and the description file.\n     *\n     * @param sectionName\n     *            The name of the process to read the values in the\n     *            configuration file from.\n     * @throws XException\n     */\n    private void initialize(String sectionName) throws XException {\n        Configuration config = Configuration.getInstance();\n        Configuration xBusConfig = Configuration.getInstance(\"xbus\");\n        String tempVariable = null;\n        // get Field Separator\n        if ((fieldSeparator = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, Constants.KEY_CSV_FIELD_SEPARATOR)) == null) {\n            fieldSeparator = xBusConfig.getValue(\"MessageDefaults\", \"CSVMessage\", Constants.KEY_CSV_FIELD_SEPARATOR);\n        }\n        // get Quote Character\n        if ((quoteChar = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, Constants.KEY_CSV_QUOTE_CHAR)) == null) {\n            quoteChar = xBusConfig.getValue(\"MessageDefaults\", \"CSVMessage\", Constants.KEY_CSV_QUOTE_CHAR);\n        }\n        // get configuration entry if containing header\n        if ((tempVariable = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, Constants.KEY_CSV_HAS_HEADER)) == null) {\n            hasHeader = xBusConfig.getValueAsBoolean(\"MessageDefaults\", \"CSVMessage\", Constants.KEY_CSV_HAS_HEADER);\n        } else if (tempVariable.equalsIgnoreCase(Constants.CONFIGURATION_TRUE)) {\n            hasHeader = true;\n        } else {\n            hasHeader = false;\n        }\n        // set line separator\n        lineSeparator = Constants.LINE_SEPERATOR;\n        String platform = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, \"Platform\");\n        if (platform != null) {\n            lineSeparator = Constants.getLineSeperator(platform);\n        }\n        if ((tempVariable = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, Constants.KEY_CSV_DESCRIPTION_FILE)) == null) {\n            setDescriptionTree(null);\n        } else {\n            String fileName = Constants.XBUS_ETC + \"InterfaceDescriptions\" + Constants.FILE_SEPERATOR + tempVariable;\n            File descriptionFile = new File(fileName);\n            if (!descriptionFile.exists()) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"7\");\n            }\n            try {\n                DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                Document doc = builder.parse(descriptionFile);\n                XDomSupport.deleteWhitespaceTextInElementNodesAndComments(doc);\n                setDescriptionTree(doc);\n            } catch (Exception e) {\n                Vector errors = new Vector();\n                errors.add(e.toString());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"8\", errors);\n            }\n        }\n    }\n\n    /**\n     * Parses the passed CSV format text into a DOM tree and returns it.\n     *\n     * @param text\n     *            The source text to parse. Has to be CSV format.\n     * @param systemName\n     *            The name of the process - used as root tag\n     * @return The parsed DOM tree.\n     * @throws XException\n     */\n    public Document parse(String text, String systemName) throws XException {\n        DocumentBuilder builder = null;\n        try {\n            builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"13\");\n        }\n        Document resultDocument = builder.newDocument();\n        // create root node <i>systemName</i>\n        Element root = resultDocument.createElement(systemName);\n        resultDocument.appendChild(root);\n        // separate the entries\n        Vector lines = returnSeparatedEntries(text);\n        int lineCounter = 0;\n        boolean useHeaderAsTagName = true;\n        if ((searchTagInDescriptionFile(\"Records\")) && (fieldNames == null)) {\n            writeFieldNamesOutOfDescriptionFile();\n            useHeaderAsTagName = false;\n        }\n        if (searchTagInDescriptionFile(\"Header\")) {\n            writeHeaderInformation(returnHeaderOfDescriptionFile(), resultDocument, root, (useHeaderAsTagName && (fieldNames == null)));\n        } else if (isHasHeader()) {\n            // only hasHeader\n            Vector headerVector = parseOneLine(lines.get(lineCounter));\n            writeHeaderInformation(headerVector, resultDocument, root, useHeaderAsTagName);\n        }\n        // isHasHeader()\n        // first Line is not content - skip!\n        if (isHasHeader()) {\n            lineCounter++;\n        }\n        Element records = resultDocument.createElement(\"Records\");\n        root.appendChild(records);\n        // go through the entries and parse every single one of them\n        for (; lineCounter < lines.size(); lineCounter++) {\n            Vector lineValues = parseOneLine(lines.get(lineCounter));\n            writeOneRecord(lineValues, resultDocument, records);\n        }\n        return resultDocument;\n    }\n\n    /**\n     * Writes the header information into the DOM tree.\n     *\n     * @param contentVector\n     *            The values of the header.\n     * @param document\n     *            The result document\n     * @param root\n     *            The root node of the document (usually systemName)\n     * @param writeFieldNames\n     *            If the header names should also be used as field tag names.\n     * @throws XException\n     */\n    private void writeHeaderInformation(Vector contentVector, Document document, Node root, boolean writeFieldNames) throws XException {\n        Element header = document.createElement(\"Header\");\n        root.appendChild(header);\n        Enumeration e = contentVector.elements();\n        while (e.hasMoreElements()) {\n            String element = getStringOutOfObject(e.nextElement());\n            Element elem = document.createElement(\"Heading\");\n            Node textElem = document.createTextNode(element);\n            header.appendChild(elem);\n            elem.appendChild(textElem);\n            if (writeFieldNames) {\n                addFieldName(element);\n            }\n        }\n    }\n\n    /**\n     * Separates the text into CSV entries by using the fieldSeparator as\n     * indicator and sticking together again entries which consist of more than\n     * one line\n     *\n     * @param sourceText\n     *            The text to separate.\n     * @return A Vector containing the entries.\n     * @throws XException\n     *             If last entry does not end correctly before end of text.\n     *             Usually missing quoteChar.\n     */\n    private Vector returnSeparatedEntries(String sourceText) throws XException {\n        Vector entries = new Vector();\n        int lineTokenizer = 0;\n        // get rid of empty lines(just spaces) in the beginning and the end\n        sourceText = sourceText.trim();\n        String[] lines = sourceText.split(getLineSeparator());\n        while (lineTokenizer < lines.length) {\n            // are we lucky and the line does not contain any line break in a\n            // field\n            // an odd number of quoteChars indicates that line is not a complete\n            // entry\n            if ((countOccurencesOfString(getQuoteChar(), lines[lineTokenizer]) % 2) == 0) {\n                entries.add(lines[lineTokenizer++]);\n                continue;\n            }\n            // we have a line break in the field!\n            int startLine = lineTokenizer;\n            // run until we get a line without a line break in a field\n            try {\n                while (((countOccurencesOfString(quoteChar, lines[++lineTokenizer])) % 2) == 0) ;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                Vector error = new Vector();\n                error.add(Integer.toString(lineTokenizer));\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"4\", error);\n            }\n            String buildEntry = \"\";\n            for (int i = startLine; i <= lineTokenizer; i++) {\n                // add lineSeparator inside text(lost when spliting)\n                if (i != startLine) {\n                    buildEntry += getLineSeparator();\n                }\n                buildEntry += lines[i];\n            }\n            entries.add(buildEntry);\n            lineTokenizer++;\n        }\n        return entries;\n    }\n\n    /**\n     * Parses one entry into the fields and returns them as Vector.\n     *\n     * @param lineText\n     *            The source text to parse.\n     * @return The parsed fields as Vector.\n     * @throws XException\n     */\n    private Vector parseOneLine(Object lineText) throws XException {\n        Vector returnVector = new Vector();\n        int fieldTokenizer = 0;\n        // add a space at the end to successfully parse empty fields at the end\n        // of line\n        // a; b; c; would be interpreted as 3 fields otherwise\n        String[] fields = (getStringOutOfObject(lineText) + \" \").split(getFieldSeparator());\n        while (fieldTokenizer < fields.length) {\n            if ((countOccurencesOfString(getQuoteChar(), fields[fieldTokenizer]) % 2) == 0) {\n                returnVector.add(fields[fieldTokenizer++]);\n                continue;\n            }\n            // we have a fieldSeparator in the field!\n            int startField = fieldTokenizer;\n            // run until we get a field without a fieldSeparator\n            try {\n                while (((countOccurencesOfString(getQuoteChar(), fields[++fieldTokenizer])) % 2) == 0) ;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"4\");\n            }\n            String buildEntry = \"\";\n            for (int i = startField; i <= fieldTokenizer; i++) {\n                // add lineSeparator inside text(lost when spliting)\n                if (i != startField) {\n                    buildEntry += getFieldSeparator();\n                }\n                buildEntry += fields[i];\n            }\n            returnVector.add(buildEntry);\n            fieldTokenizer++;\n        }\n        returnVector = cleanFields(returnVector);\n        return returnVector;\n    }\n\n    /**\n     * Parses one record into a document.\n     *\n     * @param values\n     *            The entries of the record.\n     * @param document\n     *            The document where the nodes have to be integrated.\n     * @param recordsElement\n     *            The root element of the entry fields.\n     * @throws XException\n     *             If the entry does not have the correct number of fields\n     */\n    private void writeOneRecord(Vector values, Document document, Node recordsElement) throws XException {\n        Element record = document.createElement(\"Record\");\n        recordsElement.appendChild(record);\n        // we require same number of fields for every entry\n        // could be changed if necessary like done for RecordTypeMessage\n        // do we have no field declaration (out of header or description file)?\n        if (getFieldNames() == null) {\n            // first entry defines the number of fields\n            for (int i = 0; i < values.size(); i++) {\n                addFieldName(\"Field\");\n            }\n        }\n        // does the entry have the correct number of fields?\n        if (values.size() != getFieldNames().size()) {\n            Vector error = new Vector();\n            error.add(values.toString());\n            error.add(Integer.toString(values.size()));\n            error.add(Integer.toString(getFieldNames().size()));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"12\", error);\n        }\n        // create node for every field\n        for (int i = 0; i < values.size(); i++) {\n            Element elem = document.createElement(getStringOutOfObject(getFieldNames().get(i)));\n            Node textElem = document.createTextNode(getStringOutOfObject(values.get(i)));\n            record.appendChild(elem);\n            elem.appendChild(textElem);\n        }\n    }\n\n    /**\n     * Fetches the field tag names out of the description file\n     *\n     * @throws XException\n     */\n    private void writeFieldNamesOutOfDescriptionFile() throws XException {\n        Document descriptionTree = getDescriptionTree();\n        // get Records Node\n        NodeList nodeList = descriptionTree.getElementsByTagName(\"Records\");\n        // get Record nodes\n        // get record node\n        nodeList = nodeList.item(0).getChildNodes();\n        // get field nodes\n        nodeList = nodeList.item(0).getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            addFieldName(nodeList.item(i).getAttributes().getNamedItem(\"Name\").getNodeValue());\n        }\n    }\n\n    /**\n     * Reads the header out of the description file and returns it als Vector.\n     *\n     * @return The Header fields as Vector.\n     * @throws XException\n     */\n    private Vector returnHeaderOfDescriptionFile() throws XException {\n        Vector returnVector = new Vector();\n        NodeList nodeList = getDescriptionTree().getElementsByTagName(\"Header\");\n        Node fileHeaderRoot = null;\n        try {\n            fileHeaderRoot = nodeList.item(0);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"9\");\n        }\n        nodeList = fileHeaderRoot.getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            try {\n                returnVector.add(nodeList.item(i).getAttributes().getNamedItem(\"Name\").getNodeValue());\n            } catch (DOMException e) {\n                Vector error = new Vector();\n                error.add(e.toString());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"11\", error);\n            }\n        }\n        return returnVector;\n    }\n\n    /**\n     * Returns the number of occurence of a pattern in a String.\n     *\n     * @param pattern\n     *            The search pattern.\n     * @param baseString\n     *            The String to search in.\n     * @return The number of occurences.\n     */\n    private int countOccurencesOfString(String pattern, String baseString) {\n        int count = 0;\n        int currentIndex = 0;\n        while ((currentIndex = baseString.indexOf(pattern, currentIndex)) != -1) {\n            currentIndex += pattern.length();\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Cleans the fields from all the unnecessary dust and tests if unallowed\n     * characters exist. Removes leading and trailing white spaces, removes\n     * quoting of fields and replaces double quoteChars with a single.\n     *\n     * @param sourceVector\n     *            The Vector containing the dirty fields.\n     * @return A Vector with the cleaned entries.\n     * @throws XException\n     *             If unallowed characters exist in fields.\n     */\n    private Vector cleanFields(Vector sourceVector) throws XException {\n        Vector resultVector = new Vector();\n        Enumeration e = sourceVector.elements();\n        while (e.hasMoreElements()) {\n            String fieldString = getStringOutOfObject(e.nextElement());\n            fieldString = fieldString.trim();\n            // is this a quoted field\n            if (fieldString.indexOf(getQuoteChar()) == 0) {\n                // is there also a quote in the end of the string\n                if (fieldString.lastIndexOf(getQuoteChar()) != fieldString.length() - getQuoteChar().length()) {\n                    Vector error = new Vector();\n                    error.add(fieldString);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"14\", error);\n                }\n                fieldString = fieldString.substring(getQuoteChar().length(), fieldString.length() - getQuoteChar().length());\n                fieldString = fieldString.replaceAll(getQuoteChar() + getQuoteChar(), getQuoteChar());\n            } else {\n                // are unallowed values in field even it has not been quoted?\n                if (fieldString.indexOf(getLineSeparator()) >= 0 || fieldString.indexOf(getQuoteChar()) >= 0) {\n                    Vector error = new Vector();\n                    error.add(fieldString);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"6\", error);\n                }\n            }\n            resultVector.add(fieldString);\n        }\n        return resultVector;\n    }\n\n    /**\n     * Converts a passed object into a String.\n     *\n     * @param content\n     *            The object to convert\n     * @return The converted String representation.\n     * @throws XException\n     *             If passed object is not a String.\n     */\n    private String getStringOutOfObject(Object content) throws XException {\n        if (!(content instanceof String)) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"5\");\n        }\n        return (String) content;\n    }\n\n    /**\n     * Searches for a tag with the name of the passed parameter.\n     *\n     * @param tag\n     *            The tag name to search for\n     * @return true if tag name found\n     * @return false if tag name not found\n     */\n    private boolean searchTagInDescriptionFile(String tag) {\n        if (getDescriptionTree() == null || (getDescriptionTree().getElementsByTagName(tag)).getLength() == 0) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/csv/CSVParserTest0.java",
		"test_prompt": "// CSVParserTest0.java\npackage net.sf.xbus.protocol.csv;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CSVParser}.\n* It contains ten unit test cases for the {@link CSVParser#isHasHeader()} method.\n*/\nclass CSVParserTest0 {"
	},
	{
		"original_code": "// CSVParser.java\n/*\n * Created on 04.10.2004\n */\npackage net.sf.xbus.protocol.csv;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <p>\n * The <code>CSVParser</code> class contains all methods necessary for parsing\n * CSV format into an XML representation.\n * </p>\n * <p>\n * This parser supports all CSV format content which satisfies the rules\n * indicated in <a href=\"http://www.edoceo.com/utilis/csv-file-format.php\">this\n * CSV definition </a>.\n * </p>\n * <p>\n * The parsing result is a DOM tree with the following structure:\n * </p>\n * <p>\n * &lt;InterfaceName&gt; <dir>&lt;+ <i>Header </i>+&gt; <dir>&lt;+ <i>heading\n * </i>+&gt;+ <b>FieldValue </b>+&lt;/+ <i>heading </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>Header </i>+&gt; </dir> <dir>&lt;Records&gt; <dir>&lt;+\n * <i>Record </i>+&gt; <dir>&lt;+ <i>FieldName </i>+&gt;+ <b>FieldValue\n * </b>+&lt;/+ <i>FieldName </i>+&gt; <br>\n * ... </dir> &lt;/+ <i>Record </i>+&gt; <br>\n * ... </dir> &lt;/Records&gt; </dir> &lt;/InterfaceName&gt;\n * </p>\n * <p>\n * The header is optional. For every entry a Record tag structure is created.\n * </p>\n * <p>\n * The information for the names and values of the DOM entities are taken out of\n * the CSV source text and the optional Description file. A description file\n * must be valid (InterfaceSpecCSV.dtd).\n * </p>\n * <p>\n * The following table gives an overview, how the Header information and the\n * names of the entry tags are selected:\n * </p>\n *\n * <table border=\"1\">\n * <tr>\n * <td colspan=\"2\"><b>CSV file </b></td>\n * <td colspan=\"5\"><b>Description file </b></td>\n * <td colspan=\"2\"><b>Result </b></td>\n * </tr>\n * <tr  align=\"center\">\n * <td>has header</td>\n * <td>does not contain header</td>\n * <td>No description file</td>\n * <td>does not contain any information</td>\n * <td>contains only Header information</td>\n * <td>contains only Records information</td>\n * <td>contains Header and Records information</td>\n * <td><b>Header information taken from: </b></td>\n * <td><b>Tag names of entries taken from: </b></td>\n * </tr>\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>CSV header</td>\n * <td>CSV header</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>CSV header</td>\n * <td>CSV header</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>Description file</td>\n * <td>Header information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>CSV header</td>\n * <td>Records information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>Description file</td>\n * <td>Records information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>No header</td>\n * <td>Tag name = &quot;field&quot;</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>No header</td>\n * <td>Tag name = &quot;field&quot;</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>Description file</td>\n * <td>Header information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>No header</td>\n * <td>Records information in description file</td>\n * </tr>\n *\n * <tr align=\"center\">\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>&nbsp;</td>\n * <td>X</td>\n * <td>Description file</td>\n * <td>Records information in description file</td>\n * </tr>* </table>\n */\npublic class CSVParser {\n\n    private static Hashtable instances = new Hashtable();\n\n    private static final Object classLock = CSVParser.class;\n\n    private String fieldSeparator;\n\n    private String quoteChar;\n\n    private boolean hasHeader;\n\n    private String lineSeparator;\n\n    private Document descriptionTree = null;\n\n    private Vector fieldNames = null;\n\n    /**\n     * @param quoteChar\n     *            The quoteChar to set.\n     */\n    public void setQuoteChar(String quoteChar) {\n        this.quoteChar = quoteChar;\n    }\n\n    /**\n     * @return Returns the quoteChar.\n     */\n    public String getQuoteChar() {\n        return quoteChar;\n    }\n\n    /**\n     * @return Returns the hasHeader.\n     */\n    public boolean isHasHeader() {\n        return hasHeader;\n    }\n\n    /**\n     * @param hasHeader\n     *            The hasHeader to set.\n     */\n    public void setHasHeader(boolean hasHeader) {\n        this.hasHeader = hasHeader;\n    }\n\n    /**\n     * @param fieldSeparator\n     *            The fieldSeparator to set.\n     */\n    public void setFieldSeparator(String fieldSeparator) {\n        this.fieldSeparator = fieldSeparator;\n    }\n\n    /**\n     * @return Returns the fieldSeparator.\n     */\n    public String getFieldSeparator() {\n        return fieldSeparator;\n    }\n\n    /**\n     * @param lineSeparator\n     *            The lineSeparator to set.\n     */\n    public void setLineSeparator(String lineSeparator) {\n        this.lineSeparator = lineSeparator;\n    }\n\n    /**\n     * @return Returns the lineSeparator.\n     */\n    public String getLineSeparator() {\n        return lineSeparator;\n    }\n\n    /**\n     * @return Returns the descriptionTree.\n     */\n    public Document getDescriptionTree() {\n        return descriptionTree;\n    }\n\n    /**\n     * @param descriptionTree\n     *            The descriptionTree to set.\n     */\n    public void setDescriptionTree(Document descriptionTree) {\n        this.descriptionTree = descriptionTree;\n    }\n\n    /**\n     * @return Returns the headerArray.\n     */\n    public Vector getFieldNames() {\n        return fieldNames;\n    }\n\n    /**\n     * @param fieldNames\n     */\n    public void setFieldNames(Vector fieldNames) {\n        this.fieldNames = fieldNames;\n    }\n\n    /**\n     * Adds a value to the field names. The field names are the names of the\n     * tags of an entry. If the passed name is not a valid tagname,\n     * &quot;field&quot; is added to the list of names instead of the passed\n     * name. Namespace tag names are also not allowed and replaced bz\n     * &quot;field&quot;\n     *\n     * @param fieldName\n     *            The field name to add\n     * @throws XException\n     *             If parser configuration is not valid.\n     */\n    private void addFieldName(String fieldName) throws XException {\n        if (getFieldNames() == null) {\n            setFieldNames(new Vector());\n        }\n        try {\n            DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement(fieldName);\n        } catch (DOMException e) {\n            // if fieldName is not a valid tag name\n            fieldName = \"Field\";\n        } catch (ParserConfigurationException parserException) {\n            Vector error = new Vector();\n            error.add(parserException.toString());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"10\");\n        }\n        // we do not allow : otherwise namespace declaration would be necessary\n        if (fieldName.indexOf(\":\") >= 0) {\n            fieldName = \"Field\";\n        }\n        getFieldNames().add(fieldName);\n    }\n\n    /**\n     * Constructor of the parser. Starts the initialization which loads the\n     * configuration values.\n     *\n     * @param system\n     *            the name of the process\n     * @throws XException\n     */\n    public CSVParser(String system) throws XException {\n        initialize(system);\n    }\n\n    /**\n     * Returns an instance of <code>CSVParser</code>\n     *\n     * @param sourceType\n     *            The name of the process\n     * @return An instance of the CSVSerializer class\n     */\n    protected static CSVParser getInstance(String sourceType) throws XException {\n        synchronized (classLock) {\n            if (sourceType == null || sourceType.length() == 0)\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"1\");\n            CSVParser instance = (CSVParser) instances.get(Thread.currentThread().getName() + sourceType);\n            if (instance == null) {\n                // no suitable instance available yet\n                instance = new CSVParser(sourceType);\n                instances.put(Thread.currentThread().getName() + sourceType, instance);\n            }\n            // if (instance==null)\n            return instance;\n        }\n    }\n\n    /**\n     * Initializes a CSVParser object by reading and setting the configuration.\n     * Parameters of CSVparser are: fieldSeparator, quoteChar, hasHeader,\n     * lineSeparator and the description file.\n     *\n     * @param sectionName\n     *            The name of the process to read the values in the\n     *            configuration file from.\n     * @throws XException\n     */\n    private void initialize(String sectionName) throws XException {\n        Configuration config = Configuration.getInstance();\n        Configuration xBusConfig = Configuration.getInstance(\"xbus\");\n        String tempVariable = null;\n        // get Field Separator\n        if ((fieldSeparator = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, Constants.KEY_CSV_FIELD_SEPARATOR)) == null) {\n            fieldSeparator = xBusConfig.getValue(\"MessageDefaults\", \"CSVMessage\", Constants.KEY_CSV_FIELD_SEPARATOR);\n        }\n        // get Quote Character\n        if ((quoteChar = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, Constants.KEY_CSV_QUOTE_CHAR)) == null) {\n            quoteChar = xBusConfig.getValue(\"MessageDefaults\", \"CSVMessage\", Constants.KEY_CSV_QUOTE_CHAR);\n        }\n        // get configuration entry if containing header\n        if ((tempVariable = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, Constants.KEY_CSV_HAS_HEADER)) == null) {\n            hasHeader = xBusConfig.getValueAsBoolean(\"MessageDefaults\", \"CSVMessage\", Constants.KEY_CSV_HAS_HEADER);\n        } else if (tempVariable.equalsIgnoreCase(Constants.CONFIGURATION_TRUE)) {\n            hasHeader = true;\n        } else {\n            hasHeader = false;\n        }\n        // set line separator\n        lineSeparator = Constants.LINE_SEPERATOR;\n        String platform = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, \"Platform\");\n        if (platform != null) {\n            lineSeparator = Constants.getLineSeperator(platform);\n        }\n        if ((tempVariable = config.getValueOptional(Constants.CHAPTER_SYSTEM, sectionName, Constants.KEY_CSV_DESCRIPTION_FILE)) == null) {\n            setDescriptionTree(null);\n        } else {\n            String fileName = Constants.XBUS_ETC + \"InterfaceDescriptions\" + Constants.FILE_SEPERATOR + tempVariable;\n            File descriptionFile = new File(fileName);\n            if (!descriptionFile.exists()) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"7\");\n            }\n            try {\n                DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                Document doc = builder.parse(descriptionFile);\n                XDomSupport.deleteWhitespaceTextInElementNodesAndComments(doc);\n                setDescriptionTree(doc);\n            } catch (Exception e) {\n                Vector errors = new Vector();\n                errors.add(e.toString());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"8\", errors);\n            }\n        }\n    }\n\n    /**\n     * Parses the passed CSV format text into a DOM tree and returns it.\n     *\n     * @param text\n     *            The source text to parse. Has to be CSV format.\n     * @param systemName\n     *            The name of the process - used as root tag\n     * @return The parsed DOM tree.\n     * @throws XException\n     */\n    public Document parse(String text, String systemName) throws XException {\n        DocumentBuilder builder = null;\n        try {\n            builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"13\");\n        }\n        Document resultDocument = builder.newDocument();\n        // create root node <i>systemName</i>\n        Element root = resultDocument.createElement(systemName);\n        resultDocument.appendChild(root);\n        // separate the entries\n        Vector lines = returnSeparatedEntries(text);\n        int lineCounter = 0;\n        boolean useHeaderAsTagName = true;\n        if ((searchTagInDescriptionFile(\"Records\")) && (fieldNames == null)) {\n            writeFieldNamesOutOfDescriptionFile();\n            useHeaderAsTagName = false;\n        }\n        if (searchTagInDescriptionFile(\"Header\")) {\n            writeHeaderInformation(returnHeaderOfDescriptionFile(), resultDocument, root, (useHeaderAsTagName && (fieldNames == null)));\n        } else if (isHasHeader()) {\n            // only hasHeader\n            Vector headerVector = parseOneLine(lines.get(lineCounter));\n            writeHeaderInformation(headerVector, resultDocument, root, useHeaderAsTagName);\n        }\n        // isHasHeader()\n        // first Line is not content - skip!\n        if (isHasHeader()) {\n            lineCounter++;\n        }\n        Element records = resultDocument.createElement(\"Records\");\n        root.appendChild(records);\n        // go through the entries and parse every single one of them\n        for (; lineCounter < lines.size(); lineCounter++) {\n            Vector lineValues = parseOneLine(lines.get(lineCounter));\n            writeOneRecord(lineValues, resultDocument, records);\n        }\n        return resultDocument;\n    }\n\n    /**\n     * Writes the header information into the DOM tree.\n     *\n     * @param contentVector\n     *            The values of the header.\n     * @param document\n     *            The result document\n     * @param root\n     *            The root node of the document (usually systemName)\n     * @param writeFieldNames\n     *            If the header names should also be used as field tag names.\n     * @throws XException\n     */\n    private void writeHeaderInformation(Vector contentVector, Document document, Node root, boolean writeFieldNames) throws XException {\n        Element header = document.createElement(\"Header\");\n        root.appendChild(header);\n        Enumeration e = contentVector.elements();\n        while (e.hasMoreElements()) {\n            String element = getStringOutOfObject(e.nextElement());\n            Element elem = document.createElement(\"Heading\");\n            Node textElem = document.createTextNode(element);\n            header.appendChild(elem);\n            elem.appendChild(textElem);\n            if (writeFieldNames) {\n                addFieldName(element);\n            }\n        }\n    }\n\n    /**\n     * Separates the text into CSV entries by using the fieldSeparator as\n     * indicator and sticking together again entries which consist of more than\n     * one line\n     *\n     * @param sourceText\n     *            The text to separate.\n     * @return A Vector containing the entries.\n     * @throws XException\n     *             If last entry does not end correctly before end of text.\n     *             Usually missing quoteChar.\n     */\n    private Vector returnSeparatedEntries(String sourceText) throws XException {\n        Vector entries = new Vector();\n        int lineTokenizer = 0;\n        // get rid of empty lines(just spaces) in the beginning and the end\n        sourceText = sourceText.trim();\n        String[] lines = sourceText.split(getLineSeparator());\n        while (lineTokenizer < lines.length) {\n            // are we lucky and the line does not contain any line break in a\n            // field\n            // an odd number of quoteChars indicates that line is not a complete\n            // entry\n            if ((countOccurencesOfString(getQuoteChar(), lines[lineTokenizer]) % 2) == 0) {\n                entries.add(lines[lineTokenizer++]);\n                continue;\n            }\n            // we have a line break in the field!\n            int startLine = lineTokenizer;\n            // run until we get a line without a line break in a field\n            try {\n                while (((countOccurencesOfString(quoteChar, lines[++lineTokenizer])) % 2) == 0) ;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                Vector error = new Vector();\n                error.add(Integer.toString(lineTokenizer));\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"4\", error);\n            }\n            String buildEntry = \"\";\n            for (int i = startLine; i <= lineTokenizer; i++) {\n                // add lineSeparator inside text(lost when spliting)\n                if (i != startLine) {\n                    buildEntry += getLineSeparator();\n                }\n                buildEntry += lines[i];\n            }\n            entries.add(buildEntry);\n            lineTokenizer++;\n        }\n        return entries;\n    }\n\n    /**\n     * Parses one entry into the fields and returns them as Vector.\n     *\n     * @param lineText\n     *            The source text to parse.\n     * @return The parsed fields as Vector.\n     * @throws XException\n     */\n    private Vector parseOneLine(Object lineText) throws XException {\n        Vector returnVector = new Vector();\n        int fieldTokenizer = 0;\n        // add a space at the end to successfully parse empty fields at the end\n        // of line\n        // a; b; c; would be interpreted as 3 fields otherwise\n        String[] fields = (getStringOutOfObject(lineText) + \" \").split(getFieldSeparator());\n        while (fieldTokenizer < fields.length) {\n            if ((countOccurencesOfString(getQuoteChar(), fields[fieldTokenizer]) % 2) == 0) {\n                returnVector.add(fields[fieldTokenizer++]);\n                continue;\n            }\n            // we have a fieldSeparator in the field!\n            int startField = fieldTokenizer;\n            // run until we get a field without a fieldSeparator\n            try {\n                while (((countOccurencesOfString(getQuoteChar(), fields[++fieldTokenizer])) % 2) == 0) ;\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"4\");\n            }\n            String buildEntry = \"\";\n            for (int i = startField; i <= fieldTokenizer; i++) {\n                // add lineSeparator inside text(lost when spliting)\n                if (i != startField) {\n                    buildEntry += getFieldSeparator();\n                }\n                buildEntry += fields[i];\n            }\n            returnVector.add(buildEntry);\n            fieldTokenizer++;\n        }\n        returnVector = cleanFields(returnVector);\n        return returnVector;\n    }\n\n    /**\n     * Parses one record into a document.\n     *\n     * @param values\n     *            The entries of the record.\n     * @param document\n     *            The document where the nodes have to be integrated.\n     * @param recordsElement\n     *            The root element of the entry fields.\n     * @throws XException\n     *             If the entry does not have the correct number of fields\n     */\n    private void writeOneRecord(Vector values, Document document, Node recordsElement) throws XException {\n        Element record = document.createElement(\"Record\");\n        recordsElement.appendChild(record);\n        // we require same number of fields for every entry\n        // could be changed if necessary like done for RecordTypeMessage\n        // do we have no field declaration (out of header or description file)?\n        if (getFieldNames() == null) {\n            // first entry defines the number of fields\n            for (int i = 0; i < values.size(); i++) {\n                addFieldName(\"Field\");\n            }\n        }\n        // does the entry have the correct number of fields?\n        if (values.size() != getFieldNames().size()) {\n            Vector error = new Vector();\n            error.add(values.toString());\n            error.add(Integer.toString(values.size()));\n            error.add(Integer.toString(getFieldNames().size()));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"12\", error);\n        }\n        // create node for every field\n        for (int i = 0; i < values.size(); i++) {\n            Element elem = document.createElement(getStringOutOfObject(getFieldNames().get(i)));\n            Node textElem = document.createTextNode(getStringOutOfObject(values.get(i)));\n            record.appendChild(elem);\n            elem.appendChild(textElem);\n        }\n    }\n\n    /**\n     * Fetches the field tag names out of the description file\n     *\n     * @throws XException\n     */\n    private void writeFieldNamesOutOfDescriptionFile() throws XException {\n        Document descriptionTree = getDescriptionTree();\n        // get Records Node\n        NodeList nodeList = descriptionTree.getElementsByTagName(\"Records\");\n        // get Record nodes\n        // get record node\n        nodeList = nodeList.item(0).getChildNodes();\n        // get field nodes\n        nodeList = nodeList.item(0).getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            addFieldName(nodeList.item(i).getAttributes().getNamedItem(\"Name\").getNodeValue());\n        }\n    }\n\n    /**\n     * Reads the header out of the description file and returns it als Vector.\n     *\n     * @return The Header fields as Vector.\n     * @throws XException\n     */\n    private Vector returnHeaderOfDescriptionFile() throws XException {\n        Vector returnVector = new Vector();\n        NodeList nodeList = getDescriptionTree().getElementsByTagName(\"Header\");\n        Node fileHeaderRoot = null;\n        try {\n            fileHeaderRoot = nodeList.item(0);\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"9\");\n        }\n        nodeList = fileHeaderRoot.getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            try {\n                returnVector.add(nodeList.item(i).getAttributes().getNamedItem(\"Name\").getNodeValue());\n            } catch (DOMException e) {\n                Vector error = new Vector();\n                error.add(e.toString());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"11\", error);\n            }\n        }\n        return returnVector;\n    }\n\n    /**\n     * Returns the number of occurence of a pattern in a String.\n     *\n     * @param pattern\n     *            The search pattern.\n     * @param baseString\n     *            The String to search in.\n     * @return The number of occurences.\n     */\n    private int countOccurencesOfString(String pattern, String baseString) {\n        int count = 0;\n        int currentIndex = 0;\n        while ((currentIndex = baseString.indexOf(pattern, currentIndex)) != -1) {\n            currentIndex += pattern.length();\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Cleans the fields from all the unnecessary dust and tests if unallowed\n     * characters exist. Removes leading and trailing white spaces, removes\n     * quoting of fields and replaces double quoteChars with a single.\n     *\n     * @param sourceVector\n     *            The Vector containing the dirty fields.\n     * @return A Vector with the cleaned entries.\n     * @throws XException\n     *             If unallowed characters exist in fields.\n     */\n    private Vector cleanFields(Vector sourceVector) throws XException {\n        Vector resultVector = new Vector();\n        Enumeration e = sourceVector.elements();\n        while (e.hasMoreElements()) {\n            String fieldString = getStringOutOfObject(e.nextElement());\n            fieldString = fieldString.trim();\n            // is this a quoted field\n            if (fieldString.indexOf(getQuoteChar()) == 0) {\n                // is there also a quote in the end of the string\n                if (fieldString.lastIndexOf(getQuoteChar()) != fieldString.length() - getQuoteChar().length()) {\n                    Vector error = new Vector();\n                    error.add(fieldString);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"14\", error);\n                }\n                fieldString = fieldString.substring(getQuoteChar().length(), fieldString.length() - getQuoteChar().length());\n                fieldString = fieldString.replaceAll(getQuoteChar() + getQuoteChar(), getQuoteChar());\n            } else {\n                // are unallowed values in field even it has not been quoted?\n                if (fieldString.indexOf(getLineSeparator()) >= 0 || fieldString.indexOf(getQuoteChar()) >= 0) {\n                    Vector error = new Vector();\n                    error.add(fieldString);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"6\", error);\n                }\n            }\n            resultVector.add(fieldString);\n        }\n        return resultVector;\n    }\n\n    /**\n     * Converts a passed object into a String.\n     *\n     * @param content\n     *            The object to convert\n     * @return The converted String representation.\n     * @throws XException\n     *             If passed object is not a String.\n     */\n    private String getStringOutOfObject(Object content) throws XException {\n        if (!(content instanceof String)) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_CSV, \"5\");\n        }\n        return (String) content;\n    }\n\n    /**\n     * Searches for a tag with the name of the passed parameter.\n     *\n     * @param tag\n     *            The tag name to search for\n     * @return true if tag name found\n     * @return false if tag name not found\n     */\n    private boolean searchTagInDescriptionFile(String tag) {\n        if (getDescriptionTree() == null || (getDescriptionTree().getElementsByTagName(tag)).getLength() == 0) {\n            return false;\n        }\n        return true;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/protocol/csv/CSVParserTest1.java",
		"test_prompt": "// CSVParserTest1.java\npackage net.sf.xbus.protocol.csv;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CSVParser}.\n* It contains ten unit test cases for the {@link CSVParser#parse(String, String)} method.\n*/\nclass CSVParserTest1 {"
	},
	{
		"original_code": "// JavaWorker.java\n/*\n * Created on 07.04.2003\n * \n * To change the template for this generated file go to\n * Window>Preferences>Java>Code Generation>Code and Comments\n */\npackage net.sf.xbus.sample;\n\n/**\n * @author Fleckenstein\n *\n * To change the template for this generated type comment go to\n * Window>Preferences>Java>Code Generation>Code and Comments\n */\npublic class JavaWorker {\n\n    public Object doSomething(Object indata) {\n        return indata;\n    }\n\n    public String reverse(Object indata) {\n        String data = (String) indata;\n        int length = data.length();\n        StringBuffer retData = new StringBuffer(length);\n        for (int i = 0; i < length; i++) {\n            retData.append(data.charAt(length - i - 1));\n        }\n        return retData.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/sample/JavaWorkerTest0.java",
		"test_prompt": "// JavaWorkerTest0.java\npackage net.sf.xbus.sample;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaWorker}.\n* It contains ten unit test cases for the {@link JavaWorker#doSomething(Object)} method.\n*/\nclass JavaWorkerTest0 {"
	},
	{
		"original_code": "// JavaWorker.java\n/*\n * Created on 07.04.2003\n * \n * To change the template for this generated file go to\n * Window>Preferences>Java>Code Generation>Code and Comments\n */\npackage net.sf.xbus.sample;\n\n/**\n * @author Fleckenstein\n *\n * To change the template for this generated type comment go to\n * Window>Preferences>Java>Code Generation>Code and Comments\n */\npublic class JavaWorker {\n\n    public Object doSomething(Object indata) {\n        return indata;\n    }\n\n    public String reverse(Object indata) {\n        String data = (String) indata;\n        int length = data.length();\n        StringBuffer retData = new StringBuffer(length);\n        for (int i = 0; i < length; i++) {\n            retData.append(data.charAt(length - i - 1));\n        }\n        return retData.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/sample/JavaWorkerTest1.java",
		"test_prompt": "// JavaWorkerTest1.java\npackage net.sf.xbus.sample;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaWorker}.\n* It contains ten unit test cases for the {@link JavaWorker#reverse(Object)} method.\n*/\nclass JavaWorkerTest1 {"
	},
	{
		"original_code": "// StringTransformerSample.java\npackage net.sf.xbus.sample;\n\nimport net.sf.xbus.base.linereader.LineTransformer;\n\n/**\n * TODO Kommentierung\n */\npublic class StringTransformerSample implements LineTransformer {\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.base.core.strings.StringTransformer#transform(java.lang.String)\n\t */\n    public String transform(String string) {\n        return new JavaWorker().reverse(string);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/sample/StringTransformerSampleTest.java",
		"test_prompt": "// StringTransformerSampleTest.java\npackage net.sf.xbus.sample;\n\nimport net.sf.xbus.base.linereader.LineTransformer;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringTransformerSample}.\n* It contains ten unit test cases for the {@link StringTransformerSample#transform(String)} method.\n*/\nclass StringTransformerSampleTest {"
	},
	{
		"original_code": "// JavaTransformerSample.java\npackage net.sf.xbus.sample;\n\nimport net.sf.xbus.base.core.XException;\n\n/**\n * This example of a class called by the <code>JavaTransformer</code> reverses\n * a string.\n */\npublic class JavaTransformerSample {\n\n    /**\n     * Reverses the given string\n     *\n     * @param inObject must be of type <code>String</code>\n     * @return the reversed string\n     * @throws XException if something goes wrong\n     */\n    public Object reverse(Object inObject) {\n        return new JavaWorker().reverse(inObject);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/sample/JavaTransformerSampleTest.java",
		"test_prompt": "// JavaTransformerSampleTest.java\npackage net.sf.xbus.sample;\n\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaTransformerSample}.\n* It contains ten unit test cases for the {@link JavaTransformerSample#reverse(Object)} method.\n*/\nclass JavaTransformerSampleTest {"
	},
	{
		"original_code": "// Dealer.java\npackage net.sf.xbus.sample;\n\nimport java.util.List;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.xbussystem.AdditionalAddress;\n\n/**\n * Specific data about dealers is stored in the standard configuration. This\n * convience class enables an easy access.\n */\npublic class Dealer implements AdditionalAddress {\n\n    private static final String DEALERNUMBER = \"$DEALERNUMBER$\";\n\n    private static final String DEALERNAME = \"$DEALERNAME$\";\n\n    private static final String CHAPTER = \"Dealer\";\n\n    /**\n     * Returns a list of all dealernumbers.\n     *\n     * @return list of dealernumbers\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public List getAddresses() throws XException {\n        List dealers = Configuration.getInstance().getSections(CHAPTER);\n        if (dealers != null) {\n            return dealers;\n        } else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_SAMPLE, Constants.PACKAGE_SAMPLE_SAMPLE, \"1\");\n        }\n    }\n\n    /**\n     * Returns if the given text contains placeholders for informations on the\n     * address.\n     *\n     * @param text text eventually containing markers\n     * @return true if text contains markers\n     * @exception XException if any error occurs\n     */\n    public boolean hasMarker(String text) {\n        return ((text != null) && ((text.indexOf(DEALERNUMBER) >= 0) || (text.indexOf(DEALERNAME) >= 0)));\n    }\n\n    /**\n     * Replaces all occurences of special markers. The following markers are\n     * defined for dealers:\n     * <p>\n     * <ul>\n     * <li>DEALERNUMBER\n     * <li>DEALERNAME\n     * </ul>\n     *\n     * @param text text containing markers\n     * @param address dealernumber\n     * @return text with replacements for markers\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public String replaceMarker(String text, String address) throws XException {\n        if (text.indexOf(DEALERNUMBER) >= 0) {\n            text = XStringSupport.replaceAll(text, DEALERNUMBER, address);\n        }\n        if (text.indexOf(DEALERNAME) >= 0) {\n            text = XStringSupport.replaceAll(text, DEALERNAME, getDealerName(address));\n        }\n        return text;\n    }\n\n    /**\n     * Returns the name of the dealer.\n     *\n     * @param dealernumber\n     * @return name of the dealer\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public String getDealerName(String dealernumber) throws XException {\n        return Configuration.getInstance().getValue(CHAPTER, dealernumber, \"Name\");\n    }\n\n    /**\n     * @see net.sf.xbus.base.xbussystem.AdditionalAddress#getValue(java.lang.String,\n     *      java.lang.String, java.lang.String)\n     */\n    public String getValue(String inValue, String outValue, String key) {\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/sample/DealerTest0.java",
		"test_prompt": "// DealerTest0.java\npackage net.sf.xbus.sample;\n\nimport java.util.List;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.xbussystem.AdditionalAddress;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dealer}.\n* It contains ten unit test cases for the {@link Dealer#hasMarker(String)} method.\n*/\nclass DealerTest0 {"
	},
	{
		"original_code": "// Dealer.java\npackage net.sf.xbus.sample;\n\nimport java.util.List;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.xbussystem.AdditionalAddress;\n\n/**\n * Specific data about dealers is stored in the standard configuration. This\n * convience class enables an easy access.\n */\npublic class Dealer implements AdditionalAddress {\n\n    private static final String DEALERNUMBER = \"$DEALERNUMBER$\";\n\n    private static final String DEALERNAME = \"$DEALERNAME$\";\n\n    private static final String CHAPTER = \"Dealer\";\n\n    /**\n     * Returns a list of all dealernumbers.\n     *\n     * @return list of dealernumbers\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public List getAddresses() throws XException {\n        List dealers = Configuration.getInstance().getSections(CHAPTER);\n        if (dealers != null) {\n            return dealers;\n        } else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_SAMPLE, Constants.PACKAGE_SAMPLE_SAMPLE, \"1\");\n        }\n    }\n\n    /**\n     * Returns if the given text contains placeholders for informations on the\n     * address.\n     *\n     * @param text text eventually containing markers\n     * @return true if text contains markers\n     * @exception XException if any error occurs\n     */\n    public boolean hasMarker(String text) {\n        return ((text != null) && ((text.indexOf(DEALERNUMBER) >= 0) || (text.indexOf(DEALERNAME) >= 0)));\n    }\n\n    /**\n     * Replaces all occurences of special markers. The following markers are\n     * defined for dealers:\n     * <p>\n     * <ul>\n     * <li>DEALERNUMBER\n     * <li>DEALERNAME\n     * </ul>\n     *\n     * @param text text containing markers\n     * @param address dealernumber\n     * @return text with replacements for markers\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public String replaceMarker(String text, String address) throws XException {\n        if (text.indexOf(DEALERNUMBER) >= 0) {\n            text = XStringSupport.replaceAll(text, DEALERNUMBER, address);\n        }\n        if (text.indexOf(DEALERNAME) >= 0) {\n            text = XStringSupport.replaceAll(text, DEALERNAME, getDealerName(address));\n        }\n        return text;\n    }\n\n    /**\n     * Returns the name of the dealer.\n     *\n     * @param dealernumber\n     * @return name of the dealer\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public String getDealerName(String dealernumber) throws XException {\n        return Configuration.getInstance().getValue(CHAPTER, dealernumber, \"Name\");\n    }\n\n    /**\n     * @see net.sf.xbus.base.xbussystem.AdditionalAddress#getValue(java.lang.String,\n     *      java.lang.String, java.lang.String)\n     */\n    public String getValue(String inValue, String outValue, String key) {\n        return null;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/sample/DealerTest1.java",
		"test_prompt": "// DealerTest1.java\npackage net.sf.xbus.sample;\n\nimport java.util.List;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.xbussystem.AdditionalAddress;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Dealer}.\n* It contains ten unit test cases for the {@link Dealer#replaceMarker(String, String)} method.\n*/\nclass DealerTest1 {"
	},
	{
		"original_code": "// PingSender.java\npackage net.sf.xbus.technical.misc;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\n\n/**\n * <code>PingSender</code> simply returns the data that was sent.\n * <p>\n */\npublic class PingSender implements Sender, ObjectSender {\n\n    XBUSSystem mDestination = null;\n\n    /**\n     */\n    public PingSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    /**\n     * The given object <code>callData</code> will be returned.\n     */\n    public Object execute(String function, Object callData) {\n        return callData;\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/misc/PingSenderTest.java",
		"test_prompt": "// PingSenderTest.java\npackage net.sf.xbus.technical.misc;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PingSender}.\n* It contains ten unit test cases for the {@link PingSender#execute(String, Object)} method.\n*/\nclass PingSenderTest {"
	},
	{
		"original_code": "// SimpleProgramSender.java\n/*\n * Created on 26.10.2004\n */\npackage net.sf.xbus.technical.misc;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.TextSender;\n\n/**\n * <code>SimpleProgramSender</code> calls an external program. Program name\n * and parameters are read out of the configuration. It is simple in that sense\n * that it does not support specific timeout requirements - in contrast to the\n * {@link ProgramSender}.\n *\n * @author Stephan D�wel\n */\npublic class SimpleProgramSender extends ProgramSender implements TextSender {\n\n    /**\n     * @see ProgramSender#ProgramSender(XBUSSystem)\n     */\n    public SimpleProgramSender(XBUSSystem destination) {\n        super(destination);\n    }\n\n    /**\n     * @see ProgramSender#execute(String, String)\n     * @see ProgramCaller#call()\n     */\n    public String execute(String function, String callData) throws XException {\n        String programName = getProgramName();\n        List parameters = getParameters();\n        String[] cmdarray = new String[parameters.size() + 1];\n        cmdarray[0] = programName;\n        for (int i = 0; i < parameters.size(); i++) {\n            cmdarray[i + 1] = (String) parameters.get(i);\n        }\n        // for (int i = 0; i < parameters.size(); i++)\n        StringBuffer message = new StringBuffer();\n        message.append(\"Calling:\");\n        for (int i = 0; i < cmdarray.length; i++) {\n            message.append(\" \");\n            message.append(cmdarray[i]);\n        }\n        // for (int i=0; i<cmdarray.length; i++)\n        Process proc = null;\n        try {\n            proc = Runtime.getRuntime().exec(cmdarray);\n        }// try\n         catch (Exception e) {\n            List params = new Vector(1);\n            params.add(cmdarray[0]);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MISC, \"6\", e, params);\n        }\n        // catch (Exception e)\n        InputStreamReader reader = new InputStreamReader(proc.getInputStream());\n        int character = 0;\n        byte[] ba = new byte[1];\n        String oneChar = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            while ((character = reader.read()) >= 0) {\n                ba[0] = new Integer(character).byteValue();\n                oneChar = new String(ba);\n                buffer.append(oneChar);\n                System.out.print(oneChar);\n            }\n            // while ((character = reader.read()) >= 0)\n        }// try\n         catch (IOException e) {\n            List params = new Vector(1);\n            params.add(cmdarray[0]);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MISC, \"7\", e, params);\n        } finally // catch (IOException e)\n        {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e1) {\n                    // do nothing\n                }\n            }\n        }\n        try {\n            proc.waitFor();\n        }// try\n         catch (InterruptedException e) {\n            List params = new Vector(1);\n            params.add(cmdarray[0]);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MISC, \"7\", e, params);\n        }\n        // catch (InterruptedException e)\n        return buffer.toString();\n    }\n\n    // execute(String function, String callData)\n    /**\n     * Reading the name of the program out of the configuration.The program name\n     * may contain markers for additional address information which will be\n     * replaced by their actual values.\n     *\n     * @return name ot the program to be called\n     * @throws XException if something goes wrong\n     */\n    private String getProgramName() throws XException {\n        Configuration config = Configuration.getInstance();\n        String programName = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ProgramName\");\n        programName = mDestination.replaceAllMarkers(programName)[0];\n        return programName;\n    }\n\n    // getProgramName()\n    /**\n     * Reading the the list of parameters out of the configuration. Parameters\n     * may contain markers for additional address information which will be\n     * replaced by their actual values.\n     *\n     * @return list of parameters\n     * @throws XException if something something goes wrong\n     */\n    private List getParameters() throws XException {\n        Vector parameters = new Vector();\n        Configuration config = Configuration.getInstance();\n        String parameter = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Parameter1\");\n        int i = 1;\n        while (parameter != null) {\n            i++;\n            parameter = mDestination.replaceAllMarkers(parameter)[0];\n            parameters.add(parameter);\n            parameter = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Parameter\" + i);\n        }\n        // while (parameter != null)\n        return parameters;\n    }\n    // getParameters()\n}\n// SimpleProgramSender\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/misc/SimpleProgramSenderTest.java",
		"test_prompt": "// SimpleProgramSenderTest.java\npackage net.sf.xbus.technical.misc;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.TextSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleProgramSender}.\n* It contains ten unit test cases for the {@link SimpleProgramSender#execute(String, String)} method.\n*/\nclass SimpleProgramSenderTest {"
	},
	{
		"original_code": "// ProgramSender.java\npackage net.sf.xbus.technical.misc;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.timeoutcall.TimedCallable;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\n\n/**\n * <code>ProgramSender</code> calls an external program. Program name and\n * parameters are read out of the configuration.\n */\npublic class ProgramSender implements Sender, TextSender {\n\n    protected XBUSSystem mDestination = null;\n\n    /**\n     * Stores the destination.\n     *\n     * @param destination name of the interface definition\n     * @throws XException never\n     */\n    public ProgramSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    /**\n     * Calls an external program. Program name and parameters are read out of\n     * the configuration.\n     *\n     * @param function ignored\n     * @param callData ignored\n     */\n    public String execute(String function, String callData) throws XException {\n        String retString = null;\n        Configuration config = Configuration.getInstance();\n        int timeout = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Timeout\") * 1000;\n        if (timeout == 0) {\n            timeout = Integer.MAX_VALUE;\n        }\n        ProgramCaller caller = new ProgramCaller(mDestination, callData);\n        TimedCallable tc = new TimedCallable(caller, timeout);\n        try {\n            retString = (String) tc.call();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_JAVA, \"0\", e);\n        }\n        return retString;\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.Sender#getType()\n\t */\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/misc/ProgramSenderTest.java",
		"test_prompt": "// ProgramSenderTest.java\npackage net.sf.xbus.technical.misc;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.timeoutcall.TimedCallable;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProgramSender}.\n* It contains ten unit test cases for the {@link ProgramSender#execute(String, String)} method.\n*/\nclass ProgramSenderTest {"
	},
	{
		"original_code": "// ProgramCaller.java\npackage net.sf.xbus.technical.misc;\n\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.timeoutcall.Callable;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * Used by {@link ProgramSender#execute(String, String)}together with the\n * {@link net.sf.xbus.base.core.timeoutcall.TimedCallable}to be able to stop\n * the execution of the program after a timeout.\n */\npublic class ProgramCaller implements Callable {\n\n    private XBUSSystem mDestination = null;\n\n    private Process mProcess = null;\n\n    /**\n     * Stores the destination.\n     *\n     * @param destination name of the interface definition\n     * @param callData ignored\n     */\n    public ProgramCaller(XBUSSystem destination, String callData) {\n        mDestination = destination;\n    }\n\n    /**\n     * Calls an external program. Program name and parameters are read out of\n     * the configuration.\n     */\n    public Object call() throws XException {\n        String programName = getProgramName();\n        List parameters = getParameters();\n        String[] cmdarray = new String[parameters.size() + 1];\n        cmdarray[0] = programName;\n        for (int i = 0; i < parameters.size(); i++) {\n            cmdarray[i + 1] = (String) parameters.get(i);\n        }\n        StringBuffer message = new StringBuffer();\n        message.append(\"Calling:\");\n        for (int i = 0; i < cmdarray.length; i++) {\n            message.append(\" \");\n            message.append(cmdarray[i]);\n        }\n        try {\n            mProcess = Runtime.getRuntime().exec(cmdarray);\n        } catch (Exception e) {\n            List params = new Vector(1);\n            params.add(cmdarray[0]);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MISC, \"6\", e, params);\n        }\n        // Input piped to the called process\n        List internalCommands = getProcessInputs();\n        if (internalCommands != null && internalCommands.size() > 0) {\n            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(mProcess.getOutputStream()));\n            try {\n                for (int i = 0; i < internalCommands.size(); i++) {\n                    writer.write((String) internalCommands.get(i));\n                    writer.newLine();\n                }\n                writer.flush();\n            } catch (IOException e) {\n                List params = new Vector(1);\n                params.add(cmdarray[0]);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MISC, \"7\", e, params);\n            } finally {\n                try {\n                    writer.close();\n                } catch (IOException e) {\n                    // do nothing\n                }\n            }\n        }\n        InputStreamReader reader = new InputStreamReader(mProcess.getInputStream());\n        int character = 0;\n        byte[] ba = new byte[1];\n        String oneChar = null;\n        StringBuffer buffer = new StringBuffer();\n        try {\n            while ((character = reader.read()) >= 0) {\n                ba[0] = new Integer(character).byteValue();\n                oneChar = new String(ba);\n                buffer.append(oneChar);\n                System.out.print(oneChar);\n            }\n        } catch (IOException e) {\n            List params = new Vector(1);\n            params.add(cmdarray[0]);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MISC, \"7\", e, params);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // do nothing\n            }\n        }\n        try {\n            mProcess.waitFor();\n        } catch (InterruptedException e) {\n            List params = new Vector(1);\n            params.add(cmdarray[0]);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MISC, \"7\", e, params);\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Stopping the execution of the program by destroying the program.\n     */\n    public void stop() {\n        if (mProcess != null) {\n            mProcess.destroy();\n        }\n    }\n\n    /**\n     * Reading the name of the program out of the configuration.The program name\n     * may contain markers for additional address information which will be\n     * replaced by their actual values.\n     *\n     * @return name ot the program to be called\n     * @throws XException if something goes wrong\n     */\n    private String getProgramName() throws XException {\n        Configuration config = Configuration.getInstance();\n        String programName = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ProgramName\");\n        programName = mDestination.replaceAllMarkers(programName)[0];\n        return programName;\n    }\n\n    /**\n     * Reading the the list of parameters out of the configuration. Parameters\n     * may contain markers for additional address information which will be\n     * replaced by their actual values.\n     *\n     * @return list of parameters\n     * @throws XException if something something goes wrong\n     */\n    private List getParameters() throws XException {\n        Vector parameters = new Vector();\n        Configuration config = Configuration.getInstance();\n        String parameter = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Parameter1\");\n        int i = 1;\n        while (parameter != null) {\n            i++;\n            parameter = mDestination.replaceAllMarkers(parameter)[0];\n            parameters.add(parameter);\n            parameter = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Parameter\" + i);\n        }\n        return parameters;\n    }\n\n    /**\n     * @return\n     */\n    private List getProcessInputs() throws XException {\n        Vector processInputs = new Vector();\n        Configuration config = Configuration.getInstance();\n        String processInput = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ProcessInput1\");\n        int i = 1;\n        while (processInput != null) {\n            i++;\n            String[] pInput = mDestination.replaceAllMarkers(processInput);\n            // Array for broadcast\n            for (int j = 0; j < pInput.length; j++) processInputs.add(pInput[j]);\n            processInput = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ProcessInput\" + i);\n        }\n        return processInputs;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/misc/ProgramCallerTest.java",
		"test_prompt": "// ProgramCallerTest.java\npackage net.sf.xbus.technical.misc;\n\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.timeoutcall.Callable;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ProgramCaller}.\n* It contains ten unit test cases for the {@link ProgramCaller#call()} method.\n*/\nclass ProgramCallerTest {"
	},
	{
		"original_code": "// DatabaseSender.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\n\n/**\n * The <code>DatabaseSender</code> sends SQL-statements to a database and\n * returns the results. The request and the response are XML documents.\n * <p />\n * Please refer to the documentation about the structure of the XML documents.\n */\npublic class DatabaseSender implements Sender, ObjectSender {\n\n    private XBUSSystem mDestination = null;\n\n    /**\n     * The constructor stores the destination.\n     *\n     * @param destination definition of the interface in\n     *            <code>standard.conf</code>\n     * @throws XException never thrown\n     */\n    public DatabaseSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    /**\n     * Sends SQL statements to the database and return the results.\n     *\n     * @param function not used\n     * @param callData XML document containing SQL statements\n     * @return XML document with result when <code>callData</code> contained\n     *         <code>SELECT</code> statements, NULL otherwise\n     * @throws XException in case of errors\n     */\n    public Object execute(String function, Object callData) throws XException {\n        Document retDocument = XMLHelper.getDocumentBuilder(\"Default\", mDestination.getName()).newDocument();\n        retDocument.appendChild(retDocument.createElement(mDestination.getName()));\n        /*\n\t\t * Getting an instance of the NamedDBConnection\n\t\t */\n        Configuration config = Configuration.getInstance();\n        String connectionName = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"DBConnection\");\n        DBConnection connection = DBConnection.getInstance(connectionName);\n        /*\n\t\t * Execute the given SQL statements\n\t\t */\n        Vector statements = extractStatements((Document) callData);\n        ResultSet results = null;\n        for (Iterator it = statements.iterator(); it.hasNext(); ) {\n            String sqlStatement = (String) it.next();\n            if (sqlStatement.toUpperCase().startsWith(\"SELECT\")) {\n                /*\n\t\t\t\t * SELECT statements return a ResultSet, that is copied into a\n\t\t\t\t * XML structure\n\t\t\t\t */\n                results = connection.executeRead(sqlStatement);\n                addResultSelect(results, retDocument, sqlStatement);\n            } else {\n                /*\n\t\t\t\t * other statements alter the database content and return no\n\t\t\t\t * results\n\t\t\t\t */\n                int result = connection.executeUpdate(sqlStatement);\n                addResultUpdate(result, retDocument, sqlStatement);\n            }\n        }\n        return retDocument;\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n\n    private Vector extractStatements(Document doc) {\n        Vector retVector = new Vector();\n        String statement = null;\n        NodeList nodes = doc.getElementsByTagName(\"Statement\");\n        for (int i = 0; i < nodes.getLength(); i++) {\n            statement = XMLHelper.getNodeText(nodes.item(i));\n            if (statement != null) {\n                retVector.add(statement);\n            }\n        }\n        return retVector;\n    }\n\n    private void addResultSelect(ResultSet results, Document doc, String sqlStatement) throws XException {\n        Element statement = doc.createElement(\"Result\");\n        statement.setAttribute(\"statement\", sqlStatement);\n        doc.getDocumentElement().appendChild(statement);\n        Element record = null;\n        Element column = null;\n        String data = null;\n        Text columnData = null;\n        try {\n            ResultSetMetaData metadata = results.getMetaData();\n            while (results.next()) {\n                record = doc.createElement(\"Record\");\n                for (int i = 1; i <= metadata.getColumnCount(); i++) {\n                    String tableName = metadata.getTableName(i);\n                    if (tableName == null) {\n                        tableName = \"\";\n                    }\n                    if (tableName.equals(\"\")) {\n                        column = doc.createElement(metadata.getColumnName(i));\n                    } else {\n                        column = doc.createElement(new StringBuffer(tableName).append(\".\").append(metadata.getColumnName(i)).toString());\n                    }\n                    data = results.getString(i);\n                    if (data != null) {\n                        columnData = doc.createTextNode(data);\n                        column.appendChild(columnData);\n                    }\n                    record.appendChild(column);\n                }\n                statement.appendChild(record);\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    private void addResultUpdate(int result, Document doc, String sqlStatement) {\n        Element statement = doc.createElement(\"Result\");\n        statement.setAttribute(\"statement\", sqlStatement);\n        statement.setAttribute(\"rowcount\", new Integer(result).toString());\n        doc.getDocumentElement().appendChild(statement);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/database/DatabaseSenderTest.java",
		"test_prompt": "// DatabaseSenderTest.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DatabaseSender}.\n* It contains ten unit test cases for the {@link DatabaseSender#execute(String, Object)} method.\n*/\nclass DatabaseSenderTest {"
	},
	{
		"original_code": "// DBConnection.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\n\n/**\n * <code>DBConnection</code> manages connections to databases.\n * <p>\n *\n * It implements two Design-Patterns:\n * <ol>\n * <li><b>Singleton: </b> An instance of <code>DBConnection</code> is created\n * for every thread. This instance can be fetched with\n * <code>getInstance()</code>.</li>\n * <li><b>Facade: </b> The complexity of creating and managing a connection is\n * capsuled.</li>\n * </ol>\n */\npublic class DBConnection implements TAResource {\n\n    public static final String UNNAMED = \"UNNAMED\";\n\n    private static Hashtable mDBConnections = new Hashtable();\n\n    private static final Object classLock = DBConnection.class;\n\n    private Hashtable mPreparedStatements = new Hashtable();\n\n    private StringBuffer mDBUrl = null;\n\n    private Connection mConnection = null;\n\n    private boolean mIsOpen = false;\n\n    private String mName = null;\n\n    String mConfigChapter = null;\n\n    String mConfigSection = null;\n\n    /**\n     * The constructor is private, instances of <code>DBConnection</code> can\n     * only be generated by the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * as the key.\n     */\n    private DBConnection(String name) throws XException {\n        mName = name;\n        if (UNNAMED.equals(mName)) {\n            mConfigChapter = \"Connection\";\n            mConfigSection = \"Database\";\n        } else {\n            mConfigChapter = \"DBConnection\";\n            mConfigSection = mName;\n        }\n        Configuration config = Configuration.getInstance();\n        String driver = config.getValue(mConfigChapter, mConfigSection, \"Driver\");\n        String url = config.getValueOptional(mConfigChapter, mConfigSection, \"URL\");\n        mDBUrl = new StringBuffer();\n        if (url != null) {\n            mDBUrl.append(url);\n        } else {\n            String prefix = config.getValue(mConfigChapter, mConfigSection, \"URLPrefix\");\n            String host = config.getValueOptional(mConfigChapter, mConfigSection, \"Host\");\n            String port = config.getValueOptional(mConfigChapter, mConfigSection, \"Port\");\n            String database = config.getValueOptional(mConfigChapter, mConfigSection, \"Database\");\n            mDBUrl.append(prefix);\n            if (host != null) {\n                mDBUrl.append(\"://\").append(host);\n            }\n            if (port != null) {\n                mDBUrl.append(\":\").append(port);\n            }\n            if (database != null) {\n                mDBUrl.append(\"/\").append(database);\n            }\n        }\n        ReflectionSupport.classForName(driver);\n        open();\n        mDBConnections.put(getFullName(mName), this);\n        /*\n\t\t * DBConnection will only be registered in TAManager when AutoCommit =\n\t\t * false\n\t\t */\n        if (!config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\")) {\n            TAManager.getInstance().registerResource(this);\n        }\n    }\n\n    /**\n     * Delivers an instance of <code>DBConnection</code>.\n     * <p>\n     *\n     * If it is the first call for the actual thread, a new\n     * <code>DBConnection</code> -object gets created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     */\n    public static DBConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            DBConnection dbConnection = (DBConnection) mDBConnections.get(getFullName(name));\n            if (dbConnection == null) {\n                dbConnection = new DBConnection(name);\n            }\n            return dbConnection;\n        }\n    }\n\n    /**\n     * Opens the connection to the database.\n     */\n    public void open() throws XException {\n        if (!mIsOpen) {\n            try {\n                Configuration config = Configuration.getInstance();\n                String user = config.getValueOptional(mConfigChapter, mConfigSection, \"User\");\n                if (user != null) {\n                    String password = config.getValue(mConfigChapter, mConfigSection, \"Password\");\n                    mConnection = DriverManager.getConnection(mDBUrl.toString(), user, password);\n                } else {\n                    mConnection = DriverManager.getConnection(mDBUrl.toString());\n                }\n                mConnection.setAutoCommit(config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\"));\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n            mIsOpen = true;\n        }\n    }\n\n    public void close() throws XException {\n        if (mIsOpen) {\n            try {\n                mConnection.close();\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Commits all actions on the database.\n     */\n    public void commit() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.commit();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Performs a rollback for all actions on the database.\n     */\n    public void rollback() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.rollback();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Reopens a database connection after an error has been detected. All\n     * internal variables are initialized.\n     */\n    public void reopen() throws XException {\n        mIsOpen = false;\n        mPreparedStatements.clear();\n        open();\n    }\n\n    /**\n     * Executes a SQL statement to read data.\n     *\n     * @param statement SQL statement to read data\n     * @return set of read rows\n     * @throws XException if something goes wrong\n     */\n    public ResultSet executeRead(String statement) throws XException {\n        Configuration config = Configuration.getInstance();\n        Statement stmt = null;\n        try {\n            stmt = mConnection.createStatement();\n            int maxRows = config.getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                stmt.setMaxRows(maxRows);\n            }\n            ResultSet results = stmt.executeQuery(statement);\n            return results;\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes an update, insert or delete statement.\n     *\n     * @param statement SQL statement to update, insert or delete rows\n     * @return number of rows affected\n     * @throws XException if something goes wrong\n     */\n    public int executeUpdate(String statement) throws XException {\n        Statement stmt = null;\n        int result;\n        try {\n            stmt = mConnection.createStatement();\n            result = stmt.executeUpdate(statement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        } finally {\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (SQLException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Stores the given SQL statement as a prepared statement under the given\n     * name.\n     */\n    public void prepareStatement(Object name, String statement) throws XException {\n        try {\n            PreparedStatement pStatement = mConnection.prepareStatement(statement);\n            mPreparedStatements.put(name, pStatement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a string value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, String value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setString(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds an integer value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, int value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setInt(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a null value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param type the type of the column (see <code>java.sql.Types</code>)\n     */\n    public void bindNull(Object name, int pos, int type) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setNull(pos, type);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return number of affected rows\n     */\n    public int executeUpdatePrepared(Object name) throws XException {\n        int result;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            result = pStatement.executeUpdate();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @return the ResultSet for the query\n     */\n    public ResultSet executeReadPrepared(Object name) throws XException {\n        ResultSet result = null;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            int maxRows = Configuration.getInstance().getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                pStatement.setMaxRows(maxRows);\n            }\n            result = pStatement.executeQuery();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Tests if a prepared statement is stored.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return true if the prepared statement exists\n     */\n    public boolean existsPrepared(Object name) {\n        return mPreparedStatements.containsKey(name);\n    }\n\n    static public void clear() {\n        mDBConnections.clear();\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n\n    /**\n     * Returns the complete URL of the DBConnection\n     */\n    public String getUrl() {\n        return mDBUrl.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/database/DBConnectionTest0.java",
		"test_prompt": "// DBConnectionTest0.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DBConnection}.\n* It contains ten unit test cases for the {@link DBConnection#getInstance(String)} method.\n*/\nclass DBConnectionTest0 {"
	},
	{
		"original_code": "// DBConnection.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\n\n/**\n * <code>DBConnection</code> manages connections to databases.\n * <p>\n *\n * It implements two Design-Patterns:\n * <ol>\n * <li><b>Singleton: </b> An instance of <code>DBConnection</code> is created\n * for every thread. This instance can be fetched with\n * <code>getInstance()</code>.</li>\n * <li><b>Facade: </b> The complexity of creating and managing a connection is\n * capsuled.</li>\n * </ol>\n */\npublic class DBConnection implements TAResource {\n\n    public static final String UNNAMED = \"UNNAMED\";\n\n    private static Hashtable mDBConnections = new Hashtable();\n\n    private static final Object classLock = DBConnection.class;\n\n    private Hashtable mPreparedStatements = new Hashtable();\n\n    private StringBuffer mDBUrl = null;\n\n    private Connection mConnection = null;\n\n    private boolean mIsOpen = false;\n\n    private String mName = null;\n\n    String mConfigChapter = null;\n\n    String mConfigSection = null;\n\n    /**\n     * The constructor is private, instances of <code>DBConnection</code> can\n     * only be generated by the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * as the key.\n     */\n    private DBConnection(String name) throws XException {\n        mName = name;\n        if (UNNAMED.equals(mName)) {\n            mConfigChapter = \"Connection\";\n            mConfigSection = \"Database\";\n        } else {\n            mConfigChapter = \"DBConnection\";\n            mConfigSection = mName;\n        }\n        Configuration config = Configuration.getInstance();\n        String driver = config.getValue(mConfigChapter, mConfigSection, \"Driver\");\n        String url = config.getValueOptional(mConfigChapter, mConfigSection, \"URL\");\n        mDBUrl = new StringBuffer();\n        if (url != null) {\n            mDBUrl.append(url);\n        } else {\n            String prefix = config.getValue(mConfigChapter, mConfigSection, \"URLPrefix\");\n            String host = config.getValueOptional(mConfigChapter, mConfigSection, \"Host\");\n            String port = config.getValueOptional(mConfigChapter, mConfigSection, \"Port\");\n            String database = config.getValueOptional(mConfigChapter, mConfigSection, \"Database\");\n            mDBUrl.append(prefix);\n            if (host != null) {\n                mDBUrl.append(\"://\").append(host);\n            }\n            if (port != null) {\n                mDBUrl.append(\":\").append(port);\n            }\n            if (database != null) {\n                mDBUrl.append(\"/\").append(database);\n            }\n        }\n        ReflectionSupport.classForName(driver);\n        open();\n        mDBConnections.put(getFullName(mName), this);\n        /*\n\t\t * DBConnection will only be registered in TAManager when AutoCommit =\n\t\t * false\n\t\t */\n        if (!config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\")) {\n            TAManager.getInstance().registerResource(this);\n        }\n    }\n\n    /**\n     * Delivers an instance of <code>DBConnection</code>.\n     * <p>\n     *\n     * If it is the first call for the actual thread, a new\n     * <code>DBConnection</code> -object gets created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     */\n    public static DBConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            DBConnection dbConnection = (DBConnection) mDBConnections.get(getFullName(name));\n            if (dbConnection == null) {\n                dbConnection = new DBConnection(name);\n            }\n            return dbConnection;\n        }\n    }\n\n    /**\n     * Opens the connection to the database.\n     */\n    public void open() throws XException {\n        if (!mIsOpen) {\n            try {\n                Configuration config = Configuration.getInstance();\n                String user = config.getValueOptional(mConfigChapter, mConfigSection, \"User\");\n                if (user != null) {\n                    String password = config.getValue(mConfigChapter, mConfigSection, \"Password\");\n                    mConnection = DriverManager.getConnection(mDBUrl.toString(), user, password);\n                } else {\n                    mConnection = DriverManager.getConnection(mDBUrl.toString());\n                }\n                mConnection.setAutoCommit(config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\"));\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n            mIsOpen = true;\n        }\n    }\n\n    public void close() throws XException {\n        if (mIsOpen) {\n            try {\n                mConnection.close();\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Commits all actions on the database.\n     */\n    public void commit() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.commit();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Performs a rollback for all actions on the database.\n     */\n    public void rollback() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.rollback();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Reopens a database connection after an error has been detected. All\n     * internal variables are initialized.\n     */\n    public void reopen() throws XException {\n        mIsOpen = false;\n        mPreparedStatements.clear();\n        open();\n    }\n\n    /**\n     * Executes a SQL statement to read data.\n     *\n     * @param statement SQL statement to read data\n     * @return set of read rows\n     * @throws XException if something goes wrong\n     */\n    public ResultSet executeRead(String statement) throws XException {\n        Configuration config = Configuration.getInstance();\n        Statement stmt = null;\n        try {\n            stmt = mConnection.createStatement();\n            int maxRows = config.getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                stmt.setMaxRows(maxRows);\n            }\n            ResultSet results = stmt.executeQuery(statement);\n            return results;\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes an update, insert or delete statement.\n     *\n     * @param statement SQL statement to update, insert or delete rows\n     * @return number of rows affected\n     * @throws XException if something goes wrong\n     */\n    public int executeUpdate(String statement) throws XException {\n        Statement stmt = null;\n        int result;\n        try {\n            stmt = mConnection.createStatement();\n            result = stmt.executeUpdate(statement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        } finally {\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (SQLException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Stores the given SQL statement as a prepared statement under the given\n     * name.\n     */\n    public void prepareStatement(Object name, String statement) throws XException {\n        try {\n            PreparedStatement pStatement = mConnection.prepareStatement(statement);\n            mPreparedStatements.put(name, pStatement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a string value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, String value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setString(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds an integer value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, int value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setInt(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a null value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param type the type of the column (see <code>java.sql.Types</code>)\n     */\n    public void bindNull(Object name, int pos, int type) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setNull(pos, type);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return number of affected rows\n     */\n    public int executeUpdatePrepared(Object name) throws XException {\n        int result;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            result = pStatement.executeUpdate();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @return the ResultSet for the query\n     */\n    public ResultSet executeReadPrepared(Object name) throws XException {\n        ResultSet result = null;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            int maxRows = Configuration.getInstance().getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                pStatement.setMaxRows(maxRows);\n            }\n            result = pStatement.executeQuery();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Tests if a prepared statement is stored.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return true if the prepared statement exists\n     */\n    public boolean existsPrepared(Object name) {\n        return mPreparedStatements.containsKey(name);\n    }\n\n    static public void clear() {\n        mDBConnections.clear();\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n\n    /**\n     * Returns the complete URL of the DBConnection\n     */\n    public String getUrl() {\n        return mDBUrl.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/database/DBConnectionTest1.java",
		"test_prompt": "// DBConnectionTest1.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DBConnection}.\n* It contains ten unit test cases for the {@link DBConnection#executeRead(String)} method.\n*/\nclass DBConnectionTest1 {"
	},
	{
		"original_code": "// DBConnection.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\n\n/**\n * <code>DBConnection</code> manages connections to databases.\n * <p>\n *\n * It implements two Design-Patterns:\n * <ol>\n * <li><b>Singleton: </b> An instance of <code>DBConnection</code> is created\n * for every thread. This instance can be fetched with\n * <code>getInstance()</code>.</li>\n * <li><b>Facade: </b> The complexity of creating and managing a connection is\n * capsuled.</li>\n * </ol>\n */\npublic class DBConnection implements TAResource {\n\n    public static final String UNNAMED = \"UNNAMED\";\n\n    private static Hashtable mDBConnections = new Hashtable();\n\n    private static final Object classLock = DBConnection.class;\n\n    private Hashtable mPreparedStatements = new Hashtable();\n\n    private StringBuffer mDBUrl = null;\n\n    private Connection mConnection = null;\n\n    private boolean mIsOpen = false;\n\n    private String mName = null;\n\n    String mConfigChapter = null;\n\n    String mConfigSection = null;\n\n    /**\n     * The constructor is private, instances of <code>DBConnection</code> can\n     * only be generated by the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * as the key.\n     */\n    private DBConnection(String name) throws XException {\n        mName = name;\n        if (UNNAMED.equals(mName)) {\n            mConfigChapter = \"Connection\";\n            mConfigSection = \"Database\";\n        } else {\n            mConfigChapter = \"DBConnection\";\n            mConfigSection = mName;\n        }\n        Configuration config = Configuration.getInstance();\n        String driver = config.getValue(mConfigChapter, mConfigSection, \"Driver\");\n        String url = config.getValueOptional(mConfigChapter, mConfigSection, \"URL\");\n        mDBUrl = new StringBuffer();\n        if (url != null) {\n            mDBUrl.append(url);\n        } else {\n            String prefix = config.getValue(mConfigChapter, mConfigSection, \"URLPrefix\");\n            String host = config.getValueOptional(mConfigChapter, mConfigSection, \"Host\");\n            String port = config.getValueOptional(mConfigChapter, mConfigSection, \"Port\");\n            String database = config.getValueOptional(mConfigChapter, mConfigSection, \"Database\");\n            mDBUrl.append(prefix);\n            if (host != null) {\n                mDBUrl.append(\"://\").append(host);\n            }\n            if (port != null) {\n                mDBUrl.append(\":\").append(port);\n            }\n            if (database != null) {\n                mDBUrl.append(\"/\").append(database);\n            }\n        }\n        ReflectionSupport.classForName(driver);\n        open();\n        mDBConnections.put(getFullName(mName), this);\n        /*\n\t\t * DBConnection will only be registered in TAManager when AutoCommit =\n\t\t * false\n\t\t */\n        if (!config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\")) {\n            TAManager.getInstance().registerResource(this);\n        }\n    }\n\n    /**\n     * Delivers an instance of <code>DBConnection</code>.\n     * <p>\n     *\n     * If it is the first call for the actual thread, a new\n     * <code>DBConnection</code> -object gets created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     */\n    public static DBConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            DBConnection dbConnection = (DBConnection) mDBConnections.get(getFullName(name));\n            if (dbConnection == null) {\n                dbConnection = new DBConnection(name);\n            }\n            return dbConnection;\n        }\n    }\n\n    /**\n     * Opens the connection to the database.\n     */\n    public void open() throws XException {\n        if (!mIsOpen) {\n            try {\n                Configuration config = Configuration.getInstance();\n                String user = config.getValueOptional(mConfigChapter, mConfigSection, \"User\");\n                if (user != null) {\n                    String password = config.getValue(mConfigChapter, mConfigSection, \"Password\");\n                    mConnection = DriverManager.getConnection(mDBUrl.toString(), user, password);\n                } else {\n                    mConnection = DriverManager.getConnection(mDBUrl.toString());\n                }\n                mConnection.setAutoCommit(config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\"));\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n            mIsOpen = true;\n        }\n    }\n\n    public void close() throws XException {\n        if (mIsOpen) {\n            try {\n                mConnection.close();\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Commits all actions on the database.\n     */\n    public void commit() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.commit();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Performs a rollback for all actions on the database.\n     */\n    public void rollback() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.rollback();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Reopens a database connection after an error has been detected. All\n     * internal variables are initialized.\n     */\n    public void reopen() throws XException {\n        mIsOpen = false;\n        mPreparedStatements.clear();\n        open();\n    }\n\n    /**\n     * Executes a SQL statement to read data.\n     *\n     * @param statement SQL statement to read data\n     * @return set of read rows\n     * @throws XException if something goes wrong\n     */\n    public ResultSet executeRead(String statement) throws XException {\n        Configuration config = Configuration.getInstance();\n        Statement stmt = null;\n        try {\n            stmt = mConnection.createStatement();\n            int maxRows = config.getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                stmt.setMaxRows(maxRows);\n            }\n            ResultSet results = stmt.executeQuery(statement);\n            return results;\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes an update, insert or delete statement.\n     *\n     * @param statement SQL statement to update, insert or delete rows\n     * @return number of rows affected\n     * @throws XException if something goes wrong\n     */\n    public int executeUpdate(String statement) throws XException {\n        Statement stmt = null;\n        int result;\n        try {\n            stmt = mConnection.createStatement();\n            result = stmt.executeUpdate(statement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        } finally {\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (SQLException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Stores the given SQL statement as a prepared statement under the given\n     * name.\n     */\n    public void prepareStatement(Object name, String statement) throws XException {\n        try {\n            PreparedStatement pStatement = mConnection.prepareStatement(statement);\n            mPreparedStatements.put(name, pStatement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a string value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, String value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setString(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds an integer value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, int value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setInt(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a null value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param type the type of the column (see <code>java.sql.Types</code>)\n     */\n    public void bindNull(Object name, int pos, int type) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setNull(pos, type);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return number of affected rows\n     */\n    public int executeUpdatePrepared(Object name) throws XException {\n        int result;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            result = pStatement.executeUpdate();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @return the ResultSet for the query\n     */\n    public ResultSet executeReadPrepared(Object name) throws XException {\n        ResultSet result = null;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            int maxRows = Configuration.getInstance().getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                pStatement.setMaxRows(maxRows);\n            }\n            result = pStatement.executeQuery();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Tests if a prepared statement is stored.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return true if the prepared statement exists\n     */\n    public boolean existsPrepared(Object name) {\n        return mPreparedStatements.containsKey(name);\n    }\n\n    static public void clear() {\n        mDBConnections.clear();\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n\n    /**\n     * Returns the complete URL of the DBConnection\n     */\n    public String getUrl() {\n        return mDBUrl.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/database/DBConnectionTest2.java",
		"test_prompt": "// DBConnectionTest2.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DBConnection}.\n* It contains ten unit test cases for the {@link DBConnection#executeUpdate(String)} method.\n*/\nclass DBConnectionTest2 {"
	},
	{
		"original_code": "// DBConnection.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\n\n/**\n * <code>DBConnection</code> manages connections to databases.\n * <p>\n *\n * It implements two Design-Patterns:\n * <ol>\n * <li><b>Singleton: </b> An instance of <code>DBConnection</code> is created\n * for every thread. This instance can be fetched with\n * <code>getInstance()</code>.</li>\n * <li><b>Facade: </b> The complexity of creating and managing a connection is\n * capsuled.</li>\n * </ol>\n */\npublic class DBConnection implements TAResource {\n\n    public static final String UNNAMED = \"UNNAMED\";\n\n    private static Hashtable mDBConnections = new Hashtable();\n\n    private static final Object classLock = DBConnection.class;\n\n    private Hashtable mPreparedStatements = new Hashtable();\n\n    private StringBuffer mDBUrl = null;\n\n    private Connection mConnection = null;\n\n    private boolean mIsOpen = false;\n\n    private String mName = null;\n\n    String mConfigChapter = null;\n\n    String mConfigSection = null;\n\n    /**\n     * The constructor is private, instances of <code>DBConnection</code> can\n     * only be generated by the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * as the key.\n     */\n    private DBConnection(String name) throws XException {\n        mName = name;\n        if (UNNAMED.equals(mName)) {\n            mConfigChapter = \"Connection\";\n            mConfigSection = \"Database\";\n        } else {\n            mConfigChapter = \"DBConnection\";\n            mConfigSection = mName;\n        }\n        Configuration config = Configuration.getInstance();\n        String driver = config.getValue(mConfigChapter, mConfigSection, \"Driver\");\n        String url = config.getValueOptional(mConfigChapter, mConfigSection, \"URL\");\n        mDBUrl = new StringBuffer();\n        if (url != null) {\n            mDBUrl.append(url);\n        } else {\n            String prefix = config.getValue(mConfigChapter, mConfigSection, \"URLPrefix\");\n            String host = config.getValueOptional(mConfigChapter, mConfigSection, \"Host\");\n            String port = config.getValueOptional(mConfigChapter, mConfigSection, \"Port\");\n            String database = config.getValueOptional(mConfigChapter, mConfigSection, \"Database\");\n            mDBUrl.append(prefix);\n            if (host != null) {\n                mDBUrl.append(\"://\").append(host);\n            }\n            if (port != null) {\n                mDBUrl.append(\":\").append(port);\n            }\n            if (database != null) {\n                mDBUrl.append(\"/\").append(database);\n            }\n        }\n        ReflectionSupport.classForName(driver);\n        open();\n        mDBConnections.put(getFullName(mName), this);\n        /*\n\t\t * DBConnection will only be registered in TAManager when AutoCommit =\n\t\t * false\n\t\t */\n        if (!config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\")) {\n            TAManager.getInstance().registerResource(this);\n        }\n    }\n\n    /**\n     * Delivers an instance of <code>DBConnection</code>.\n     * <p>\n     *\n     * If it is the first call for the actual thread, a new\n     * <code>DBConnection</code> -object gets created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     */\n    public static DBConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            DBConnection dbConnection = (DBConnection) mDBConnections.get(getFullName(name));\n            if (dbConnection == null) {\n                dbConnection = new DBConnection(name);\n            }\n            return dbConnection;\n        }\n    }\n\n    /**\n     * Opens the connection to the database.\n     */\n    public void open() throws XException {\n        if (!mIsOpen) {\n            try {\n                Configuration config = Configuration.getInstance();\n                String user = config.getValueOptional(mConfigChapter, mConfigSection, \"User\");\n                if (user != null) {\n                    String password = config.getValue(mConfigChapter, mConfigSection, \"Password\");\n                    mConnection = DriverManager.getConnection(mDBUrl.toString(), user, password);\n                } else {\n                    mConnection = DriverManager.getConnection(mDBUrl.toString());\n                }\n                mConnection.setAutoCommit(config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\"));\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n            mIsOpen = true;\n        }\n    }\n\n    public void close() throws XException {\n        if (mIsOpen) {\n            try {\n                mConnection.close();\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Commits all actions on the database.\n     */\n    public void commit() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.commit();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Performs a rollback for all actions on the database.\n     */\n    public void rollback() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.rollback();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Reopens a database connection after an error has been detected. All\n     * internal variables are initialized.\n     */\n    public void reopen() throws XException {\n        mIsOpen = false;\n        mPreparedStatements.clear();\n        open();\n    }\n\n    /**\n     * Executes a SQL statement to read data.\n     *\n     * @param statement SQL statement to read data\n     * @return set of read rows\n     * @throws XException if something goes wrong\n     */\n    public ResultSet executeRead(String statement) throws XException {\n        Configuration config = Configuration.getInstance();\n        Statement stmt = null;\n        try {\n            stmt = mConnection.createStatement();\n            int maxRows = config.getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                stmt.setMaxRows(maxRows);\n            }\n            ResultSet results = stmt.executeQuery(statement);\n            return results;\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes an update, insert or delete statement.\n     *\n     * @param statement SQL statement to update, insert or delete rows\n     * @return number of rows affected\n     * @throws XException if something goes wrong\n     */\n    public int executeUpdate(String statement) throws XException {\n        Statement stmt = null;\n        int result;\n        try {\n            stmt = mConnection.createStatement();\n            result = stmt.executeUpdate(statement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        } finally {\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (SQLException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Stores the given SQL statement as a prepared statement under the given\n     * name.\n     */\n    public void prepareStatement(Object name, String statement) throws XException {\n        try {\n            PreparedStatement pStatement = mConnection.prepareStatement(statement);\n            mPreparedStatements.put(name, pStatement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a string value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, String value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setString(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds an integer value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, int value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setInt(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a null value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param type the type of the column (see <code>java.sql.Types</code>)\n     */\n    public void bindNull(Object name, int pos, int type) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setNull(pos, type);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return number of affected rows\n     */\n    public int executeUpdatePrepared(Object name) throws XException {\n        int result;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            result = pStatement.executeUpdate();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @return the ResultSet for the query\n     */\n    public ResultSet executeReadPrepared(Object name) throws XException {\n        ResultSet result = null;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            int maxRows = Configuration.getInstance().getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                pStatement.setMaxRows(maxRows);\n            }\n            result = pStatement.executeQuery();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Tests if a prepared statement is stored.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return true if the prepared statement exists\n     */\n    public boolean existsPrepared(Object name) {\n        return mPreparedStatements.containsKey(name);\n    }\n\n    static public void clear() {\n        mDBConnections.clear();\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n\n    /**\n     * Returns the complete URL of the DBConnection\n     */\n    public String getUrl() {\n        return mDBUrl.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/database/DBConnectionTest3.java",
		"test_prompt": "// DBConnectionTest3.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DBConnection}.\n* It contains ten unit test cases for the {@link DBConnection#executeUpdatePrepared(Object)} method.\n*/\nclass DBConnectionTest3 {"
	},
	{
		"original_code": "// DBConnection.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\n\n/**\n * <code>DBConnection</code> manages connections to databases.\n * <p>\n *\n * It implements two Design-Patterns:\n * <ol>\n * <li><b>Singleton: </b> An instance of <code>DBConnection</code> is created\n * for every thread. This instance can be fetched with\n * <code>getInstance()</code>.</li>\n * <li><b>Facade: </b> The complexity of creating and managing a connection is\n * capsuled.</li>\n * </ol>\n */\npublic class DBConnection implements TAResource {\n\n    public static final String UNNAMED = \"UNNAMED\";\n\n    private static Hashtable mDBConnections = new Hashtable();\n\n    private static final Object classLock = DBConnection.class;\n\n    private Hashtable mPreparedStatements = new Hashtable();\n\n    private StringBuffer mDBUrl = null;\n\n    private Connection mConnection = null;\n\n    private boolean mIsOpen = false;\n\n    private String mName = null;\n\n    String mConfigChapter = null;\n\n    String mConfigSection = null;\n\n    /**\n     * The constructor is private, instances of <code>DBConnection</code> can\n     * only be generated by the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * as the key.\n     */\n    private DBConnection(String name) throws XException {\n        mName = name;\n        if (UNNAMED.equals(mName)) {\n            mConfigChapter = \"Connection\";\n            mConfigSection = \"Database\";\n        } else {\n            mConfigChapter = \"DBConnection\";\n            mConfigSection = mName;\n        }\n        Configuration config = Configuration.getInstance();\n        String driver = config.getValue(mConfigChapter, mConfigSection, \"Driver\");\n        String url = config.getValueOptional(mConfigChapter, mConfigSection, \"URL\");\n        mDBUrl = new StringBuffer();\n        if (url != null) {\n            mDBUrl.append(url);\n        } else {\n            String prefix = config.getValue(mConfigChapter, mConfigSection, \"URLPrefix\");\n            String host = config.getValueOptional(mConfigChapter, mConfigSection, \"Host\");\n            String port = config.getValueOptional(mConfigChapter, mConfigSection, \"Port\");\n            String database = config.getValueOptional(mConfigChapter, mConfigSection, \"Database\");\n            mDBUrl.append(prefix);\n            if (host != null) {\n                mDBUrl.append(\"://\").append(host);\n            }\n            if (port != null) {\n                mDBUrl.append(\":\").append(port);\n            }\n            if (database != null) {\n                mDBUrl.append(\"/\").append(database);\n            }\n        }\n        ReflectionSupport.classForName(driver);\n        open();\n        mDBConnections.put(getFullName(mName), this);\n        /*\n\t\t * DBConnection will only be registered in TAManager when AutoCommit =\n\t\t * false\n\t\t */\n        if (!config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\")) {\n            TAManager.getInstance().registerResource(this);\n        }\n    }\n\n    /**\n     * Delivers an instance of <code>DBConnection</code>.\n     * <p>\n     *\n     * If it is the first call for the actual thread, a new\n     * <code>DBConnection</code> -object gets created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     */\n    public static DBConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            DBConnection dbConnection = (DBConnection) mDBConnections.get(getFullName(name));\n            if (dbConnection == null) {\n                dbConnection = new DBConnection(name);\n            }\n            return dbConnection;\n        }\n    }\n\n    /**\n     * Opens the connection to the database.\n     */\n    public void open() throws XException {\n        if (!mIsOpen) {\n            try {\n                Configuration config = Configuration.getInstance();\n                String user = config.getValueOptional(mConfigChapter, mConfigSection, \"User\");\n                if (user != null) {\n                    String password = config.getValue(mConfigChapter, mConfigSection, \"Password\");\n                    mConnection = DriverManager.getConnection(mDBUrl.toString(), user, password);\n                } else {\n                    mConnection = DriverManager.getConnection(mDBUrl.toString());\n                }\n                mConnection.setAutoCommit(config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\"));\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n            mIsOpen = true;\n        }\n    }\n\n    public void close() throws XException {\n        if (mIsOpen) {\n            try {\n                mConnection.close();\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Commits all actions on the database.\n     */\n    public void commit() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.commit();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Performs a rollback for all actions on the database.\n     */\n    public void rollback() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.rollback();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Reopens a database connection after an error has been detected. All\n     * internal variables are initialized.\n     */\n    public void reopen() throws XException {\n        mIsOpen = false;\n        mPreparedStatements.clear();\n        open();\n    }\n\n    /**\n     * Executes a SQL statement to read data.\n     *\n     * @param statement SQL statement to read data\n     * @return set of read rows\n     * @throws XException if something goes wrong\n     */\n    public ResultSet executeRead(String statement) throws XException {\n        Configuration config = Configuration.getInstance();\n        Statement stmt = null;\n        try {\n            stmt = mConnection.createStatement();\n            int maxRows = config.getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                stmt.setMaxRows(maxRows);\n            }\n            ResultSet results = stmt.executeQuery(statement);\n            return results;\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes an update, insert or delete statement.\n     *\n     * @param statement SQL statement to update, insert or delete rows\n     * @return number of rows affected\n     * @throws XException if something goes wrong\n     */\n    public int executeUpdate(String statement) throws XException {\n        Statement stmt = null;\n        int result;\n        try {\n            stmt = mConnection.createStatement();\n            result = stmt.executeUpdate(statement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        } finally {\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (SQLException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Stores the given SQL statement as a prepared statement under the given\n     * name.\n     */\n    public void prepareStatement(Object name, String statement) throws XException {\n        try {\n            PreparedStatement pStatement = mConnection.prepareStatement(statement);\n            mPreparedStatements.put(name, pStatement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a string value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, String value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setString(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds an integer value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, int value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setInt(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a null value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param type the type of the column (see <code>java.sql.Types</code>)\n     */\n    public void bindNull(Object name, int pos, int type) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setNull(pos, type);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return number of affected rows\n     */\n    public int executeUpdatePrepared(Object name) throws XException {\n        int result;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            result = pStatement.executeUpdate();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @return the ResultSet for the query\n     */\n    public ResultSet executeReadPrepared(Object name) throws XException {\n        ResultSet result = null;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            int maxRows = Configuration.getInstance().getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                pStatement.setMaxRows(maxRows);\n            }\n            result = pStatement.executeQuery();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Tests if a prepared statement is stored.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return true if the prepared statement exists\n     */\n    public boolean existsPrepared(Object name) {\n        return mPreparedStatements.containsKey(name);\n    }\n\n    static public void clear() {\n        mDBConnections.clear();\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n\n    /**\n     * Returns the complete URL of the DBConnection\n     */\n    public String getUrl() {\n        return mDBUrl.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/database/DBConnectionTest4.java",
		"test_prompt": "// DBConnectionTest4.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DBConnection}.\n* It contains ten unit test cases for the {@link DBConnection#executeReadPrepared(Object)} method.\n*/\nclass DBConnectionTest4 {"
	},
	{
		"original_code": "// DBConnection.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\n\n/**\n * <code>DBConnection</code> manages connections to databases.\n * <p>\n *\n * It implements two Design-Patterns:\n * <ol>\n * <li><b>Singleton: </b> An instance of <code>DBConnection</code> is created\n * for every thread. This instance can be fetched with\n * <code>getInstance()</code>.</li>\n * <li><b>Facade: </b> The complexity of creating and managing a connection is\n * capsuled.</li>\n * </ol>\n */\npublic class DBConnection implements TAResource {\n\n    public static final String UNNAMED = \"UNNAMED\";\n\n    private static Hashtable mDBConnections = new Hashtable();\n\n    private static final Object classLock = DBConnection.class;\n\n    private Hashtable mPreparedStatements = new Hashtable();\n\n    private StringBuffer mDBUrl = null;\n\n    private Connection mConnection = null;\n\n    private boolean mIsOpen = false;\n\n    private String mName = null;\n\n    String mConfigChapter = null;\n\n    String mConfigSection = null;\n\n    /**\n     * The constructor is private, instances of <code>DBConnection</code> can\n     * only be generated by the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * as the key.\n     */\n    private DBConnection(String name) throws XException {\n        mName = name;\n        if (UNNAMED.equals(mName)) {\n            mConfigChapter = \"Connection\";\n            mConfigSection = \"Database\";\n        } else {\n            mConfigChapter = \"DBConnection\";\n            mConfigSection = mName;\n        }\n        Configuration config = Configuration.getInstance();\n        String driver = config.getValue(mConfigChapter, mConfigSection, \"Driver\");\n        String url = config.getValueOptional(mConfigChapter, mConfigSection, \"URL\");\n        mDBUrl = new StringBuffer();\n        if (url != null) {\n            mDBUrl.append(url);\n        } else {\n            String prefix = config.getValue(mConfigChapter, mConfigSection, \"URLPrefix\");\n            String host = config.getValueOptional(mConfigChapter, mConfigSection, \"Host\");\n            String port = config.getValueOptional(mConfigChapter, mConfigSection, \"Port\");\n            String database = config.getValueOptional(mConfigChapter, mConfigSection, \"Database\");\n            mDBUrl.append(prefix);\n            if (host != null) {\n                mDBUrl.append(\"://\").append(host);\n            }\n            if (port != null) {\n                mDBUrl.append(\":\").append(port);\n            }\n            if (database != null) {\n                mDBUrl.append(\"/\").append(database);\n            }\n        }\n        ReflectionSupport.classForName(driver);\n        open();\n        mDBConnections.put(getFullName(mName), this);\n        /*\n\t\t * DBConnection will only be registered in TAManager when AutoCommit =\n\t\t * false\n\t\t */\n        if (!config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\")) {\n            TAManager.getInstance().registerResource(this);\n        }\n    }\n\n    /**\n     * Delivers an instance of <code>DBConnection</code>.\n     * <p>\n     *\n     * If it is the first call for the actual thread, a new\n     * <code>DBConnection</code> -object gets created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     */\n    public static DBConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            DBConnection dbConnection = (DBConnection) mDBConnections.get(getFullName(name));\n            if (dbConnection == null) {\n                dbConnection = new DBConnection(name);\n            }\n            return dbConnection;\n        }\n    }\n\n    /**\n     * Opens the connection to the database.\n     */\n    public void open() throws XException {\n        if (!mIsOpen) {\n            try {\n                Configuration config = Configuration.getInstance();\n                String user = config.getValueOptional(mConfigChapter, mConfigSection, \"User\");\n                if (user != null) {\n                    String password = config.getValue(mConfigChapter, mConfigSection, \"Password\");\n                    mConnection = DriverManager.getConnection(mDBUrl.toString(), user, password);\n                } else {\n                    mConnection = DriverManager.getConnection(mDBUrl.toString());\n                }\n                mConnection.setAutoCommit(config.getValueAsBoolean(mConfigChapter, mConfigSection, \"AutoCommit\"));\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n            mIsOpen = true;\n        }\n    }\n\n    public void close() throws XException {\n        if (mIsOpen) {\n            try {\n                mConnection.close();\n            } catch (SQLException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Commits all actions on the database.\n     */\n    public void commit() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.commit();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Performs a rollback for all actions on the database.\n     */\n    public void rollback() throws XException {\n        try {\n            if (!mConnection.getAutoCommit()) {\n                mConnection.rollback();\n            }\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Reopens a database connection after an error has been detected. All\n     * internal variables are initialized.\n     */\n    public void reopen() throws XException {\n        mIsOpen = false;\n        mPreparedStatements.clear();\n        open();\n    }\n\n    /**\n     * Executes a SQL statement to read data.\n     *\n     * @param statement SQL statement to read data\n     * @return set of read rows\n     * @throws XException if something goes wrong\n     */\n    public ResultSet executeRead(String statement) throws XException {\n        Configuration config = Configuration.getInstance();\n        Statement stmt = null;\n        try {\n            stmt = mConnection.createStatement();\n            int maxRows = config.getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                stmt.setMaxRows(maxRows);\n            }\n            ResultSet results = stmt.executeQuery(statement);\n            return results;\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes an update, insert or delete statement.\n     *\n     * @param statement SQL statement to update, insert or delete rows\n     * @return number of rows affected\n     * @throws XException if something goes wrong\n     */\n    public int executeUpdate(String statement) throws XException {\n        Statement stmt = null;\n        int result;\n        try {\n            stmt = mConnection.createStatement();\n            result = stmt.executeUpdate(statement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        } finally {\n            if (stmt != null) {\n                try {\n                    stmt.close();\n                } catch (SQLException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Stores the given SQL statement as a prepared statement under the given\n     * name.\n     */\n    public void prepareStatement(Object name, String statement) throws XException {\n        try {\n            PreparedStatement pStatement = mConnection.prepareStatement(statement);\n            mPreparedStatements.put(name, pStatement);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a string value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, String value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setString(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds an integer value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param value value that will be bound to the parameter\n     */\n    public void bind(Object name, int pos, int value) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setInt(pos, value);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Binds a null value to a parameter in a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @param pos position of the parameter in the prepared statement\n     * @param type the type of the column (see <code>java.sql.Types</code>)\n     */\n    public void bindNull(Object name, int pos, int type) throws XException {\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            pStatement.setNull(pos, type);\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return number of affected rows\n     */\n    public int executeUpdatePrepared(Object name) throws XException {\n        int result;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            result = pStatement.executeUpdate();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Executes a stored prepared statement.\n     *\n     * @param name the name under which the prepared statement is stored\n     * @return the ResultSet for the query\n     */\n    public ResultSet executeReadPrepared(Object name) throws XException {\n        ResultSet result = null;\n        try {\n            PreparedStatement pStatement = (PreparedStatement) mPreparedStatements.get(name);\n            if (pStatement == null) {\n                List params = new Vector();\n                params.add(name);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"7\", params);\n            }\n            int maxRows = Configuration.getInstance().getValueAsInt(mConfigChapter, mConfigSection, \"MaxRows\");\n            if (maxRows >= 0) {\n                pStatement.setMaxRows(maxRows);\n            }\n            result = pStatement.executeQuery();\n        } catch (SQLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_DATABASE, \"0\", e);\n        }\n        return result;\n    }\n\n    /**\n     * Tests if a prepared statement is stored.\n     *\n     * @param name the name under which the prepared statement is stored\n     *\n     * @return true if the prepared statement exists\n     */\n    public boolean existsPrepared(Object name) {\n        return mPreparedStatements.containsKey(name);\n    }\n\n    static public void clear() {\n        mDBConnections.clear();\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n\n    /**\n     * Returns the complete URL of the DBConnection\n     */\n    public String getUrl() {\n        return mDBUrl.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/database/DBConnectionTest5.java",
		"test_prompt": "// DBConnectionTest5.java\npackage net.sf.xbus.technical.database;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DBConnection}.\n* It contains ten unit test cases for the {@link DBConnection#existsPrepared(Object)} method.\n*/\nclass DBConnectionTest5 {"
	},
	{
		"original_code": "// FTPConnection.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\n\n/**\n * <code>FTPConnection</code> manages connections to FTP servers and provide\n * methods for read and write access of files via FTP.\n */\npublic class FTPConnection {\n\n    static final private String CHAPTER_FTPCONNECTION = \"FTPConnection\";\n\n    /*\n\t * Variables used to implement the Singleton pattern\n\t */\n    private static Hashtable mFTPConnections = new Hashtable();\n\n    private static final Object classLock = FTPConnection.class;\n\n    /*\n\t * Other variables\n\t */\n    private String mName = null;\n\n    private FTPClient mFTPClient = null;\n\n    private boolean mOpen = false;\n\n    private String mHost = null;\n\n    private int mPort = 0;\n\n    /**\n     * The constructor is private, instances of <code>FTPConnection</code> can\n     * only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the concatenation of\n     * the thread name and the connection name as the key.\n     */\n    private FTPConnection(String name) {\n        mName = name;\n        mFTPConnections.put(getFullName(name), this);\n    }\n\n    /**\n     * Delivers an open instance of <code>FTPConnection</code>.\n     * <p />\n     *\n     * If it is the first call with this name for the actual thread, a new\n     * <code>FTPConnection</code> object will be created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     *\n     * @param name\n     *            name of the FTPConnection\n     * @return an open FTPConnection\n     * @throws XException\n     *             if something goes wrong\n     */\n    public static FTPConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            FTPConnection ftpConnection = (FTPConnection) mFTPConnections.get(getFullName(name));\n            if (ftpConnection == null) {\n                ftpConnection = new FTPConnection(name);\n            }\n            ftpConnection.open(false);\n            return ftpConnection;\n        }\n    }\n\n    /**\n     * Opens a connection to a FTP server, does the login and sets the file\n     * type.\n     *\n     * @param force\n     *            Forces the connection to be opened\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void open(boolean force) throws XException {\n        if ((!mOpen) || force) {\n            mFTPClient = new FTPClient();\n            /*\n\t\t\t * Connect to the FTP Server\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            mHost = config.getValue(CHAPTER_FTPCONNECTION, mName, \"Host\");\n            mPort = config.getValueAsIntOptional(CHAPTER_FTPCONNECTION, mName, \"Port\");\n            try {\n                if (mPort > 0) {\n                    mFTPClient.connect(mHost, mPort);\n                } else {\n                    mFTPClient.connect(mHost);\n                }\n                int reply = getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    close();\n                    Vector params = new Vector(2);\n                    params.add(mHost);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"1\", params);\n                }\n                mOpen = true;\n                /*\n\t\t\t\t * Login to the FTP server\n\t\t\t\t */\n                String user = config.getValue(CHAPTER_FTPCONNECTION, mName, \"User\");\n                String password = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Password\");\n                String account = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Account\");\n                boolean successful = false;\n                if (account == null) {\n                    successful = mFTPClient.login(user, password);\n                } else {\n                    successful = mFTPClient.login(user, password, account);\n                }\n                if (!successful) {\n                    close();\n                    Vector params = new Vector(3);\n                    params.add(mHost);\n                    params.add(user);\n                    if (account == null) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                    } else {\n                        params.add(user);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"3\", params);\n                    }\n                }\n                /*\n\t\t\t\t * Set the file type\n\t\t\t\t */\n                int fileTypeInt = 0;\n                String fileTypeString = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"FileType\");\n                if (fileTypeString == null) {\n                    fileTypeString = \"ASCII\";\n                }\n                if (fileTypeString.toUpperCase().equals(\"ASCII\")) {\n                    fileTypeInt = FTP.ASCII_FILE_TYPE;\n                } else if (fileTypeString.toUpperCase().equals(\"BINARY\")) {\n                    fileTypeInt = FTP.BINARY_FILE_TYPE;\n                } else {\n                    close();\n                    Vector params = new Vector(1);\n                    params.add(fileTypeString);\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                }\n                mFTPClient.setFileType(fileTypeInt);\n            } catch (XException e) {\n                close();\n                throw e;\n            } catch (SocketException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            } catch (IOException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Closes the connection to the FTP server\n     */\n    public void close() {\n        if (mOpen) {\n            try {\n                if (mFTPClient != null) {\n                    mFTPClient.disconnect();\n                }\n            } catch (Exception e) {\n                Trace.warn(\"Cannot disconnect from FTP server for connection \" + mName);\n            }\n        }\n        mOpen = false;\n    }\n\n    /**\n     * Returns the reply code send by the FTP server after an operation\n     */\n    private int getReplyCode() {\n        return mFTPClient.getReplyCode();\n    }\n\n    /**\n     * Returns the reply string send by the FTP server after an operation\n     */\n    private String getReplyString() {\n        return mFTPClient.getReplyString();\n    }\n\n    /**\n     * Retrieves the content of a file from the FTP server.\n     *\n     * @param workDir\n     *            working directory where the file is stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @return content of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public String retrieveFile(String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            boolean successful = mFTPClient.retrieveFile(fileName, outStream);\n            if (!successful) {\n                outStream.close();\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"5\", params);\n            }\n            String retString = outStream.toString(encoding);\n            outStream.close();\n            return retString;\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDirInternal(String workDir) throws FTPException, IOException {\n        if (!mFTPClient.changeWorkingDirectory(workDir)) {\n            throw new FTPException();\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDir(String workDir) throws XException {\n        try {\n            if (workDir != null) {\n                changeWorkDirInternal(workDir);\n            }\n        } catch (Exception e1) {\n            try {\n                /*\n\t\t\t\t * Reopen connection and try a second time\n\t\t\t\t */\n                Trace.warn(\"FTP connection may be gone, will try a second time\");\n                open(true);\n                changeWorkDirInternal(workDir);\n            } catch (FTPException e) {\n                Vector params = new Vector(1);\n                params.add(workDir);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"12\", params);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\");\n            }\n        }\n    }\n\n    /**\n     * Writes the given data to a file on the FTP server. Existing files will be\n     * overwritten.\n     *\n     * @param data\n     *            new content of the file on the server\n     * @param workDir\n     *            working directory where the file shall be stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the working directory doesn't\n     *             exist\n     */\n    public void storeFile(String data, String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayInputStream inStream = new ByteArrayInputStream(data.getBytes(encoding));\n            boolean successful = mFTPClient.storeFile(fileName, inStream);\n            inStream.close();\n            if (!successful) {\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"9\", params);\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Renames a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fromFile\n     *            old name of the file, without any directory information\n     * @param toFile\n     *            new name of the file, without any directory information\n     * @throws XException\n     *             if something goes wrong, e.g. the <code>fromFile</code>\n     *             doesn't exist\n     */\n    public void rename(String workDir, String fromFile, String toFile) throws XException {\n        try {\n            changeWorkDir(workDir);\n            boolean successful = mFTPClient.rename(fromFile, toFile);\n            if (!successful) {\n                Vector params = new Vector(3);\n                params.add(fromFile);\n                params.add(toFile);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"7\", params);\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Deletes a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file that shall be deleted, without any directory\n     *            information\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public void delete(String workDir, String fileName) throws XException {\n        if (mOpen) {\n            try {\n                changeWorkDir(workDir);\n                boolean successful = mFTPClient.deleteFile(fileName);\n                if (!successful) {\n                    Vector params = new Vector(2);\n                    params.add(fileName);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"8\", params);\n                }\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Checks if a file exists on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return <code>true</code> if the file exists, <code>false</code> if\n     *         not\n     * @throws XException\n     *             if something goes wrong\n     */\n    public boolean existsFile(String workDir, String fileName) throws XException {\n        try {\n            changeWorkDir(workDir);\n            String[] files = mFTPClient.listNames(fileName);\n            if ((files != null) && (files.length == 1) && (fileName.equals(files[0]))) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Returns a string containing host, port, working directory and name of the\n     * file, mainly used for tracing.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return string as described above\n     */\n    public String getFTPName(String workDir, String fileName) {\n        StringBuffer buffer = new StringBuffer(\"ftp://\").append(mHost);\n        if (mPort > 0) {\n            buffer.append(\":\").append(mPort);\n        }\n        if (workDir != null) {\n            buffer.append(workDir);\n        }\n        buffer.append(\"/\");\n        buffer.append(fileName);\n        return buffer.toString();\n    }\n\n    /**\n     * Extracts the name of the directory from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the directory with leading slash, <code>null</code> if\n     *         the name doesn't contain any directory information\n     */\n    static public String getWorkingDirectory(String name) {\n        String workDir = null;\n        int index = 0;\n        if ((index = name.lastIndexOf(\"/\")) >= 0) {\n            workDir = name.substring(0, index);\n        }\n        if ((workDir != null) && (!workDir.startsWith(\"/\"))) {\n            StringBuffer newWorkDir = new StringBuffer(workDir.length() + 1);\n            newWorkDir.append(\"/\").append(workDir);\n            workDir = newWorkDir.toString();\n        }\n        return workDir;\n    }\n\n    /**\n     * Extracts the name of the file itself from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the file itself\n     * @throws XException\n     *             if the name of the file can't be extracted, e.g. the given\n     *             name ends with a slash\n     */\n    static public String getFileName(String name) throws XException {\n        String fileName = null;\n        int index = 0;\n        int lastPos = name.length() - 1;\n        if ((index = name.lastIndexOf(\"/\")) < 0) {\n            /*\n\t\t\t * no slash => no directory\n\t\t\t */\n            fileName = name;\n        } else {\n            if (index < lastPos) {\n                /*\n\t\t\t\t * There is at least one character after the slash\n\t\t\t\t */\n                fileName = name.substring(index + 1);\n            }\n        }\n        if (fileName == null) {\n            Vector params = new Vector(1);\n            params.add(name);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"11\", params);\n        }\n        return fileName;\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ftp/FTPConnectionTest0.java",
		"test_prompt": "// FTPConnectionTest0.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPConnection}.\n* It contains ten unit test cases for the {@link FTPConnection#getInstance(String)} method.\n*/\nclass FTPConnectionTest0 {"
	},
	{
		"original_code": "// FTPConnection.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\n\n/**\n * <code>FTPConnection</code> manages connections to FTP servers and provide\n * methods for read and write access of files via FTP.\n */\npublic class FTPConnection {\n\n    static final private String CHAPTER_FTPCONNECTION = \"FTPConnection\";\n\n    /*\n\t * Variables used to implement the Singleton pattern\n\t */\n    private static Hashtable mFTPConnections = new Hashtable();\n\n    private static final Object classLock = FTPConnection.class;\n\n    /*\n\t * Other variables\n\t */\n    private String mName = null;\n\n    private FTPClient mFTPClient = null;\n\n    private boolean mOpen = false;\n\n    private String mHost = null;\n\n    private int mPort = 0;\n\n    /**\n     * The constructor is private, instances of <code>FTPConnection</code> can\n     * only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the concatenation of\n     * the thread name and the connection name as the key.\n     */\n    private FTPConnection(String name) {\n        mName = name;\n        mFTPConnections.put(getFullName(name), this);\n    }\n\n    /**\n     * Delivers an open instance of <code>FTPConnection</code>.\n     * <p />\n     *\n     * If it is the first call with this name for the actual thread, a new\n     * <code>FTPConnection</code> object will be created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     *\n     * @param name\n     *            name of the FTPConnection\n     * @return an open FTPConnection\n     * @throws XException\n     *             if something goes wrong\n     */\n    public static FTPConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            FTPConnection ftpConnection = (FTPConnection) mFTPConnections.get(getFullName(name));\n            if (ftpConnection == null) {\n                ftpConnection = new FTPConnection(name);\n            }\n            ftpConnection.open(false);\n            return ftpConnection;\n        }\n    }\n\n    /**\n     * Opens a connection to a FTP server, does the login and sets the file\n     * type.\n     *\n     * @param force\n     *            Forces the connection to be opened\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void open(boolean force) throws XException {\n        if ((!mOpen) || force) {\n            mFTPClient = new FTPClient();\n            /*\n\t\t\t * Connect to the FTP Server\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            mHost = config.getValue(CHAPTER_FTPCONNECTION, mName, \"Host\");\n            mPort = config.getValueAsIntOptional(CHAPTER_FTPCONNECTION, mName, \"Port\");\n            try {\n                if (mPort > 0) {\n                    mFTPClient.connect(mHost, mPort);\n                } else {\n                    mFTPClient.connect(mHost);\n                }\n                int reply = getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    close();\n                    Vector params = new Vector(2);\n                    params.add(mHost);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"1\", params);\n                }\n                mOpen = true;\n                /*\n\t\t\t\t * Login to the FTP server\n\t\t\t\t */\n                String user = config.getValue(CHAPTER_FTPCONNECTION, mName, \"User\");\n                String password = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Password\");\n                String account = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Account\");\n                boolean successful = false;\n                if (account == null) {\n                    successful = mFTPClient.login(user, password);\n                } else {\n                    successful = mFTPClient.login(user, password, account);\n                }\n                if (!successful) {\n                    close();\n                    Vector params = new Vector(3);\n                    params.add(mHost);\n                    params.add(user);\n                    if (account == null) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                    } else {\n                        params.add(user);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"3\", params);\n                    }\n                }\n                /*\n\t\t\t\t * Set the file type\n\t\t\t\t */\n                int fileTypeInt = 0;\n                String fileTypeString = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"FileType\");\n                if (fileTypeString == null) {\n                    fileTypeString = \"ASCII\";\n                }\n                if (fileTypeString.toUpperCase().equals(\"ASCII\")) {\n                    fileTypeInt = FTP.ASCII_FILE_TYPE;\n                } else if (fileTypeString.toUpperCase().equals(\"BINARY\")) {\n                    fileTypeInt = FTP.BINARY_FILE_TYPE;\n                } else {\n                    close();\n                    Vector params = new Vector(1);\n                    params.add(fileTypeString);\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                }\n                mFTPClient.setFileType(fileTypeInt);\n            } catch (XException e) {\n                close();\n                throw e;\n            } catch (SocketException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            } catch (IOException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Closes the connection to the FTP server\n     */\n    public void close() {\n        if (mOpen) {\n            try {\n                if (mFTPClient != null) {\n                    mFTPClient.disconnect();\n                }\n            } catch (Exception e) {\n                Trace.warn(\"Cannot disconnect from FTP server for connection \" + mName);\n            }\n        }\n        mOpen = false;\n    }\n\n    /**\n     * Returns the reply code send by the FTP server after an operation\n     */\n    private int getReplyCode() {\n        return mFTPClient.getReplyCode();\n    }\n\n    /**\n     * Returns the reply string send by the FTP server after an operation\n     */\n    private String getReplyString() {\n        return mFTPClient.getReplyString();\n    }\n\n    /**\n     * Retrieves the content of a file from the FTP server.\n     *\n     * @param workDir\n     *            working directory where the file is stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @return content of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public String retrieveFile(String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            boolean successful = mFTPClient.retrieveFile(fileName, outStream);\n            if (!successful) {\n                outStream.close();\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"5\", params);\n            }\n            String retString = outStream.toString(encoding);\n            outStream.close();\n            return retString;\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDirInternal(String workDir) throws FTPException, IOException {\n        if (!mFTPClient.changeWorkingDirectory(workDir)) {\n            throw new FTPException();\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDir(String workDir) throws XException {\n        try {\n            if (workDir != null) {\n                changeWorkDirInternal(workDir);\n            }\n        } catch (Exception e1) {\n            try {\n                /*\n\t\t\t\t * Reopen connection and try a second time\n\t\t\t\t */\n                Trace.warn(\"FTP connection may be gone, will try a second time\");\n                open(true);\n                changeWorkDirInternal(workDir);\n            } catch (FTPException e) {\n                Vector params = new Vector(1);\n                params.add(workDir);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"12\", params);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\");\n            }\n        }\n    }\n\n    /**\n     * Writes the given data to a file on the FTP server. Existing files will be\n     * overwritten.\n     *\n     * @param data\n     *            new content of the file on the server\n     * @param workDir\n     *            working directory where the file shall be stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the working directory doesn't\n     *             exist\n     */\n    public void storeFile(String data, String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayInputStream inStream = new ByteArrayInputStream(data.getBytes(encoding));\n            boolean successful = mFTPClient.storeFile(fileName, inStream);\n            inStream.close();\n            if (!successful) {\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"9\", params);\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Renames a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fromFile\n     *            old name of the file, without any directory information\n     * @param toFile\n     *            new name of the file, without any directory information\n     * @throws XException\n     *             if something goes wrong, e.g. the <code>fromFile</code>\n     *             doesn't exist\n     */\n    public void rename(String workDir, String fromFile, String toFile) throws XException {\n        try {\n            changeWorkDir(workDir);\n            boolean successful = mFTPClient.rename(fromFile, toFile);\n            if (!successful) {\n                Vector params = new Vector(3);\n                params.add(fromFile);\n                params.add(toFile);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"7\", params);\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Deletes a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file that shall be deleted, without any directory\n     *            information\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public void delete(String workDir, String fileName) throws XException {\n        if (mOpen) {\n            try {\n                changeWorkDir(workDir);\n                boolean successful = mFTPClient.deleteFile(fileName);\n                if (!successful) {\n                    Vector params = new Vector(2);\n                    params.add(fileName);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"8\", params);\n                }\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Checks if a file exists on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return <code>true</code> if the file exists, <code>false</code> if\n     *         not\n     * @throws XException\n     *             if something goes wrong\n     */\n    public boolean existsFile(String workDir, String fileName) throws XException {\n        try {\n            changeWorkDir(workDir);\n            String[] files = mFTPClient.listNames(fileName);\n            if ((files != null) && (files.length == 1) && (fileName.equals(files[0]))) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Returns a string containing host, port, working directory and name of the\n     * file, mainly used for tracing.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return string as described above\n     */\n    public String getFTPName(String workDir, String fileName) {\n        StringBuffer buffer = new StringBuffer(\"ftp://\").append(mHost);\n        if (mPort > 0) {\n            buffer.append(\":\").append(mPort);\n        }\n        if (workDir != null) {\n            buffer.append(workDir);\n        }\n        buffer.append(\"/\");\n        buffer.append(fileName);\n        return buffer.toString();\n    }\n\n    /**\n     * Extracts the name of the directory from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the directory with leading slash, <code>null</code> if\n     *         the name doesn't contain any directory information\n     */\n    static public String getWorkingDirectory(String name) {\n        String workDir = null;\n        int index = 0;\n        if ((index = name.lastIndexOf(\"/\")) >= 0) {\n            workDir = name.substring(0, index);\n        }\n        if ((workDir != null) && (!workDir.startsWith(\"/\"))) {\n            StringBuffer newWorkDir = new StringBuffer(workDir.length() + 1);\n            newWorkDir.append(\"/\").append(workDir);\n            workDir = newWorkDir.toString();\n        }\n        return workDir;\n    }\n\n    /**\n     * Extracts the name of the file itself from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the file itself\n     * @throws XException\n     *             if the name of the file can't be extracted, e.g. the given\n     *             name ends with a slash\n     */\n    static public String getFileName(String name) throws XException {\n        String fileName = null;\n        int index = 0;\n        int lastPos = name.length() - 1;\n        if ((index = name.lastIndexOf(\"/\")) < 0) {\n            /*\n\t\t\t * no slash => no directory\n\t\t\t */\n            fileName = name;\n        } else {\n            if (index < lastPos) {\n                /*\n\t\t\t\t * There is at least one character after the slash\n\t\t\t\t */\n                fileName = name.substring(index + 1);\n            }\n        }\n        if (fileName == null) {\n            Vector params = new Vector(1);\n            params.add(name);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"11\", params);\n        }\n        return fileName;\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ftp/FTPConnectionTest1.java",
		"test_prompt": "// FTPConnectionTest1.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPConnection}.\n* It contains ten unit test cases for the {@link FTPConnection#retrieveFile(String, String, String)} method.\n*/\nclass FTPConnectionTest1 {"
	},
	{
		"original_code": "// FTPConnection.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\n\n/**\n * <code>FTPConnection</code> manages connections to FTP servers and provide\n * methods for read and write access of files via FTP.\n */\npublic class FTPConnection {\n\n    static final private String CHAPTER_FTPCONNECTION = \"FTPConnection\";\n\n    /*\n\t * Variables used to implement the Singleton pattern\n\t */\n    private static Hashtable mFTPConnections = new Hashtable();\n\n    private static final Object classLock = FTPConnection.class;\n\n    /*\n\t * Other variables\n\t */\n    private String mName = null;\n\n    private FTPClient mFTPClient = null;\n\n    private boolean mOpen = false;\n\n    private String mHost = null;\n\n    private int mPort = 0;\n\n    /**\n     * The constructor is private, instances of <code>FTPConnection</code> can\n     * only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the concatenation of\n     * the thread name and the connection name as the key.\n     */\n    private FTPConnection(String name) {\n        mName = name;\n        mFTPConnections.put(getFullName(name), this);\n    }\n\n    /**\n     * Delivers an open instance of <code>FTPConnection</code>.\n     * <p />\n     *\n     * If it is the first call with this name for the actual thread, a new\n     * <code>FTPConnection</code> object will be created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     *\n     * @param name\n     *            name of the FTPConnection\n     * @return an open FTPConnection\n     * @throws XException\n     *             if something goes wrong\n     */\n    public static FTPConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            FTPConnection ftpConnection = (FTPConnection) mFTPConnections.get(getFullName(name));\n            if (ftpConnection == null) {\n                ftpConnection = new FTPConnection(name);\n            }\n            ftpConnection.open(false);\n            return ftpConnection;\n        }\n    }\n\n    /**\n     * Opens a connection to a FTP server, does the login and sets the file\n     * type.\n     *\n     * @param force\n     *            Forces the connection to be opened\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void open(boolean force) throws XException {\n        if ((!mOpen) || force) {\n            mFTPClient = new FTPClient();\n            /*\n\t\t\t * Connect to the FTP Server\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            mHost = config.getValue(CHAPTER_FTPCONNECTION, mName, \"Host\");\n            mPort = config.getValueAsIntOptional(CHAPTER_FTPCONNECTION, mName, \"Port\");\n            try {\n                if (mPort > 0) {\n                    mFTPClient.connect(mHost, mPort);\n                } else {\n                    mFTPClient.connect(mHost);\n                }\n                int reply = getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    close();\n                    Vector params = new Vector(2);\n                    params.add(mHost);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"1\", params);\n                }\n                mOpen = true;\n                /*\n\t\t\t\t * Login to the FTP server\n\t\t\t\t */\n                String user = config.getValue(CHAPTER_FTPCONNECTION, mName, \"User\");\n                String password = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Password\");\n                String account = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Account\");\n                boolean successful = false;\n                if (account == null) {\n                    successful = mFTPClient.login(user, password);\n                } else {\n                    successful = mFTPClient.login(user, password, account);\n                }\n                if (!successful) {\n                    close();\n                    Vector params = new Vector(3);\n                    params.add(mHost);\n                    params.add(user);\n                    if (account == null) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                    } else {\n                        params.add(user);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"3\", params);\n                    }\n                }\n                /*\n\t\t\t\t * Set the file type\n\t\t\t\t */\n                int fileTypeInt = 0;\n                String fileTypeString = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"FileType\");\n                if (fileTypeString == null) {\n                    fileTypeString = \"ASCII\";\n                }\n                if (fileTypeString.toUpperCase().equals(\"ASCII\")) {\n                    fileTypeInt = FTP.ASCII_FILE_TYPE;\n                } else if (fileTypeString.toUpperCase().equals(\"BINARY\")) {\n                    fileTypeInt = FTP.BINARY_FILE_TYPE;\n                } else {\n                    close();\n                    Vector params = new Vector(1);\n                    params.add(fileTypeString);\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                }\n                mFTPClient.setFileType(fileTypeInt);\n            } catch (XException e) {\n                close();\n                throw e;\n            } catch (SocketException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            } catch (IOException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Closes the connection to the FTP server\n     */\n    public void close() {\n        if (mOpen) {\n            try {\n                if (mFTPClient != null) {\n                    mFTPClient.disconnect();\n                }\n            } catch (Exception e) {\n                Trace.warn(\"Cannot disconnect from FTP server for connection \" + mName);\n            }\n        }\n        mOpen = false;\n    }\n\n    /**\n     * Returns the reply code send by the FTP server after an operation\n     */\n    private int getReplyCode() {\n        return mFTPClient.getReplyCode();\n    }\n\n    /**\n     * Returns the reply string send by the FTP server after an operation\n     */\n    private String getReplyString() {\n        return mFTPClient.getReplyString();\n    }\n\n    /**\n     * Retrieves the content of a file from the FTP server.\n     *\n     * @param workDir\n     *            working directory where the file is stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @return content of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public String retrieveFile(String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            boolean successful = mFTPClient.retrieveFile(fileName, outStream);\n            if (!successful) {\n                outStream.close();\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"5\", params);\n            }\n            String retString = outStream.toString(encoding);\n            outStream.close();\n            return retString;\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDirInternal(String workDir) throws FTPException, IOException {\n        if (!mFTPClient.changeWorkingDirectory(workDir)) {\n            throw new FTPException();\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDir(String workDir) throws XException {\n        try {\n            if (workDir != null) {\n                changeWorkDirInternal(workDir);\n            }\n        } catch (Exception e1) {\n            try {\n                /*\n\t\t\t\t * Reopen connection and try a second time\n\t\t\t\t */\n                Trace.warn(\"FTP connection may be gone, will try a second time\");\n                open(true);\n                changeWorkDirInternal(workDir);\n            } catch (FTPException e) {\n                Vector params = new Vector(1);\n                params.add(workDir);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"12\", params);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\");\n            }\n        }\n    }\n\n    /**\n     * Writes the given data to a file on the FTP server. Existing files will be\n     * overwritten.\n     *\n     * @param data\n     *            new content of the file on the server\n     * @param workDir\n     *            working directory where the file shall be stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the working directory doesn't\n     *             exist\n     */\n    public void storeFile(String data, String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayInputStream inStream = new ByteArrayInputStream(data.getBytes(encoding));\n            boolean successful = mFTPClient.storeFile(fileName, inStream);\n            inStream.close();\n            if (!successful) {\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"9\", params);\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Renames a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fromFile\n     *            old name of the file, without any directory information\n     * @param toFile\n     *            new name of the file, without any directory information\n     * @throws XException\n     *             if something goes wrong, e.g. the <code>fromFile</code>\n     *             doesn't exist\n     */\n    public void rename(String workDir, String fromFile, String toFile) throws XException {\n        try {\n            changeWorkDir(workDir);\n            boolean successful = mFTPClient.rename(fromFile, toFile);\n            if (!successful) {\n                Vector params = new Vector(3);\n                params.add(fromFile);\n                params.add(toFile);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"7\", params);\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Deletes a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file that shall be deleted, without any directory\n     *            information\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public void delete(String workDir, String fileName) throws XException {\n        if (mOpen) {\n            try {\n                changeWorkDir(workDir);\n                boolean successful = mFTPClient.deleteFile(fileName);\n                if (!successful) {\n                    Vector params = new Vector(2);\n                    params.add(fileName);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"8\", params);\n                }\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Checks if a file exists on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return <code>true</code> if the file exists, <code>false</code> if\n     *         not\n     * @throws XException\n     *             if something goes wrong\n     */\n    public boolean existsFile(String workDir, String fileName) throws XException {\n        try {\n            changeWorkDir(workDir);\n            String[] files = mFTPClient.listNames(fileName);\n            if ((files != null) && (files.length == 1) && (fileName.equals(files[0]))) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Returns a string containing host, port, working directory and name of the\n     * file, mainly used for tracing.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return string as described above\n     */\n    public String getFTPName(String workDir, String fileName) {\n        StringBuffer buffer = new StringBuffer(\"ftp://\").append(mHost);\n        if (mPort > 0) {\n            buffer.append(\":\").append(mPort);\n        }\n        if (workDir != null) {\n            buffer.append(workDir);\n        }\n        buffer.append(\"/\");\n        buffer.append(fileName);\n        return buffer.toString();\n    }\n\n    /**\n     * Extracts the name of the directory from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the directory with leading slash, <code>null</code> if\n     *         the name doesn't contain any directory information\n     */\n    static public String getWorkingDirectory(String name) {\n        String workDir = null;\n        int index = 0;\n        if ((index = name.lastIndexOf(\"/\")) >= 0) {\n            workDir = name.substring(0, index);\n        }\n        if ((workDir != null) && (!workDir.startsWith(\"/\"))) {\n            StringBuffer newWorkDir = new StringBuffer(workDir.length() + 1);\n            newWorkDir.append(\"/\").append(workDir);\n            workDir = newWorkDir.toString();\n        }\n        return workDir;\n    }\n\n    /**\n     * Extracts the name of the file itself from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the file itself\n     * @throws XException\n     *             if the name of the file can't be extracted, e.g. the given\n     *             name ends with a slash\n     */\n    static public String getFileName(String name) throws XException {\n        String fileName = null;\n        int index = 0;\n        int lastPos = name.length() - 1;\n        if ((index = name.lastIndexOf(\"/\")) < 0) {\n            /*\n\t\t\t * no slash => no directory\n\t\t\t */\n            fileName = name;\n        } else {\n            if (index < lastPos) {\n                /*\n\t\t\t\t * There is at least one character after the slash\n\t\t\t\t */\n                fileName = name.substring(index + 1);\n            }\n        }\n        if (fileName == null) {\n            Vector params = new Vector(1);\n            params.add(name);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"11\", params);\n        }\n        return fileName;\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ftp/FTPConnectionTest2.java",
		"test_prompt": "// FTPConnectionTest2.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPConnection}.\n* It contains ten unit test cases for the {@link FTPConnection#existsFile(String, String)} method.\n*/\nclass FTPConnectionTest2 {"
	},
	{
		"original_code": "// FTPConnection.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\n\n/**\n * <code>FTPConnection</code> manages connections to FTP servers and provide\n * methods for read and write access of files via FTP.\n */\npublic class FTPConnection {\n\n    static final private String CHAPTER_FTPCONNECTION = \"FTPConnection\";\n\n    /*\n\t * Variables used to implement the Singleton pattern\n\t */\n    private static Hashtable mFTPConnections = new Hashtable();\n\n    private static final Object classLock = FTPConnection.class;\n\n    /*\n\t * Other variables\n\t */\n    private String mName = null;\n\n    private FTPClient mFTPClient = null;\n\n    private boolean mOpen = false;\n\n    private String mHost = null;\n\n    private int mPort = 0;\n\n    /**\n     * The constructor is private, instances of <code>FTPConnection</code> can\n     * only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the concatenation of\n     * the thread name and the connection name as the key.\n     */\n    private FTPConnection(String name) {\n        mName = name;\n        mFTPConnections.put(getFullName(name), this);\n    }\n\n    /**\n     * Delivers an open instance of <code>FTPConnection</code>.\n     * <p />\n     *\n     * If it is the first call with this name for the actual thread, a new\n     * <code>FTPConnection</code> object will be created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     *\n     * @param name\n     *            name of the FTPConnection\n     * @return an open FTPConnection\n     * @throws XException\n     *             if something goes wrong\n     */\n    public static FTPConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            FTPConnection ftpConnection = (FTPConnection) mFTPConnections.get(getFullName(name));\n            if (ftpConnection == null) {\n                ftpConnection = new FTPConnection(name);\n            }\n            ftpConnection.open(false);\n            return ftpConnection;\n        }\n    }\n\n    /**\n     * Opens a connection to a FTP server, does the login and sets the file\n     * type.\n     *\n     * @param force\n     *            Forces the connection to be opened\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void open(boolean force) throws XException {\n        if ((!mOpen) || force) {\n            mFTPClient = new FTPClient();\n            /*\n\t\t\t * Connect to the FTP Server\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            mHost = config.getValue(CHAPTER_FTPCONNECTION, mName, \"Host\");\n            mPort = config.getValueAsIntOptional(CHAPTER_FTPCONNECTION, mName, \"Port\");\n            try {\n                if (mPort > 0) {\n                    mFTPClient.connect(mHost, mPort);\n                } else {\n                    mFTPClient.connect(mHost);\n                }\n                int reply = getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    close();\n                    Vector params = new Vector(2);\n                    params.add(mHost);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"1\", params);\n                }\n                mOpen = true;\n                /*\n\t\t\t\t * Login to the FTP server\n\t\t\t\t */\n                String user = config.getValue(CHAPTER_FTPCONNECTION, mName, \"User\");\n                String password = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Password\");\n                String account = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Account\");\n                boolean successful = false;\n                if (account == null) {\n                    successful = mFTPClient.login(user, password);\n                } else {\n                    successful = mFTPClient.login(user, password, account);\n                }\n                if (!successful) {\n                    close();\n                    Vector params = new Vector(3);\n                    params.add(mHost);\n                    params.add(user);\n                    if (account == null) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                    } else {\n                        params.add(user);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"3\", params);\n                    }\n                }\n                /*\n\t\t\t\t * Set the file type\n\t\t\t\t */\n                int fileTypeInt = 0;\n                String fileTypeString = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"FileType\");\n                if (fileTypeString == null) {\n                    fileTypeString = \"ASCII\";\n                }\n                if (fileTypeString.toUpperCase().equals(\"ASCII\")) {\n                    fileTypeInt = FTP.ASCII_FILE_TYPE;\n                } else if (fileTypeString.toUpperCase().equals(\"BINARY\")) {\n                    fileTypeInt = FTP.BINARY_FILE_TYPE;\n                } else {\n                    close();\n                    Vector params = new Vector(1);\n                    params.add(fileTypeString);\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                }\n                mFTPClient.setFileType(fileTypeInt);\n            } catch (XException e) {\n                close();\n                throw e;\n            } catch (SocketException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            } catch (IOException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Closes the connection to the FTP server\n     */\n    public void close() {\n        if (mOpen) {\n            try {\n                if (mFTPClient != null) {\n                    mFTPClient.disconnect();\n                }\n            } catch (Exception e) {\n                Trace.warn(\"Cannot disconnect from FTP server for connection \" + mName);\n            }\n        }\n        mOpen = false;\n    }\n\n    /**\n     * Returns the reply code send by the FTP server after an operation\n     */\n    private int getReplyCode() {\n        return mFTPClient.getReplyCode();\n    }\n\n    /**\n     * Returns the reply string send by the FTP server after an operation\n     */\n    private String getReplyString() {\n        return mFTPClient.getReplyString();\n    }\n\n    /**\n     * Retrieves the content of a file from the FTP server.\n     *\n     * @param workDir\n     *            working directory where the file is stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @return content of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public String retrieveFile(String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            boolean successful = mFTPClient.retrieveFile(fileName, outStream);\n            if (!successful) {\n                outStream.close();\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"5\", params);\n            }\n            String retString = outStream.toString(encoding);\n            outStream.close();\n            return retString;\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDirInternal(String workDir) throws FTPException, IOException {\n        if (!mFTPClient.changeWorkingDirectory(workDir)) {\n            throw new FTPException();\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDir(String workDir) throws XException {\n        try {\n            if (workDir != null) {\n                changeWorkDirInternal(workDir);\n            }\n        } catch (Exception e1) {\n            try {\n                /*\n\t\t\t\t * Reopen connection and try a second time\n\t\t\t\t */\n                Trace.warn(\"FTP connection may be gone, will try a second time\");\n                open(true);\n                changeWorkDirInternal(workDir);\n            } catch (FTPException e) {\n                Vector params = new Vector(1);\n                params.add(workDir);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"12\", params);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\");\n            }\n        }\n    }\n\n    /**\n     * Writes the given data to a file on the FTP server. Existing files will be\n     * overwritten.\n     *\n     * @param data\n     *            new content of the file on the server\n     * @param workDir\n     *            working directory where the file shall be stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the working directory doesn't\n     *             exist\n     */\n    public void storeFile(String data, String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayInputStream inStream = new ByteArrayInputStream(data.getBytes(encoding));\n            boolean successful = mFTPClient.storeFile(fileName, inStream);\n            inStream.close();\n            if (!successful) {\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"9\", params);\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Renames a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fromFile\n     *            old name of the file, without any directory information\n     * @param toFile\n     *            new name of the file, without any directory information\n     * @throws XException\n     *             if something goes wrong, e.g. the <code>fromFile</code>\n     *             doesn't exist\n     */\n    public void rename(String workDir, String fromFile, String toFile) throws XException {\n        try {\n            changeWorkDir(workDir);\n            boolean successful = mFTPClient.rename(fromFile, toFile);\n            if (!successful) {\n                Vector params = new Vector(3);\n                params.add(fromFile);\n                params.add(toFile);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"7\", params);\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Deletes a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file that shall be deleted, without any directory\n     *            information\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public void delete(String workDir, String fileName) throws XException {\n        if (mOpen) {\n            try {\n                changeWorkDir(workDir);\n                boolean successful = mFTPClient.deleteFile(fileName);\n                if (!successful) {\n                    Vector params = new Vector(2);\n                    params.add(fileName);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"8\", params);\n                }\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Checks if a file exists on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return <code>true</code> if the file exists, <code>false</code> if\n     *         not\n     * @throws XException\n     *             if something goes wrong\n     */\n    public boolean existsFile(String workDir, String fileName) throws XException {\n        try {\n            changeWorkDir(workDir);\n            String[] files = mFTPClient.listNames(fileName);\n            if ((files != null) && (files.length == 1) && (fileName.equals(files[0]))) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Returns a string containing host, port, working directory and name of the\n     * file, mainly used for tracing.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return string as described above\n     */\n    public String getFTPName(String workDir, String fileName) {\n        StringBuffer buffer = new StringBuffer(\"ftp://\").append(mHost);\n        if (mPort > 0) {\n            buffer.append(\":\").append(mPort);\n        }\n        if (workDir != null) {\n            buffer.append(workDir);\n        }\n        buffer.append(\"/\");\n        buffer.append(fileName);\n        return buffer.toString();\n    }\n\n    /**\n     * Extracts the name of the directory from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the directory with leading slash, <code>null</code> if\n     *         the name doesn't contain any directory information\n     */\n    static public String getWorkingDirectory(String name) {\n        String workDir = null;\n        int index = 0;\n        if ((index = name.lastIndexOf(\"/\")) >= 0) {\n            workDir = name.substring(0, index);\n        }\n        if ((workDir != null) && (!workDir.startsWith(\"/\"))) {\n            StringBuffer newWorkDir = new StringBuffer(workDir.length() + 1);\n            newWorkDir.append(\"/\").append(workDir);\n            workDir = newWorkDir.toString();\n        }\n        return workDir;\n    }\n\n    /**\n     * Extracts the name of the file itself from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the file itself\n     * @throws XException\n     *             if the name of the file can't be extracted, e.g. the given\n     *             name ends with a slash\n     */\n    static public String getFileName(String name) throws XException {\n        String fileName = null;\n        int index = 0;\n        int lastPos = name.length() - 1;\n        if ((index = name.lastIndexOf(\"/\")) < 0) {\n            /*\n\t\t\t * no slash => no directory\n\t\t\t */\n            fileName = name;\n        } else {\n            if (index < lastPos) {\n                /*\n\t\t\t\t * There is at least one character after the slash\n\t\t\t\t */\n                fileName = name.substring(index + 1);\n            }\n        }\n        if (fileName == null) {\n            Vector params = new Vector(1);\n            params.add(name);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"11\", params);\n        }\n        return fileName;\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ftp/FTPConnectionTest3.java",
		"test_prompt": "// FTPConnectionTest3.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPConnection}.\n* It contains ten unit test cases for the {@link FTPConnection#getWorkingDirectory(String)} method.\n*/\nclass FTPConnectionTest3 {"
	},
	{
		"original_code": "// FTPConnection.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\n\n/**\n * <code>FTPConnection</code> manages connections to FTP servers and provide\n * methods for read and write access of files via FTP.\n */\npublic class FTPConnection {\n\n    static final private String CHAPTER_FTPCONNECTION = \"FTPConnection\";\n\n    /*\n\t * Variables used to implement the Singleton pattern\n\t */\n    private static Hashtable mFTPConnections = new Hashtable();\n\n    private static final Object classLock = FTPConnection.class;\n\n    /*\n\t * Other variables\n\t */\n    private String mName = null;\n\n    private FTPClient mFTPClient = null;\n\n    private boolean mOpen = false;\n\n    private String mHost = null;\n\n    private int mPort = 0;\n\n    /**\n     * The constructor is private, instances of <code>FTPConnection</code> can\n     * only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the concatenation of\n     * the thread name and the connection name as the key.\n     */\n    private FTPConnection(String name) {\n        mName = name;\n        mFTPConnections.put(getFullName(name), this);\n    }\n\n    /**\n     * Delivers an open instance of <code>FTPConnection</code>.\n     * <p />\n     *\n     * If it is the first call with this name for the actual thread, a new\n     * <code>FTPConnection</code> object will be created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     *\n     * @param name\n     *            name of the FTPConnection\n     * @return an open FTPConnection\n     * @throws XException\n     *             if something goes wrong\n     */\n    public static FTPConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            FTPConnection ftpConnection = (FTPConnection) mFTPConnections.get(getFullName(name));\n            if (ftpConnection == null) {\n                ftpConnection = new FTPConnection(name);\n            }\n            ftpConnection.open(false);\n            return ftpConnection;\n        }\n    }\n\n    /**\n     * Opens a connection to a FTP server, does the login and sets the file\n     * type.\n     *\n     * @param force\n     *            Forces the connection to be opened\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void open(boolean force) throws XException {\n        if ((!mOpen) || force) {\n            mFTPClient = new FTPClient();\n            /*\n\t\t\t * Connect to the FTP Server\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            mHost = config.getValue(CHAPTER_FTPCONNECTION, mName, \"Host\");\n            mPort = config.getValueAsIntOptional(CHAPTER_FTPCONNECTION, mName, \"Port\");\n            try {\n                if (mPort > 0) {\n                    mFTPClient.connect(mHost, mPort);\n                } else {\n                    mFTPClient.connect(mHost);\n                }\n                int reply = getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    close();\n                    Vector params = new Vector(2);\n                    params.add(mHost);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"1\", params);\n                }\n                mOpen = true;\n                /*\n\t\t\t\t * Login to the FTP server\n\t\t\t\t */\n                String user = config.getValue(CHAPTER_FTPCONNECTION, mName, \"User\");\n                String password = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Password\");\n                String account = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"Account\");\n                boolean successful = false;\n                if (account == null) {\n                    successful = mFTPClient.login(user, password);\n                } else {\n                    successful = mFTPClient.login(user, password, account);\n                }\n                if (!successful) {\n                    close();\n                    Vector params = new Vector(3);\n                    params.add(mHost);\n                    params.add(user);\n                    if (account == null) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                    } else {\n                        params.add(user);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"3\", params);\n                    }\n                }\n                /*\n\t\t\t\t * Set the file type\n\t\t\t\t */\n                int fileTypeInt = 0;\n                String fileTypeString = config.getValueOptional(CHAPTER_FTPCONNECTION, mName, \"FileType\");\n                if (fileTypeString == null) {\n                    fileTypeString = \"ASCII\";\n                }\n                if (fileTypeString.toUpperCase().equals(\"ASCII\")) {\n                    fileTypeInt = FTP.ASCII_FILE_TYPE;\n                } else if (fileTypeString.toUpperCase().equals(\"BINARY\")) {\n                    fileTypeInt = FTP.BINARY_FILE_TYPE;\n                } else {\n                    close();\n                    Vector params = new Vector(1);\n                    params.add(fileTypeString);\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"2\", params);\n                }\n                mFTPClient.setFileType(fileTypeInt);\n            } catch (XException e) {\n                close();\n                throw e;\n            } catch (SocketException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            } catch (IOException e) {\n                close();\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Closes the connection to the FTP server\n     */\n    public void close() {\n        if (mOpen) {\n            try {\n                if (mFTPClient != null) {\n                    mFTPClient.disconnect();\n                }\n            } catch (Exception e) {\n                Trace.warn(\"Cannot disconnect from FTP server for connection \" + mName);\n            }\n        }\n        mOpen = false;\n    }\n\n    /**\n     * Returns the reply code send by the FTP server after an operation\n     */\n    private int getReplyCode() {\n        return mFTPClient.getReplyCode();\n    }\n\n    /**\n     * Returns the reply string send by the FTP server after an operation\n     */\n    private String getReplyString() {\n        return mFTPClient.getReplyString();\n    }\n\n    /**\n     * Retrieves the content of a file from the FTP server.\n     *\n     * @param workDir\n     *            working directory where the file is stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @return content of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public String retrieveFile(String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            boolean successful = mFTPClient.retrieveFile(fileName, outStream);\n            if (!successful) {\n                outStream.close();\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"5\", params);\n            }\n            String retString = outStream.toString(encoding);\n            outStream.close();\n            return retString;\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDirInternal(String workDir) throws FTPException, IOException {\n        if (!mFTPClient.changeWorkingDirectory(workDir)) {\n            throw new FTPException();\n        }\n    }\n\n    /**\n     * Changes the working directory used for file operations.\n     *\n     * @param workDir\n     *            name of the new working directory\n     * @throws XException\n     *             if something goes wrong\n     */\n    private void changeWorkDir(String workDir) throws XException {\n        try {\n            if (workDir != null) {\n                changeWorkDirInternal(workDir);\n            }\n        } catch (Exception e1) {\n            try {\n                /*\n\t\t\t\t * Reopen connection and try a second time\n\t\t\t\t */\n                Trace.warn(\"FTP connection may be gone, will try a second time\");\n                open(true);\n                changeWorkDirInternal(workDir);\n            } catch (FTPException e) {\n                Vector params = new Vector(1);\n                params.add(workDir);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"12\", params);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\");\n            }\n        }\n    }\n\n    /**\n     * Writes the given data to a file on the FTP server. Existing files will be\n     * overwritten.\n     *\n     * @param data\n     *            new content of the file on the server\n     * @param workDir\n     *            working directory where the file shall be stored, may be null\n     * @param fileName\n     *            name of the file without any directory information\n     * @param encoding\n     *            encoding of the file\n     * @throws XException\n     *             if something goes wrong, e.g. the working directory doesn't\n     *             exist\n     */\n    public void storeFile(String data, String workDir, String fileName, String encoding) throws XException {\n        try {\n            changeWorkDir(workDir);\n            ByteArrayInputStream inStream = new ByteArrayInputStream(data.getBytes(encoding));\n            boolean successful = mFTPClient.storeFile(fileName, inStream);\n            inStream.close();\n            if (!successful) {\n                Vector params = new Vector(2);\n                params.add(fileName);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"9\", params);\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Renames a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fromFile\n     *            old name of the file, without any directory information\n     * @param toFile\n     *            new name of the file, without any directory information\n     * @throws XException\n     *             if something goes wrong, e.g. the <code>fromFile</code>\n     *             doesn't exist\n     */\n    public void rename(String workDir, String fromFile, String toFile) throws XException {\n        try {\n            changeWorkDir(workDir);\n            boolean successful = mFTPClient.rename(fromFile, toFile);\n            if (!successful) {\n                Vector params = new Vector(3);\n                params.add(fromFile);\n                params.add(toFile);\n                params.add(getReplyString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"7\", params);\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Deletes a file on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file that shall be deleted, without any directory\n     *            information\n     * @throws XException\n     *             if something goes wrong, e.g. the file doesn't exist\n     */\n    public void delete(String workDir, String fileName) throws XException {\n        if (mOpen) {\n            try {\n                changeWorkDir(workDir);\n                boolean successful = mFTPClient.deleteFile(fileName);\n                if (!successful) {\n                    Vector params = new Vector(2);\n                    params.add(fileName);\n                    params.add(getReplyString());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"8\", params);\n                }\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Checks if a file exists on the FTP server.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return <code>true</code> if the file exists, <code>false</code> if\n     *         not\n     * @throws XException\n     *             if something goes wrong\n     */\n    public boolean existsFile(String workDir, String fileName) throws XException {\n        try {\n            changeWorkDir(workDir);\n            String[] files = mFTPClient.listNames(fileName);\n            if ((files != null) && (files.length == 1) && (fileName.equals(files[0]))) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"0\", e);\n        }\n    }\n\n    /**\n     * Returns a string containing host, port, working directory and name of the\n     * file, mainly used for tracing.\n     *\n     * @param workDir\n     *            working directory, may be null\n     * @param fileName\n     *            name of the file, without any directory information\n     * @return string as described above\n     */\n    public String getFTPName(String workDir, String fileName) {\n        StringBuffer buffer = new StringBuffer(\"ftp://\").append(mHost);\n        if (mPort > 0) {\n            buffer.append(\":\").append(mPort);\n        }\n        if (workDir != null) {\n            buffer.append(workDir);\n        }\n        buffer.append(\"/\");\n        buffer.append(fileName);\n        return buffer.toString();\n    }\n\n    /**\n     * Extracts the name of the directory from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the directory with leading slash, <code>null</code> if\n     *         the name doesn't contain any directory information\n     */\n    static public String getWorkingDirectory(String name) {\n        String workDir = null;\n        int index = 0;\n        if ((index = name.lastIndexOf(\"/\")) >= 0) {\n            workDir = name.substring(0, index);\n        }\n        if ((workDir != null) && (!workDir.startsWith(\"/\"))) {\n            StringBuffer newWorkDir = new StringBuffer(workDir.length() + 1);\n            newWorkDir.append(\"/\").append(workDir);\n            workDir = newWorkDir.toString();\n        }\n        return workDir;\n    }\n\n    /**\n     * Extracts the name of the file itself from a complete file name.\n     *\n     * @param name\n     *            complete name of a file, containing directory and file name\n     * @return name of the file itself\n     * @throws XException\n     *             if the name of the file can't be extracted, e.g. the given\n     *             name ends with a slash\n     */\n    static public String getFileName(String name) throws XException {\n        String fileName = null;\n        int index = 0;\n        int lastPos = name.length() - 1;\n        if ((index = name.lastIndexOf(\"/\")) < 0) {\n            /*\n\t\t\t * no slash => no directory\n\t\t\t */\n            fileName = name;\n        } else {\n            if (index < lastPos) {\n                /*\n\t\t\t\t * There is at least one character after the slash\n\t\t\t\t */\n                fileName = name.substring(index + 1);\n            }\n        }\n        if (fileName == null) {\n            Vector params = new Vector(1);\n            params.add(name);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"11\", params);\n        }\n        return fileName;\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ftp/FTPConnectionTest4.java",
		"test_prompt": "// FTPConnectionTest4.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.SocketException;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPReply;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPConnection}.\n* It contains ten unit test cases for the {@link FTPConnection#getFileName(String)} method.\n*/\nclass FTPConnectionTest4 {"
	},
	{
		"original_code": "// FTPSender.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport net.sf.xbus.technical.file.FileSenderConfiguration;\n\n/**\n * <code>FTPSender</code> sends data to neighbor systems by accessing a FTP\n * server and writing the data onto this server.\n */\npublic class FTPSender implements Sender, TextSender, TAResource {\n\n    private XBUSSystem mDestination = null;\n\n    private FTPConnection mFTPConnection = null;\n\n    private FileSenderConfiguration mConfiguration = null;\n\n    private String mWorkDir = null;\n\n    private String mFileName = null;\n\n    private String mTmpFileName = null;\n\n    private String mRenameFileName = null;\n\n    /**\n     * Indicates wether execute has been called, used in commit and rollback\n     */\n    private boolean senderExecuted = false;\n\n    /**\n     * The constructor stores the destination, registers the\n     * <code>FTPSender</code> at the {@link net.sf.xbus.base.core.TAManager}\n     * and opens the connection to the FTP server.\n     *\n     * @param destination where the data shall be send to\n     * @throws XException if something goes wrong\n     */\n    public FTPSender(XBUSSystem destination) throws XException {\n        mDestination = destination;\n        TAManager.getInstance().registerResource(this);\n        open();\n    }\n\n    /**\n     * Writes the data to the FTP server. A simple transaction logic is\n     * implemented: The data will be written to a temporary file. It will be\n     * moved to the original file name during {@link #commit}.\n     *\n     * @param function ignored\n     * @param callData data to be written\n     * @return <code>null</code>\n     * @throws XException if something goes wrong\n     */\n    public String execute(String function, String callData) throws XException {\n        senderExecuted = true;\n        /*\n\t\t * Read configuration and initialize variables\n\t\t */\n        mConfiguration = new FileSenderConfiguration(mDestination);\n        /*\n\t\t * The FileName may contain a directory. It is split up into the name of\n\t\t * the directory and the name of the file itself.\n\t\t */\n        mWorkDir = FTPConnection.getWorkingDirectory(mConfiguration.getFileNames()[0]);\n        mFileName = FTPConnection.getFileName(mConfiguration.getFileNames()[0]);\n        mTmpFileName = mFileName + \".\" + Constants.TEMP_SUFFIX;\n        mRenameFileName = mFileName + Constants.getDateAsString();\n        /*\n\t\t * if resolution is WRITE_ERROR then stop if the file is already there\n\t\t */\n        if ((mConfiguration.getResolution().equals(Constants.WRITE_ERROR)) && (mFTPConnection.existsFile(mWorkDir, mFileName))) {\n            Vector params = new Vector(1);\n            params.add(mConfiguration.getFileNames());\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FTP, \"10\", params);\n        }\n        /*\n\t\t * Delete tmpFile if it exists\n\t\t */\n        if (mFTPConnection.existsFile(mWorkDir, mTmpFileName)) {\n            mFTPConnection.delete(mWorkDir, mTmpFileName);\n        }\n        /*\n\t\t * if resolution is WRITE_APPEND and file exists, data will be appended\n\t\t */\n        if ((mConfiguration.getResolution().equals(Constants.WRITE_APPEND)) && (mFTPConnection.existsFile(mWorkDir, mFileName))) {\n            // get current data\n            StringBuffer currentData = new StringBuffer(mFTPConnection.retrieveFile(mWorkDir, mFileName, mConfiguration.getEncoding()));\n            // append linebreak if necessary\n            if ((currentData.length() > 0) && (currentData.substring(currentData.length() - 1).getBytes()[0] != Constants.NEWLINE)) {\n                currentData.append(Constants.LINE_SEPERATOR);\n            }\n            // append new data to current data and write to server as tmpFile\n            currentData.append(callData);\n            mFTPConnection.storeFile(currentData.toString(), mWorkDir, mTmpFileName, mConfiguration.getEncoding());\n        } else {\n            // write callData to server as tmpFile\n            mFTPConnection.storeFile(callData, mWorkDir, mTmpFileName, mConfiguration.getEncoding());\n        }\n        return null;\n    }\n\n    /**\n     * Opens the connection to a FTP server, using the\n     * {@link net.sf.xbus.technical.ftp.FTPConnection}.\n     */\n    public void open() throws XException {\n        String ftpName = Configuration.getInstance().getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"FTPConnection\");\n        mFTPConnection = FTPConnection.getInstance(ftpName);\n    }\n\n    /**\n     * Closes the connection to the FTP server.\n     */\n    public void close() {\n        if (mFTPConnection != null) {\n            mFTPConnection.close();\n        }\n    }\n\n    /**\n     * Renames the temporary file to the original file name. If the file already\n     * exists, it will be either deleted or renamed, depending on the\n     * <code>ConflictResolution</code>.\n     *\n     * @throws XException if something goes wrong\n     */\n    public void commit() throws XException {\n        TAManager.getInstance().removeResource(this);\n        if (senderExecuted) {\n            /*\n\t\t\t * Rename the file if it exists\n\t\t\t */\n            if (mFTPConnection.existsFile(mWorkDir, mFileName)) {\n                mFTPConnection.rename(mWorkDir, mFileName, mRenameFileName);\n            }\n            /*\n\t\t\t * Rename tmpFile to original file\n\t\t\t */\n            mFTPConnection.rename(mWorkDir, mTmpFileName, mFileName);\n            /*\n\t\t\t * Remove renamed file if resolution is not WRITE_RENAME\n\t\t\t */\n            if ((!mConfiguration.getResolution().equals(Constants.WRITE_RENAME)) && (mFTPConnection.existsFile(mWorkDir, mRenameFileName))) {\n                mFTPConnection.delete(mWorkDir, mRenameFileName);\n            }\n        }\n    }\n\n    /**\n     * Deletes the temporary file.\n     *\n     * @throws XException if something goes wrong\n     */\n    public void rollback() throws XException {\n        TAManager.getInstance().removeResource(this);\n        if (senderExecuted) {\n            /*\n\t\t\t * delete tmpFile\n\t\t\t */\n            mFTPConnection.delete(mWorkDir, mTmpFileName);\n        }\n    }\n\n    /**\n     * @see net.sf.xbus.technical.Sender#getType()\n     * @return <code>Constants.TYPE_TEXT</code>\n     */\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ftp/FTPSenderTest.java",
		"test_prompt": "// FTPSenderTest.java\npackage net.sf.xbus.technical.ftp;\n\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport net.sf.xbus.technical.file.FileSenderConfiguration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FTPSender}.\n* It contains ten unit test cases for the {@link FTPSender#execute(String, String)} method.\n*/\nclass FTPSenderTest {"
	},
	{
		"original_code": "// ReceiverThreadManager.java\npackage net.sf.xbus.technical;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * Manages the state of all receivers running in the background. This class\n * implements the Singleton design pattern.\n */\npublic class ReceiverThreadManager {\n\n    /**\n     * Default for the amount of errors, after them a receiver will be stopped.\n     */\n    // times\n    static protected final int DEFAULT_STOP_AFTER_ERRORS = -1;\n\n    private static ReceiverThreadManager mReceiverThreadManager = null;\n\n    private static final Object classLock = ReceiverThreadManager.class;\n\n    /**\n     * Contains all ReceiverThreads that has been started by the\n     * ReceiverService. Key: name of the system Entry: the ReceiverServiceThread\n     * object\n     */\n    private SortedMap mAllThreads = Collections.synchronizedSortedMap(new TreeMap());\n\n    private SortedSet mStoppedThreads = Collections.synchronizedSortedSet(new TreeSet());\n\n    private SortedSet mStoppedHTTPReceivers = Collections.synchronizedSortedSet(new TreeSet());\n\n    private boolean mIsServletEngine = false;\n\n    /**\n     * All threads for the systems will run in one ThreadGroup. This makes\n     * administration easier.\n     */\n    private ThreadGroup mThreadGroup = new ThreadGroup(\"ReceiverService\");\n\n    /**\n     * The default constructor is private because this is a singleton\n     */\n    private ReceiverThreadManager() {\n    }\n\n    /**\n     * Returns the one and only object of class\n     * <code>ReceiverThreadManager</code>.\n     *\n     * @return the one and only object of class\n     *         <code>ReceiverThreadManager</code>\n     */\n    static public ReceiverThreadManager getInstance() {\n        synchronized (classLock) {\n            if (mReceiverThreadManager == null) {\n                mReceiverThreadManager = new ReceiverThreadManager();\n            }\n            return mReceiverThreadManager;\n        }\n    }\n\n    /**\n     * Starts a ReceiverThread for the given system.\n     *\n     * @param system\n     *            the name of the system to start the receiver for\n     * @throws XException\n     *             if something goes wrong\n     */\n    public void startReceiverThread(String system) throws XException {\n        /*\n\t\t * Check if System is configured with ReceiverThread\n\t\t */\n        String receiver = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n        if ((receiver != null) && (receiver.endsWith(\"Thread\"))) {\n            /*\n\t\t\t * Check if ReceiverThread isn't already running\n\t\t\t */\n            if (getRunningReceiverThreads().contains(system)) {\n                Vector params = new Vector(1);\n                params.add(system);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_TECHNICAL, \"7\", params);\n            }\n            /*\n\t\t\t * Start receiver\n\t\t\t */\n            ReceiverThreadBase receiverThreadImpl = ReceiverFactory.createReceiverThread(receiver, system);\n            Thread receiverThread = new Thread(mThreadGroup, receiverThreadImpl, system);\n            receiverThread.setDaemon(false);\n            receiverThread.setContextClassLoader(XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n            receiverThread.start();\n            /*\n\t\t\t * Put system and thread in list of all systems and remove it from\n\t\t\t * stoppedThreads\n\t\t\t */\n            mAllThreads.put(system, receiverThreadImpl);\n            mStoppedThreads.remove(system);\n        } else if (isHTTPReceiver(system)) {\n            if (mStoppedHTTPReceivers.contains(system)) {\n                mStoppedHTTPReceivers.remove(system);\n                Trace.always(\"Starting HTTPReceiver for \" + system);\n            }\n        } else {\n            Vector params = new Vector(1);\n            params.add(system);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_TECHNICAL, \"6\", params);\n        }\n    }\n\n    /**\n     * Demands the stop of the ReceiverThread for the given <code>system</code>.\n     *\n     * @param system\n     *            the name of the system to stop the receiver for\n     * @throws XException\n     *             if something goes wrong\n     */\n    public void demandStopReceiverThread(String system) throws XException {\n        Trace.always(\"Demanding stop for \" + system);\n        if (getRunningReceiverThreads().contains(system)) {\n            ReceiverThreadBase startedThread = (ReceiverThreadBase) mAllThreads.get(system);\n            if (startedThread == null) {\n                Trace.warn(system + \" is not a started receiver\");\n                return;\n            }\n            startedThread.interruptThread();\n            mStoppedThreads.add(system);\n        } else if (getRunningHTTPReceivers().contains(system)) {\n            mStoppedHTTPReceivers.add(system);\n            Trace.always(\"HTTPReceiver for \" + system + \" stopped\");\n        } else {\n            Trace.warn(system + \" is not a started receiver\");\n            return;\n        }\n    }\n\n    /**\n     * Returns a set with the names of all ReceiverThreads found in the\n     * <code>Configuration</code>.\n     *\n     * @return the names of all ReceiverThreads found in the\n     *         <code>Configuration</code>\n     */\n    public Set getAllReceiverThreads() {\n        Set returnSet = new TreeSet();\n        returnSet.addAll(mAllThreads.keySet());\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all background receivers (ReceiverThreads\n     * and HTTPReceivers) found in the <code>Configuration</code>.\n     *\n     * @return the names of all background receivers found in the\n     *         <code>Configuration</code>\n     * @throws XException\n     *             if something goes wrong\n     */\n    public Set getAllSystems() throws XException {\n        Set returnSet = getAllReceiverThreads();\n        returnSet.addAll(getAllHTTPReceivers());\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all running background receivers\n     * (ReceiverThreads and HTTPReceivers).\n     *\n     * @return the names of all running background receivers\n     * @throws XException\n     *             if something goes wrong\n     */\n    public Set getRunningSystems() throws XException {\n        Set retSet = getRunningReceiverThreads();\n        retSet.addAll(getRunningHTTPReceivers());\n        return retSet;\n    }\n\n    /**\n     * Returns a set with the names of all running ReceiverThreads.\n     *\n     * @return the names of all running ReceiverThreads\n     */\n    public Set getRunningReceiverThreads() {\n        int threadCount = mThreadGroup.activeCount();\n        TreeSet retSet = new TreeSet();\n        Thread[] startedThreads = new Thread[threadCount];\n        mThreadGroup.enumerate(startedThreads);\n        for (int i = 0; i < threadCount; i++) {\n            if ((startedThreads[i] != null) && (mAllThreads.containsKey(startedThreads[i].getName()))) {\n                retSet.add(startedThreads[i].getName());\n            }\n        }\n        return retSet;\n    }\n\n    /**\n     * Returns a set with the names of all running HTTPReceivers.\n     *\n     * @return the names of all running HTTPReceivers\n     * @throws XException\n     *             if something goes wrong\n     */\n    protected Set getRunningHTTPReceivers() throws XException {\n        TreeSet returnSet = new TreeSet();\n        for (Iterator it = getAllHTTPReceivers().iterator(); it.hasNext(); ) {\n            Object stoppedHTTPReceiver = it.next();\n            if (!mStoppedHTTPReceivers.contains(stoppedHTTPReceiver)) {\n                returnSet.add(stoppedHTTPReceiver);\n            }\n        }\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all stopped background receivers\n     * (ReceiverThreads and HTTPReceivers).\n     *\n     * @return the names of all stopped background receivers\n     */\n    public Set getStoppedSystems() {\n        TreeSet returnSet = new TreeSet();\n        returnSet.addAll(mStoppedThreads);\n        returnSet.addAll(mStoppedHTTPReceivers);\n        return returnSet;\n    }\n\n    /**\n     * Indicates whether the ReceiverService is started inside a servlet engine.\n     *\n     * @param isServletEngine\n     *            true if the ReceiverService is running in a servlet engine\n     */\n    protected void setIsServletEngine(boolean isServletEngine) {\n        mIsServletEngine = isServletEngine;\n    }\n\n    /**\n     * Clears the list of all stopped HTTPReceivers.\n     */\n    public void clearStoppedHTTPReceivers() {\n        mStoppedHTTPReceivers.clear();\n    }\n\n    /**\n     * Returns a list of all HTTPReceivers found in the\n     * <code>Configuration</code>.\n     *\n     * @return a list of all HTTPReceivers found in the\n     *         <code>Configuration</code>\n     * @throws XException\n     *             if something goes wrong\n     */\n    private List getAllHTTPReceivers() throws XException {\n        List returnSet = new Vector();\n        if (mIsServletEngine) {\n            List systems;\n            Configuration config;\n            try {\n                config = Configuration.getInstance();\n                systems = config.getSections(Constants.CHAPTER_SYSTEM);\n            } catch (XException e) {\n                return null;\n            }\n            String system = null;\n            for (Iterator it = systems.iterator(); it.hasNext(); ) {\n                system = (String) it.next();\n                if (isHTTPReceiver(system)) {\n                    returnSet.add(system);\n                }\n            }\n        }\n        return returnSet;\n    }\n\n    private boolean isHTTPReceiver(String system) throws XException {\n        String receiver = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n        if ((receiver != null) && (receiver.startsWith(\"HTTP\"))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Indicates whether a HTTPReceiver is stopped\n     *\n     * @param system\n     *            the name of the system\n     * @return true if the HTTPReceiver is stopped, false otherwise\n     */\n    public boolean isHTTPReceiverStopped(String system) {\n        return mStoppedHTTPReceivers.contains(system);\n    }\n\n    /**\n     * Returns the amount of errors, after them a receiver will be stopped The\n     * value is read out of the configuration, either a default for the receiver\n     * class or a value specific for the current source. If no value is\n     * specified in the configuration, a hard coded default is used.\n     *\n     * @return the amount of errors, after them a receiver will be stopped\n     * @param system\n     *            the name of the system\n     * @param receiverClassName\n     *            the name of the receiver class\n     */\n    public static int getStopAfterErrors(String system, String receiverClassName) {\n        int stopAfterErrors = DEFAULT_STOP_AFTER_ERRORS;\n        try {\n            Configuration config = Configuration.getInstance();\n            stopAfterErrors = config.getValueAsIntOptional(\"System\", system, \"StopAfterErrors\");\n            if (stopAfterErrors == 0) {\n                stopAfterErrors = config.getValueAsInt(\"Base\", receiverClassName, \"StopAfterErrors\");\n            }\n        } catch (XException e) {\n            Trace.warn(\"Using default for StopAfterErrors: \" + DEFAULT_STOP_AFTER_ERRORS);\n        }\n        return stopAfterErrors;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ReceiverThreadManagerTest0.java",
		"test_prompt": "// ReceiverThreadManagerTest0.java\npackage net.sf.xbus.technical;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverThreadManager}.\n* It contains ten unit test cases for the {@link ReceiverThreadManager#getInstance()} method.\n*/\nclass ReceiverThreadManagerTest0 {"
	},
	{
		"original_code": "// ReceiverThreadManager.java\npackage net.sf.xbus.technical;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * Manages the state of all receivers running in the background. This class\n * implements the Singleton design pattern.\n */\npublic class ReceiverThreadManager {\n\n    /**\n     * Default for the amount of errors, after them a receiver will be stopped.\n     */\n    // times\n    static protected final int DEFAULT_STOP_AFTER_ERRORS = -1;\n\n    private static ReceiverThreadManager mReceiverThreadManager = null;\n\n    private static final Object classLock = ReceiverThreadManager.class;\n\n    /**\n     * Contains all ReceiverThreads that has been started by the\n     * ReceiverService. Key: name of the system Entry: the ReceiverServiceThread\n     * object\n     */\n    private SortedMap mAllThreads = Collections.synchronizedSortedMap(new TreeMap());\n\n    private SortedSet mStoppedThreads = Collections.synchronizedSortedSet(new TreeSet());\n\n    private SortedSet mStoppedHTTPReceivers = Collections.synchronizedSortedSet(new TreeSet());\n\n    private boolean mIsServletEngine = false;\n\n    /**\n     * All threads for the systems will run in one ThreadGroup. This makes\n     * administration easier.\n     */\n    private ThreadGroup mThreadGroup = new ThreadGroup(\"ReceiverService\");\n\n    /**\n     * The default constructor is private because this is a singleton\n     */\n    private ReceiverThreadManager() {\n    }\n\n    /**\n     * Returns the one and only object of class\n     * <code>ReceiverThreadManager</code>.\n     *\n     * @return the one and only object of class\n     *         <code>ReceiverThreadManager</code>\n     */\n    static public ReceiverThreadManager getInstance() {\n        synchronized (classLock) {\n            if (mReceiverThreadManager == null) {\n                mReceiverThreadManager = new ReceiverThreadManager();\n            }\n            return mReceiverThreadManager;\n        }\n    }\n\n    /**\n     * Starts a ReceiverThread for the given system.\n     *\n     * @param system\n     *            the name of the system to start the receiver for\n     * @throws XException\n     *             if something goes wrong\n     */\n    public void startReceiverThread(String system) throws XException {\n        /*\n\t\t * Check if System is configured with ReceiverThread\n\t\t */\n        String receiver = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n        if ((receiver != null) && (receiver.endsWith(\"Thread\"))) {\n            /*\n\t\t\t * Check if ReceiverThread isn't already running\n\t\t\t */\n            if (getRunningReceiverThreads().contains(system)) {\n                Vector params = new Vector(1);\n                params.add(system);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_TECHNICAL, \"7\", params);\n            }\n            /*\n\t\t\t * Start receiver\n\t\t\t */\n            ReceiverThreadBase receiverThreadImpl = ReceiverFactory.createReceiverThread(receiver, system);\n            Thread receiverThread = new Thread(mThreadGroup, receiverThreadImpl, system);\n            receiverThread.setDaemon(false);\n            receiverThread.setContextClassLoader(XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n            receiverThread.start();\n            /*\n\t\t\t * Put system and thread in list of all systems and remove it from\n\t\t\t * stoppedThreads\n\t\t\t */\n            mAllThreads.put(system, receiverThreadImpl);\n            mStoppedThreads.remove(system);\n        } else if (isHTTPReceiver(system)) {\n            if (mStoppedHTTPReceivers.contains(system)) {\n                mStoppedHTTPReceivers.remove(system);\n                Trace.always(\"Starting HTTPReceiver for \" + system);\n            }\n        } else {\n            Vector params = new Vector(1);\n            params.add(system);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_TECHNICAL, \"6\", params);\n        }\n    }\n\n    /**\n     * Demands the stop of the ReceiverThread for the given <code>system</code>.\n     *\n     * @param system\n     *            the name of the system to stop the receiver for\n     * @throws XException\n     *             if something goes wrong\n     */\n    public void demandStopReceiverThread(String system) throws XException {\n        Trace.always(\"Demanding stop for \" + system);\n        if (getRunningReceiverThreads().contains(system)) {\n            ReceiverThreadBase startedThread = (ReceiverThreadBase) mAllThreads.get(system);\n            if (startedThread == null) {\n                Trace.warn(system + \" is not a started receiver\");\n                return;\n            }\n            startedThread.interruptThread();\n            mStoppedThreads.add(system);\n        } else if (getRunningHTTPReceivers().contains(system)) {\n            mStoppedHTTPReceivers.add(system);\n            Trace.always(\"HTTPReceiver for \" + system + \" stopped\");\n        } else {\n            Trace.warn(system + \" is not a started receiver\");\n            return;\n        }\n    }\n\n    /**\n     * Returns a set with the names of all ReceiverThreads found in the\n     * <code>Configuration</code>.\n     *\n     * @return the names of all ReceiverThreads found in the\n     *         <code>Configuration</code>\n     */\n    public Set getAllReceiverThreads() {\n        Set returnSet = new TreeSet();\n        returnSet.addAll(mAllThreads.keySet());\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all background receivers (ReceiverThreads\n     * and HTTPReceivers) found in the <code>Configuration</code>.\n     *\n     * @return the names of all background receivers found in the\n     *         <code>Configuration</code>\n     * @throws XException\n     *             if something goes wrong\n     */\n    public Set getAllSystems() throws XException {\n        Set returnSet = getAllReceiverThreads();\n        returnSet.addAll(getAllHTTPReceivers());\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all running background receivers\n     * (ReceiverThreads and HTTPReceivers).\n     *\n     * @return the names of all running background receivers\n     * @throws XException\n     *             if something goes wrong\n     */\n    public Set getRunningSystems() throws XException {\n        Set retSet = getRunningReceiverThreads();\n        retSet.addAll(getRunningHTTPReceivers());\n        return retSet;\n    }\n\n    /**\n     * Returns a set with the names of all running ReceiverThreads.\n     *\n     * @return the names of all running ReceiverThreads\n     */\n    public Set getRunningReceiverThreads() {\n        int threadCount = mThreadGroup.activeCount();\n        TreeSet retSet = new TreeSet();\n        Thread[] startedThreads = new Thread[threadCount];\n        mThreadGroup.enumerate(startedThreads);\n        for (int i = 0; i < threadCount; i++) {\n            if ((startedThreads[i] != null) && (mAllThreads.containsKey(startedThreads[i].getName()))) {\n                retSet.add(startedThreads[i].getName());\n            }\n        }\n        return retSet;\n    }\n\n    /**\n     * Returns a set with the names of all running HTTPReceivers.\n     *\n     * @return the names of all running HTTPReceivers\n     * @throws XException\n     *             if something goes wrong\n     */\n    protected Set getRunningHTTPReceivers() throws XException {\n        TreeSet returnSet = new TreeSet();\n        for (Iterator it = getAllHTTPReceivers().iterator(); it.hasNext(); ) {\n            Object stoppedHTTPReceiver = it.next();\n            if (!mStoppedHTTPReceivers.contains(stoppedHTTPReceiver)) {\n                returnSet.add(stoppedHTTPReceiver);\n            }\n        }\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all stopped background receivers\n     * (ReceiverThreads and HTTPReceivers).\n     *\n     * @return the names of all stopped background receivers\n     */\n    public Set getStoppedSystems() {\n        TreeSet returnSet = new TreeSet();\n        returnSet.addAll(mStoppedThreads);\n        returnSet.addAll(mStoppedHTTPReceivers);\n        return returnSet;\n    }\n\n    /**\n     * Indicates whether the ReceiverService is started inside a servlet engine.\n     *\n     * @param isServletEngine\n     *            true if the ReceiverService is running in a servlet engine\n     */\n    protected void setIsServletEngine(boolean isServletEngine) {\n        mIsServletEngine = isServletEngine;\n    }\n\n    /**\n     * Clears the list of all stopped HTTPReceivers.\n     */\n    public void clearStoppedHTTPReceivers() {\n        mStoppedHTTPReceivers.clear();\n    }\n\n    /**\n     * Returns a list of all HTTPReceivers found in the\n     * <code>Configuration</code>.\n     *\n     * @return a list of all HTTPReceivers found in the\n     *         <code>Configuration</code>\n     * @throws XException\n     *             if something goes wrong\n     */\n    private List getAllHTTPReceivers() throws XException {\n        List returnSet = new Vector();\n        if (mIsServletEngine) {\n            List systems;\n            Configuration config;\n            try {\n                config = Configuration.getInstance();\n                systems = config.getSections(Constants.CHAPTER_SYSTEM);\n            } catch (XException e) {\n                return null;\n            }\n            String system = null;\n            for (Iterator it = systems.iterator(); it.hasNext(); ) {\n                system = (String) it.next();\n                if (isHTTPReceiver(system)) {\n                    returnSet.add(system);\n                }\n            }\n        }\n        return returnSet;\n    }\n\n    private boolean isHTTPReceiver(String system) throws XException {\n        String receiver = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n        if ((receiver != null) && (receiver.startsWith(\"HTTP\"))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Indicates whether a HTTPReceiver is stopped\n     *\n     * @param system\n     *            the name of the system\n     * @return true if the HTTPReceiver is stopped, false otherwise\n     */\n    public boolean isHTTPReceiverStopped(String system) {\n        return mStoppedHTTPReceivers.contains(system);\n    }\n\n    /**\n     * Returns the amount of errors, after them a receiver will be stopped The\n     * value is read out of the configuration, either a default for the receiver\n     * class or a value specific for the current source. If no value is\n     * specified in the configuration, a hard coded default is used.\n     *\n     * @return the amount of errors, after them a receiver will be stopped\n     * @param system\n     *            the name of the system\n     * @param receiverClassName\n     *            the name of the receiver class\n     */\n    public static int getStopAfterErrors(String system, String receiverClassName) {\n        int stopAfterErrors = DEFAULT_STOP_AFTER_ERRORS;\n        try {\n            Configuration config = Configuration.getInstance();\n            stopAfterErrors = config.getValueAsIntOptional(\"System\", system, \"StopAfterErrors\");\n            if (stopAfterErrors == 0) {\n                stopAfterErrors = config.getValueAsInt(\"Base\", receiverClassName, \"StopAfterErrors\");\n            }\n        } catch (XException e) {\n            Trace.warn(\"Using default for StopAfterErrors: \" + DEFAULT_STOP_AFTER_ERRORS);\n        }\n        return stopAfterErrors;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ReceiverThreadManagerTest1.java",
		"test_prompt": "// ReceiverThreadManagerTest1.java\npackage net.sf.xbus.technical;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverThreadManager}.\n* It contains ten unit test cases for the {@link ReceiverThreadManager#isHTTPReceiverStopped(String)} method.\n*/\nclass ReceiverThreadManagerTest1 {"
	},
	{
		"original_code": "// ReceiverThreadManager.java\npackage net.sf.xbus.technical;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * Manages the state of all receivers running in the background. This class\n * implements the Singleton design pattern.\n */\npublic class ReceiverThreadManager {\n\n    /**\n     * Default for the amount of errors, after them a receiver will be stopped.\n     */\n    // times\n    static protected final int DEFAULT_STOP_AFTER_ERRORS = -1;\n\n    private static ReceiverThreadManager mReceiverThreadManager = null;\n\n    private static final Object classLock = ReceiverThreadManager.class;\n\n    /**\n     * Contains all ReceiverThreads that has been started by the\n     * ReceiverService. Key: name of the system Entry: the ReceiverServiceThread\n     * object\n     */\n    private SortedMap mAllThreads = Collections.synchronizedSortedMap(new TreeMap());\n\n    private SortedSet mStoppedThreads = Collections.synchronizedSortedSet(new TreeSet());\n\n    private SortedSet mStoppedHTTPReceivers = Collections.synchronizedSortedSet(new TreeSet());\n\n    private boolean mIsServletEngine = false;\n\n    /**\n     * All threads for the systems will run in one ThreadGroup. This makes\n     * administration easier.\n     */\n    private ThreadGroup mThreadGroup = new ThreadGroup(\"ReceiverService\");\n\n    /**\n     * The default constructor is private because this is a singleton\n     */\n    private ReceiverThreadManager() {\n    }\n\n    /**\n     * Returns the one and only object of class\n     * <code>ReceiverThreadManager</code>.\n     *\n     * @return the one and only object of class\n     *         <code>ReceiverThreadManager</code>\n     */\n    static public ReceiverThreadManager getInstance() {\n        synchronized (classLock) {\n            if (mReceiverThreadManager == null) {\n                mReceiverThreadManager = new ReceiverThreadManager();\n            }\n            return mReceiverThreadManager;\n        }\n    }\n\n    /**\n     * Starts a ReceiverThread for the given system.\n     *\n     * @param system\n     *            the name of the system to start the receiver for\n     * @throws XException\n     *             if something goes wrong\n     */\n    public void startReceiverThread(String system) throws XException {\n        /*\n\t\t * Check if System is configured with ReceiverThread\n\t\t */\n        String receiver = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n        if ((receiver != null) && (receiver.endsWith(\"Thread\"))) {\n            /*\n\t\t\t * Check if ReceiverThread isn't already running\n\t\t\t */\n            if (getRunningReceiverThreads().contains(system)) {\n                Vector params = new Vector(1);\n                params.add(system);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_TECHNICAL, \"7\", params);\n            }\n            /*\n\t\t\t * Start receiver\n\t\t\t */\n            ReceiverThreadBase receiverThreadImpl = ReceiverFactory.createReceiverThread(receiver, system);\n            Thread receiverThread = new Thread(mThreadGroup, receiverThreadImpl, system);\n            receiverThread.setDaemon(false);\n            receiverThread.setContextClassLoader(XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n            receiverThread.start();\n            /*\n\t\t\t * Put system and thread in list of all systems and remove it from\n\t\t\t * stoppedThreads\n\t\t\t */\n            mAllThreads.put(system, receiverThreadImpl);\n            mStoppedThreads.remove(system);\n        } else if (isHTTPReceiver(system)) {\n            if (mStoppedHTTPReceivers.contains(system)) {\n                mStoppedHTTPReceivers.remove(system);\n                Trace.always(\"Starting HTTPReceiver for \" + system);\n            }\n        } else {\n            Vector params = new Vector(1);\n            params.add(system);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_TECHNICAL, \"6\", params);\n        }\n    }\n\n    /**\n     * Demands the stop of the ReceiverThread for the given <code>system</code>.\n     *\n     * @param system\n     *            the name of the system to stop the receiver for\n     * @throws XException\n     *             if something goes wrong\n     */\n    public void demandStopReceiverThread(String system) throws XException {\n        Trace.always(\"Demanding stop for \" + system);\n        if (getRunningReceiverThreads().contains(system)) {\n            ReceiverThreadBase startedThread = (ReceiverThreadBase) mAllThreads.get(system);\n            if (startedThread == null) {\n                Trace.warn(system + \" is not a started receiver\");\n                return;\n            }\n            startedThread.interruptThread();\n            mStoppedThreads.add(system);\n        } else if (getRunningHTTPReceivers().contains(system)) {\n            mStoppedHTTPReceivers.add(system);\n            Trace.always(\"HTTPReceiver for \" + system + \" stopped\");\n        } else {\n            Trace.warn(system + \" is not a started receiver\");\n            return;\n        }\n    }\n\n    /**\n     * Returns a set with the names of all ReceiverThreads found in the\n     * <code>Configuration</code>.\n     *\n     * @return the names of all ReceiverThreads found in the\n     *         <code>Configuration</code>\n     */\n    public Set getAllReceiverThreads() {\n        Set returnSet = new TreeSet();\n        returnSet.addAll(mAllThreads.keySet());\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all background receivers (ReceiverThreads\n     * and HTTPReceivers) found in the <code>Configuration</code>.\n     *\n     * @return the names of all background receivers found in the\n     *         <code>Configuration</code>\n     * @throws XException\n     *             if something goes wrong\n     */\n    public Set getAllSystems() throws XException {\n        Set returnSet = getAllReceiverThreads();\n        returnSet.addAll(getAllHTTPReceivers());\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all running background receivers\n     * (ReceiverThreads and HTTPReceivers).\n     *\n     * @return the names of all running background receivers\n     * @throws XException\n     *             if something goes wrong\n     */\n    public Set getRunningSystems() throws XException {\n        Set retSet = getRunningReceiverThreads();\n        retSet.addAll(getRunningHTTPReceivers());\n        return retSet;\n    }\n\n    /**\n     * Returns a set with the names of all running ReceiverThreads.\n     *\n     * @return the names of all running ReceiverThreads\n     */\n    public Set getRunningReceiverThreads() {\n        int threadCount = mThreadGroup.activeCount();\n        TreeSet retSet = new TreeSet();\n        Thread[] startedThreads = new Thread[threadCount];\n        mThreadGroup.enumerate(startedThreads);\n        for (int i = 0; i < threadCount; i++) {\n            if ((startedThreads[i] != null) && (mAllThreads.containsKey(startedThreads[i].getName()))) {\n                retSet.add(startedThreads[i].getName());\n            }\n        }\n        return retSet;\n    }\n\n    /**\n     * Returns a set with the names of all running HTTPReceivers.\n     *\n     * @return the names of all running HTTPReceivers\n     * @throws XException\n     *             if something goes wrong\n     */\n    protected Set getRunningHTTPReceivers() throws XException {\n        TreeSet returnSet = new TreeSet();\n        for (Iterator it = getAllHTTPReceivers().iterator(); it.hasNext(); ) {\n            Object stoppedHTTPReceiver = it.next();\n            if (!mStoppedHTTPReceivers.contains(stoppedHTTPReceiver)) {\n                returnSet.add(stoppedHTTPReceiver);\n            }\n        }\n        return returnSet;\n    }\n\n    /**\n     * Returns a set with the names of all stopped background receivers\n     * (ReceiverThreads and HTTPReceivers).\n     *\n     * @return the names of all stopped background receivers\n     */\n    public Set getStoppedSystems() {\n        TreeSet returnSet = new TreeSet();\n        returnSet.addAll(mStoppedThreads);\n        returnSet.addAll(mStoppedHTTPReceivers);\n        return returnSet;\n    }\n\n    /**\n     * Indicates whether the ReceiverService is started inside a servlet engine.\n     *\n     * @param isServletEngine\n     *            true if the ReceiverService is running in a servlet engine\n     */\n    protected void setIsServletEngine(boolean isServletEngine) {\n        mIsServletEngine = isServletEngine;\n    }\n\n    /**\n     * Clears the list of all stopped HTTPReceivers.\n     */\n    public void clearStoppedHTTPReceivers() {\n        mStoppedHTTPReceivers.clear();\n    }\n\n    /**\n     * Returns a list of all HTTPReceivers found in the\n     * <code>Configuration</code>.\n     *\n     * @return a list of all HTTPReceivers found in the\n     *         <code>Configuration</code>\n     * @throws XException\n     *             if something goes wrong\n     */\n    private List getAllHTTPReceivers() throws XException {\n        List returnSet = new Vector();\n        if (mIsServletEngine) {\n            List systems;\n            Configuration config;\n            try {\n                config = Configuration.getInstance();\n                systems = config.getSections(Constants.CHAPTER_SYSTEM);\n            } catch (XException e) {\n                return null;\n            }\n            String system = null;\n            for (Iterator it = systems.iterator(); it.hasNext(); ) {\n                system = (String) it.next();\n                if (isHTTPReceiver(system)) {\n                    returnSet.add(system);\n                }\n            }\n        }\n        return returnSet;\n    }\n\n    private boolean isHTTPReceiver(String system) throws XException {\n        String receiver = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n        if ((receiver != null) && (receiver.startsWith(\"HTTP\"))) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Indicates whether a HTTPReceiver is stopped\n     *\n     * @param system\n     *            the name of the system\n     * @return true if the HTTPReceiver is stopped, false otherwise\n     */\n    public boolean isHTTPReceiverStopped(String system) {\n        return mStoppedHTTPReceivers.contains(system);\n    }\n\n    /**\n     * Returns the amount of errors, after them a receiver will be stopped The\n     * value is read out of the configuration, either a default for the receiver\n     * class or a value specific for the current source. If no value is\n     * specified in the configuration, a hard coded default is used.\n     *\n     * @return the amount of errors, after them a receiver will be stopped\n     * @param system\n     *            the name of the system\n     * @param receiverClassName\n     *            the name of the receiver class\n     */\n    public static int getStopAfterErrors(String system, String receiverClassName) {\n        int stopAfterErrors = DEFAULT_STOP_AFTER_ERRORS;\n        try {\n            Configuration config = Configuration.getInstance();\n            stopAfterErrors = config.getValueAsIntOptional(\"System\", system, \"StopAfterErrors\");\n            if (stopAfterErrors == 0) {\n                stopAfterErrors = config.getValueAsInt(\"Base\", receiverClassName, \"StopAfterErrors\");\n            }\n        } catch (XException e) {\n            Trace.warn(\"Using default for StopAfterErrors: \" + DEFAULT_STOP_AFTER_ERRORS);\n        }\n        return stopAfterErrors;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ReceiverThreadManagerTest2.java",
		"test_prompt": "// ReceiverThreadManagerTest2.java\npackage net.sf.xbus.technical;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.XBUSClassLoader;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverThreadManager}.\n* It contains ten unit test cases for the {@link ReceiverThreadManager#getStopAfterErrors(String, String)} method.\n*/\nclass ReceiverThreadManagerTest2 {"
	},
	{
		"original_code": "// FileByteArrayListSender.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedOutputStream;\nimport java.io.FileOutputStream;\nimport java.util.Iterator;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\n\n/**\n * <code>FileByteArrayListSender</code> manages writing a\n * <code>ByteArrayList</code> on a mounted file system.\n */\npublic class FileByteArrayListSender extends FileSender implements Sender, ObjectSender {\n\n    /**\n     * Constructs a FileByteArrayListSender object giving all necessary data\n     * from the standard configuration, checking file permissions and\n     * registering current resource by the\n     * {@link net.sf.xbus.base.core.TAManager}.\n     *\n     * @exception XException if any error occurs\n     */\n    public FileByteArrayListSender(XBUSSystem system) throws XException {\n        super(system);\n    }\n\n    /**\n     * <code>execute</code> sends the given <code>ByteArrayList</code>\n     * <i>callData </i> to the neighbor-system. Three actions are possible when\n     * a file already exists:\n     * <p>\n     * <dl>\n     * <dd><table>\n     * <tr>\n     * <td><code>Append</code></td>\n     * <td></td>\n     * <td>append new data to the existing file</td>\n     * </tr>\n     * <tr>\n     * <td><code>Overwrite</code></td>\n     * <td></td>\n     * <td>overwrite existing file with the new data</td>\n     * </tr>\n     * <tr>\n     * <td><code>Error</code></td>\n     * <td></td>\n     * <td>throw XException</td>\n     * </tr>\n     * </table>\n     * </dl>\n     *\n     * @param function Name of the interface\n     * @param callData String to be written\n     * @exception XException if any error occurs\n     */\n    public Object execute(String function, Object callData) throws XException {\n        senderExecuted = true;\n        try {\n            prepareWriteFile(mConfiguration.getFileNames()[0], 0);\n            BufferedOutputStream buffOut = new BufferedOutputStream(new FileOutputStream(mTempFilename[0], true));\n            if (callData == null)\n                callData = new ByteArrayList();\n            byte[] record = null;\n            Iterator it = ((ByteArrayList) callData).iterator();\n            if (it.hasNext()) {\n                record = (byte[]) it.next();\n                buffOut.write(record);\n            }\n            while (it.hasNext()) {\n                buffOut.write(Constants.LINE_SEPERATOR.getBytes(mConfiguration.getEncoding()));\n                record = (byte[]) it.next();\n                buffOut.write(record);\n            }\n            if (Constants.LINE_SEPERATOR.equals(\"\\n\"))\n                buffOut.write('\\n');\n            buffOut.close();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        }\n        return null;\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/file/FileByteArrayListSenderTest.java",
		"test_prompt": "// FileByteArrayListSenderTest.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedOutputStream;\nimport java.io.FileOutputStream;\nimport java.util.Iterator;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileByteArrayListSender}.\n* It contains ten unit test cases for the {@link FileByteArrayListSender#execute(String, Object)} method.\n*/\nclass FileByteArrayListSenderTest {"
	},
	{
		"original_code": "// FileStreamSender.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\n\n/**\n * <code>FileStreamSender</code> gets an <code>InputStream</code> and writes\n * it into a file.\n */\npublic class FileStreamSender extends FileSender implements Sender, ObjectSender {\n\n    /**\n     * Stores the given system.\n     *\n     * @param system where the data shall be send to\n     * @throws XException\n     */\n    public FileStreamSender(XBUSSystem system) throws XException {\n        super(system);\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.ObjectSender#execute(java.lang.String,\n\t *      java.lang.Object)\n\t */\n    public Object execute(String function, Object source) throws XException {\n        senderExecuted = true;\n        InputStream inStream = (InputStream) source;\n        BufferedOutputStream buffOut = prepareOutputStream();\n        try {\n            int character = inStream.read();\n            int lastChar = -1;\n            while (character >= 0) {\n                buffOut.write(character);\n                lastChar = character;\n                character = inStream.read();\n            }\n            // while (character >= 0)\n            // Writing an end of file sign on Unix systems\n            if (Constants.LINE_SEPERATOR.equals(\"\\n\") && lastChar != '\\n') {\n                buffOut.write('\\n');\n            }\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        } finally {\n            try {\n                if (buffOut != null) {\n                    buffOut.close();\n                }\n                if (inStream != null) {\n                    inStream.close();\n                }\n            } catch (IOException e1) {\n                /*\n\t\t\t\t * do nothing\n\t\t\t\t */\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Opens a stream later used to write the incoming data into the file.\n     *\n     * @return a <code>BufferedOutputStream</code> for the temporary file\n     * @throws XException if something goes wrong\n     */\n    protected BufferedOutputStream prepareOutputStream() throws XException {\n        prepareWriteFile(mConfiguration.getFileNames()[0], 0);\n        BufferedOutputStream buffOut;\n        try {\n            buffOut = new BufferedOutputStream(new FileOutputStream(mTempFilename[0], true));\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        }\n        return buffOut;\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.Sender#getType()\n\t */\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/file/FileStreamSenderTest.java",
		"test_prompt": "// FileStreamSenderTest.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileStreamSender}.\n* It contains ten unit test cases for the {@link FileStreamSender#execute(String, Object)} method.\n*/\nclass FileStreamSenderTest {"
	},
	{
		"original_code": "// SimpleFileSender.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\n\npublic class SimpleFileSender extends FileBase implements Sender, TextSender {\n\n    protected FileSenderConfiguration mConfiguration = null;\n\n    /**\n     * Constructs a FileSender object giving all necessary data from the\n     * standard configuration, checking file permissions and registering current\n     * resource by the {@link net.sf.xbus.base.core.TAManager}.\n     *\n     * @exception XException if any error occurs\n     */\n    public SimpleFileSender(XBUSSystem system) throws XException {\n        mConfiguration = new FileSenderConfiguration(system);\n        checkFilePermissions();\n    }\n\n    public String execute(String function, String callData) throws XException {\n        BufferedWriter buffOut = prepareWriter();\n        if (callData == null) {\n            callData = \"\";\n        }\n        // write callData into the file.\n        // Characters written to it are translated into bytes\n        // according to a specified character encoding.\n        try {\n            buffOut.write(callData);\n            // Writing an end of file sign on Unix systems\n            if (Constants.LINE_SEPERATOR.equals(\"\\n\") && (callData.length() == 0 || callData.charAt(callData.length() - 1) != '\\n'))\n                buffOut.newLine();\n            buffOut.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        }\n        return null;\n    }\n\n    protected BufferedWriter prepareWriter() throws XException {\n        prepareWriteFile();\n        BufferedWriter buffOut;\n        try {\n            buffOut = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(mConfiguration.getFileNames()[0], true), mConfiguration.getEncoding()));\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        }\n        return buffOut;\n    }\n\n    protected void prepareWriteFile() throws XException {\n        if (new File(mConfiguration.getFileNames()[0]).exists()) {\n            if (mConfiguration.getResolution().equals(Constants.WRITE_OVERWRITE)) {\n                deleteFile(mConfiguration.getFileNames()[0]);\n            }\n            if (mConfiguration.getResolution().equals(Constants.WRITE_APPEND)) {\n                if (getFileLength(mConfiguration.getFileNames()[0]) > 0 && getLastByteOfFile(mConfiguration.getFileNames()[0]) != 10) {\n                    try {\n                        BufferedOutputStream buffOut = new BufferedOutputStream(new FileOutputStream(mConfiguration.getFileNames()[0], true));\n                        buffOut.write(Constants.LINE_SEPERATOR.getBytes(mConfiguration.getEncoding()));\n                        buffOut.close();\n                    } catch (Exception e) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * On the basis of the ConflictResolution (resolved action when the file\n     * already exists) having read from the standard configuration, checks this\n     * method a file on an opportunity to meet the requirements\n     * <p>\n     * <table border>\n     * <tr>\n     * <th>Resolution</th>\n     * <th>Requirements</th>\n     * </tr>\n     * <tr>\n     * <td>Error</td>\n     * <td>the physical file can not be exist</td>\n     * </tr>\n     * <tr>\n     * <td>Overwrite Append</td>\n     * <td>1. the file is a normal file (not a directory) <br>\n     * 2. the application can modify this file</td>\n     * </tr>\n     * </table border>\n     *\n     * @param config Instanze of the configuration\n     * @param system Sytem name which file resoltion must be read.\n     * @return true if the file meets the requirements of ConflictResolution,\n     *         otherwise false\n     * @exception XException if any errors occurs\n     */\n    private void checkFilePermissions() throws XException {\n        String fileName = mConfiguration.getFileNames()[0];\n        File srcFile = new File(fileName);\n        // constructing the file object doesn't create a file on disk!\n        if (srcFile.exists()) {\n            // 1.check if resolution = error\n            if (mConfiguration.getResolution().equals(Constants.WRITE_ERROR)) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"29\");\n            }\n            // 2. check if it is one file\n            if (!srcFile.isFile()) {\n                List params = new Vector();\n                params.add(mConfiguration.getFileNames());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"30\", params);\n            }\n            // 3. check write permissions\n            if (!srcFile.canWrite()) {\n                List params = new Vector();\n                params.add(fileName);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"31\", params);\n            }\n        }\n    }\n\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/file/SimpleFileSenderTest.java",
		"test_prompt": "// SimpleFileSenderTest.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SimpleFileSender}.\n* It contains ten unit test cases for the {@link SimpleFileSender#execute(String, String)} method.\n*/\nclass SimpleFileSenderTest {"
	},
	{
		"original_code": "// FileBase.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.FileChannel;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * Class <code>FileBase</code> is the abstract base class for the\n * {@link FileReceiver}and {@link FileSender}classes.\n * <p>\n * It provides the methods for the copying, renaming and deleting physical\n * files.\n */\npublic abstract class FileBase {\n\n    /**\n     * Reads the file encoding for the given system name from the\n     * {@link net.sf.xbus.base.core.config.Configuration}. If this one is\n     * non-existent, returns default value from the system property.\n     *\n     * @param system name which encoding must be read\n     * @return file encoding from the standart configuration or default value\n     *         from the system property\n     * @exception XException if any error occurs.\n     */\n    static public String getEncoding(String system) throws XException {\n        Configuration config = Configuration.getInstance();\n        String configEncoding = config.getValueOptional(Constants.CHAPTER_SYSTEM, system, Constants.KEY_ENCODING);\n        return (configEncoding == null) ? Constants.SYS_ENCODING : configEncoding;\n    }\n\n    /**\n     * Renames one file to another denoted by these abstract pathnames.\n     *\n     * @param srcFilename abstract pathname for the file to be renamed\n     * @param destFilename abstract pathname for the named file\n     * @exception XException if any error occurs\n     */\n    protected void renameFile(String srcFilename, String destFilename) throws XException {\n        File srcFile = new File(srcFilename);\n        File destFile = new File(destFilename);\n        // delete destination file if it exist\n        deleteFile(destFilename);\n        // rename src file to destination\n        try {\n            if (!srcFile.renameTo(destFile)) {\n                Vector params = new Vector();\n                params.add(srcFilename);\n                params.add(destFilename);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"32\", params);\n            }\n        } catch (SecurityException e) {\n            Vector params = new Vector();\n            params.add(srcFilename);\n            params.add(destFilename);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"32\", params);\n        }\n    }\n\n    /**\n     * Copies data by opening FileInput/OutputStreams from the one file to\n     * another denoted by these abstract pathnames\n     *\n     * @param sourceFile abstract pathname of the source file\n     * @param targetFile abstract pathname of the target file\n     * @exception XException if any error occurs\n     */\n    protected void copyFile(String sourceFile, String targetFile) throws XException {\n        FileChannel srcChannel = null;\n        FileOutputStream fos = null;\n        FileChannel dstChannel = null;\n        try {\n            // Get a file channel for the SourceFile\n            File lockSourceFile = new File(sourceFile);\n            srcChannel = new RandomAccessFile(lockSourceFile, \"r\").getChannel();\n            // Create channel on the destination\n            fos = new FileOutputStream(targetFile);\n            dstChannel = fos.getChannel();\n            // Copy file contents from source to destination\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        } finally {\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n                if (fos != null) {\n                    fos.close();\n                }\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n            }\n        }\n    }\n\n    /**\n     * Deletes the file or directory denoted by this abstract pathname. If this\n     * pathname denotes a directory, then the directory must be empty in order\n     * to be deleted.\n     *\n     * @param srcFilename the name of the file to be deleted\n     * @exception XException if something goes wrong\n     */\n    protected void deleteFile(String srcFilename) throws XException {\n        File srcFile = new File(srcFilename);\n        if (srcFile.exists()) {\n            try {\n                if (!srcFile.delete()) {\n                    Trace.error(new StringBuffer().append(\"unable to delete the original file: \").append(srcFilename).toString());\n                }\n            } catch (SecurityException e) {\n                Vector params = new Vector();\n                params.add(srcFile.toString());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"32\", params);\n            }\n        }\n    }\n\n    /**\n     * @param filename name of the file\n     * @return the length of the given file\n     */\n    protected long getFileLength(String filename) {\n        File file = new File(filename);\n        return file.length();\n    }\n\n    /**\n     * @param filename name of the file\n     * @return the last byte of the given file\n     * @throws XException if something goes wrong\n     */\n    protected int getLastByteOfFile(String filename) throws XException {\n        int lastByte = -1;\n        try {\n            File file = new File(filename);\n            if (file.length() > 0) {\n                FileInputStream readingFile;\n                readingFile = new FileInputStream(filename);\n                readingFile.skip(file.length() - 1);\n                lastByte = readingFile.read();\n                readingFile.close();\n            }\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        }\n        return lastByte;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/file/FileBaseTest.java",
		"test_prompt": "// FileBaseTest.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.channels.FileChannel;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileBase}.\n* It contains ten unit test cases for the {@link FileBase#getEncoding(String)} method.\n*/\nclass FileBaseTest {"
	},
	{
		"original_code": "// FileSender.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\n\n/**\n * <code>FileSender</code> manages writing a text file on a mounted file\n * system.\n * <p>\n * <b>Configuration: </b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>Filename</td>\n * <td>File path name on the mounted-system</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>ConflictResolution</td>\n * <td>Three actions must be possible when a file already exists <br>\n * <b><i>append, overwrite <i><b>or <b><i>error </i> </b></td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>Encoding</td>\n * <td>Specified character encoding of the interface <i>(Optional) </i></td>\n * </tr>\n * </table border>\n */\npublic class FileSender extends FileBase implements Sender, TAResource, TextSender {\n\n    protected FileSenderConfiguration mConfiguration = null;\n\n    /**\n     * Path name of the temporary file to be write Array for broadcasting\n     */\n    protected String[] mTempFilename = null;\n\n    /**\n     * Path name for the backup copy Array for broadcasting\n     */\n    protected String[] mBackupFilename = null;\n\n    /**\n     * Indicates wether execute has been called, used in commit and rollback\n     */\n    protected boolean senderExecuted = false;\n\n    /**\n     * Constructs a FileSender object giving all necessary data from the\n     * standard configuration, checking file permissions and registering current\n     * resource by the {@link net.sf.xbus.base.core.TAManager}.\n     *\n     * @param system destination of the message\n     * @exception XException if an error occurs\n     */\n    public FileSender(XBUSSystem system) throws XException {\n        readConfiguration(system);\n        TAManager taManager = TAManager.getInstance();\n        taManager.registerResource(this);\n    }\n\n    /**\n     * Reads follow data for the given XBUSSystem object from the standard\n     * configuration and stores it in the class variables.\n     * <p>\n     * <dl>\n     * <dd><table>\n     * <tr>\n     * <td><code>Filename</code></td>\n     * <td></td>\n     * <td>path name of the file to be write</td>\n     * </tr>\n     * <tr>\n     * <td><code>ConflictResolution</code></td>\n     * <td></td>\n     * <td>resolved action when the file already exists <br>\n     * <i>(append, overwrite, error) </i></td>\n     * </tr>\n     * <tr>\n     * <td><code>Encoding</code></td>\n     * <td></td>\n     * <td>specified character encoding of the interface</td>\n     * </tr>\n     * </table>\n     * </dl>\n     *\n     * @param xbusSystem XBUSSystem object which consists of two informations:\n     *            <br>\n     *            &nbsp;&nbsp;-the name of the system is used to identify the\n     *            system <br>\n     *            &nbsp;&nbsp;-additionally an adress might be available.\n     * @exception XException if any error occurs\n     */\n    private void readConfiguration(XBUSSystem xbusSystem) throws XException {\n        try {\n            mConfiguration = new FileSenderConfiguration(xbusSystem);\n            // The original file names.\n            String[] fileNames = mConfiguration.getFileNames();\n            // The temporay file names used during file creation.\n            mTempFilename = new String[fileNames.length];\n            // The backup file names.\n            mBackupFilename = new String[fileNames.length];\n            for (int fileNo = 0; fileNo < fileNames.length; fileNo++) {\n                mTempFilename[fileNo] = fileNames[fileNo] + Constants.TEMP_SUFFIX;\n                mBackupFilename[fileNo] = fileNames[fileNo] + Constants.getDateAsString();\n            }\n            // for (int fileNo=0; fileNo<fileNames.length; fileNo++)\n        } catch (Exception ex) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", ex);\n        }\n    }\n\n    /**\n     * Implemented method <code>execute</code> from TextSender sends the given\n     * string <i>callData </i> to the neighbor-system. Three actions must be\n     * taking into account when a file already exists:\n     * <p>\n     * <dl>\n     * <dd><table>\n     * <tr>\n     * <td><code>Append</code></td>\n     * <td></td>\n     * <td>append new data to the existing file</td>\n     * </tr>\n     * <tr>\n     * <td><code>Overwrite</code></td>\n     * <td></td>\n     * <td>overwrite existing file with the new data</td>\n     * </tr>\n     * <tr>\n     * <td><code>Error</code></td>\n     * <td></td>\n     * <td>throw XException</td>\n     * </tr>\n     * </table>\n     * </dl>\n     *\n     * @param function Name of the interface\n     * @param callData String to be written\n     * @exception XException if any error occurs\n     */\n    public String execute(String function, String callData) throws XException {\n        senderExecuted = true;\n        if (callData == null)\n            callData = \"\";\n        BufferedWriter buffOut = null;\n        // The file name to write to finnally.\n        // Only several ones for broadcasting.\n        // Otherwise only the first array element is filled.\n        String[] fileNames = mConfiguration.getFileNames();\n        for (int fileNo = 0; fileNo < fileNames.length; fileNo++) {\n            // Loop over destination files.\n            checkFilePermissions(fileNames[fileNo]);\n            buffOut = prepareWriter(fileNames[fileNo], fileNo);\n            // write callData into the file.\n            // Characters written to it are translated into bytes\n            // according to a specified character encoding.\n            try {\n                buffOut.write(callData);\n                // Writing an end of file sign on Unix systems\n                if (Constants.LINE_SEPERATOR.equals(\"\\n\") && (callData.length() == 0 || callData.charAt(callData.length() - 1) != '\\n'))\n                    buffOut.newLine();\n                buffOut.close();\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n            }\n        }\n        return null;\n    }\n\n    protected BufferedWriter prepareWriter(String fileName, int fileNo) throws XException {\n        prepareWriteFile(fileName, fileNo);\n        BufferedWriter buffOut;\n        try {\n            buffOut = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(mTempFilename[fileNo], true), mConfiguration.getEncoding()));\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        }\n        return buffOut;\n    }\n\n    protected void prepareWriteFile(String fileName, int fileNo) throws XException {\n        if (new File(mTempFilename[fileNo]).exists()) {\n            deleteFile(mTempFilename[fileNo]);\n        }\n        if (new File(fileName).exists()) {\n            renameFile(fileName, mBackupFilename[fileNo]);\n            // copy existing file if it exist and append is allowed\n            if (mConfiguration.getResolution().equals(Constants.WRITE_APPEND)) {\n                copyFile(mBackupFilename[fileNo], mTempFilename[fileNo]);\n                if (getFileLength(mTempFilename[fileNo]) > 0 && getLastByteOfFile(mTempFilename[fileNo]) != 10) {\n                    try {\n                        BufferedOutputStream buffOut = new BufferedOutputStream(new FileOutputStream(mTempFilename[fileNo], true));\n                        buffOut.write(Constants.LINE_SEPERATOR.getBytes(mConfiguration.getEncoding()));\n                        buffOut.close();\n                    } catch (Exception e) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n                    }\n                }\n            }\n        } else {\n            mBackupFilename[fileNo] = null;\n        }\n    }\n\n    /**\n     * On the basis of the ConflictResolution (resolved action when the file\n     * already exists) having read from the standard configuration, checks this\n     * method a file on an opportunity to meet the requirements\n     * <p>\n     * <table border>\n     * <tr>\n     * <th>Resolution</th>\n     * <th>Requirements</th>\n     * </tr>\n     * <tr>\n     * <td>Error</td>\n     * <td>the physical file may not exist</td>\n     * </tr>\n     * <tr>\n     * <td>Overwrite, Append</td>\n     * <td>1. the file is a normal file (not a directory)<br>\n     * 2. the application can modify this file</td>\n     * </tr>\n     * </table border>\n     *\n     * @param fileName the file path\n     * @return true if the file meets the requirements of ConflictResolution,\n     *         otherwise false\n     * @exception XException if any error occurs\n     */\n    private void checkFilePermissions(String fileName) throws XException {\n        File srcFile = new File(fileName);\n        // constructing the file object doesn't create a file on disk!\n        if (srcFile.exists()) {\n            // 1.check if resolution = error\n            if (mConfiguration.getResolution().equals(Constants.WRITE_ERROR)) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"29\");\n            }\n            // 2. check if it is one file\n            if (!srcFile.isFile()) {\n                List params = new Vector();\n                params.add(mConfiguration.getFileNames());\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"30\", params);\n            }\n            // 3. check write permissions\n            if (!srcFile.canWrite()) {\n                List params = new Vector();\n                params.add(fileName);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"31\", params);\n            }\n        }\n    }\n\n    /**\n     * Implemented method <code>commit</code> from TAResource interface. The\n     * purpose of commit actions is to remove any backup information that had\n     * been created during process (tansaction).\n     * <p>\n     * Undepending on the ConflictResolution, the following acts commit all\n     * actions.\n     * <ol>\n     * <li>remove resorce from the TAManager\n     * <li>rename temporary file to the current file\n     * <li>delete backup copy if exist\n     * </ol>\n     *\n     * @see net.sf.xbus.base.core.TAResource#commit()\n     * @exception XException if any error occurs\n     */\n    public void commit() throws XException {\n        TAManager.getInstance().removeResource(this);\n        if (senderExecuted) {\n            // The destination files.\n            // Up to now the transferred data is still in the tempoirary files.\n            String[] fileNames = mConfiguration.getFileNames();\n            for (int fileNo = 0; fileNo < fileNames.length; fileNo++) {\n                // rename temp file to original\n                renameFile(mTempFilename[fileNo], fileNames[fileNo]);\n                // delete backup file if it exists\n                if ((mBackupFilename[fileNo] != null) && (!mConfiguration.getResolution().equals(Constants.WRITE_RENAME))) {\n                    deleteFile(mBackupFilename[fileNo]);\n                }\n                // if ((mBackupFilename[fileNo] != null) &&\n                // (!mConfiguration.getResolution().equals(Constants.WRITE_RENAME)))\n            }\n            // for (int fileNo=0; fileNo<fileNames.length;fileNo++)\n        }\n        // if (senderExecuted)\n    }\n\n    // commit()\n    /**\n     * Implemented method <code>rollback</code> from TAResource ignores all\n     * changes have made since the beginning of the process (transaction).\n     * <p>\n     * Undepending on the ConflictResolution, the following acts roll back all\n     * modifications that have been made in the file system associated with this\n     * <code>FileSender</code>:\n     * <ol>\n     * <li>remove resorce from the TAManager\n     * <li>delete temp file\n     * <li>if backup copy exist, then rename it to the original file\n     * </ol>\n     *\n     * @see net.sf.xbus.base.core.TAResource#rollback()\n     * @exception XException if any error occurs\n     */\n    public void rollback() throws XException {\n        TAManager.getInstance().removeResource(this);\n        if (senderExecuted) {\n            // The destination files.\n            // The transferred data is still in the tempoirary files.\n            String[] fileNames = mConfiguration.getFileNames();\n            for (int fileNo = 0; fileNo < fileNames.length; fileNo++) {\n                deleteFile(mTempFilename[fileNo]);\n                if (mBackupFilename[fileNo] != null && new File(mBackupFilename[fileNo]).exists()) {\n                    renameFile(mBackupFilename[fileNo], fileNames[fileNo]);\n                }\n                // if (mBackupFilename[fileNo] != null && new\n                // File(mBackupFilename[fileNo]).exists())\n            }\n            // for (int fileNo=0; fileNo<fileNames.length;fileNo++)\n        }\n        // if (senderExecuted)\n    }\n\n    // rollback()\n    /**\n     * Is not implemented for file system\n     */\n    public void open() // open()\n    {\n    }\n\n    /**\n     * Is not implemented for file system\n     */\n    public void close() // close()\n    {\n    }\n\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n    // getType()\n}\n// FileSender\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/file/FileSenderTest.java",
		"test_prompt": "// FileSenderTest.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileSender}.\n* It contains ten unit test cases for the {@link FileSender#execute(String, String)} method.\n*/\nclass FileSenderTest {"
	},
	{
		"original_code": "// FileSenderConfiguration.java\npackage net.sf.xbus.technical.file;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * TODO Kommentierung\n */\npublic class FileSenderConfiguration {\n\n    /**\n     * The file paths. Only multiple ones in case of broadcast. Otherwise only\n     * the first array element is filled.\n     */\n    private String[] mFilenames = null;\n\n    private String mResolution = null;\n\n    private String mEncoding = null;\n\n    /**\n     * Reads some configuration entries and stores them in class variables.\n     *\n     * @throws XException if something goes wrong\n     */\n    public FileSenderConfiguration(XBUSSystem xbusSystem) throws XException {\n        Configuration config = Configuration.getInstance();\n        mResolution = retrieveResolution(xbusSystem.getName());\n        mEncoding = retrieveEncoding(xbusSystem.getName());\n        String filenameString = config.getValue(Constants.CHAPTER_SYSTEM, xbusSystem.getName(), Constants.KEY_FILENAME);\n        if (xbusSystem.getBroadcast())\n            xbusSystem.getBroadcastData(filenameString);\n        mFilenames = xbusSystem.replaceAllMarkers(filenameString);\n    }\n\n    public String getEncoding() {\n        return mEncoding;\n    }\n\n    public String[] getFileNames() {\n        return mFilenames;\n    }\n\n    public String getResolution() {\n        return mResolution;\n    }\n\n    /**\n     * Reads conflict resolution (resolved action when the file already exists)\n     * for the given system name from the configuration and checks its\n     * conformity with the allowed ones:\n     * <dl>\n     * <dd>Append\n     * <dd>Overwrie\n     * <dd>Error\n     * </dl>\n     *\n     * @param system Sytem name which file resolution must be read.\n     * @return conflict resolution (Append, Overwrite or Error) as String\n     * @exception XException if resolution is false or an errors occurs\n     */\n    public String retrieveResolution(String system) throws XException {\n        String resolution = Configuration.getInstance().getValue(Constants.CHAPTER_SYSTEM, system, Constants.KEY_SEND_RESOL);\n        if (!resolution.equals(Constants.WRITE_APPEND) && !resolution.equals(Constants.WRITE_ERROR) && !resolution.equals(Constants.WRITE_OVERWRITE) && !resolution.equals(Constants.WRITE_RENAME)) {\n            List params = new Vector();\n            params.add(resolution);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"28\", params);\n        }\n        return resolution;\n    }\n\n    /**\n     * Reads the file encoding for the given system name from the\n     * {@link net.sf.xbus.base.core.config.Configuration}. If this one is\n     * non-existent, returns default value from the system property.\n     *\n     * @param system name which encoding must be read\n     * @return file encoding from the standart configuration or default value\n     *         from the system property\n     * @exception XException if any errors occurs.\n     */\n    private String retrieveEncoding(String system) throws XException {\n        String configEncoding = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, Constants.KEY_ENCODING);\n        return (configEncoding == null) ? Constants.SYS_ENCODING : configEncoding;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/file/FileSenderConfigurationTest.java",
		"test_prompt": "// FileSenderConfigurationTest.java\npackage net.sf.xbus.technical.file;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileSenderConfiguration}.\n* It contains ten unit test cases for the {@link FileSenderConfiguration#retrieveResolution(String)} method.\n*/\nclass FileSenderConfigurationTest {"
	},
	{
		"original_code": "// FileLineReader.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.linereader.LineReader;\nimport net.sf.xbus.base.linereader.LineTransformer;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * <code>LineReader</code> to read/send a character stream from/to a file.\n */\npublic class FileLineReader extends BufferedReader implements LineReader {\n\n    private LineTransformer mTransformer = null;\n\n    public FileLineReader(File sourceFile, String encoding) throws UnsupportedEncodingException, FileNotFoundException {\n        super(new InputStreamReader(new FileInputStream(sourceFile), encoding));\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.LineReader#prepareReading()\n\t */\n    public void prepareReading(XBUSSystem destination) throws XException {\n        /*\n\t\t * Check if lines shall be transformed before writing\n\t\t */\n        String stringTransformer = Configuration.getInstance().getValueOptional(\"System\", destination.getName(), \"StringTransformer\");\n        if (stringTransformer != null) {\n            String transformerClassName = Configuration.getClass(\"StringTransformer\", stringTransformer);\n            mTransformer = (LineTransformer) ReflectionSupport.createObject(transformerClassName);\n        }\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.LineReader#readRecord()\n\t */\n    public String readRecord() throws XException {\n        String line = null;\n        try {\n            line = readLine();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        }\n        if ((mTransformer != null) && (line != null)) {\n            line = mTransformer.transform(line);\n        }\n        return line;\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.LineReader#terminateReading()\n\t */\n    public void terminateReading() throws XException {\n        try {\n            close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/file/FileLineReaderTest.java",
		"test_prompt": "// FileLineReaderTest.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.linereader.LineReader;\nimport net.sf.xbus.base.linereader.LineTransformer;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileLineReader}.\n* It contains ten unit test cases for the {@link FileLineReader#readRecord()} method.\n*/\nclass FileLineReaderTest {"
	},
	{
		"original_code": "// FileLineWriterSender.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedWriter;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.linereader.LineReader;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\n\n/**\n * <code></code>\n *\n * @author d�wel\n */\npublic class FileLineWriterSender extends FileSender implements Sender, ObjectSender {\n\n    private XBUSSystem mDestination = null;\n\n    /**\n     * Constructor for FileLineWriterSender.\n     *\n     * @param system\n     * @throws XException\n     */\n    public FileLineWriterSender(XBUSSystem system) throws XException {\n        super(system);\n        mDestination = system;\n    }\n\n    public Object execute(String function, Object source) throws XException {\n        senderExecuted = true;\n        LineReader reader = null;\n        BufferedWriter buffOut = null;\n        try {\n            reader = (LineReader) source;\n            reader.prepareReading(mDestination);\n            buffOut = prepareWriter(mConfiguration.getFileNames()[0], 0);\n            String record = reader.readRecord();\n            String lastRecord = \"\";\n            if (record != null) {\n                buffOut.write(record);\n                lastRecord = record;\n                record = reader.readRecord();\n            }\n            // while (record != null)\n            while (record != null) {\n                buffOut.write(Constants.LINE_SEPERATOR);\n                buffOut.write(record);\n                lastRecord = record;\n                record = reader.readRecord();\n            }\n            // while (record != null)\n            // Writing an end of file sign on Unix systems\n            if (Constants.LINE_SEPERATOR.equals(\"\\n\") && (lastRecord.length() == 0 || lastRecord.charAt(lastRecord.length() - 1) != '\\n'))\n                buffOut.newLine();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_FILE, \"0\", e);\n        } finally {\n            try {\n                if (reader != null) {\n                    reader.terminateReading();\n                }\n                if (buffOut != null) {\n                    buffOut.close();\n                }\n            } catch (Exception e) {\n                /*\n\t\t\t\t * do nothing\n\t\t\t\t */\n            }\n        }\n        return null;\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/file/FileLineWriterSenderTest.java",
		"test_prompt": "// FileLineWriterSenderTest.java\npackage net.sf.xbus.technical.file;\n\nimport java.io.BufferedWriter;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.linereader.LineReader;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileLineWriterSender}.\n* It contains ten unit test cases for the {@link FileLineWriterSender#execute(String, Object)} method.\n*/\nclass FileLineWriterSenderTest {"
	},
	{
		"original_code": "// Email.java\npackage net.sf.xbus.technical.mail;\n\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport javax.mail.internet.InternetAddress;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Text;\n\n/**\n * <p>\n * Description: An instance of that class will store an manupulate the email\n * receive by the POP3XMLReceiver.\n * </p>\n *\n * @author Dominique Boivin\n * @version 1.3\n */\npublic class Email {\n\n    private String mSystem;\n\n    private InternetAddress mFromAddress;\n\n    private List mToAddresses;\n\n    private List mCCAddresses;\n\n    private List mBCCAddresses;\n\n    private String mSubject;\n\n    private String mContent;\n\n    private Date mSentDate;\n\n    private String mContentType;\n\n    public Email(String system) {\n        mSystem = system;\n    }\n\n    public String toString() {\n        try {\n            return XMLHelper.serializeXML(getXML(), null);\n        } catch (XException e) {\n            return e.getMessage();\n        }\n    }\n\n    public Document getXML() throws XException {\n        if (isEmpty()) {\n            return null;\n        }\n        Document doc = XMLHelper.getDocumentBuilder(\"Default\", null).newDocument();\n        Element root = doc.createElement(mSystem);\n        doc.appendChild(root);\n        Element emailElement = null;\n        Text emailNode = null;\n        if (mFromAddress != null) {\n            root.appendChild(createAddressNode(doc, \"From\", mFromAddress));\n        }\n        if ((mToAddresses != null) && (!mToAddresses.isEmpty())) {\n            for (Iterator it = mToAddresses.iterator(); it.hasNext(); ) {\n                root.appendChild(createAddressNode(doc, \"To\", (InternetAddress) it.next()));\n            }\n        }\n        if ((mCCAddresses != null) && (!mCCAddresses.isEmpty())) {\n            for (Iterator it = mCCAddresses.iterator(); it.hasNext(); ) {\n                root.appendChild(createAddressNode(doc, \"CC\", (InternetAddress) it.next()));\n            }\n        }\n        if ((mBCCAddresses != null) && (!mBCCAddresses.isEmpty())) {\n            for (Iterator it = mBCCAddresses.iterator(); it.hasNext(); ) {\n                root.appendChild(createAddressNode(doc, \"BCC\", (InternetAddress) it.next()));\n            }\n        }\n        if (mSentDate != null) {\n            emailElement = doc.createElement(\"SentDate\");\n            emailNode = doc.createTextNode(Constants.getDateFormat().format(mSentDate));\n            emailElement.appendChild(emailNode);\n            root.appendChild(emailElement);\n        }\n        if (mContentType != null) {\n            emailElement = doc.createElement(\"ContentType\");\n            emailNode = doc.createTextNode(mContentType);\n            emailElement.appendChild(emailNode);\n            root.appendChild(emailElement);\n        }\n        if (mSubject != null) {\n            emailElement = doc.createElement(\"Subject\");\n            emailNode = doc.createTextNode(mSubject);\n            emailElement.appendChild(emailNode);\n            root.appendChild(emailElement);\n        }\n        if (mContent != null && !mContent.trim().equals(\"\")) {\n            emailElement = doc.createElement(\"Content\");\n            emailNode = doc.createTextNode(mContent);\n            emailElement.appendChild(emailNode);\n            root.appendChild(emailElement);\n            emailElement = doc.createElement(\"IsHTMLMessage\");\n            if (isHTMLMessage()) {\n                emailNode = doc.createTextNode(\"true\");\n            } else {\n                emailNode = doc.createTextNode(\"false\");\n            }\n            emailElement.appendChild(emailNode);\n            root.appendChild(emailElement);\n        }\n        return doc;\n    }\n\n    public boolean isEmpty() {\n        return ((mContent == null) || (mContent.trim().equals(\"\")));\n    }\n\n    public InternetAddress getFromAddress() {\n        return mFromAddress;\n    }\n\n    public void setFromAddress(InternetAddress fromAddress) {\n        mFromAddress = fromAddress;\n    }\n\n    public void setToAddress(InternetAddress toAddress) {\n        if (mToAddresses == null) {\n            mToAddresses = new Vector();\n        }\n        mToAddresses.add(toAddress);\n    }\n\n    public List getToAddresses() {\n        return mToAddresses;\n    }\n\n    public void setCCAddress(InternetAddress ccAddress) {\n        if (mCCAddresses == null) {\n            mCCAddresses = new Vector();\n        }\n        mCCAddresses.add(ccAddress);\n    }\n\n    public List getCCAddresses() {\n        return mCCAddresses;\n    }\n\n    public void setBCCAddress(InternetAddress bccAddress) {\n        if (mBCCAddresses == null) {\n            mBCCAddresses = new Vector();\n        }\n        mBCCAddresses.add(bccAddress);\n    }\n\n    public List getBCCAddresses() {\n        return mBCCAddresses;\n    }\n\n    public void setSubject(String subject) {\n        mSubject = subject;\n    }\n\n    public String getSubject() {\n        return mSubject;\n    }\n\n    public void setContent(String content) {\n        mContent = content;\n    }\n\n    public String getContent() {\n        return mContent;\n    }\n\n    public void setSentDate(Date sentDate) {\n        mSentDate = sentDate;\n    }\n\n    public Date getSentDate() {\n        return mSentDate;\n    }\n\n    public String getContentType() {\n        return mContentType;\n    }\n\n    public void setContentType(String contentType) {\n        mContentType = contentType;\n    }\n\n    private Node createAddressNode(Document doc, String tag, InternetAddress internetAddress) {\n        Node retNode = doc.createElement(tag);\n        String name = internetAddress.getPersonal();\n        String address = internetAddress.getAddress();\n        Node tmpNode = null;\n        if (name != null) {\n            tmpNode = doc.createElement(\"Name\");\n            tmpNode.appendChild(doc.createTextNode(name));\n            retNode.appendChild(tmpNode);\n        }\n        if (address != null) {\n            tmpNode = doc.createElement(\"Address\");\n            tmpNode.appendChild(doc.createTextNode(address));\n            retNode.appendChild(tmpNode);\n        }\n        return retNode;\n    }\n\n    private boolean isHTMLMessage() {\n        /*\n\t\t * Whe cannot use directly the </HTML> tag because the <> can be\n\t\t * converted to &lt;/HTML&gt;\n\t\t */\n        return ((mContent != null) && (mContent.toUpperCase().indexOf(\"/HTML\") != -1));\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/mail/EmailTest.java",
		"test_prompt": "// EmailTest.java\npackage net.sf.xbus.technical.mail;\n\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport javax.mail.internet.InternetAddress;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.Text;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Email}.\n* It contains ten unit test cases for the {@link Email#isEmpty()} method.\n*/\nclass EmailTest {"
	},
	{
		"original_code": "// SMTPSender.java\npackage net.sf.xbus.technical.mail;\n\nimport java.util.Date;\nimport java.util.Properties;\nimport java.util.Vector;\nimport javax.mail.Address;\nimport javax.mail.Authenticator;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.SendFailedException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\n\n/**\n * The <code>SMTPSender</code> sends messages to mail accounts via the SMTP\n * protocol.\n * <p>\n * This sender is very simple. It does not support the transaction mechanism.\n * Instead of it, the message will directly be sent when calling the execute\n * method.\n *\n * <p>\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td><i>logical name of the sender</i></td>\n * <td>Host</td>\n * <td>Hostname of the SMTP server</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td><i>logical name of the sender</i></td>\n * <td>Subject</td>\n * <td>Subject line for the mail message</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td><i>logical name of the sender</i></td>\n * <td>ToAddress <i>i</i></td>\n * <td>List of mail addresses where the message will be sent to</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td><i>logical name of the sender</i></td>\n * <td>FromAddress</td>\n * <td>Mail Address of the mail sender</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td><i>logical name of the sender</i></td>\n * <td>FromName</td>\n * <td>Optional: Name of the mail sender</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td><i>logical name of the sender</i></td>\n * <td>User</td>\n * <td>Optional: User needed for authentication</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td><i>logical name of the sender</i></td>\n * <td>Password</td>\n * <td>Optional: Password needed for authentication</td>\n * </tr>\n * </table>\n */\npublic class SMTPSender implements Sender, TextSender {\n\n    XBUSSystem mDestination = null;\n\n    String mUser = null;\n\n    String mPassword = null;\n\n    /**\n     * The constructor stores the given destination.\n     */\n    public SMTPSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    /**\n     * Sends the <code>callData</code>. <code>function</code> is ignored.\n     *\n     * @return <code>null</code>\n     */\n    public String execute(String function, String callData) throws XException {\n        if (callData == null)\n            callData = \"\";\n        /*\n\t\t * Getting some parameters from the configuration\n\t\t */\n        Configuration config = Configuration.getInstance();\n        String host = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Host\");\n        String subject = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Subject\");\n        Address fromAddress;\n        Address[] toAddresses;\n        try {\n            String address = null;\n            Vector addressList = new Vector();\n            address = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ToAddress1\");\n            int i = 1;\n            while (address != null) {\n                i++;\n                addressList.add(address);\n                address = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ToAddress\" + i);\n            }\n            int amountAddresses = addressList.size();\n            toAddresses = new Address[amountAddresses];\n            for (int k = 0; k < amountAddresses; k++) {\n                toAddresses[k] = new InternetAddress((String) addressList.elementAt(k));\n            }\n            String fromAddressString = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"FromAddress\");\n            String fromName = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"FromName\");\n            if (fromName != null) {\n                fromAddress = new InternetAddress(fromAddressString, fromName);\n            } else {\n                fromAddress = new InternetAddress(fromAddressString);\n            }\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MAIL, \"0\", e);\n        }\n        mUser = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"User\");\n        if (mUser != null) {\n            mPassword = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Password\");\n        }\n        /*\n\t\t * Setting the session\n\t\t */\n        Properties props = new Properties();\n        props.put(\"mail.smtp.host\", host);\n        if (mUser != null) {\n            props.put(\"mail.smtp.auth\", \"true\");\n        }\n        Authenticator auth = new MyAuthenticator();\n        Session session = Session.getInstance(props, auth);\n        try {\n            /*\n\t\t\t * Creating the message\n\t\t\t */\n            MimeMessage msg = new MimeMessage(session);\n            if (mUser != null) {\n                msg.setHeader(\"AUTH\", \"PLAIN\");\n            }\n            msg.setFrom(fromAddress);\n            msg.setRecipients(Message.RecipientType.TO, toAddresses);\n            msg.setSubject(subject);\n            msg.setSentDate(new Date());\n            msg.setText(callData, getEncoding());\n            /*\n\t\t\t * Sending the message\n\t\t\t */\n            Transport.send(msg);\n        } catch (// (MessagingException e) per casting below\n        Exception e) {\n            // HP Java runtime did not recognise MessagingException as a subtype\n            // of\n            // Throwable.\n            try {\n                MessagingException me = (MessagingException) e;\n                Exception nextException = me.getNextException();\n                if (nextException != null) {\n                    Trace.error(nextException.getMessage());\n                    if (nextException instanceof SendFailedException) {\n                        Address[] invalid = ((SendFailedException) nextException).getInvalidAddresses();\n                        for (int i = 0; i < invalid.length; i++) {\n                            Trace.error(\"Invalid address: \" + ((InternetAddress) invalid[i]).getAddress());\n                        }\n                    }\n                }\n            } catch (ClassCastException ce) {\n            }\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MAIL, \"0\", e);\n        }\n        return null;\n    }\n\n    /**\n     * Reads the file encoding for the given system name from the\n     * {@link net.sf.xbus.base.core.config.Configuration}. If this one is\n     * non-existent, returns default value from the system property.\n     *\n     * @param system name which encoding must be read\n     * @return file encoding from the standart configuration or default value\n     *         from the system property\n     * @exception XException if any errors occurs.\n     */\n    private String getEncoding() throws XException {\n        Configuration config = Configuration.getInstance();\n        String configEncoding = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), Constants.KEY_ENCODING);\n        return (configEncoding == null) ? Constants.SYS_ENCODING : configEncoding;\n    }\n\n    private class MyAuthenticator extends Authenticator {\n\n        protected PasswordAuthentication getPasswordAuthentication() {\n            if (mUser != null) {\n                return new PasswordAuthentication(mUser, mPassword);\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/mail/SMTPSenderTest.java",
		"test_prompt": "// SMTPSenderTest.java\npackage net.sf.xbus.technical.mail;\n\nimport java.util.Date;\nimport java.util.Properties;\nimport java.util.Vector;\nimport javax.mail.Address;\nimport javax.mail.Authenticator;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.PasswordAuthentication;\nimport javax.mail.SendFailedException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SMTPSender}.\n* It contains ten unit test cases for the {@link SMTPSender#execute(String, String)} method.\n*/\nclass SMTPSenderTest {"
	},
	{
		"original_code": "// ReceiverFactory.java\npackage net.sf.xbus.technical;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * The class <code>ReceiverFactory</code> is used to dynamically create\n * receivers to receive messages from neighbor-systems. Both\n * <code>ReceiverThreads</code> and <code>ReceiverSingles</code> can be\n * created.\n * <p>\n * It implements the <b>Factory</b>-Design-Pattern.\n */\npublic class ReceiverFactory {\n\n    /**\n     * The appropriate <code>ReceiverThread</code> for the given system will\n     * be created.\n     */\n    public static ReceiverThreadBase createReceiverThread(String receiverName, String system) throws XException {\n        String receiverClass = Configuration.getClass(\"Receiver\", receiverName);\n        Class[] conArgsClass = new Class[] { ReflectionSupport.classForName(\"net.sf.xbus.base.xbussystem.XBUSSystem\") };\n        Object[] conArgs = new Object[] { new XBUSSystem(system) };\n        return (ReceiverThreadBase) ReflectionSupport.createObject(receiverClass, conArgsClass, conArgs);\n    }\n\n    /**\n     * The appropriate <code>ReceiverSingle</code> for the given system will\n     * be created.\n     */\n    public static ReceiverSingleInterface createReceiverSingle(String receiverName) throws XException {\n        String receiverClassName = Configuration.getClass(\"Receiver\", receiverName);\n        return (ReceiverSingleInterface) ReflectionSupport.createObject(receiverClassName);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ReceiverFactoryTest0.java",
		"test_prompt": "// ReceiverFactoryTest0.java\npackage net.sf.xbus.technical;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverFactory}.\n* It contains ten unit test cases for the {@link ReceiverFactory#createReceiverThread(String, String)} method.\n*/\nclass ReceiverFactoryTest0 {"
	},
	{
		"original_code": "// ReceiverFactory.java\npackage net.sf.xbus.technical;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * The class <code>ReceiverFactory</code> is used to dynamically create\n * receivers to receive messages from neighbor-systems. Both\n * <code>ReceiverThreads</code> and <code>ReceiverSingles</code> can be\n * created.\n * <p>\n * It implements the <b>Factory</b>-Design-Pattern.\n */\npublic class ReceiverFactory {\n\n    /**\n     * The appropriate <code>ReceiverThread</code> for the given system will\n     * be created.\n     */\n    public static ReceiverThreadBase createReceiverThread(String receiverName, String system) throws XException {\n        String receiverClass = Configuration.getClass(\"Receiver\", receiverName);\n        Class[] conArgsClass = new Class[] { ReflectionSupport.classForName(\"net.sf.xbus.base.xbussystem.XBUSSystem\") };\n        Object[] conArgs = new Object[] { new XBUSSystem(system) };\n        return (ReceiverThreadBase) ReflectionSupport.createObject(receiverClass, conArgsClass, conArgs);\n    }\n\n    /**\n     * The appropriate <code>ReceiverSingle</code> for the given system will\n     * be created.\n     */\n    public static ReceiverSingleInterface createReceiverSingle(String receiverName) throws XException {\n        String receiverClassName = Configuration.getClass(\"Receiver\", receiverName);\n        return (ReceiverSingleInterface) ReflectionSupport.createObject(receiverClassName);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ReceiverFactoryTest1.java",
		"test_prompt": "// ReceiverFactoryTest1.java\npackage net.sf.xbus.technical;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverFactory}.\n* It contains ten unit test cases for the {@link ReceiverFactory#createReceiverSingle(String)} method.\n*/\nclass ReceiverFactoryTest1 {"
	},
	{
		"original_code": "// LDAPConnection.java\npackage net.sf.xbus.technical.ldap;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.naming.Context;\nimport javax.naming.NamingException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * Manages connections to LDAP servers.\n * <p />\n * LDAP connections are not transacted. <code>TAResource</code> is just\n * implemented to open and close the connections.\n */\npublic class LDAPConnection implements TAResource {\n\n    static final private String CHAPTER_LDAPCONNECTION = \"LDAPConnection\";\n\n    /*\n\t * Variables used to implement the Singleton pattern\n\t */\n    private static Hashtable mLDAPConnections = new Hashtable();\n\n    private static final Object classLock = LDAPConnection.class;\n\n    /*\n\t * Other variables\n\t */\n    private String mName = null;\n\n    private boolean mOpen = false;\n\n    private DirContext mContext = null;\n\n    /**\n     * The constructor is private, instances of <code>LDAPConnection</code>\n     * can only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the concatenation of\n     * the thread name and the connection name as the key.\n     */\n    private LDAPConnection(String name) {\n        mName = name;\n        mLDAPConnections.put(getFullName(name), this);\n        TAManager.getInstance().registerResource(this);\n    }\n\n    /**\n     * Delivers an open instance of <code>LDAPConnection</code>.\n     * <p />\n     *\n     * If it is the first call with this name for the actual thread, a new\n     * <code>LDAPConnection</code> object will be created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     *\n     * @param name name of the LDAPConnection\n     * @return an open LDAPConnection\n     * @throws XException if something goes wrong\n     */\n    public static LDAPConnection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            LDAPConnection ldapConnection = (LDAPConnection) mLDAPConnections.get(getFullName(name));\n            if (ldapConnection == null) {\n                ldapConnection = new LDAPConnection(name);\n            }\n            ldapConnection.open();\n            return ldapConnection;\n        }\n    }\n\n    /**\n     * Opens a connection to a LDAP server.\n     *\n     * @throws XException if something goes wrong\n     */\n    public void open() throws XException {\n        if (!mOpen) {\n            /*\n\t\t\t * Connect to the FTP Server\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            String host = config.getValue(CHAPTER_LDAPCONNECTION, mName, \"Host\");\n            int port = config.getValueAsIntOptional(CHAPTER_LDAPCONNECTION, mName, \"Port\");\n            String baseDN = config.getValue(CHAPTER_LDAPCONNECTION, mName, \"BaseDN\");\n            String rootDN = config.getValueOptional(CHAPTER_LDAPCONNECTION, mName, \"RootDN\");\n            String password = config.getValueOptional(CHAPTER_LDAPCONNECTION, mName, \"Password\");\n            /*\n\t\t\t * Set up the initial context\n\t\t\t */\n            try {\n                Hashtable env = new Hashtable();\n                env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n                env.put(Context.PROVIDER_URL, buildURL(host, port, baseDN));\n                if (rootDN != null) {\n                    env.put(Context.SECURITY_PRINCIPAL, rootDN);\n                }\n                if (password != null) {\n                    env.put(Context.SECURITY_CREDENTIALS, password);\n                }\n                mContext = new InitialDirContext(env);\n            } catch (NamingException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_LDAP, \"0\", e);\n            }\n        }\n        mOpen = true;\n    }\n\n    /**\n     * Closes the connection to the LDAP server\n     */\n    public void close() {\n        if (mOpen) {\n            try {\n                if (mContext != null) {\n                    mContext.close();\n                }\n            } catch (NamingException e) {\n                Trace.warn(\"Cannot close context for LDAP connection \" + mName);\n            }\n        }\n        mOpen = false;\n    }\n\n    /**\n     * Returns the <code>Context</code> of the current connection to the LDAP\n     * server.\n     */\n    public DirContext getContext() {\n        return mContext;\n    }\n\n    /**\n     * Creates and returns <code>SearchControls</code> used to search entries\n     * in the LDAP server. Some values are read out of the configuration.\n     *\n     * @return new <code>SearchControls</code>, initialized with values of\n     *         the configuration\n     * @throws XException if something goes wrong\n     */\n    public SearchControls getSearchControls() throws XException {\n        Configuration config = Configuration.getInstance();\n        int scope = getScope();\n        long countlim = config.getValueAsIntOptional(CHAPTER_LDAPCONNECTION, mName, \"CountLimit\");\n        if (countlim < 0) {\n            countlim = 0;\n        }\n        int timelim = config.getValueAsIntOptional(CHAPTER_LDAPCONNECTION, mName, \"TimeLimit\");\n        if (timelim < 0) {\n            timelim = 0;\n        }\n        SearchControls controls = new SearchControls();\n        controls.setSearchScope(scope);\n        controls.setCountLimit(countlim);\n        controls.setCountLimit(timelim);\n        return controls;\n    }\n\n    private int getScope() throws XException {\n        int scope = SearchControls.SUBTREE_SCOPE;\n        String configScope = Configuration.getInstance().getValueOptional(CHAPTER_LDAPCONNECTION, mName, \"Scope\");\n        if (configScope != null) {\n            if (configScope.toLowerCase().equals(\"onelevel\")) {\n                scope = SearchControls.ONELEVEL_SCOPE;\n            } else if (configScope.toLowerCase().equals(\"subtree\")) {\n                scope = SearchControls.SUBTREE_SCOPE;\n            } else {\n                Vector params = new Vector(1);\n                params.add(configScope);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_LDAP, \"1\");\n            }\n        }\n        return scope;\n    }\n\n    /**\n     * Builds an URL that points to a LDAP server.\n     *\n     * @return URL that points to a LDAP server.\n     */\n    private String buildURL(String host, int port, String baseDN) {\n        StringBuffer buffer = new StringBuffer(\"ldap://\").append(host);\n        if (port > 0) {\n            buffer.append(\":\").append(port);\n        }\n        if (baseDN != null) {\n            buffer.append(\"/\").append(baseDN);\n        }\n        return buffer.toString();\n    }\n\n    static private String getFullName(String name) {\n        return new StringBuffer().append(name).append(\".\").append(Thread.currentThread().getName()).toString();\n    }\n\n    /**\n     * Empty method, LDAP connections are not transacted.\n     */\n    public void commit() {\n        // intentionally empty\n    }\n\n    /**\n     * Empty method, LDAP connections are not transacted.\n     */\n    public void rollback() {\n        // intentionally empty\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ldap/LDAPConnectionTest.java",
		"test_prompt": "// LDAPConnectionTest.java\npackage net.sf.xbus.technical.ldap;\n\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport javax.naming.Context;\nimport javax.naming.NamingException;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LDAPConnection}.\n* It contains ten unit test cases for the {@link LDAPConnection#getInstance(String)} method.\n*/\nclass LDAPConnectionTest {"
	},
	{
		"original_code": "// LDAPSender.java\npackage net.sf.xbus.technical.ldap;\n\nimport java.util.Iterator;\nimport java.util.Vector;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.BasicAttributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * The <code>LDAPSender</code> sends requests to a LDAP server and returns the\n * results. The request and the response are XML documents.\n * <p />\n * Please refer to the documentation about the structure of the XML documents.\n */\npublic class LDAPSender implements Sender, ObjectSender {\n\n    private static final String SEARCH_STRING = \"SearchString\";\n\n    private static final String SEARCH_ATTRIBUTES = \"SearchAttributes\";\n\n    private static final String CONTEXT = \"context\";\n\n    private XBUSSystem mDestination = null;\n\n    /**\n     * The constructor stores the destination.\n     *\n     * @param destination definition of the interface in\n     *            <code>standard.conf</code>\n     * @throws XException never thrown\n     */\n    public LDAPSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    /**\n     * Sends requests to the LDAP server and return the results. Currently only\n     * searching for entries is implemented.\n     *\n     * @param function not used\n     * @param callData XML document containing requests\n     * @return XML document with results\n     * @throws XException in case of errors\n     */\n    public Object execute(String function, Object callData) throws XException {\n        Document retDocument = XMLHelper.getDocumentBuilder(\"Default\", mDestination.getName()).newDocument();\n        retDocument.appendChild(retDocument.createElement(mDestination.getName()));\n        /*\n\t\t * Getting an instance of the LDAPConnection\n\t\t */\n        Configuration config = Configuration.getInstance();\n        String connectionName = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"LDAPConnection\");\n        LDAPConnection connection = LDAPConnection.getInstance(connectionName);\n        /*\n\t\t * Execute the given LDAP requests\n\t\t */\n        Vector requests = extractRequests((Document) callData);\n        NamingEnumeration results = null;\n        DirContext context = connection.getContext();\n        SearchControls controls = connection.getSearchControls();\n        for (Iterator it = requests.iterator(); it.hasNext(); ) {\n            RequestContainer request = (RequestContainer) it.next();\n            String requestType = request.getType();\n            try {\n                if (requestType.equals(SEARCH_STRING)) {\n                    results = context.search(request.getContext(), (String) request.getRequest(), controls);\n                    addResultSearch(results, retDocument, SEARCH_STRING, request.getContext(), request.toString());\n                } else if (requestType.equals(SEARCH_ATTRIBUTES)) {\n                    results = context.search(request.getContext(), (Attributes) request.getRequest());\n                    addResultSearch(results, retDocument, SEARCH_ATTRIBUTES, request.getContext(), request.toString());\n                }\n            } catch (NamingException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_LDAP, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * @see net.sf.xbus.technical.Sender#getType()\n     *\n     * @return Constants.TYPE_OBJECT\n     */\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n\n    private Vector extractRequests(Document doc) throws XException {\n        Vector retVector = new Vector();\n        Node parent = doc.getFirstChild();\n        if (parent == null) {\n            return retVector;\n        }\n        NodeList nodes = parent.getChildNodes();\n        Node requestNode = null;\n        String requestString = null;\n        RequestContainer request = null;\n        NodeList children = null;\n        Node child = null;\n        Attributes attrs;\n        for (int i = 0; i < nodes.getLength(); i++) {\n            requestNode = nodes.item(i);\n            if (requestNode.getNodeType() == Element.ELEMENT_NODE) {\n                if (requestNode.getNodeName().equals(SEARCH_STRING)) {\n                    requestString = XMLHelper.getNodeText(requestNode);\n                    if (requestString == null) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_LDAP, \"1\");\n                    } else {\n                        request = new RequestContainer(SEARCH_STRING, getContext(requestNode), requestString);\n                        retVector.add(request);\n                    }\n                } else if (requestNode.getNodeName().equals(SEARCH_ATTRIBUTES)) {\n                    children = requestNode.getChildNodes();\n                    attrs = new BasicAttributes();\n                    for (int j = 0; j < children.getLength(); j++) {\n                        child = children.item(j);\n                        if (child.getNodeType() == Element.ELEMENT_NODE) {\n                            String attributeName = child.getNodeName();\n                            String attributeValue = XMLHelper.getNodeText(child);\n                            attrs.put(attributeName, attributeValue);\n                        }\n                    }\n                    request = new RequestContainer(SEARCH_ATTRIBUTES, getContext(requestNode), attrs);\n                    retVector.add(request);\n                } else {\n                    Vector params = new Vector(1);\n                    params.add(requestNode.getNodeName());\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_LDAP, \"2\", params);\n                }\n            }\n        }\n        return retVector;\n    }\n\n    private void addResultSearch(NamingEnumeration results, Document doc, String type, String context, String request) throws XException {\n        Element resultElement = doc.createElement(\"Result\");\n        resultElement.setAttribute(type.toLowerCase(), request);\n        resultElement.setAttribute(CONTEXT, context);\n        doc.getDocumentElement().appendChild(resultElement);\n        Element record = null;\n        Element attribute = null;\n        SearchResult sr = null;\n        NamingEnumeration attrs = null;\n        Attribute attr = null;\n        String key = null;\n        NamingEnumeration values = null;\n        String value = null;\n        try {\n            while (results.hasMore()) {\n                sr = (SearchResult) results.next();\n                attrs = sr.getAttributes().getAll();\n                record = doc.createElement(\"Record\");\n                while (attrs.hasMore()) {\n                    attr = (Attribute) attrs.next();\n                    key = attr.getID();\n                    values = attr.getAll();\n                    while (values.hasMore()) {\n                        value = values.next().toString();\n                        attribute = doc.createElement(key);\n                        attribute.appendChild(doc.createTextNode(value));\n                        record.appendChild(attribute);\n                    }\n                }\n                resultElement.appendChild(record);\n            }\n        } catch (NamingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_LDAP, \"0\", e);\n        }\n    }\n\n    private String getContext(Node node) {\n        NamedNodeMap attributes = node.getAttributes();\n        for (int j = 0; j < attributes.getLength(); j++) {\n            if (attributes.item(j).getNodeName().equals(CONTEXT)) {\n                // searched attribute found\n                return attributes.item(j).getNodeValue();\n            }\n        }\n        return \"\";\n    }\n\n    private class RequestContainer {\n\n        private String mType;\n\n        private String mContext;\n\n        private Object mRequest;\n\n        public RequestContainer(String type, String context, Object request) {\n            mType = type;\n            mContext = context;\n            mRequest = request;\n        }\n\n        public String getType() {\n            return mType;\n        }\n\n        public String getContext() {\n            return mContext;\n        }\n\n        public Object getRequest() {\n            return mRequest;\n        }\n\n        public String toString() {\n            return mRequest.toString();\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ldap/LDAPSenderTest.java",
		"test_prompt": "// LDAPSenderTest.java\npackage net.sf.xbus.technical.ldap;\n\nimport java.util.Iterator;\nimport java.util.Vector;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.BasicAttributes;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LDAPSender}.\n* It contains ten unit test cases for the {@link LDAPSender#execute(String, Object)} method.\n*/\nclass LDAPSenderTest {"
	},
	{
		"original_code": "// SenderFactory.java\npackage net.sf.xbus.technical;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * The class <code>SenderFactory</code> is used to dynamically create senders\n * to neighbor systems.\n * <p />\n * It implements the <b>Factory</b>-Design-Pattern.\n */\npublic class SenderFactory {\n\n    /**\n     * The appropriate {@link Sender} for the given destination will be created.\n     * The name of the class is read from the\n     * {@link net.sf.xbus.base.core.config.Configuration}.\n     *\n     * @param destination name of the interface definition\n     * @throws XException if something goes wrong\n     */\n    public static Sender createSender(XBUSSystem destination) throws XException {\n        Configuration config = Configuration.getInstance();\n        String senderClassShortname = config.getValue(Constants.CHAPTER_SYSTEM, destination.getName(), \"Sender\");\n        String senderClass = Configuration.getClass(\"Sender\", senderClassShortname);\n        Class[] conArgsClass = new Class[] { destination.getClass() };\n        Object[] conArgs = new Object[] { destination };\n        return (Sender) ReflectionSupport.createObject(senderClass, conArgsClass, conArgs);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/SenderFactoryTest.java",
		"test_prompt": "// SenderFactoryTest.java\npackage net.sf.xbus.technical;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SenderFactory}.\n* It contains ten unit test cases for the {@link SenderFactory#createSender(XBUSSystem)} method.\n*/\nclass SenderFactoryTest {"
	},
	{
		"original_code": "// JavaSender.java\npackage net.sf.xbus.technical.java;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.timeoutcall.TimedCallable;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\n\n/**\n * <code>JavaSender</code> sends data by calling a method of an object. Both\n * method and object are read out of the configuration.\n * <p>\n *\n * The method must have one of these two signatures:\n * <p>\n * <code>    public String methodname(String callData)</code>\n * <p>\n * or\n * <p>\n * <code>    public Object methodname(Object callData)</code>\n * <p>\n */\npublic class JavaSender implements Sender, ObjectSender {\n\n    private XBUSSystem mDestination = null;\n\n    private boolean mIsText = false;\n\n    /**\n     */\n    public JavaSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    /**\n     * The given object will be sent to the neighbor-system. The answer of the\n     * neighbor-system is the return-value of this method.\n     * <p>\n     *\n     * The function is used for calling different methods of the\n     * neighbor-system.\n     */\n    public Object execute(String function, Object callData) throws XException {\n        Object retObject = null;\n        Configuration config = Configuration.getInstance();\n        int timeout = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Timeout\") * 1000;\n        if (timeout == 0) {\n            timeout = Integer.MAX_VALUE;\n        }\n        JavaCaller caller = new JavaCaller(mDestination, function, callData, mIsText);\n        TimedCallable tc = new TimedCallable(caller, timeout);\n        try {\n            retObject = tc.call();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_JAVA, \"0\", e);\n        }\n        return retObject;\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/java/JavaSenderTest.java",
		"test_prompt": "// JavaSenderTest.java\npackage net.sf.xbus.technical.java;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.timeoutcall.TimedCallable;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaSender}.\n* It contains ten unit test cases for the {@link JavaSender#execute(String, Object)} method.\n*/\nclass JavaSenderTest {"
	},
	{
		"original_code": "// JavaCaller.java\npackage net.sf.xbus.technical.java;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.timeoutcall.Callable;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * Used by {@link JavaSender#execute(String, Object)} together with the\n * {@link net.sf.xbus.base.core.timeoutcall.TimedCallable} to be able to stop\n * the execution of the program after a timeout.\n */\npublic class JavaCaller implements Callable {\n\n    private String mFunction = null;\n\n    private Object mCallData = null;\n\n    private XBUSSystem mDestination = null;\n\n    private boolean mIsText = false;\n\n    /**\n     * Stores the given data.\n     *\n     * @param destination name of the interface definition\n     * @param function used to determine the method\n     * @param callData data to be send\n     * @param isText indicates whether the method accepts a String (<code>true</code>)\n     *            or an Object (<code>false</code>)\n     */\n    public JavaCaller(XBUSSystem destination, String function, Object callData, boolean isText) {\n        mDestination = destination;\n        mFunction = function;\n        mCallData = callData;\n        mIsText = isText;\n    }\n\n    /**\n     * Calling the Java method. The name of the class and the name of the method\n     * are read out of the configuration.\n     *\n     * @return the response of the called method\n     */\n    public Object call() throws XException {\n        Configuration config = Configuration.getInstance();\n        String classname = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Class\");\n        Object callObject = ReflectionSupport.createObject(classname);\n        String methodname = getMethodName(mFunction);\n        Class[] parameterTypes = null;\n        if (mIsText) {\n            parameterTypes = new Class[] { String.class };\n        } else {\n            parameterTypes = new Class[] { Object.class };\n        }\n        Object[] arguments = new Object[] { mCallData };\n        return ReflectionSupport.callMethod(methodname, callObject, parameterTypes, arguments);\n    }\n\n    /**\n     * Stopping the execution of the program by doing nothing.\n     */\n    public void stop() {\n    }\n\n    /**\n     * Reads the name of the method out of the configuration.\n     *\n     * @param function which method is called may depend on the given function\n     * @return name of the method\n     */\n    private String getMethodName(String function) throws XException {\n        Configuration config = Configuration.getInstance();\n        String retString = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Method\");\n        if (retString == null) {\n            retString = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Method.\" + function);\n        }\n        return retString;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/java/JavaCallerTest.java",
		"test_prompt": "// JavaCallerTest.java\npackage net.sf.xbus.technical.java;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.timeoutcall.Callable;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaCaller}.\n* It contains ten unit test cases for the {@link JavaCaller#call()} method.\n*/\nclass JavaCallerTest {"
	},
	{
		"original_code": "// JavaReceiver.java\npackage net.sf.xbus.technical.java;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.notifyerror.NotifyError;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Receiver;\n\n/**\n * The class <code>JavaReceiver</code> receives a request via a call of its\n * <code>receive</code> method. It creates a <code>Message</code> -object\n * and calls the application-layer.\n */\npublic class JavaReceiver implements Receiver {\n\n    /**\n     * Receives a request and returns a response.\n     */\n    public Object receive(String system, Object request) throws XException {\n        if (system == null) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_JAVA, \"2\");\n        }\n        String errormessage = null;\n        XBUSSystem source = new XBUSSystem(system);\n        Trace.info(\"Receiving data from \" + source.getCompleteName());\n        Object responseObject = null;\n        /*\n\t\t * Initialize transaction manager\n\t\t */\n        TAManager taManager = TAManager.getInstance();\n        try {\n            taManager.clearManager();\n            taManager.begin();\n            Adapter adapter = new Adapter();\n            adapter.callApplication(source, request, getType());\n            responseObject = adapter.getResponse();\n            if (Constants.RC_OK.equals(adapter.getReturncode())) {\n                taManager.commit();\n                PostProcessor.start(source, responseObject, Constants.POSTPROCESSING_PERSYSTEM);\n                Trace.info(\"End processing \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n            } else {\n                errormessage = adapter.getErrormessage();\n                taManager.rollback();\n                NotifyError.notifyError(this, source, errormessage, request, null);\n                Trace.info(\"Error while processing \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n            }\n        } catch (Exception t) {\n            errormessage = t.getMessage();\n            NotifyError.notifyError(this, source, errormessage, request, null);\n            Trace.info(\"Error while processing \" + source.getCompleteName());\n            Trace.info(\"-----------------------------\");\n            if (t instanceof XException) {\n                throw (XException) t;\n            }\n        }\n        taManager.close();\n        if (errormessage != null) {\n            List messages = new Vector(1);\n            messages.add(errormessage);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_JAVA, \"3\", messages);\n        }\n        return responseObject;\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/java/JavaReceiverTest.java",
		"test_prompt": "// JavaReceiverTest.java\npackage net.sf.xbus.technical.java;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.notifyerror.NotifyError;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Receiver;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JavaReceiver}.\n* It contains ten unit test cases for the {@link JavaReceiver#receive(String, Object)} method.\n*/\nclass JavaReceiverTest {"
	},
	{
		"original_code": "// ReceiverService.java\npackage net.sf.xbus.technical;\n\nimport java.lang.management.ManagementFactory;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MalformedObjectNameException;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.ObjectName;\nimport net.sf.xbus.admin.jmx.Administrator;\nimport net.sf.xbus.application.PreProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * <code>ReceiverService</code> runs as a background service and waits for\n * incoming messages to process.\n * <p>\n * At startup, <code>ReceiverService</code> searches for systems, which receiver\n * ends with <code>\"Thread\"</code>. For every found system, a thread is started\n * to process the messages. The used receivers must extend the\n * {@link net.sf.xbus.technical.ReceiverThreadBase}.\n * <p>\n */\npublic class ReceiverService {\n\n    /**\n     * Reference to the Singleton object\n     */\n    static private ReceiverService mReceiverService = null;\n\n    /**\n     * Used for locking during <code>getInstance</code>\n     */\n    static private final Object classLock = ReceiverService.class;\n\n    /**\n     * Indicates if the JMX administration shall be started\n     */\n    private boolean mStartJMX = false;\n\n    /**\n     * Indicates if the systems for processing incoming messages are already\n     * started\n     */\n    private boolean mSystemsStarted = false;\n\n    /**\n     * The Watchdog is a thread that checks every few seconds, if all\n     * ReceiverThreads are still running.\n     */\n    private ReceiverServiceWatchdog mWatchdog = null;\n\n    private Thread mWatchdogThread = null;\n\n    /**\n     * The constructor should be private to implement the <code>Singleton</code>\n     * pattern. But the bootstrapping mechanism needs a public constructor.\n     */\n    public ReceiverService() {\n    }\n\n    /**\n     * Returns the one and only instance of the <code>ReceiverService</code>,\n     * which implements the <b>Singleton </b> pattern. If the object doesn't\n     * exist, it is created.\n     *\n     * @return the one and only instance of the <code>ReceiverService</code>\n     */\n    public static ReceiverService getInstance() {\n        synchronized (classLock) {\n            if (mReceiverService == null) {\n                mReceiverService = new ReceiverService();\n            }\n            return mReceiverService;\n        }\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration.\n     *\n     * @param insideServletEngine\n     *            if true, the ReceiverService is running inside a servlet\n     *            engine\n     */\n    public synchronized void start(boolean insideServletEngine) throws XException {\n        Trace.always(\"Entering ReceiverService.start\");\n        /*\n\t\t * The class variable must be set here because an issue with the\n\t\t * classloader. Do not remove!\n\t\t */\n        mReceiverService = this;\n        /*\n\t\t * Register MBeans\n\t\t */\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(\"xBus:mbean=Administrator\");\n            Administrator mbean = new Administrator();\n            mbs.registerMBean(mbean, name);\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n        startAllSystems();\n        ReceiverThreadManager.getInstance().setIsServletEngine(insideServletEngine);\n        startWatchdog();\n        Trace.always(\"Leaving ReceiverService.start\");\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration. The\n     * <code>ReceiverService</code> is running inside a servlet engine.\n     */\n    public synchronized void startInsideServletEngine() throws XException {\n        start(true);\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration. The\n     * <code>ReceiverService</code> is not running inside a servlet engine.\n     */\n    public synchronized void startWithoutServletEngine() throws XException {\n        start(false);\n    }\n\n    /**\n     * Stops all threads, including the administration threads.\n     *\n     * @return true if ReceiverService has been stopped\n     */\n    public synchronized boolean stop() throws XException {\n        Trace.always(\"Stopping ReceiverService...\");\n        stopWatchdog();\n        stopAllSystems();\n        TAManager.getInstance().close();\n        // if (mStartJMX)\n        // {\n        // AdministratorJMXServer.stop();\n        // }\n        Trace.always(\"ReceiverService stopped\");\n        return true;\n    }\n\n    /**\n     * Starts all configured threads to process message for different systems.\n     */\n    public synchronized void startAllSystems() throws XException {\n        Configuration config = Configuration.getInstance();\n        PreProcessor.process(PreProcessor.RECEIVER_SERVICE);\n        List sections = config.getSections(Constants.CHAPTER_SYSTEM);\n        String system = null;\n        String receiver = null;\n        for (Iterator it = sections.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            receiver = config.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n            if ((receiver != null) && (receiver.endsWith(\"Thread\"))) {\n                ReceiverThreadManager.getInstance().startReceiverThread(system);\n            }\n        }\n        mSystemsStarted = true;\n    }\n\n    /**\n     * Stops all threads after processing their current message.\n     */\n    public synchronized void stopAllSystems() throws XException {\n        if (!mSystemsStarted) {\n            return;\n        }\n        ReceiverThreadManager receiverThreadManager = ReceiverThreadManager.getInstance();\n        /*\n\t\t * Demand to stop all running systems\n\t\t */\n        String systemname;\n        for (Iterator i = receiverThreadManager.getRunningReceiverThreads().iterator(); i.hasNext(); ) {\n            systemname = (String) i.next();\n            receiverThreadManager.demandStopReceiverThread(systemname);\n        }\n        /*\n\t\t * Wait until all systems have been stopped\n\t\t */\n        boolean completed = receiverThreadManager.getRunningReceiverThreads().isEmpty();\n        while (!completed) {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n            }\n            completed = receiverThreadManager.getRunningReceiverThreads().isEmpty();\n        }\n        mSystemsStarted = false;\n    }\n\n    public boolean isWatchdogRunning() {\n        return ((mWatchdogThread != null) && (mWatchdogThread.isAlive()));\n    }\n\n    /**\n     * TODO Kommentierung\n     */\n    private void startWatchdog() {\n        mWatchdog = new ReceiverServiceWatchdog();\n        mWatchdogThread = new Thread(mWatchdog, \"ReceiverServiceWatchdog\");\n        mWatchdogThread.start();\n    }\n\n    /**\n     * TODO Kommentierung\n     */\n    private void stopWatchdog() {\n        mWatchdog.stopWatchdog();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ReceiverServiceTest0.java",
		"test_prompt": "// ReceiverServiceTest0.java\npackage net.sf.xbus.technical;\n\nimport java.lang.management.ManagementFactory;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MalformedObjectNameException;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.ObjectName;\nimport net.sf.xbus.admin.jmx.Administrator;\nimport net.sf.xbus.application.PreProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverService}.\n* It contains ten unit test cases for the {@link ReceiverService#getInstance()} method.\n*/\nclass ReceiverServiceTest0 {"
	},
	{
		"original_code": "// ReceiverService.java\npackage net.sf.xbus.technical;\n\nimport java.lang.management.ManagementFactory;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MalformedObjectNameException;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.ObjectName;\nimport net.sf.xbus.admin.jmx.Administrator;\nimport net.sf.xbus.application.PreProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * <code>ReceiverService</code> runs as a background service and waits for\n * incoming messages to process.\n * <p>\n * At startup, <code>ReceiverService</code> searches for systems, which receiver\n * ends with <code>\"Thread\"</code>. For every found system, a thread is started\n * to process the messages. The used receivers must extend the\n * {@link net.sf.xbus.technical.ReceiverThreadBase}.\n * <p>\n */\npublic class ReceiverService {\n\n    /**\n     * Reference to the Singleton object\n     */\n    static private ReceiverService mReceiverService = null;\n\n    /**\n     * Used for locking during <code>getInstance</code>\n     */\n    static private final Object classLock = ReceiverService.class;\n\n    /**\n     * Indicates if the JMX administration shall be started\n     */\n    private boolean mStartJMX = false;\n\n    /**\n     * Indicates if the systems for processing incoming messages are already\n     * started\n     */\n    private boolean mSystemsStarted = false;\n\n    /**\n     * The Watchdog is a thread that checks every few seconds, if all\n     * ReceiverThreads are still running.\n     */\n    private ReceiverServiceWatchdog mWatchdog = null;\n\n    private Thread mWatchdogThread = null;\n\n    /**\n     * The constructor should be private to implement the <code>Singleton</code>\n     * pattern. But the bootstrapping mechanism needs a public constructor.\n     */\n    public ReceiverService() {\n    }\n\n    /**\n     * Returns the one and only instance of the <code>ReceiverService</code>,\n     * which implements the <b>Singleton </b> pattern. If the object doesn't\n     * exist, it is created.\n     *\n     * @return the one and only instance of the <code>ReceiverService</code>\n     */\n    public static ReceiverService getInstance() {\n        synchronized (classLock) {\n            if (mReceiverService == null) {\n                mReceiverService = new ReceiverService();\n            }\n            return mReceiverService;\n        }\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration.\n     *\n     * @param insideServletEngine\n     *            if true, the ReceiverService is running inside a servlet\n     *            engine\n     */\n    public synchronized void start(boolean insideServletEngine) throws XException {\n        Trace.always(\"Entering ReceiverService.start\");\n        /*\n\t\t * The class variable must be set here because an issue with the\n\t\t * classloader. Do not remove!\n\t\t */\n        mReceiverService = this;\n        /*\n\t\t * Register MBeans\n\t\t */\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(\"xBus:mbean=Administrator\");\n            Administrator mbean = new Administrator();\n            mbs.registerMBean(mbean, name);\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n        startAllSystems();\n        ReceiverThreadManager.getInstance().setIsServletEngine(insideServletEngine);\n        startWatchdog();\n        Trace.always(\"Leaving ReceiverService.start\");\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration. The\n     * <code>ReceiverService</code> is running inside a servlet engine.\n     */\n    public synchronized void startInsideServletEngine() throws XException {\n        start(true);\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration. The\n     * <code>ReceiverService</code> is not running inside a servlet engine.\n     */\n    public synchronized void startWithoutServletEngine() throws XException {\n        start(false);\n    }\n\n    /**\n     * Stops all threads, including the administration threads.\n     *\n     * @return true if ReceiverService has been stopped\n     */\n    public synchronized boolean stop() throws XException {\n        Trace.always(\"Stopping ReceiverService...\");\n        stopWatchdog();\n        stopAllSystems();\n        TAManager.getInstance().close();\n        // if (mStartJMX)\n        // {\n        // AdministratorJMXServer.stop();\n        // }\n        Trace.always(\"ReceiverService stopped\");\n        return true;\n    }\n\n    /**\n     * Starts all configured threads to process message for different systems.\n     */\n    public synchronized void startAllSystems() throws XException {\n        Configuration config = Configuration.getInstance();\n        PreProcessor.process(PreProcessor.RECEIVER_SERVICE);\n        List sections = config.getSections(Constants.CHAPTER_SYSTEM);\n        String system = null;\n        String receiver = null;\n        for (Iterator it = sections.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            receiver = config.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n            if ((receiver != null) && (receiver.endsWith(\"Thread\"))) {\n                ReceiverThreadManager.getInstance().startReceiverThread(system);\n            }\n        }\n        mSystemsStarted = true;\n    }\n\n    /**\n     * Stops all threads after processing their current message.\n     */\n    public synchronized void stopAllSystems() throws XException {\n        if (!mSystemsStarted) {\n            return;\n        }\n        ReceiverThreadManager receiverThreadManager = ReceiverThreadManager.getInstance();\n        /*\n\t\t * Demand to stop all running systems\n\t\t */\n        String systemname;\n        for (Iterator i = receiverThreadManager.getRunningReceiverThreads().iterator(); i.hasNext(); ) {\n            systemname = (String) i.next();\n            receiverThreadManager.demandStopReceiverThread(systemname);\n        }\n        /*\n\t\t * Wait until all systems have been stopped\n\t\t */\n        boolean completed = receiverThreadManager.getRunningReceiverThreads().isEmpty();\n        while (!completed) {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n            }\n            completed = receiverThreadManager.getRunningReceiverThreads().isEmpty();\n        }\n        mSystemsStarted = false;\n    }\n\n    public boolean isWatchdogRunning() {\n        return ((mWatchdogThread != null) && (mWatchdogThread.isAlive()));\n    }\n\n    /**\n     * TODO Kommentierung\n     */\n    private void startWatchdog() {\n        mWatchdog = new ReceiverServiceWatchdog();\n        mWatchdogThread = new Thread(mWatchdog, \"ReceiverServiceWatchdog\");\n        mWatchdogThread.start();\n    }\n\n    /**\n     * TODO Kommentierung\n     */\n    private void stopWatchdog() {\n        mWatchdog.stopWatchdog();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ReceiverServiceTest1.java",
		"test_prompt": "// ReceiverServiceTest1.java\npackage net.sf.xbus.technical;\n\nimport java.lang.management.ManagementFactory;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MalformedObjectNameException;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.ObjectName;\nimport net.sf.xbus.admin.jmx.Administrator;\nimport net.sf.xbus.application.PreProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverService}.\n* It contains ten unit test cases for the {@link ReceiverService#stop()} method.\n*/\nclass ReceiverServiceTest1 {"
	},
	{
		"original_code": "// ReceiverService.java\npackage net.sf.xbus.technical;\n\nimport java.lang.management.ManagementFactory;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MalformedObjectNameException;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.ObjectName;\nimport net.sf.xbus.admin.jmx.Administrator;\nimport net.sf.xbus.application.PreProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * <code>ReceiverService</code> runs as a background service and waits for\n * incoming messages to process.\n * <p>\n * At startup, <code>ReceiverService</code> searches for systems, which receiver\n * ends with <code>\"Thread\"</code>. For every found system, a thread is started\n * to process the messages. The used receivers must extend the\n * {@link net.sf.xbus.technical.ReceiverThreadBase}.\n * <p>\n */\npublic class ReceiverService {\n\n    /**\n     * Reference to the Singleton object\n     */\n    static private ReceiverService mReceiverService = null;\n\n    /**\n     * Used for locking during <code>getInstance</code>\n     */\n    static private final Object classLock = ReceiverService.class;\n\n    /**\n     * Indicates if the JMX administration shall be started\n     */\n    private boolean mStartJMX = false;\n\n    /**\n     * Indicates if the systems for processing incoming messages are already\n     * started\n     */\n    private boolean mSystemsStarted = false;\n\n    /**\n     * The Watchdog is a thread that checks every few seconds, if all\n     * ReceiverThreads are still running.\n     */\n    private ReceiverServiceWatchdog mWatchdog = null;\n\n    private Thread mWatchdogThread = null;\n\n    /**\n     * The constructor should be private to implement the <code>Singleton</code>\n     * pattern. But the bootstrapping mechanism needs a public constructor.\n     */\n    public ReceiverService() {\n    }\n\n    /**\n     * Returns the one and only instance of the <code>ReceiverService</code>,\n     * which implements the <b>Singleton </b> pattern. If the object doesn't\n     * exist, it is created.\n     *\n     * @return the one and only instance of the <code>ReceiverService</code>\n     */\n    public static ReceiverService getInstance() {\n        synchronized (classLock) {\n            if (mReceiverService == null) {\n                mReceiverService = new ReceiverService();\n            }\n            return mReceiverService;\n        }\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration.\n     *\n     * @param insideServletEngine\n     *            if true, the ReceiverService is running inside a servlet\n     *            engine\n     */\n    public synchronized void start(boolean insideServletEngine) throws XException {\n        Trace.always(\"Entering ReceiverService.start\");\n        /*\n\t\t * The class variable must be set here because an issue with the\n\t\t * classloader. Do not remove!\n\t\t */\n        mReceiverService = this;\n        /*\n\t\t * Register MBeans\n\t\t */\n        try {\n            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n            ObjectName name = new ObjectName(\"xBus:mbean=Administrator\");\n            Administrator mbean = new Administrator();\n            mbs.registerMBean(mbean, name);\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_ADMIN, Constants.PACKAGE_ADMIN_JMX, \"0\", e);\n        }\n        startAllSystems();\n        ReceiverThreadManager.getInstance().setIsServletEngine(insideServletEngine);\n        startWatchdog();\n        Trace.always(\"Leaving ReceiverService.start\");\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration. The\n     * <code>ReceiverService</code> is running inside a servlet engine.\n     */\n    public synchronized void startInsideServletEngine() throws XException {\n        start(true);\n    }\n\n    /**\n     * Starts all threads to receive messages and for administration. The\n     * <code>ReceiverService</code> is not running inside a servlet engine.\n     */\n    public synchronized void startWithoutServletEngine() throws XException {\n        start(false);\n    }\n\n    /**\n     * Stops all threads, including the administration threads.\n     *\n     * @return true if ReceiverService has been stopped\n     */\n    public synchronized boolean stop() throws XException {\n        Trace.always(\"Stopping ReceiverService...\");\n        stopWatchdog();\n        stopAllSystems();\n        TAManager.getInstance().close();\n        // if (mStartJMX)\n        // {\n        // AdministratorJMXServer.stop();\n        // }\n        Trace.always(\"ReceiverService stopped\");\n        return true;\n    }\n\n    /**\n     * Starts all configured threads to process message for different systems.\n     */\n    public synchronized void startAllSystems() throws XException {\n        Configuration config = Configuration.getInstance();\n        PreProcessor.process(PreProcessor.RECEIVER_SERVICE);\n        List sections = config.getSections(Constants.CHAPTER_SYSTEM);\n        String system = null;\n        String receiver = null;\n        for (Iterator it = sections.iterator(); it.hasNext(); ) {\n            system = (String) it.next();\n            receiver = config.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Receiver\");\n            if ((receiver != null) && (receiver.endsWith(\"Thread\"))) {\n                ReceiverThreadManager.getInstance().startReceiverThread(system);\n            }\n        }\n        mSystemsStarted = true;\n    }\n\n    /**\n     * Stops all threads after processing their current message.\n     */\n    public synchronized void stopAllSystems() throws XException {\n        if (!mSystemsStarted) {\n            return;\n        }\n        ReceiverThreadManager receiverThreadManager = ReceiverThreadManager.getInstance();\n        /*\n\t\t * Demand to stop all running systems\n\t\t */\n        String systemname;\n        for (Iterator i = receiverThreadManager.getRunningReceiverThreads().iterator(); i.hasNext(); ) {\n            systemname = (String) i.next();\n            receiverThreadManager.demandStopReceiverThread(systemname);\n        }\n        /*\n\t\t * Wait until all systems have been stopped\n\t\t */\n        boolean completed = receiverThreadManager.getRunningReceiverThreads().isEmpty();\n        while (!completed) {\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n            }\n            completed = receiverThreadManager.getRunningReceiverThreads().isEmpty();\n        }\n        mSystemsStarted = false;\n    }\n\n    public boolean isWatchdogRunning() {\n        return ((mWatchdogThread != null) && (mWatchdogThread.isAlive()));\n    }\n\n    /**\n     * TODO Kommentierung\n     */\n    private void startWatchdog() {\n        mWatchdog = new ReceiverServiceWatchdog();\n        mWatchdogThread = new Thread(mWatchdog, \"ReceiverServiceWatchdog\");\n        mWatchdogThread.start();\n    }\n\n    /**\n     * TODO Kommentierung\n     */\n    private void stopWatchdog() {\n        mWatchdog.stopWatchdog();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/ReceiverServiceTest2.java",
		"test_prompt": "// ReceiverServiceTest2.java\npackage net.sf.xbus.technical;\n\nimport java.lang.management.ManagementFactory;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.management.InstanceAlreadyExistsException;\nimport javax.management.MBeanRegistrationException;\nimport javax.management.MBeanServer;\nimport javax.management.MalformedObjectNameException;\nimport javax.management.NotCompliantMBeanException;\nimport javax.management.ObjectName;\nimport net.sf.xbus.admin.jmx.Administrator;\nimport net.sf.xbus.application.PreProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReceiverService}.\n* It contains ten unit test cases for the {@link ReceiverService#isWatchdogRunning()} method.\n*/\nclass ReceiverServiceTest2 {"
	},
	{
		"original_code": "// HTTPSender.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.HttpState;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.commons.httpclient.methods.StringRequestEntity;\nimport org.apache.commons.httpclient.params.HttpClientParams;\nimport org.apache.commons.httpclient.protocol.Protocol;\nimport org.apache.commons.io.IOUtils;\n\n/**\n * The <code>HTTPSender</code> sends a message to an URL.\n * <p>\n * For sending <code>SOAPMessages</code> there are two special features:\n * <ul>\n * <li>The HTTP Header contains an additional entry <code>SOAPAction</code>,\n * referencing the function.</li>\n * <li>When the other side sends a returncode other than <code>OK</code>,\n * the <code>HTTPSender</code> reads the error stream as the response.</li>\n * </ul>\n */\npublic class HTTPSender implements Sender, TextSender {\n\n    XBUSSystem mDestination = null;\n\n    String mContentType = null;\n\n    /**\n     * Stores the destination for later use.\n     */\n    public HTTPSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    /**\n     * Sends the <code>callData</code> to the system. <code>function</code>\n     * is ignored.\n     *\n     * @return <code>null</code>\n     */\n    public String execute(String function, String callData) throws XException {\n        PostMethod method = initialize(function, null);\n        if (callData == null)\n            callData = \"\";\n        method.setRequestEntity(new StringRequestEntity(callData));\n        // method.setRequestContentLength(callData.length());\n        // method.setRequestBody(callData);\n        return sendMessage(method);\n    }\n\n    protected PostMethod initialize(String function, String url) throws XException {\n        Configuration config = Configuration.getInstance();\n        /*\n\t\t * HTTPParameterSender doesn`t have a Content-Type, all other\n\t\t * HTTPxxxSenders must have that parameter\n\t\t */\n        if (!(this instanceof HTTPParameterSender)) {\n            mContentType = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Content-Type\");\n        }\n        /*\n\t\t * If no URL is given, we must have it in the configuration\n\t\t */\n        if (url == null) {\n            url = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"URL\");\n        }\n        url = mDestination.replaceAllMarkers(url)[0];\n        setKeystore(url);\n        /*\n\t\t * Self-signed certificates SHOULD NOT be used for productive systems\n\t\t * due to security reasons, unless it is a concious decision and you are\n\t\t * perfectly aware of security implications of accepting self-signed\n\t\t * certificates.\n\t\t */\n        boolean allowSelfSignedCertificate = config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"AllowSelfSignedCertificate\");\n        if (allowSelfSignedCertificate) {\n            Protocol.registerProtocol(\"https\", new Protocol(\"https\", new EasySSLProtocolSocketFactory(), 8443));\n        }\n        PostMethod method = new PostMethod(url);\n        setRequestHeaders(function, method);\n        return method;\n    }\n\n    protected void setRequestHeaders(String function, PostMethod method) throws XException {\n        if (mContentType != null) {\n            method.setRequestHeader(\"Content-Type\", mContentType);\n        }\n        if (isSOAPMessage()) {\n            method.setRequestHeader(\"SOAPAction\", function);\n        }\n    }\n\n    protected String sendMessage(PostMethod method) throws XException {\n        String response = null;\n        int statusCode = 0;\n        try {\n            HttpClient client = new HttpClient();\n            setAuthentication(client, method);\n            statusCode = client.executeMethod(method);\n            response = IOUtils.toString(method.getResponseBodyAsStream(), method.getResponseCharSet());\n            method.releaseConnection();\n            if (((statusCode < 200) || statusCode > 299) && (!isSOAPMessage())) {\n                List params = new Vector();\n                params.add(String.valueOf(statusCode));\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_HTTP, \"1\", params);\n            }\n        } catch (HttpException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_HTTP, \"0\", e);\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_HTTP, \"0\", e);\n        }\n        return response;\n    }\n\n    private boolean isSOAPMessage() throws XException {\n        Configuration config = Configuration.getInstance();\n        String message = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Message\");\n        boolean isSOAPMessage = (\"SOAPMessage\".equals(message));\n        return isSOAPMessage;\n    }\n\n    private void setKeystore(String urlName) throws XException {\n        Configuration config = Configuration.getInstance();\n        try {\n            URL url = new URL(urlName);\n            if (\"https\".equals(url.getProtocol()) && (System.getProperty(\"javax.net.ssl.trustStore\") == null)) {\n                System.setProperty(\"javax.net.ssl.trustStore\", Constants.XBUS_ETC + config.getValue(\"Connection\", \"HTTP\", \"Keystore\"));\n            }\n        } catch (MalformedURLException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_HTTP, \"0\", e);\n        }\n    }\n\n    private void setAuthentication(HttpClient client, HttpMethod method) throws XException {\n        Configuration config = Configuration.getInstance();\n        String user = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"User\");\n        if (user != null) {\n            String realm = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Realm\");\n            String password = config.getValueOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Password\");\n            HttpState state = client.getState();\n            state.setCredentials(new AuthScope(client.getHostConfiguration().getHost(), client.getHostConfiguration().getPort(), realm), new UsernamePasswordCredentials(user, password));\n            HttpClientParams params = new HttpClientParams();\n            params.setAuthenticationPreemptive(config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"AuthenticationPreemptive\"));\n            client.setParams(params);\n        }\n    }\n\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/HTTPSenderTest.java",
		"test_prompt": "// HTTPSenderTest.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.commons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.HttpState;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.commons.httpclient.methods.StringRequestEntity;\nimport org.apache.commons.httpclient.params.HttpClientParams;\nimport org.apache.commons.httpclient.protocol.Protocol;\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTTPSender}.\n* It contains ten unit test cases for the {@link HTTPSender#execute(String, String)} method.\n*/\nclass HTTPSenderTest {"
	},
	{
		"original_code": "// HTTPByteArrayListSender.java\npackage net.sf.xbus.technical.http;\n\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\n\n/**\n * The <code>HTTPByteArrayListSender</code> sends a ByteArrayList in the form\n * of a String to an URL.\n */\npublic class HTTPByteArrayListSender extends HTTPSender implements Sender, ObjectSender {\n\n    /**\n     * @see HTTPSender#HTTPSender(XBUSSystem)\n     */\n    public HTTPByteArrayListSender(XBUSSystem destination) {\n        super(destination);\n    }\n\n    // HTTPByteArrayListSender(XBUSSystem destination)\n    /**\n     * Sends the <code>callData</code> to the system. <code>function</code>\n     * is ignored.\n     */\n    public Object execute(String function, Object callData) throws XException {\n        String callString = ((ByteArrayList) callData).getContentAsString(mDestination.getName());\n        super.execute(function, callString);\n        return null;\n    }\n\n    // execute(String function, Object callData)\n    /**\n     * @see net.sf.xbus.technical.Sender#getType()\n     *\n     * @return Constants.TYPE_OBJECT\n     */\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n    // getType()\n}\n// HTTPByteArrayListSender\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/HTTPByteArrayListSenderTest.java",
		"test_prompt": "// HTTPByteArrayListSenderTest.java\npackage net.sf.xbus.technical.http;\n\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTTPByteArrayListSender}.\n* It contains ten unit test cases for the {@link HTTPByteArrayListSender#execute(String, Object)} method.\n*/\nclass HTTPByteArrayListSenderTest {"
	},
	{
		"original_code": "// HTTPStreamSender.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.apache.commons.httpclient.methods.InputStreamRequestEntity;\nimport org.apache.commons.httpclient.methods.PostMethod;\n\n/**\n * <code>HTTPStreamSender</code> gets an <code>InputStream</code> and\n * streams it to an URL.\n */\npublic class HTTPStreamSender extends HTTPSender implements Sender, ObjectSender {\n\n    /**\n     * Stores the given destination.\n     *\n     * @param destination name of the interface definition\n     * @throws XException never\n     */\n    public HTTPStreamSender(XBUSSystem destination) {\n        super(destination);\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.ObjectSender#execute(java.lang.String,\n\t *      java.lang.Object)\n\t */\n    public Object execute(String function, Object callData) throws XException {\n        PostMethod method = initialize(function, null);\n        InputStream inStream = (InputStream) callData;\n        method.setRequestEntity(new InputStreamRequestEntity(inStream));\n        sendMessage(method);\n        try {\n            inStream.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_HTTP, \"0\", e);\n        }\n        return null;\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.Sender#getType()\n\t */\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/HTTPStreamSenderTest.java",
		"test_prompt": "// HTTPStreamSenderTest.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.apache.commons.httpclient.methods.InputStreamRequestEntity;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTTPStreamSender}.\n* It contains ten unit test cases for the {@link HTTPStreamSender#execute(String, Object)} method.\n*/\nclass HTTPStreamSenderTest {"
	},
	{
		"original_code": "// HTTPParameterSender.java\npackage net.sf.xbus.technical.http;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.apache.commons.httpclient.NameValuePair;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>HTTPParameterSender</code> gets a XML document containing parameter\n * and values and sends them as a query string to an URL.\n */\npublic class HTTPParameterSender extends HTTPSender implements Sender, ObjectSender {\n\n    /**\n     * Stores the given destination.\n     *\n     * @param destination\n     *            name of the interface definition\n     * @throws XException\n     *             never\n     */\n    public HTTPParameterSender(XBUSSystem destination) {\n        super(destination);\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.ObjectSender#execute(java.lang.String,\n\t *      java.lang.Object)\n\t */\n    public Object execute(String function, Object callData) throws XException {\n        Document doc = (Document) callData;\n        XDomSupport.deleteWhitespaceTextInElementNodes(doc);\n        NodeList nodes = doc.getChildNodes();\n        if ((nodes == null) || (nodes.getLength() == 0)) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_HTTP, \"4\");\n        }\n        Node rootNode = nodes.item(0);\n        String url = XMLHelper.getAttribute(rootNode, \"url\");\n        PostMethod method = initialize(function, url);\n        nodes = rootNode.getChildNodes();\n        String name = null;\n        String value = null;\n        Vector params = new Vector();\n        for (int i = 0; i < nodes.getLength(); i++) {\n            name = nodes.item(i).getNodeName();\n            value = XMLHelper.getNodeText(nodes.item(i));\n            if (value == null) {\n                value = \"\";\n            }\n            params.add(new NameValuePair(name, value));\n        }\n        /*\n\t\t * Copy WILDCARDS from XBUSSystem into parameters\n\t\t */\n        Hashtable info = mDestination.getAddresses();\n        String key = null;\n        for (Enumeration en = info.keys(); en.hasMoreElements(); ) {\n            key = (String) en.nextElement();\n            if (XBUSSystem.FILENAME_WILDCARD.equals(key)) {\n                value = (String) info.get(key);\n                params.add(new NameValuePair(key, value));\n            }\n        }\n        NameValuePair[] paramArray = new NameValuePair[params.size()];\n        params.copyInto(paramArray);\n        method.setQueryString(paramArray);\n        String response = sendMessage(method);\n        return XMLHelper.parseXML(response, \"Default\", mDestination.getName());\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.Sender#getType()\n\t */\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/HTTPParameterSenderTest.java",
		"test_prompt": "// HTTPParameterSenderTest.java\npackage net.sf.xbus.technical.http;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.apache.commons.httpclient.NameValuePair;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HTTPParameterSender}.\n* It contains ten unit test cases for the {@link HTTPParameterSender#execute(String, Object)} method.\n*/\nclass HTTPParameterSenderTest {"
	},
	{
		"original_code": "// EasySSLProtocolSocketFactory.java\n/*\n * ====================================================================\n *\n *  Copyright 2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\n/**\n * <p>\n * EasySSLProtocolSocketFactory can be used to creats SSL {@link Socket}s that\n * accept self-signed certificates.\n * </p>\n * <p>\n * This socket factory SHOULD NOT be used for productive systems due to security\n * reasons, unless it is a concious decision and you are perfectly aware of\n * security implications of accepting self-signed certificates\n * </p>\n *\n * <p>\n * Example of using custom protocol socket factory for a specific host:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n *\n * HttpClient client = new HttpClient();\n * client.getHostConfiguration().setHost(&quot;localhost&quot;, 443, easyhttps);\n * // use relative url only\n * GetMethod httpget = new GetMethod(&quot;/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n * <p>\n * Example of using custom protocol socket factory per default instead of the\n * standard one:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n * Protocol.registerProtocol(&quot;https&quot;, easyhttps);\n *\n * HttpClient client = new HttpClient();\n * GetMethod httpget = new GetMethod(&quot;https://localhost/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n *\n * @author <a href=\"mailto:oleg -at- ural.ru\">Oleg Kalnichevski</a>\n *\n * <p>\n * DISCLAIMER: HttpClient developers DO NOT actively support this component. The\n * component is provided as a reference material, which may be inappropriate for\n * use without additional customization.\n * </p>\n */\npublic class EasySSLProtocolSocketFactory implements SecureProtocolSocketFactory {\n\n    /**\n     * Log object for this class.\n     */\n    private static final Log LOG = LogFactory.getLog(EasySSLProtocolSocketFactory.class);\n\n    private SSLContext sslcontext = null;\n\n    /**\n     * Constructor for EasySSLProtocolSocketFactory.\n     */\n    public EasySSLProtocolSocketFactory() {\n        super();\n    }\n\n    private static SSLContext createEasySSLContext() {\n        try {\n            SSLContext context = SSLContext.getInstance(\"SSL\");\n            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n            return context;\n        } catch (Exception e) {\n            LOG.error(e.getMessage(), e);\n            throw new HttpClientError(e.toString());\n        }\n    }\n\n    private SSLContext getSSLContext() {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int,java.net.InetAddress,int)\n     */\n    public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);\n    }\n\n    /**\n     * Attempts to get a new socket connection to the given host within the\n     * given time limit.\n     * <p>\n     * To circumvent the limitations of older JREs that do not support connect\n     * timeout a controller thread is executed. The controller thread attempts\n     * to create a new socket within the given limit of time. If socket\n     * constructor does not return until the timeout expires, the controller\n     * terminates and throws an {@link ConnectTimeoutException}\n     * </p>\n     *\n     * @param host\n     *            the host name/IP\n     * @param port\n     *            the port on the host\n     * @param clientHost\n     *            the local host name/IP to bind the socket to\n     * @param clientPort\n     *            the port on the local machine\n     * @param params\n     *            {@link HttpConnectionParams Http connection parameters}\n     *\n     * @return Socket a new socket\n     *\n     * @throws IOException\n     *             if an I/O error occurs while creating the socket\n     * @throws UnknownHostException\n     *             if the IP address of the host cannot be determined\n     */\n    public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        SocketFactory socketfactory = getSSLContext().getSocketFactory();\n        if (timeout == 0) {\n            return socketfactory.createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = socketfactory.createSocket();\n            SocketAddress localaddr = new InetSocketAddress(localAddress, localPort);\n            SocketAddress remoteaddr = new InetSocketAddress(host, port);\n            socket.bind(localaddr);\n            socket.connect(remoteaddr, timeout);\n            return socket;\n        }\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int)\n     */\n    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port);\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket,java.lang.String,int,boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(EasySSLProtocolSocketFactory.class));\n    }\n\n    public int hashCode() {\n        return EasySSLProtocolSocketFactory.class.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/EasySSLProtocolSocketFactoryTest0.java",
		"test_prompt": "// EasySSLProtocolSocketFactoryTest0.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EasySSLProtocolSocketFactory}.\n* It contains ten unit test cases for the {@link EasySSLProtocolSocketFactory#createSocket(String, int, InetAddress, int)} method.\n*/\nclass EasySSLProtocolSocketFactoryTest0 {"
	},
	{
		"original_code": "// EasySSLProtocolSocketFactory.java\n/*\n * ====================================================================\n *\n *  Copyright 2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\n/**\n * <p>\n * EasySSLProtocolSocketFactory can be used to creats SSL {@link Socket}s that\n * accept self-signed certificates.\n * </p>\n * <p>\n * This socket factory SHOULD NOT be used for productive systems due to security\n * reasons, unless it is a concious decision and you are perfectly aware of\n * security implications of accepting self-signed certificates\n * </p>\n *\n * <p>\n * Example of using custom protocol socket factory for a specific host:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n *\n * HttpClient client = new HttpClient();\n * client.getHostConfiguration().setHost(&quot;localhost&quot;, 443, easyhttps);\n * // use relative url only\n * GetMethod httpget = new GetMethod(&quot;/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n * <p>\n * Example of using custom protocol socket factory per default instead of the\n * standard one:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n * Protocol.registerProtocol(&quot;https&quot;, easyhttps);\n *\n * HttpClient client = new HttpClient();\n * GetMethod httpget = new GetMethod(&quot;https://localhost/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n *\n * @author <a href=\"mailto:oleg -at- ural.ru\">Oleg Kalnichevski</a>\n *\n * <p>\n * DISCLAIMER: HttpClient developers DO NOT actively support this component. The\n * component is provided as a reference material, which may be inappropriate for\n * use without additional customization.\n * </p>\n */\npublic class EasySSLProtocolSocketFactory implements SecureProtocolSocketFactory {\n\n    /**\n     * Log object for this class.\n     */\n    private static final Log LOG = LogFactory.getLog(EasySSLProtocolSocketFactory.class);\n\n    private SSLContext sslcontext = null;\n\n    /**\n     * Constructor for EasySSLProtocolSocketFactory.\n     */\n    public EasySSLProtocolSocketFactory() {\n        super();\n    }\n\n    private static SSLContext createEasySSLContext() {\n        try {\n            SSLContext context = SSLContext.getInstance(\"SSL\");\n            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n            return context;\n        } catch (Exception e) {\n            LOG.error(e.getMessage(), e);\n            throw new HttpClientError(e.toString());\n        }\n    }\n\n    private SSLContext getSSLContext() {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int,java.net.InetAddress,int)\n     */\n    public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);\n    }\n\n    /**\n     * Attempts to get a new socket connection to the given host within the\n     * given time limit.\n     * <p>\n     * To circumvent the limitations of older JREs that do not support connect\n     * timeout a controller thread is executed. The controller thread attempts\n     * to create a new socket within the given limit of time. If socket\n     * constructor does not return until the timeout expires, the controller\n     * terminates and throws an {@link ConnectTimeoutException}\n     * </p>\n     *\n     * @param host\n     *            the host name/IP\n     * @param port\n     *            the port on the host\n     * @param clientHost\n     *            the local host name/IP to bind the socket to\n     * @param clientPort\n     *            the port on the local machine\n     * @param params\n     *            {@link HttpConnectionParams Http connection parameters}\n     *\n     * @return Socket a new socket\n     *\n     * @throws IOException\n     *             if an I/O error occurs while creating the socket\n     * @throws UnknownHostException\n     *             if the IP address of the host cannot be determined\n     */\n    public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        SocketFactory socketfactory = getSSLContext().getSocketFactory();\n        if (timeout == 0) {\n            return socketfactory.createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = socketfactory.createSocket();\n            SocketAddress localaddr = new InetSocketAddress(localAddress, localPort);\n            SocketAddress remoteaddr = new InetSocketAddress(host, port);\n            socket.bind(localaddr);\n            socket.connect(remoteaddr, timeout);\n            return socket;\n        }\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int)\n     */\n    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port);\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket,java.lang.String,int,boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(EasySSLProtocolSocketFactory.class));\n    }\n\n    public int hashCode() {\n        return EasySSLProtocolSocketFactory.class.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/EasySSLProtocolSocketFactoryTest1.java",
		"test_prompt": "// EasySSLProtocolSocketFactoryTest1.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EasySSLProtocolSocketFactory}.\n* It contains ten unit test cases for the {@link EasySSLProtocolSocketFactory#createSocket(String, int, InetAddress, int, HttpConnectionParams)} method.\n*/\nclass EasySSLProtocolSocketFactoryTest1 {"
	},
	{
		"original_code": "// EasySSLProtocolSocketFactory.java\n/*\n * ====================================================================\n *\n *  Copyright 2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\n/**\n * <p>\n * EasySSLProtocolSocketFactory can be used to creats SSL {@link Socket}s that\n * accept self-signed certificates.\n * </p>\n * <p>\n * This socket factory SHOULD NOT be used for productive systems due to security\n * reasons, unless it is a concious decision and you are perfectly aware of\n * security implications of accepting self-signed certificates\n * </p>\n *\n * <p>\n * Example of using custom protocol socket factory for a specific host:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n *\n * HttpClient client = new HttpClient();\n * client.getHostConfiguration().setHost(&quot;localhost&quot;, 443, easyhttps);\n * // use relative url only\n * GetMethod httpget = new GetMethod(&quot;/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n * <p>\n * Example of using custom protocol socket factory per default instead of the\n * standard one:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n * Protocol.registerProtocol(&quot;https&quot;, easyhttps);\n *\n * HttpClient client = new HttpClient();\n * GetMethod httpget = new GetMethod(&quot;https://localhost/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n *\n * @author <a href=\"mailto:oleg -at- ural.ru\">Oleg Kalnichevski</a>\n *\n * <p>\n * DISCLAIMER: HttpClient developers DO NOT actively support this component. The\n * component is provided as a reference material, which may be inappropriate for\n * use without additional customization.\n * </p>\n */\npublic class EasySSLProtocolSocketFactory implements SecureProtocolSocketFactory {\n\n    /**\n     * Log object for this class.\n     */\n    private static final Log LOG = LogFactory.getLog(EasySSLProtocolSocketFactory.class);\n\n    private SSLContext sslcontext = null;\n\n    /**\n     * Constructor for EasySSLProtocolSocketFactory.\n     */\n    public EasySSLProtocolSocketFactory() {\n        super();\n    }\n\n    private static SSLContext createEasySSLContext() {\n        try {\n            SSLContext context = SSLContext.getInstance(\"SSL\");\n            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n            return context;\n        } catch (Exception e) {\n            LOG.error(e.getMessage(), e);\n            throw new HttpClientError(e.toString());\n        }\n    }\n\n    private SSLContext getSSLContext() {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int,java.net.InetAddress,int)\n     */\n    public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);\n    }\n\n    /**\n     * Attempts to get a new socket connection to the given host within the\n     * given time limit.\n     * <p>\n     * To circumvent the limitations of older JREs that do not support connect\n     * timeout a controller thread is executed. The controller thread attempts\n     * to create a new socket within the given limit of time. If socket\n     * constructor does not return until the timeout expires, the controller\n     * terminates and throws an {@link ConnectTimeoutException}\n     * </p>\n     *\n     * @param host\n     *            the host name/IP\n     * @param port\n     *            the port on the host\n     * @param clientHost\n     *            the local host name/IP to bind the socket to\n     * @param clientPort\n     *            the port on the local machine\n     * @param params\n     *            {@link HttpConnectionParams Http connection parameters}\n     *\n     * @return Socket a new socket\n     *\n     * @throws IOException\n     *             if an I/O error occurs while creating the socket\n     * @throws UnknownHostException\n     *             if the IP address of the host cannot be determined\n     */\n    public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        SocketFactory socketfactory = getSSLContext().getSocketFactory();\n        if (timeout == 0) {\n            return socketfactory.createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = socketfactory.createSocket();\n            SocketAddress localaddr = new InetSocketAddress(localAddress, localPort);\n            SocketAddress remoteaddr = new InetSocketAddress(host, port);\n            socket.bind(localaddr);\n            socket.connect(remoteaddr, timeout);\n            return socket;\n        }\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int)\n     */\n    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port);\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket,java.lang.String,int,boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(EasySSLProtocolSocketFactory.class));\n    }\n\n    public int hashCode() {\n        return EasySSLProtocolSocketFactory.class.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/EasySSLProtocolSocketFactoryTest2.java",
		"test_prompt": "// EasySSLProtocolSocketFactoryTest2.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EasySSLProtocolSocketFactory}.\n* It contains ten unit test cases for the {@link EasySSLProtocolSocketFactory#createSocket(String, int)} method.\n*/\nclass EasySSLProtocolSocketFactoryTest2 {"
	},
	{
		"original_code": "// EasySSLProtocolSocketFactory.java\n/*\n * ====================================================================\n *\n *  Copyright 2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\n/**\n * <p>\n * EasySSLProtocolSocketFactory can be used to creats SSL {@link Socket}s that\n * accept self-signed certificates.\n * </p>\n * <p>\n * This socket factory SHOULD NOT be used for productive systems due to security\n * reasons, unless it is a concious decision and you are perfectly aware of\n * security implications of accepting self-signed certificates\n * </p>\n *\n * <p>\n * Example of using custom protocol socket factory for a specific host:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n *\n * HttpClient client = new HttpClient();\n * client.getHostConfiguration().setHost(&quot;localhost&quot;, 443, easyhttps);\n * // use relative url only\n * GetMethod httpget = new GetMethod(&quot;/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n * <p>\n * Example of using custom protocol socket factory per default instead of the\n * standard one:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n * Protocol.registerProtocol(&quot;https&quot;, easyhttps);\n *\n * HttpClient client = new HttpClient();\n * GetMethod httpget = new GetMethod(&quot;https://localhost/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n *\n * @author <a href=\"mailto:oleg -at- ural.ru\">Oleg Kalnichevski</a>\n *\n * <p>\n * DISCLAIMER: HttpClient developers DO NOT actively support this component. The\n * component is provided as a reference material, which may be inappropriate for\n * use without additional customization.\n * </p>\n */\npublic class EasySSLProtocolSocketFactory implements SecureProtocolSocketFactory {\n\n    /**\n     * Log object for this class.\n     */\n    private static final Log LOG = LogFactory.getLog(EasySSLProtocolSocketFactory.class);\n\n    private SSLContext sslcontext = null;\n\n    /**\n     * Constructor for EasySSLProtocolSocketFactory.\n     */\n    public EasySSLProtocolSocketFactory() {\n        super();\n    }\n\n    private static SSLContext createEasySSLContext() {\n        try {\n            SSLContext context = SSLContext.getInstance(\"SSL\");\n            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n            return context;\n        } catch (Exception e) {\n            LOG.error(e.getMessage(), e);\n            throw new HttpClientError(e.toString());\n        }\n    }\n\n    private SSLContext getSSLContext() {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int,java.net.InetAddress,int)\n     */\n    public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);\n    }\n\n    /**\n     * Attempts to get a new socket connection to the given host within the\n     * given time limit.\n     * <p>\n     * To circumvent the limitations of older JREs that do not support connect\n     * timeout a controller thread is executed. The controller thread attempts\n     * to create a new socket within the given limit of time. If socket\n     * constructor does not return until the timeout expires, the controller\n     * terminates and throws an {@link ConnectTimeoutException}\n     * </p>\n     *\n     * @param host\n     *            the host name/IP\n     * @param port\n     *            the port on the host\n     * @param clientHost\n     *            the local host name/IP to bind the socket to\n     * @param clientPort\n     *            the port on the local machine\n     * @param params\n     *            {@link HttpConnectionParams Http connection parameters}\n     *\n     * @return Socket a new socket\n     *\n     * @throws IOException\n     *             if an I/O error occurs while creating the socket\n     * @throws UnknownHostException\n     *             if the IP address of the host cannot be determined\n     */\n    public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        SocketFactory socketfactory = getSSLContext().getSocketFactory();\n        if (timeout == 0) {\n            return socketfactory.createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = socketfactory.createSocket();\n            SocketAddress localaddr = new InetSocketAddress(localAddress, localPort);\n            SocketAddress remoteaddr = new InetSocketAddress(host, port);\n            socket.bind(localaddr);\n            socket.connect(remoteaddr, timeout);\n            return socket;\n        }\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int)\n     */\n    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port);\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket,java.lang.String,int,boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(EasySSLProtocolSocketFactory.class));\n    }\n\n    public int hashCode() {\n        return EasySSLProtocolSocketFactory.class.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/EasySSLProtocolSocketFactoryTest3.java",
		"test_prompt": "// EasySSLProtocolSocketFactoryTest3.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EasySSLProtocolSocketFactory}.\n* It contains ten unit test cases for the {@link EasySSLProtocolSocketFactory#createSocket(Socket, String, int, boolean)} method.\n*/\nclass EasySSLProtocolSocketFactoryTest3 {"
	},
	{
		"original_code": "// EasySSLProtocolSocketFactory.java\n/*\n * ====================================================================\n *\n *  Copyright 2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\n/**\n * <p>\n * EasySSLProtocolSocketFactory can be used to creats SSL {@link Socket}s that\n * accept self-signed certificates.\n * </p>\n * <p>\n * This socket factory SHOULD NOT be used for productive systems due to security\n * reasons, unless it is a concious decision and you are perfectly aware of\n * security implications of accepting self-signed certificates\n * </p>\n *\n * <p>\n * Example of using custom protocol socket factory for a specific host:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n *\n * HttpClient client = new HttpClient();\n * client.getHostConfiguration().setHost(&quot;localhost&quot;, 443, easyhttps);\n * // use relative url only\n * GetMethod httpget = new GetMethod(&quot;/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n * <p>\n * Example of using custom protocol socket factory per default instead of the\n * standard one:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n * Protocol.registerProtocol(&quot;https&quot;, easyhttps);\n *\n * HttpClient client = new HttpClient();\n * GetMethod httpget = new GetMethod(&quot;https://localhost/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n *\n * @author <a href=\"mailto:oleg -at- ural.ru\">Oleg Kalnichevski</a>\n *\n * <p>\n * DISCLAIMER: HttpClient developers DO NOT actively support this component. The\n * component is provided as a reference material, which may be inappropriate for\n * use without additional customization.\n * </p>\n */\npublic class EasySSLProtocolSocketFactory implements SecureProtocolSocketFactory {\n\n    /**\n     * Log object for this class.\n     */\n    private static final Log LOG = LogFactory.getLog(EasySSLProtocolSocketFactory.class);\n\n    private SSLContext sslcontext = null;\n\n    /**\n     * Constructor for EasySSLProtocolSocketFactory.\n     */\n    public EasySSLProtocolSocketFactory() {\n        super();\n    }\n\n    private static SSLContext createEasySSLContext() {\n        try {\n            SSLContext context = SSLContext.getInstance(\"SSL\");\n            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n            return context;\n        } catch (Exception e) {\n            LOG.error(e.getMessage(), e);\n            throw new HttpClientError(e.toString());\n        }\n    }\n\n    private SSLContext getSSLContext() {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int,java.net.InetAddress,int)\n     */\n    public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);\n    }\n\n    /**\n     * Attempts to get a new socket connection to the given host within the\n     * given time limit.\n     * <p>\n     * To circumvent the limitations of older JREs that do not support connect\n     * timeout a controller thread is executed. The controller thread attempts\n     * to create a new socket within the given limit of time. If socket\n     * constructor does not return until the timeout expires, the controller\n     * terminates and throws an {@link ConnectTimeoutException}\n     * </p>\n     *\n     * @param host\n     *            the host name/IP\n     * @param port\n     *            the port on the host\n     * @param clientHost\n     *            the local host name/IP to bind the socket to\n     * @param clientPort\n     *            the port on the local machine\n     * @param params\n     *            {@link HttpConnectionParams Http connection parameters}\n     *\n     * @return Socket a new socket\n     *\n     * @throws IOException\n     *             if an I/O error occurs while creating the socket\n     * @throws UnknownHostException\n     *             if the IP address of the host cannot be determined\n     */\n    public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        SocketFactory socketfactory = getSSLContext().getSocketFactory();\n        if (timeout == 0) {\n            return socketfactory.createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = socketfactory.createSocket();\n            SocketAddress localaddr = new InetSocketAddress(localAddress, localPort);\n            SocketAddress remoteaddr = new InetSocketAddress(host, port);\n            socket.bind(localaddr);\n            socket.connect(remoteaddr, timeout);\n            return socket;\n        }\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int)\n     */\n    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port);\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket,java.lang.String,int,boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(EasySSLProtocolSocketFactory.class));\n    }\n\n    public int hashCode() {\n        return EasySSLProtocolSocketFactory.class.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/EasySSLProtocolSocketFactoryTest4.java",
		"test_prompt": "// EasySSLProtocolSocketFactoryTest4.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EasySSLProtocolSocketFactory}.\n* It contains ten unit test cases for the {@link EasySSLProtocolSocketFactory#equals(Object)} method.\n*/\nclass EasySSLProtocolSocketFactoryTest4 {"
	},
	{
		"original_code": "// EasySSLProtocolSocketFactory.java\n/*\n * ====================================================================\n *\n *  Copyright 2002-2004 The Apache Software Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\n/**\n * <p>\n * EasySSLProtocolSocketFactory can be used to creats SSL {@link Socket}s that\n * accept self-signed certificates.\n * </p>\n * <p>\n * This socket factory SHOULD NOT be used for productive systems due to security\n * reasons, unless it is a concious decision and you are perfectly aware of\n * security implications of accepting self-signed certificates\n * </p>\n *\n * <p>\n * Example of using custom protocol socket factory for a specific host:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n *\n * HttpClient client = new HttpClient();\n * client.getHostConfiguration().setHost(&quot;localhost&quot;, 443, easyhttps);\n * // use relative url only\n * GetMethod httpget = new GetMethod(&quot;/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n * <p>\n * Example of using custom protocol socket factory per default instead of the\n * standard one:\n *\n * <pre>\n * Protocol easyhttps = new Protocol(&quot;https&quot;, new EasySSLProtocolSocketFactory(),\n * \t\t443);\n * Protocol.registerProtocol(&quot;https&quot;, easyhttps);\n *\n * HttpClient client = new HttpClient();\n * GetMethod httpget = new GetMethod(&quot;https://localhost/&quot;);\n * client.executeMethod(httpget);\n * </pre>\n *\n * </p>\n *\n * @author <a href=\"mailto:oleg -at- ural.ru\">Oleg Kalnichevski</a>\n *\n * <p>\n * DISCLAIMER: HttpClient developers DO NOT actively support this component. The\n * component is provided as a reference material, which may be inappropriate for\n * use without additional customization.\n * </p>\n */\npublic class EasySSLProtocolSocketFactory implements SecureProtocolSocketFactory {\n\n    /**\n     * Log object for this class.\n     */\n    private static final Log LOG = LogFactory.getLog(EasySSLProtocolSocketFactory.class);\n\n    private SSLContext sslcontext = null;\n\n    /**\n     * Constructor for EasySSLProtocolSocketFactory.\n     */\n    public EasySSLProtocolSocketFactory() {\n        super();\n    }\n\n    private static SSLContext createEasySSLContext() {\n        try {\n            SSLContext context = SSLContext.getInstance(\"SSL\");\n            context.init(null, new TrustManager[] { new EasyX509TrustManager(null) }, null);\n            return context;\n        } catch (Exception e) {\n            LOG.error(e.getMessage(), e);\n            throw new HttpClientError(e.toString());\n        }\n    }\n\n    private SSLContext getSSLContext() {\n        if (this.sslcontext == null) {\n            this.sslcontext = createEasySSLContext();\n        }\n        return this.sslcontext;\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int,java.net.InetAddress,int)\n     */\n    public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);\n    }\n\n    /**\n     * Attempts to get a new socket connection to the given host within the\n     * given time limit.\n     * <p>\n     * To circumvent the limitations of older JREs that do not support connect\n     * timeout a controller thread is executed. The controller thread attempts\n     * to create a new socket within the given limit of time. If socket\n     * constructor does not return until the timeout expires, the controller\n     * terminates and throws an {@link ConnectTimeoutException}\n     * </p>\n     *\n     * @param host\n     *            the host name/IP\n     * @param port\n     *            the port on the host\n     * @param clientHost\n     *            the local host name/IP to bind the socket to\n     * @param clientPort\n     *            the port on the local machine\n     * @param params\n     *            {@link HttpConnectionParams Http connection parameters}\n     *\n     * @return Socket a new socket\n     *\n     * @throws IOException\n     *             if an I/O error occurs while creating the socket\n     * @throws UnknownHostException\n     *             if the IP address of the host cannot be determined\n     */\n    public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        SocketFactory socketfactory = getSSLContext().getSocketFactory();\n        if (timeout == 0) {\n            return socketfactory.createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = socketfactory.createSocket();\n            SocketAddress localaddr = new InetSocketAddress(localAddress, localPort);\n            SocketAddress remoteaddr = new InetSocketAddress(host, port);\n            socket.bind(localaddr);\n            socket.connect(remoteaddr, timeout);\n            return socket;\n        }\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.lang.String,int)\n     */\n    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(host, port);\n    }\n\n    /**\n     * @see SecureProtocolSocketFactory#createSocket(java.net.Socket,java.lang.String,int,boolean)\n     */\n    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {\n        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);\n    }\n\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(EasySSLProtocolSocketFactory.class));\n    }\n\n    public int hashCode() {\n        return EasySSLProtocolSocketFactory.class.hashCode();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/http/EasySSLProtocolSocketFactoryTest5.java",
		"test_prompt": "// EasySSLProtocolSocketFactoryTest5.java\npackage net.sf.xbus.technical.http;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketAddress;\nimport java.net.UnknownHostException;\nimport javax.net.SocketFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport org.apache.commons.httpclient.ConnectTimeoutException;\nimport org.apache.commons.httpclient.HttpClientError;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link EasySSLProtocolSocketFactory}.\n* It contains ten unit test cases for the {@link EasySSLProtocolSocketFactory#hashCode()} method.\n*/\nclass EasySSLProtocolSocketFactoryTest5 {"
	},
	{
		"original_code": "// AS400ByteArrayListSender.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.Iterator;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport com.ibm.as400.access.AS400File;\nimport com.ibm.as400.access.Record;\nimport com.ibm.as400.access.RecordFormat;\nimport com.ibm.as400.access.SequentialFile;\n\n/**\n * <code>AS400AS400ByteArrayListSender</code> manages writing a file on the\n * iSeries integrated file System.\n * <p>\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>Filename</td>\n * <td>Path name that represents an object in the <br>\n * QSYS library file system on the AS400 machine<</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>ConflictResolution</td>\n * <td>Three actions must be possible when a file already exists <br>\n * <b><i>apend, overwrite</i></b> or<b><i> error</i></b></td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>Encoding</td>\n * <td>Specified character encoding of the interface <i>(Optional)</i></td>\n * </tr>\n * </table border>\n */\npublic class AS400ByteArrayListSender extends AS400FileSender implements Sender, TAResource, ObjectSender {\n\n    /**\n     * Constructs a AS400ByteArrayListSender object giving all necessary data\n     * from the standard configuration, connecting to the iSeries and\n     * registering current resource by the\n     * {@link net.sf.xbus.base.core.TAManager}.\n     *\n     * @see AS400Connection\n     * @exception XException - If any error occurs\n     */\n    public AS400ByteArrayListSender(XBUSSystem system) throws XException {\n        super(system);\n    }\n\n    /**\n     * Implemented method <code>execute</code> from ObjectSender sends the\n     * given object <i>callData</i> to the AS400-system. Three actions must be\n     * taking into account if a file already exists:\n     * <p>\n     * <dl>\n     * <dd><table>\n     * <tr>\n     * <td><code>Append</code></td>\n     * <td></td>\n     * <td>append new data to the existing file</td>\n     * </tr>\n     * <tr>\n     * <td><code>Overwrite</code></td>\n     * <td></td>\n     * <td>overwrite existing file with the new data</td>\n     * </tr>\n     * <tr>\n     * <td><code>Error</code></td>\n     * <td></td>\n     * <td>throw XException</td>\n     * </tr>\n     * </table>\n     * </dl>\n     *\n     * @param function - name of the interface\n     * @param callData - String to be written\n     * @exception XException if any error occurs\n     */\n    public Object execute(String function, Object callData) throws XException {\n        RecordFormat format = prepareWriting();\n        if (callData == null)\n            callData = new ByteArrayList();\n        writeData(callData, mOriginFile, format);\n        return null;\n    }\n\n    /**\n     * Writes data to the write to the integrated file system object represented\n     * by this path name.<br>\n     * Follow actions are implemented to do it:\n     * <ol>\n     * <li>break a callData into tokens\n     * <li>convert each tokens in to byte[] according to a specified character\n     * encoding.\n     * <li>create from this array new record based on the record format\n     * <li>write this record into temp file object in the iSeries integrated\n     * fiel system.\n     * </ol>\n     * <i>Note:</i> The integrated file system object must be opened prior to\n     * invoking this method\n     *\n     * @param callData Data to be wrote to the file object in the iSeries\n     *            integrated file system\n     * @param file AS/400 physical file to be written\n     * @param format Record format which was retreived from the original file\n     * @exception XException if any errors occurs\n     */\n    private void writeData(Object callData, SequentialFile file, RecordFormat format) {\n        try {\n            // open original file for each resolution.\n            mOriginFile.open(AS400File.READ_WRITE, 0, AS400File.COMMIT_LOCK_LEVEL_DEFAULT);\n            for (Iterator it = ((ByteArrayList) callData).iterator(); it.hasNext(); ) {\n                Record record = format.getNewRecord((byte[]) it.next());\n                // write Record into file\n                file.write(record);\n            }\n            mOriginFile.close();\n        } catch (Exception ex) {\n        }\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400ByteArrayListSenderTest.java",
		"test_prompt": "// AS400ByteArrayListSenderTest.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.Iterator;\nimport net.sf.xbus.base.bytearraylist.ByteArrayList;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport com.ibm.as400.access.AS400File;\nimport com.ibm.as400.access.Record;\nimport com.ibm.as400.access.RecordFormat;\nimport com.ibm.as400.access.SequentialFile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400ByteArrayListSender}.\n* It contains ten unit test cases for the {@link AS400ByteArrayListSender#execute(String, Object)} method.\n*/\nclass AS400ByteArrayListSenderTest {"
	},
	{
		"original_code": "// AS400LineReader.java\npackage net.sf.xbus.technical.as400;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.linereader.LineReader;\nimport net.sf.xbus.base.linereader.LineTransformer;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.AS400File;\nimport com.ibm.as400.access.AS400FileRecordDescription;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.QSYSObjectPathName;\nimport com.ibm.as400.access.Record;\nimport com.ibm.as400.access.RecordFormat;\nimport com.ibm.as400.access.SequentialFile;\n\n/**\n * <code>LineReader</code> to read/send a character stream from/to an AS/400.\n */\npublic class AS400LineReader implements LineReader {\n\n    private AS400 mAS400System;\n\n    private QSYSObjectPathName mQSYSObject;\n\n    private SequentialFile mOriginFile;\n\n    private CharConverter mCharConverter;\n\n    private LineTransformer mTransformer = null;\n\n    /**\n     * Constructor an AS400LineReader.\n     *\n     * @param aS400System reference to the AS400\n     * @param qSYSObject ???\n     * @param originFile\n     * @param encoding\n     * @throws XException if something goes wrong\n     */\n    public AS400LineReader(AS400 aS400System, QSYSObjectPathName qSYSObject, SequentialFile originFile, String encoding) throws XException {\n        mAS400System = aS400System;\n        mQSYSObject = qSYSObject;\n        mOriginFile = originFile;\n        try {\n            mCharConverter = new CharConverter(encoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.LineReader#prepareReading()\n\t */\n    public void prepareReading(XBUSSystem destination) throws XException {\n        /*\n\t\t * Check if lines shall be transformed before writing\n\t\t */\n        String stringTransformer = Configuration.getInstance().getValueOptional(\"System\", destination.getName(), \"StringTransformer\");\n        if (stringTransformer != null) {\n            String transformerClassName = Configuration.getClass(\"StringTransformer\", stringTransformer);\n            mTransformer = (LineTransformer) ReflectionSupport.createObject(transformerClassName);\n        }\n        AS400FileRecordDescription recordDescription = new AS400FileRecordDescription(mAS400System, mQSYSObject.getPath());\n        // Set record format of the file.\n        RecordFormat[] format;\n        try {\n            format = recordDescription.retrieveRecordFormat();\n            mOriginFile.setRecordFormat(format[0]);\n            // Open the file.\n            mOriginFile.open(AS400File.READ_WRITE, 0, AS400File.COMMIT_LOCK_LEVEL_NONE);\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.LineReader#readRecord()\n\t */\n    public String readRecord() throws XException {\n        String result = null;\n        Record record;\n        try {\n            record = mOriginFile.readNext();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        if (record != null) {\n            byte[] inData = null;\n            // save record contents to the byte array\n            try {\n                inData = record.getContents();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n            }\n            // convert this content to the String\n            result = mCharConverter.byteArrayToString(inData);\n            if ((mTransformer != null) && (result != null)) {\n                result = mTransformer.transform(result);\n            }\n        }\n        return result;\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.technical.LineReader#terminateReading()\n\t */\n    public void terminateReading() throws XException {\n        // close the file since I am done using it\n        try {\n            mOriginFile.close();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400LineReaderTest.java",
		"test_prompt": "// AS400LineReaderTest.java\npackage net.sf.xbus.technical.as400;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.linereader.LineReader;\nimport net.sf.xbus.base.linereader.LineTransformer;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.AS400File;\nimport com.ibm.as400.access.AS400FileRecordDescription;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.QSYSObjectPathName;\nimport com.ibm.as400.access.Record;\nimport com.ibm.as400.access.RecordFormat;\nimport com.ibm.as400.access.SequentialFile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400LineReader}.\n* It contains ten unit test cases for the {@link AS400LineReader#readRecord()} method.\n*/\nclass AS400LineReaderTest {"
	},
	{
		"original_code": "// AS400FileSender.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.AS400File;\nimport com.ibm.as400.access.AS400FileRecordDescription;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.IFSFile;\nimport com.ibm.as400.access.QSYSObjectPathName;\nimport com.ibm.as400.access.Record;\nimport com.ibm.as400.access.RecordFormat;\nimport com.ibm.as400.access.SequentialFile;\n\n/**\n * <code>AS400AS400FileSender</code> manages writing a file on the iSeries\n * integrated file System.\n * <p>\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>Filename</td>\n * <td>Path name that represents an object in the <br>\n * QSYS library file system on the AS400 machine<</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>ConflictResolution</td>\n * <td>Three actions must be possible when a file already exists <br>\n * <b><i>apend, overwrite</i></b> or<b><i> error</i></b></td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>Encoding</td>\n * <td>Specified character encoding of the interface <i>(Optional)</i></td>\n * </tr>\n * </table border>\n */\npublic class AS400FileSender extends AS400FileBase implements Sender, TAResource, TextSender {\n\n    /**\n     * Current QSYSObjectPathName representes an object in the integrated file\n     * system which must be write\n     */\n    private QSYSObjectPathName mQSYSobjPathname = null;\n\n    /**\n     * Resolved action when the file already exists<br>\n     * <i>append, overwrite</i> or <i>error</i>\n     */\n    private String mResolution = null;\n\n    /**\n     * File encoding\n     */\n    private String mEncoding = null;\n\n    /**\n     * AS400 object that represents the iSeries system\n     */\n    private AS400 mAS400System = null;\n\n    /**\n     * Represents an AS/400 physical or logical file. Allows the user to use\n     * commitment control when accessing an AS/400 file and access the records\n     * in an AS/400 file sequentially or by record number.\n     */\n    protected SequentialFile mOriginFile = null;\n\n    /**\n     * Constructs a AS400FileSender object giving all necessary data from the\n     * standard configuration, connecting to the iSeries and registering current\n     * resource by the {@link net.sf.xbus.base.core.TAManager}.\n     *\n     * @see AS400Connection\n     * @exception XException - If any error occurs\n     */\n    public AS400FileSender(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        String as400name = config.getValue(Constants.CHAPTER_SYSTEM, system.getName(), \"AS400\");\n        // create an AS400 object for the server that holds the files\n        // and connection to the iSeries\n        AS400Connection connection = AS400Connection.getInstance(as400name);\n        mAS400System = connection.getSystem();\n        // readConfiguration\n        readConfiguration(system);\n        // register resource by TAManager\n        TAManager taManager = TAManager.getInstance();\n        taManager.registerResource(this);\n    }\n\n    /**\n     * Reads follow data for the given XBUSSystem object from the standard\n     * configuration and stores it in the class variables.\n     * <p>\n     * <dl>\n     * <dd><table>\n     * <tr>\n     * <td><code>Filename</code></td>\n     * <td></td>\n     * <td>path name that represents the object to be write in the QSYS library</td>\n     * </tr>\n     * <tr>\n     * <td><code>ConflictResolution</code></td>\n     * <td></td>\n     * <td>resolved action when the file already exists<br>\n     * <i>append, overwrite, error</i></td>\n     * </tr>\n     * <tr>\n     * <td><code>Encoding</code></td>\n     * <td></td>\n     * <td>specified character encoding of the interface</td>\n     * </tr>\n     * </table>\n     * </dl>\n     *\n     * @param xbusSystem XBUSSystem object which consists of two informations:<br>\n     *            &nbsp;&nbsp;-the name of the system is used to identify the\n     *            system<br>\n     *            &nbsp;&nbsp;-additionally an adress might be available.\n     * @exception XException if any error occurs\n     */\n    private void readConfiguration(XBUSSystem system) throws XException {\n        try {\n            Configuration config = Configuration.getInstance();\n            mResolution = getResolution(config, system.getName());\n            mEncoding = getEncoding(mAS400System, system.getName());\n            String filename = config.getValue(Constants.CHAPTER_SYSTEM, system.getName(), Constants.KEY_FILENAME);\n            filename = system.replaceAllMarkers(filename)[0];\n            mQSYSobjPathname = new QSYSObjectPathName(filename);\n        } catch (Exception ex) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", ex);\n        }\n    }\n\n    /**\n     * Implemented method <code>execute</code> from TextSender sends the given\n     * string <i>callData</i> to the AS400-system. Three actions must be taking\n     * into account when a file already exists:\n     * <p>\n     * <dl>\n     * <dd><table>\n     * <tr>\n     * <td><code>Append</code></td>\n     * <td></td>\n     * <td>append new data to the existing file</td>\n     * </tr>\n     * <tr>\n     * <td><code>Overwrite</code></td>\n     * <td></td>\n     * <td>overwrite existing file with the new data</td>\n     * </tr>\n     * <tr>\n     * <td><code>Error</code></td>\n     * <td></td>\n     * <td>throw XException</td>\n     * </tr>\n     * </table>\n     * </dl>\n     *\n     * @param function - name of the interface\n     * @param callData - String to be written\n     * @exception XException if any error occurs\n     */\n    public String execute(String function, String callData) throws XException {\n        RecordFormat format = prepareWriting();\n        if (callData == null)\n            callData = \"\";\n        writeData(callData, mOriginFile, format);\n        return null;\n    }\n\n    /**\n     * Writes data to the write to the integrated file system object represented\n     * by this path name.<br>\n     * Follow actions are implemented to do it:\n     * <ol>\n     * <li>break a callData into tokens\n     * <li>convert each tokens in to byte[] according to a specified character\n     * encoding.\n     * <li>create from this array new record based on the record format\n     * <li>write this record into temp file object in the iSeries integrated\n     * fiel system.\n     * </ol>\n     * <i>Note:</i> The integrated file system object must be opened prior to\n     * invoking this method\n     *\n     * @param callData Data to be wrote to the file object in the iSeries\n     *            integrated file system\n     * @param file AS/400 physical file to be written\n     * @param format Record format which was retreived from the original file\n     * @exception XException if any errors occurs\n     */\n    private void writeData(String callData, SequentialFile file, RecordFormat format) {\n        byte[] dataByte = null;\n        try {\n            // open original file for each resolution.\n            mOriginFile.open(AS400File.READ_WRITE, 0, AS400File.COMMIT_LOCK_LEVEL_DEFAULT);\n            CharConverter charConverter = new CharConverter(mEncoding);\n            StringTokenizer tokenizer = new StringTokenizer(callData, Constants.LINE_SEPERATOR);\n            while (tokenizer.hasMoreTokens()) {\n                String token = tokenizer.nextToken();\n                // Characters written to it are translated into bytes array\n                // according to a specified character encoding.\n                dataByte = charConverter.stringToByteArray(token);\n                // Save byteArray into Record based on the file format\n                Record record = format.getNewRecord(dataByte);\n                // write Record into file\n                file.write(record);\n            }\n            mOriginFile.close();\n        } catch (Exception ex) {\n        }\n    }\n\n    public RecordFormat prepareWriting() throws XException {\n        try {\n            // Write file ONLY if file exist because the format of the file is\n            // needed!\n            if (new IFSFile(mAS400System, mQSYSobjPathname.getPath()).exists()) {\n                // initiate the SequentialFile object\n                mOriginFile = new SequentialFile(mAS400System, mQSYSobjPathname.getPath());\n                // Retreive and set an record format of the file.\n                AS400FileRecordDescription recordDescription = new AS400FileRecordDescription(mAS400System, mQSYSobjPathname.getPath());\n                RecordFormat[] formatArr = recordDescription.retrieveRecordFormat();\n                RecordFormat format = formatArr[0];\n                mOriginFile.setRecordFormat(format);\n                if (mResolution.equals(Constants.WRITE_OVERWRITE)) {\n                    deleteMember(mAS400System, mQSYSobjPathname.getPath());\n                    mOriginFile.addPhysicalFileMember(mQSYSobjPathname.getMemberName(), \"\");\n                }\n                return format;\n            } else // if (new IFSFile(mAS400System,\n            // mQSYSobjPathname.getPath()).exists())\n            {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"28\");\n            }\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n    }\n\n    /**\n     * Reads conflict resolution (resolved action when the file already exists)\n     * for the given system name from the configuration and checks its\n     * conformity with the allowed ones:\n     * <dl>\n     * <dd>Append\n     * <dd>Overwrite\n     * <dd>Error\n     * </dl>\n     *\n     * @param config Instanze of the configuration\n     * @param system Sytem name which resoltion must be read.\n     * @return conflict resolution as String (Append, Overwrite or Error)\n     * @exception XException if resolution is falsh or any errors occurs\n     */\n    public String getResolution(Configuration config, String system) throws XException {\n        String resolution = config.getValue(Constants.CHAPTER_SYSTEM, system, Constants.KEY_SEND_RESOL);\n        if (!resolution.equals(Constants.WRITE_APPEND) && !resolution.equals(Constants.WRITE_ERROR) && !resolution.equals(Constants.WRITE_OVERWRITE)) {\n            List params = new Vector();\n            params.add(mResolution);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"30\", params);\n        }\n        return resolution;\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.base.core.TAResource#commit()\n\t */\n    public void commit() {\n        // remove resource\n        TAManager.getInstance().removeResource(this);\n        // disconnect\n        mAS400System.disconnectAllServices();\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.base.core.TAResource#rollback()\n\t */\n    public void rollback() {\n        // remove resource\n        TAManager.getInstance().removeResource(this);\n        // disconnect\n        mAS400System.disconnectAllServices();\n    }\n\n    /**\n     * Is not implemented for iSeries integrated file system\n     */\n    public void open() {\n    }\n\n    /**\n     * Is not implemented for iSeries integrated file system\n     */\n    public void close() {\n    }\n\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400FileSenderTest0.java",
		"test_prompt": "// AS400FileSenderTest0.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.AS400File;\nimport com.ibm.as400.access.AS400FileRecordDescription;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.IFSFile;\nimport com.ibm.as400.access.QSYSObjectPathName;\nimport com.ibm.as400.access.Record;\nimport com.ibm.as400.access.RecordFormat;\nimport com.ibm.as400.access.SequentialFile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400FileSender}.\n* It contains ten unit test cases for the {@link AS400FileSender#execute(String, String)} method.\n*/\nclass AS400FileSenderTest0 {"
	},
	{
		"original_code": "// AS400FileSender.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.AS400File;\nimport com.ibm.as400.access.AS400FileRecordDescription;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.IFSFile;\nimport com.ibm.as400.access.QSYSObjectPathName;\nimport com.ibm.as400.access.Record;\nimport com.ibm.as400.access.RecordFormat;\nimport com.ibm.as400.access.SequentialFile;\n\n/**\n * <code>AS400AS400FileSender</code> manages writing a file on the iSeries\n * integrated file System.\n * <p>\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>Filename</td>\n * <td>Path name that represents an object in the <br>\n * QSYS library file system on the AS400 machine<</td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>ConflictResolution</td>\n * <td>Three actions must be possible when a file already exists <br>\n * <b><i>apend, overwrite</i></b> or<b><i> error</i></b></td>\n * </tr>\n * <tr>\n * <td>System</td>\n * <td>Interface</td>\n * <td>Encoding</td>\n * <td>Specified character encoding of the interface <i>(Optional)</i></td>\n * </tr>\n * </table border>\n */\npublic class AS400FileSender extends AS400FileBase implements Sender, TAResource, TextSender {\n\n    /**\n     * Current QSYSObjectPathName representes an object in the integrated file\n     * system which must be write\n     */\n    private QSYSObjectPathName mQSYSobjPathname = null;\n\n    /**\n     * Resolved action when the file already exists<br>\n     * <i>append, overwrite</i> or <i>error</i>\n     */\n    private String mResolution = null;\n\n    /**\n     * File encoding\n     */\n    private String mEncoding = null;\n\n    /**\n     * AS400 object that represents the iSeries system\n     */\n    private AS400 mAS400System = null;\n\n    /**\n     * Represents an AS/400 physical or logical file. Allows the user to use\n     * commitment control when accessing an AS/400 file and access the records\n     * in an AS/400 file sequentially or by record number.\n     */\n    protected SequentialFile mOriginFile = null;\n\n    /**\n     * Constructs a AS400FileSender object giving all necessary data from the\n     * standard configuration, connecting to the iSeries and registering current\n     * resource by the {@link net.sf.xbus.base.core.TAManager}.\n     *\n     * @see AS400Connection\n     * @exception XException - If any error occurs\n     */\n    public AS400FileSender(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        String as400name = config.getValue(Constants.CHAPTER_SYSTEM, system.getName(), \"AS400\");\n        // create an AS400 object for the server that holds the files\n        // and connection to the iSeries\n        AS400Connection connection = AS400Connection.getInstance(as400name);\n        mAS400System = connection.getSystem();\n        // readConfiguration\n        readConfiguration(system);\n        // register resource by TAManager\n        TAManager taManager = TAManager.getInstance();\n        taManager.registerResource(this);\n    }\n\n    /**\n     * Reads follow data for the given XBUSSystem object from the standard\n     * configuration and stores it in the class variables.\n     * <p>\n     * <dl>\n     * <dd><table>\n     * <tr>\n     * <td><code>Filename</code></td>\n     * <td></td>\n     * <td>path name that represents the object to be write in the QSYS library</td>\n     * </tr>\n     * <tr>\n     * <td><code>ConflictResolution</code></td>\n     * <td></td>\n     * <td>resolved action when the file already exists<br>\n     * <i>append, overwrite, error</i></td>\n     * </tr>\n     * <tr>\n     * <td><code>Encoding</code></td>\n     * <td></td>\n     * <td>specified character encoding of the interface</td>\n     * </tr>\n     * </table>\n     * </dl>\n     *\n     * @param xbusSystem XBUSSystem object which consists of two informations:<br>\n     *            &nbsp;&nbsp;-the name of the system is used to identify the\n     *            system<br>\n     *            &nbsp;&nbsp;-additionally an adress might be available.\n     * @exception XException if any error occurs\n     */\n    private void readConfiguration(XBUSSystem system) throws XException {\n        try {\n            Configuration config = Configuration.getInstance();\n            mResolution = getResolution(config, system.getName());\n            mEncoding = getEncoding(mAS400System, system.getName());\n            String filename = config.getValue(Constants.CHAPTER_SYSTEM, system.getName(), Constants.KEY_FILENAME);\n            filename = system.replaceAllMarkers(filename)[0];\n            mQSYSobjPathname = new QSYSObjectPathName(filename);\n        } catch (Exception ex) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", ex);\n        }\n    }\n\n    /**\n     * Implemented method <code>execute</code> from TextSender sends the given\n     * string <i>callData</i> to the AS400-system. Three actions must be taking\n     * into account when a file already exists:\n     * <p>\n     * <dl>\n     * <dd><table>\n     * <tr>\n     * <td><code>Append</code></td>\n     * <td></td>\n     * <td>append new data to the existing file</td>\n     * </tr>\n     * <tr>\n     * <td><code>Overwrite</code></td>\n     * <td></td>\n     * <td>overwrite existing file with the new data</td>\n     * </tr>\n     * <tr>\n     * <td><code>Error</code></td>\n     * <td></td>\n     * <td>throw XException</td>\n     * </tr>\n     * </table>\n     * </dl>\n     *\n     * @param function - name of the interface\n     * @param callData - String to be written\n     * @exception XException if any error occurs\n     */\n    public String execute(String function, String callData) throws XException {\n        RecordFormat format = prepareWriting();\n        if (callData == null)\n            callData = \"\";\n        writeData(callData, mOriginFile, format);\n        return null;\n    }\n\n    /**\n     * Writes data to the write to the integrated file system object represented\n     * by this path name.<br>\n     * Follow actions are implemented to do it:\n     * <ol>\n     * <li>break a callData into tokens\n     * <li>convert each tokens in to byte[] according to a specified character\n     * encoding.\n     * <li>create from this array new record based on the record format\n     * <li>write this record into temp file object in the iSeries integrated\n     * fiel system.\n     * </ol>\n     * <i>Note:</i> The integrated file system object must be opened prior to\n     * invoking this method\n     *\n     * @param callData Data to be wrote to the file object in the iSeries\n     *            integrated file system\n     * @param file AS/400 physical file to be written\n     * @param format Record format which was retreived from the original file\n     * @exception XException if any errors occurs\n     */\n    private void writeData(String callData, SequentialFile file, RecordFormat format) {\n        byte[] dataByte = null;\n        try {\n            // open original file for each resolution.\n            mOriginFile.open(AS400File.READ_WRITE, 0, AS400File.COMMIT_LOCK_LEVEL_DEFAULT);\n            CharConverter charConverter = new CharConverter(mEncoding);\n            StringTokenizer tokenizer = new StringTokenizer(callData, Constants.LINE_SEPERATOR);\n            while (tokenizer.hasMoreTokens()) {\n                String token = tokenizer.nextToken();\n                // Characters written to it are translated into bytes array\n                // according to a specified character encoding.\n                dataByte = charConverter.stringToByteArray(token);\n                // Save byteArray into Record based on the file format\n                Record record = format.getNewRecord(dataByte);\n                // write Record into file\n                file.write(record);\n            }\n            mOriginFile.close();\n        } catch (Exception ex) {\n        }\n    }\n\n    public RecordFormat prepareWriting() throws XException {\n        try {\n            // Write file ONLY if file exist because the format of the file is\n            // needed!\n            if (new IFSFile(mAS400System, mQSYSobjPathname.getPath()).exists()) {\n                // initiate the SequentialFile object\n                mOriginFile = new SequentialFile(mAS400System, mQSYSobjPathname.getPath());\n                // Retreive and set an record format of the file.\n                AS400FileRecordDescription recordDescription = new AS400FileRecordDescription(mAS400System, mQSYSobjPathname.getPath());\n                RecordFormat[] formatArr = recordDescription.retrieveRecordFormat();\n                RecordFormat format = formatArr[0];\n                mOriginFile.setRecordFormat(format);\n                if (mResolution.equals(Constants.WRITE_OVERWRITE)) {\n                    deleteMember(mAS400System, mQSYSobjPathname.getPath());\n                    mOriginFile.addPhysicalFileMember(mQSYSobjPathname.getMemberName(), \"\");\n                }\n                return format;\n            } else // if (new IFSFile(mAS400System,\n            // mQSYSobjPathname.getPath()).exists())\n            {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"28\");\n            }\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n    }\n\n    /**\n     * Reads conflict resolution (resolved action when the file already exists)\n     * for the given system name from the configuration and checks its\n     * conformity with the allowed ones:\n     * <dl>\n     * <dd>Append\n     * <dd>Overwrite\n     * <dd>Error\n     * </dl>\n     *\n     * @param config Instanze of the configuration\n     * @param system Sytem name which resoltion must be read.\n     * @return conflict resolution as String (Append, Overwrite or Error)\n     * @exception XException if resolution is falsh or any errors occurs\n     */\n    public String getResolution(Configuration config, String system) throws XException {\n        String resolution = config.getValue(Constants.CHAPTER_SYSTEM, system, Constants.KEY_SEND_RESOL);\n        if (!resolution.equals(Constants.WRITE_APPEND) && !resolution.equals(Constants.WRITE_ERROR) && !resolution.equals(Constants.WRITE_OVERWRITE)) {\n            List params = new Vector();\n            params.add(mResolution);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"30\", params);\n        }\n        return resolution;\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.base.core.TAResource#commit()\n\t */\n    public void commit() {\n        // remove resource\n        TAManager.getInstance().removeResource(this);\n        // disconnect\n        mAS400System.disconnectAllServices();\n    }\n\n    /*\n\t * (non-Javadoc)\n\t * \n\t * @see net.sf.xbus.base.core.TAResource#rollback()\n\t */\n    public void rollback() {\n        // remove resource\n        TAManager.getInstance().removeResource(this);\n        // disconnect\n        mAS400System.disconnectAllServices();\n    }\n\n    /**\n     * Is not implemented for iSeries integrated file system\n     */\n    public void open() {\n    }\n\n    /**\n     * Is not implemented for iSeries integrated file system\n     */\n    public void close() {\n    }\n\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400FileSenderTest1.java",
		"test_prompt": "// AS400FileSenderTest1.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.AS400File;\nimport com.ibm.as400.access.AS400FileRecordDescription;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.IFSFile;\nimport com.ibm.as400.access.QSYSObjectPathName;\nimport com.ibm.as400.access.Record;\nimport com.ibm.as400.access.RecordFormat;\nimport com.ibm.as400.access.SequentialFile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400FileSender}.\n* It contains ten unit test cases for the {@link AS400FileSender#prepareWriting()} method.\n*/\nclass AS400FileSenderTest1 {"
	},
	{
		"original_code": "// AS400FileBase.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.timeoutcall.TimedCallable;\nimport net.sf.xbus.base.core.trace.Trace;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.IFSFile;\nimport com.ibm.as400.access.IFSFileInputStream;\nimport com.ibm.as400.access.IFSFileOutputStream;\nimport com.ibm.as400.access.ProgramParameter;\nimport com.ibm.as400.access.QSYSObjectPathName;\nimport com.ibm.as400.access.SequentialFile;\n\n/**\n * Class <code>AS400FileBase</code> is the abstract base class for the\n * {@link AS400FileReceiver} and {@link AS400FileSender} classes.\n * <p>\n * It provides the methods for the following:\n * <ul>\n * <li>Renaming files and members</li>\n * <li>Deleting files and members</li>\n * <li>Copying files</li>\n * <li>Locking files for different types of access</li>\n * <li>Calling programs</li>\n * </ul>.\n * </p>\n */\npublic abstract class AS400FileBase {\n\n    /**\n     * The char converter according to actual string encoding. It is\n     * <code>protected</code> to grant access by the subclasses.\n     */\n    protected CharConverter mConverter;\n\n    /**\n     * Returns the encoding of the data type from the\n     * {@link net.sf.xbus.base.core.config.Configuration}. If this one is\n     * non-existent, the method returns the default value from the AS400 object\n     * that corresponds to the job CCSID of the server.\n     * <p>\n     *\n     * @param as400System AS400 object for the server that holds the files\n     * @param system system name for which encoding must be read\n     * @return character encoding from Configuration or default encoding that\n     *         corresponds to the job CCSID of the server.\n     * @exception XException if encoding cannot be determined neither from the\n     *                configurationnor by accesing the AS400\n     */\n    static public String getEncoding(AS400 as400System, String system) throws XException {\n        Configuration config = Configuration.getInstance();\n        String configEncoding = null;\n        configEncoding = config.getValueOptional(Constants.CHAPTER_SYSTEM, system, Constants.KEY_ENCODING);\n        if (configEncoding == null) {\n            try {\n                configEncoding = as400System.getJobCCSIDEncoding();\n            }// try\n             catch (Exception ex) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", ex);\n            }\n            // catch\n        }\n        // if (configEncoding == null)\n        return configEncoding;\n    }\n\n    // getEncoding(AS400 as400System, String system)\n    /**\n     * Sets a lock on the file to prevent other users from accessing the file\n     * while it is in use.\n     * <p>\n     * The following type of lock is used:\n     * <p>\n     * <code>WRITE_EXCLUSIVE_LOCK</code>&nbsp;&nbsp;&nbsp;The current Java\n     * program changes the file, and no other program can access the file.\n     * <p>\n     * <i>Note:</i> If a lock has already been obtained for this file, no\n     * action is taken.\n     *\n     * @param as400System The AS400 system to which to connect. The system\n     *            cannot be null.\n     * @param lockFilename The integrated file system pathname of the file to be\n     *            locked. The name cannot be null.\n     * @exception XException if locking did not work\n     */\n    protected void setLock(AS400 as400System, String lockFilename) throws XException {\n        try {\n            SequentialFile seqFile = new SequentialFile(as400System, lockFilename);\n            seqFile.lock(SequentialFile.WRITE_EXCLUSIVE_LOCK);\n        }// try\n         catch (Exception ex) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", ex);\n        }\n        // catch\n    }\n\n    // setLock(AS400 as400System, String lockFilename)\n    /**\n     * Releases all locks acquired via the {@link #setLock(AS400, String)}\n     * method.\n     * <p>\n     * If no locks have been explicitly obtained, no action is taken.\n     *\n     * @param as400System The AS400 system to which to connect. The system\n     *            cannot be null.\n     * @param lockFilename The integrated file system pathname of the file to be\n     *            locked. The name cannot be null.\n     * @exception XException if the file lock can not be released\n     */\n    protected void releaseLock(AS400 as400System, String lockFilename) throws XException {\n        SequentialFile lockFile = new SequentialFile(as400System, lockFilename);\n        if (lockFile.getExplicitLocks().length > 0) {\n            // There are locks.\n            try {\n                lockFile.releaseExplicitLocks();\n            }// try\n             catch (Exception ex) {\n                List params = new Vector();\n                params.add(lockFilename);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"6\", params);\n            }\n            // catch\n        }\n        // if (lockFile.getExplicitLocks().length > 0)\n    }\n\n    // releaseLock(AS400 as400System, String lockFilename)\n    /**\n     * Return a path name with a new member name. The QSYSObjectPathName\n     * provides an integrated file system path name that represents an object in\n     * the QSYS library file system.\n     * <p>\n     * <i>For example:</i><br>\n     * <dl>\n     * <dd>/QSYS.<b>LIB</b>/QGPL.<b>LIB</b>/ACCOUNTS.<b>FILE</b>/PAYABLE.<b>MBR</b>\n     * </dl>\n     * <p>\n     * This method parses the given QSYSObjectPathName object to extract the\n     * library, object, member, and object type and builds integrated file\n     * system path name with <b>new member</b> as follows:\n     * <p>\n     * <dl>\n     * <dd>/QSYS.LIB/<b>OLDLIB</b>.LIB/<b>OLDFILE</b>.FILE/<b>NEWMEMBER</b>.MBR\n     * </dl>\n     *\n     * @param qsysPathname represents old object in the QSYS library file system\n     * @param newMember new member name, cannot exceed 10 characters in length!\n     *            Must start with a letter.\n     * @return fully qualified integrated file system path of the new object in\n     *         the QSYS file system\n     */\n    protected String getRenamedMember(QSYSObjectPathName qsysPathname, String newMember) {\n        return new QSYSObjectPathName(qsysPathname.getLibraryName(), qsysPathname.getObjectName(), newMember, qsysPathname.getObjectType()).getPath();\n    }\n\n    /**\n     * Renames the integrated file system object specified by the <i>source</i>\n     * path name to have the path name of <i>dest</i>.\n     *\n     * @param as400System AS400 system to which to connect. The system cannot be\n     *            null\n     * @param sourceFilename old abstract pathname of the integrated file system\n     *            object\n     * @param destFilename new abstract pathname of the integrated file system\n     *            object\n     * @exception XException if an error occurs while communicating with the\n     *                server.\n     */\n    protected void renameFile(AS400 as400System, String sourceFilename, String destFilename) throws XException {\n        IFSFile srcFile = new IFSFile(as400System, sourceFilename);\n        IFSFile destFile = new IFSFile(as400System, destFilename);\n        // construct temp name and temp member for destination file\n        String tempName = new StringBuffer(destFile.getParent()).append(Constants.FILE_SEPERATOR).append(\"xbusTemp.MBR\").toString();\n        IFSFile tempFile = null;\n        try {\n            // 1. rename destination file to temp one if it exists\n            if (destFile.exists()) {\n                tempFile = new IFSFile(as400System, tempName);\n                if (tempFile.exists())\n                    if (!tempFile.delete()) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"7\", (List) null);\n                    }\n                if (!destFile.renameTo(tempFile)) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"8\", (List) null);\n                }\n                // Reinitialize to check existance of the renamed member\n                // Return value of renameTo is not reliable. It may be <true>\n                // even if\n                // the renaming was not successful.\n                tempFile = new IFSFile(as400System, tempName);\n                // Make sure that renaming was successful.\n                if (!tempFile.exists()) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"8\", (List) null);\n                }\n                // Reinitialise to allow further renaming\n                destFile = new IFSFile(as400System, destFilename);\n            }\n            // if (destFile.exists())\n            boolean renameBackTempFile = false;\n            // Should the renaming of the destination member be reversed?\n            // 2. rename source file to dest file\n            if (srcFile.renameTo(destFile)) {\n                // Reinitialise to check existance of the destination file\n                // Return value of renameTo is not reliable. It may be <true>\n                // even if\n                // the renaming was not successful.\n                destFile = new IFSFile(as400System, destFilename);\n                // Make sure that renaming was successful.\n                if (!destFile.exists())\n                    renameBackTempFile = true;\n                // delete temp member\n                if (tempFile != null && tempFile.exists())\n                    deleteMember(as400System, tempName);\n            } else\n                // if (srcFile.renameTo(destFile))\n                // Reverse initial renaming of the destination file member\n                renameBackTempFile = true;\n            // 3. Rename the destination file member bach to its original name\n            // if\n            // any error prevented the renaming of the source file.\n            // Only necessary if the destination filemember existed before and\n            // was\n            // renamed to a temporyry member name.\n            if (tempFile != null && renameBackTempFile) {\n                // Reverse initial renaming of the destination file member\n                // Reinitialise to allow backwards renaming\n                destFile = new IFSFile(as400System, destFilename);\n                // rename back temp member to destination member\n                tempFile.renameTo(destFile);\n                List params = new Vector();\n                params.add(sourceFilename);\n                params.add(destFilename);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"10\", params);\n            }\n            // if (tempFile!=null && renameBackTempFile)\n        }// try\n         catch (Exception ex) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", ex);\n        }\n        // catch\n    }\n\n    // renameFile(AS400 as400System,String sourceFilename,String\n    // destFilename)\n    /**\n     * This method uses the installable file system classes to copy a file from\n     * one directory to another on the server.\n     *\n     * @param as400System AS400 object for the server which holds the files.\n     * @param sourceName name the source file to be copied\n     * @param targetName name the target file to be copied to\n     * @exception XException if file processing cannot be completed\n     */\n    protected void copyFile(AS400 as400System, String sourceName, String targetName) throws XException {\n        byte[] buffer = new byte[1024 * 64];\n        IFSFileInputStream source = null;\n        IFSFileOutputStream target = null;\n        try {\n            // Open the source file for exclusive access.\n            source = new IFSFileInputStream(as400System, sourceName, IFSFileInputStream.SHARE_NONE);\n            IFSFile targetFile = new IFSFile(as400System, targetName);\n            if (!targetFile.exists()) {\n                targetFile.createNewFile();\n            }\n            // if (!targetFile.exists())\n            // Open the target file for exclusive access.\n            target = new IFSFileOutputStream(as400System, targetName, IFSFileOutputStream.SHARE_NONE, false);\n            // Read the first 64K bytes from the source file.\n            int bytesRead = source.read(buffer);\n            // While there is data in the source file copy the data from\n            // the source file to the target file.\n            while (bytesRead > 0) {\n                target.write(buffer, 0, bytesRead);\n                bytesRead = source.read(buffer);\n            }\n            // Clean up by closing the source and target file.\n            source.close();\n            target.close();\n        }// try\n         catch (Exception e) {\n            // If any of the above operations failed trace error\n            // and output the exception.\n            Trace.error(\"Copy failed\");\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        // catch\n    }\n\n    // copyFile(AS400 as400System,String sourceName,String targetName)\n    /**\n     * <code>deleteFile</code> deletes a file on the AS400 file system. This\n     * method is used for files in the AS400 inegrated file system sense.\n     *\n     * @see #deleteMember(AS400, String)\n     * @param mAS400System the AS400 to interact with\n     * @param fileName the path of the file to delete\n     * @throws XException if the file cannot be deleted for any reason\n     */\n    protected void deleteFile(AS400 mAS400System, String fileName) throws XException {\n        SequentialFile file = new SequentialFile(mAS400System, fileName);\n        try {\n            file.delete();\n        }// try\n         catch (Exception ex) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", ex);\n        }\n        // catch\n    }\n\n    // deleteFile(AS400 mAS400System, String fileName)\n    /**\n     * Deletes a member of a sequential file on the AS/400 file system. The\n     * surrounding file will continue to exist.\n     *\n     * @param as400System the AS/400 to interact with\n     * @param fileName the name of the file and member to delete\n     * @throws XException if the member cannot be deleted for any reason\n     */\n    protected void deleteMember(AS400 as400System, String fileName) throws XException {\n        SequentialFile srcFile = new SequentialFile(as400System, fileName);\n        try {\n            srcFile.deleteMember();\n        }// try\n         catch (Exception ex) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", ex);\n        }\n        // catch\n    }\n\n    // deleteMember(AS400 as400System, String fileName)\n    /**\n     * Calls an AS400 program.\n     *\n     * @param as400 the AS400 to interact with\n     * @param programName the path of the program to call\n     * @param parameters the input and output paremeters of the program call\n     * @param timeout seconds before program will be stopped\n     * @throws XException if the AS400 issues an error\n     */\n    protected void callAS400Program(AS400 as400, String programName, ProgramParameter[] parameters, int timeout) throws XException {\n        AS400ProgramCaller caller = new AS400ProgramCaller(as400, programName, parameters, mConverter);\n        TimedCallable tc = new TimedCallable(caller, timeout);\n        try {\n            tc.call();\n        } catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n    }\n    // callAS400Program(AS400 as400,String programName,ProgramParameter[]\n    // parameters)\n}\n// AS400FileBase\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400FileBaseTest.java",
		"test_prompt": "// AS400FileBaseTest.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.timeoutcall.TimedCallable;\nimport net.sf.xbus.base.core.trace.Trace;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.IFSFile;\nimport com.ibm.as400.access.IFSFileInputStream;\nimport com.ibm.as400.access.IFSFileOutputStream;\nimport com.ibm.as400.access.ProgramParameter;\nimport com.ibm.as400.access.QSYSObjectPathName;\nimport com.ibm.as400.access.SequentialFile;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400FileBase}.\n* It contains ten unit test cases for the {@link AS400FileBase#getEncoding(AS400, String)} method.\n*/\nclass AS400FileBaseTest {"
	},
	{
		"original_code": "// AS400ProgramCaller.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.timeoutcall.Callable;\nimport net.sf.xbus.base.core.trace.Trace;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.AS400Message;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.ProgramCall;\nimport com.ibm.as400.access.ProgramParameter;\n\n/**\n * Used by {@link AS400ProgramSender#execute(String, Object)} together with\n * {@link net.sf.xbus.base.core.timeoutcall.TimedCallable} to be able to stop\n * the execution of the program after a timeout.\n */\npublic class AS400ProgramCaller implements Callable {\n\n    private AS400 mAS400 = null;\n\n    private String mProgramName = null;\n\n    private ProgramParameter[] mParameters = null;\n\n    public AS400ProgramCaller(AS400 as400, String programName, ProgramParameter[] parameters, CharConverter converter) {\n        mAS400 = as400;\n        mProgramName = programName;\n        mParameters = parameters;\n    }\n\n    /**\n     * Calling the AS400 program.\n     */\n    public Object call() throws XException {\n        String message = \"Call AS400 program \" + mProgramName;\n        if (mParameters != null && mParameters.length > 0)\n            message = message + \" \" + CharConverter.byteArrayToString(mAS400, mParameters[0].getInputData());\n        // Constructs a program call object for specified server, program name,\n        // and parameter list.\n        ProgramCall programCall = new ProgramCall(mAS400, mProgramName, mParameters);\n        try {\n            Trace.info(\"Program \" + mProgramName + \" called\");\n            // Run the program.\n            if (!programCall.run()) {\n                // Show the messages\n                AS400Message[] msgList = programCall.getMessageList();\n                StringBuffer buf = new StringBuffer();\n                for (int i = 1; i < msgList.length; i++) {\n                    buf.append(msgList[i].getText());\n                }\n                // for (int i = 1; i < msgList.length; i++)\n                List params = new Vector();\n                params.add(buf);\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"36\", params);\n            }\n            // if (!programCall.run())\n            Trace.info(\"Program \" + mProgramName + \" returned\");\n        }// try\n         catch (Exception e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        } finally // catch\n        {\n            mAS400.disconnectService(AS400.COMMAND);\n        }\n        return mParameters;\n    }\n\n    /**\n     * Stopping the execution of the program by disconnecting from the AS400.\n     */\n    public void stop() {\n        mAS400.disconnectService(AS400.COMMAND);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400ProgramCallerTest.java",
		"test_prompt": "// AS400ProgramCallerTest.java\npackage net.sf.xbus.technical.as400;\n\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.timeoutcall.Callable;\nimport net.sf.xbus.base.core.trace.Trace;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.AS400Message;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.ProgramCall;\nimport com.ibm.as400.access.ProgramParameter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400ProgramCaller}.\n* It contains ten unit test cases for the {@link AS400ProgramCaller#call()} method.\n*/\nclass AS400ProgramCallerTest {"
	},
	{
		"original_code": "// AS400ProgramSender.java\npackage net.sf.xbus.technical.as400;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.ProgramParameter;\n\n/**\n * The <code>AS400ProgramSender</code> calls a program on an AS400 and gives\n * back the result.\n * <p>\n */\npublic class AS400ProgramSender extends AS400FileBase implements Sender, ObjectSender {\n\n    public static final String CALLTYPE_SINGLE = \"Single\";\n\n    public static final String CALLTYPE_MULTI = \"Multi\";\n\n    private static final String TAG_INPUT = \"Input\";\n\n    private static final String TAG_OUTPUT = \"Output\";\n\n    private static final String TAG_FIELD = \"Field\";\n\n    private static final String ATTRIBUTE_NAME = \"Name\";\n\n    private static final String ATTRIBUTE_VALUE = \"Value\";\n\n    private static final String ATTRIBUTE_FORMAT = \"Format\";\n\n    private static final String ATTRIBUTE_LENGTH = \"Length\";\n\n    private static final String FORMAT_ALPHA = \"alpha\";\n\n    private static final String FORMAT_NUM = \"num\";\n\n    private static final String FORMAT_DATE = \"date\";\n\n    /**\n     * Interface reference in the xBus\n     */\n    private XBUSSystem mDestination = null;\n\n    /**\n     * Declaration of input parameters for program\n     */\n    private List mInputFields = null;\n\n    /**\n     * Declaration of output parameters\n     */\n    private List mOutputFields = null;\n\n    /**\n     * Length of output parameter string\n     */\n    private int mOutputLength = 0;\n\n    /**\n     * Input parameter values lined up in a string\n     */\n    private StringBuffer mInputParams;\n\n    /**\n     * Length of counter field for call type \"multiple\"\n     */\n    private int mCountLength;\n\n    /**\n     * Constructs an <code>AS400ProgramSender</code> for a given XBUSSystem\n     *\n     * @param destination XBUSSystem which consists two informations:<br>\n     *            &nbsp;&nbsp;-The name of the system is used to identify the\n     *            system<br>\n     *            &nbsp;&nbsp;-Additionally an adress might be available.\n     */\n    public AS400ProgramSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    // constructor AS400ProgramSender(XBUSSystem destination)\n    /**\n     * Performs the program call on the AS400. Steps to do this:\n     * <ul>\n     * <li>prepare input parameter</li>\n     * <li>call program with input parameters</li>\n     * <li>retrieve result and fromat output parameters\n     *\n     * @param function the path of the called program\n     * @param callData <code>org.w3c.Document</code> containing input\n     *            parameter structure and values and output parameter structure\n     * @return <code>org.w3c.Document</code> containing the output data of the\n     *         AS400 program in the specied structure\n     * @exception XException\n     */\n    public Object execute(String function, Object callData) throws XException {\n        // for result\n        Document response = null;\n        Configuration config = Configuration.getInstance();\n        AS400Connection as400Connection = AS400Connection.getInstance(config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"AS400Name\"));\n        int timeout = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ProgramTimeout\") * 1000;\n        if (timeout == 0) {\n            timeout = Integer.MAX_VALUE;\n        }\n        /*\n\t\t * If there is no real AS400 available, then testdata will be used.\n\t\t */\n        if (as400Connection.isTestSystem()) {\n            return XMLHelper.parseXML(getTestData(function), null, null);\n        }\n        // Conect to the iSeries\n        AS400 as400 = as400Connection.getSystem();\n        // Character converter\n        try {\n            mConverter = new CharConverter(as400.getCcsid());\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        // Determine how to operate\n        String callType = config.getValue(\"AS400Program\", function, \"CallType\");\n        if (!CALLTYPE_SINGLE.equals(callType) && !CALLTYPE_MULTI.equals(callType)) {\n            List params = new Vector();\n            params.add(callType);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"39\", params);\n        }\n        // if (!CALLTYPE_SINGLE.equals(callType) &&\n        // !CALLTYPE_MULTI.equals(callType))\n        if (CALLTYPE_SINGLE.equals(callType)) {\n            // Only one calling step, only one record wil be returned as result\n            // Read the name of the programm from the configuration\n            String programName = config.getValue(\"AS400Program\", function, \"Program\");\n            // Structure for input an (still empty) output parameters\n            ProgramParameter[] parameters = getParametersFromDocument((Document) callData, callType, function, 1, 1);\n            // the program call itself\n            callAS400Program(as400, programName, parameters, timeout);\n            // Get the output values.\n            List outputList = makeOutputFields(as400, parameters, 1);\n            // Place output values in specified XML structure.\n            response = getResponseDocument(function, outputList);\n        } else // then (CALLTYPE_SINGLE.equals(callType))\n        if (CALLTYPE_MULTI.equals(callType)) {\n            // Call multiple times to get entire list of output data\n            // First call will determine amount of returned records.\n            // Next phase is to call (another program) to get each time one\n            // record.\n            // Read the name of the output count determining program from the\n            // configuration\n            String programNameAmount = config.getValue(\"AS400Program\", function, \"ProgramAmount\");\n            // Read the e\n            String programNameData = config.getValue(\"AS400Program\", function, \"ProgramData\");\n            /*\n\t\t\t * First call of the AS400 program to get the amount of rows to be\n\t\t\t * retrieved.\n\t\t\t */\n            // Structure for input an (still empty) output parameters\n            ProgramParameter[] parameters = getParametersFromDocument((Document) callData, callType, function, 1, 1);\n            // The first program call itself\n            callAS400Program(as400, programNameAmount, parameters, timeout);\n            // Number of result records to retrieve in next calling phase\n            int recordAmount = getParameterAsInt(as400, parameters, 1);\n            /*\n\t\t\t * Subsequent calls of the AS400 program to get all rows.\n\t\t\t */\n            // for the result records\n            List outputVector = new Vector();\n            // Loop over all result records - count already known\n            for (int row = 0; row < recordAmount; row++) {\n                // Structure for input an (still empty) output parameters\n                parameters = getParametersFromDocument((Document) callData, callType, function, 2 + row, 1);\n                // The program call itself\n                callAS400Program(as400, programNameData, parameters, timeout);\n                // Retrieve result record and add it to list\n                outputVector.addAll(makeOutputFields(as400, parameters, 1));\n            }\n            // for (int row=0; row<recordAmount; row++)\n            response = getResponseDocument(function, outputVector);\n        }\n        // if (CALLTYPE_MULTI.equals(callType))\n        // Done with the server\n        as400.disconnectService(AS400.COMMAND);\n        return response;\n    }\n\n    // execute(String function, Object callData)\n    /**\n     * Gets one output parameter from the parameterlist as a string.\n     */\n    private String getParameterAsString(AS400 as400, ProgramParameter[] parameters, int position) {\n        byte[] data = parameters[position].getOutputData();\n        return mConverter.byteArrayToString(data);\n    }\n\n    /**\n     * Gets one output parameter from the parameterlist as an integer.\n     */\n    private int getParameterAsInt(AS400 as400, ProgramParameter[] parameters, int position) throws XException {\n        int response = 0;\n        try {\n            response = Integer.parseInt(getParameterAsString(as400, parameters, position));\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        return response;\n    }\n\n    /**\n     * A list of program parameters is created out of the given\n     * <code>org.w3c.document</code>.\n     */\n    private ProgramParameter[] getParametersFromDocument(Document doc, String callType, String function, int callNumber, int numOutputRows) throws XException {\n        ProgramParameter[] parameters = null;\n        parameters = new ProgramParameter[numOutputRows + 1];\n        /*\n\t\t * Filling the input parameter\n\t\t */\n        if (callNumber == 1) {\n            NodeList input = doc.getElementsByTagName(TAG_INPUT);\n            if (input.getLength() != 1) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"41\");\n            }\n            mInputFields = getFields(input.item(0).getChildNodes());\n            mInputParams = new StringBuffer();\n            Field field = null;\n            for (Iterator it = mInputFields.iterator(); it.hasNext(); ) {\n                field = (Field) it.next();\n                if (FORMAT_ALPHA.equals(field.format)) {\n                    if (field.length < field.value.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"42\", params);\n                    }\n                    // if (field.length < field.value.length())\n                    mInputParams.append(field.value);\n                    // Fill in blanks if the value is to short.\n                    for (int j = 0; j < field.length - field.value.length(); j++) {\n                        mInputParams.append(\" \");\n                    }\n                    // for (int j = 0; j < field.length -\n                    // field.value.length(); j++)\n                } else // if (FORMAT_ALPHA.equals(field.format))\n                if (FORMAT_NUM.equals(field.format)) {\n                    // Test if the value is an integer\n                    try {\n                        Integer.parseInt(field.value);\n                    }// try\n                     catch (NumberFormatException e) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        params.add(field.name);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"43\", params);\n                    }\n                    // catch\n                    if (field.length < field.value.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"42\", params);\n                    }\n                    // if (field.length < field.value.length())\n                    // Fill in trailing zeros if the value is too short\n                    for (int j = 0; j < field.length - field.value.length(); j++) {\n                        mInputParams.append(\"0\");\n                    }\n                    // for (int j = 0; j < field.length -\n                    // field.value.length()\n                    mInputParams.append(field.value);\n                } else // if (FORMAT_NUM.equals(field.format))\n                if (FORMAT_DATE.equals(field.format)) {\n                    if (field.value.length() != Constants.AS400_CALL_DATE_FORMAT.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"45\", params);\n                    }\n                    mInputParams.append(field.value);\n                } else // then (FORMAT_DATE.equals(field.format))\n                {\n                    List params = new Vector();\n                    params.add(field.name);\n                    params.add(field.format);\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"46\", params);\n                }\n                // (FORMAT_DATE.equals(field.format))\n            }\n            // for (Iterator it = mInputFields.iterator(); it.hasNext();)\n        } else // if (callNumber==1)\n        if (callNumber == 2)\n            mInputParams.append(XStringSupport.getNumberString(1, mCountLength));\n        else {\n            mInputParams.delete(mInputParams.lastIndexOf(XStringSupport.getNumberString(callNumber - 2, mCountLength)), mInputParams.length());\n            mInputParams.append(XStringSupport.getNumberString(callNumber - 1, mCountLength));\n        }\n        parameters[0] = new ProgramParameter(mConverter.stringToByteArray(mInputParams.toString()));\n        /*\n\t\t * Filling the output parameters\n\t\t */\n        if (callNumber == 1) {\n            NodeList output = doc.getElementsByTagName(TAG_OUTPUT);\n            if (output.getLength() != 1) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"47\");\n            }\n            mOutputFields = getFields(output.item(0).getChildNodes());\n        }\n        if ((CALLTYPE_MULTI.equals(callType)) && callNumber == 1) {\n            Configuration config = Configuration.getInstance();\n            mCountLength = config.getValueAsInt(\"AS400Program\", function, \"CounterLength\");\n            parameters[1] = new ProgramParameter(mCountLength);\n        } else {\n            if (callNumber < 3) {\n                Field field = null;\n                for (Iterator it = mOutputFields.iterator(); it.hasNext(); ) {\n                    field = (Field) it.next();\n                    mOutputLength = mOutputLength + field.length;\n                }\n            }\n            parameters[1] = new ProgramParameter(mOutputLength);\n        }\n        return parameters;\n    }\n\n    /**\n     * Makes a list of fields out of the output parameters of the given\n     * parameter list.\n     */\n    private List makeOutputFields(AS400 as400, ProgramParameter[] parameters, int numRows) throws XException {\n        /*\n\t\t * Since the first parameter is an input parameter, the length of the\n\t\t * parameters array must be larger than numRows\n\t\t */\n        if (parameters.length <= numRows) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"66\");\n        }\n        Vector response = new Vector();\n        Vector row = null;\n        Field field = null;\n        int position = 0;\n        String data = null;\n        for (int i = 1; i <= numRows; i++) {\n            row = new Vector();\n            data = getParameterAsString(as400, parameters, i);\n            for (Iterator it = mOutputFields.iterator(); it.hasNext(); ) {\n                field = (Field) ((Field) it.next()).clone();\n                field.value = data.substring(position, position + field.length).trim();\n                if (FORMAT_NUM.equals(field.format)) {\n                    try {\n                        field.value = String.valueOf(Integer.parseInt(field.value));\n                    } catch (NumberFormatException e) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n                    }\n                }\n                position = position + field.length;\n                row.add(field);\n            }\n            response.add(row);\n        }\n        return response;\n    }\n\n    /**\n     * Creates an <code>org.w3c.Document</code> out of the given list of\n     * output fields\n     */\n    private Document getResponseDocument(String function, List outputLists) throws XException {\n        Document response = getTemplateAsDocument();\n        Element newFunction = response.createElement(Constants.XBUSXMLMESSAGE_FUNCTION);\n        newFunction.appendChild(response.createTextNode(function));\n        NodeList children = response.getElementsByTagName(Constants.XBUSXMLMESSAGE_FUNCTION);\n        if (children.getLength() > 0) {\n            Node oldData = children.item(0);\n            Node father = oldData.getParentNode();\n            father.replaceChild(newFunction, oldData);\n        }\n        Element newData = response.createElement(Constants.XBUSXMLMESSAGE_DATA);\n        List fields = null;\n        Field field = null;\n        Element outputNode = null;\n        Element fieldNode = null;\n        for (Iterator it1 = outputLists.iterator(); it1.hasNext(); ) {\n            fields = (List) it1.next();\n            outputNode = response.createElement(TAG_OUTPUT);\n            newData.appendChild(outputNode);\n            outputNode.appendChild(response.createTextNode(\"\\n\"));\n            for (Iterator it2 = fields.iterator(); it2.hasNext(); ) {\n                field = (Field) it2.next();\n                fieldNode = response.createElement(TAG_FIELD);\n                outputNode.appendChild(fieldNode);\n                fieldNode.setAttribute(ATTRIBUTE_NAME, field.name);\n                fieldNode.setAttribute(ATTRIBUTE_VALUE, field.value);\n                fieldNode.setAttribute(ATTRIBUTE_FORMAT, field.format);\n                if (!FORMAT_DATE.equals(field.format)) {\n                    fieldNode.setAttribute(ATTRIBUTE_LENGTH, String.valueOf(field.length));\n                }\n                outputNode.appendChild(response.createTextNode(\"\\n\"));\n            }\n        }\n        children = response.getElementsByTagName(Constants.XBUSXMLMESSAGE_DATA);\n        if (children.getLength() > 0) {\n            Node oldData = children.item(0);\n            Node father = oldData.getParentNode();\n            father.replaceChild(newData, oldData);\n        }\n        return response;\n    }\n\n    /**\n     * Makes a list of fields for either input or output parameters.\n     */\n    private List getFields(NodeList nodes) throws XException {\n        Vector fields = new Vector();\n        Field field;\n        Node node, name, value, length, format;\n        NamedNodeMap attributes;\n        for (int i = 0; i < nodes.getLength(); i++) {\n            node = nodes.item(i);\n            if ((TAG_FIELD.equals(node.getNodeName())) && (node.getNodeType() == Node.ELEMENT_NODE)) {\n                field = new Field();\n                attributes = node.getAttributes();\n                name = attributes.getNamedItem(ATTRIBUTE_NAME);\n                if (name != null) {\n                    field.name = name.getNodeValue();\n                } else {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"50\");\n                }\n                value = attributes.getNamedItem(ATTRIBUTE_VALUE);\n                if (value != null) {\n                    field.value = value.getNodeValue();\n                } else {\n                    field.value = null;\n                }\n                format = attributes.getNamedItem(ATTRIBUTE_FORMAT);\n                if (format != null) {\n                    field.format = format.getNodeValue();\n                } else {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"51\");\n                }\n                if (FORMAT_DATE.equals(field.format)) {\n                    field.length = Constants.AS400_CALL_DATE_FORMAT.length();\n                } else {\n                    length = attributes.getNamedItem(ATTRIBUTE_LENGTH);\n                    if (length != null) {\n                        try {\n                            field.length = Integer.parseInt(length.getNodeValue());\n                        } catch (NumberFormatException e) {\n                            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n                        }\n                    } else {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"53\");\n                    }\n                }\n                fields.add(field);\n            }\n        }\n        return fields;\n    }\n\n    /**\n     * Reads test data from a file, when there is no AS/400 available.\n     */\n    private String getTestData(String function) throws XException {\n        Trace.info(\"Entering AS400ProgramMessage.getTestData\");\n        String filename;\n        if (\"StockCheck\".equals(function)) {\n            filename = Constants.XBUS_ETC + \"AS400Test\" + Constants.FILE_SEPERATOR + \"StockCheck.xml\";\n        } else if (\"OrderCheck\".equals(function)) {\n            filename = Constants.XBUS_ETC + \"AS400Test\" + Constants.FILE_SEPERATOR + \"OrderCheck.xml\";\n        } else {\n            List params = new Vector();\n            params.add(function);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"54\", params);\n        }\n        String line;\n        StringBuffer testData = new StringBuffer();\n        try {\n            BufferedReader instream = new BufferedReader(new FileReader(new File(filename)));\n            while ((line = instream.readLine()) != null) {\n                testData.append(line);\n                testData.append(Constants.LINE_SEPERATOR);\n            }\n            instream.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        Trace.info(\"Leaving  AS400ProgramMessage.getTestData\");\n        return testData.toString();\n    }\n\n    /**\n     * Acts as a container for the information of one field of either an input\n     * or an output parameter.\n     */\n    class Field implements Cloneable {\n\n        public String name = null;\n\n        public String value = null;\n\n        public int length = 0;\n\n        public String format = null;\n\n        public Object clone() {\n            Field field = new Field();\n            field.name = this.name;\n            field.value = this.value;\n            field.length = this.length;\n            field.format = this.format;\n            return field;\n        }\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n\n    /**\n     * Returns a XML string containing an empty AS400ProgramMessage\n     */\n    static public String getTemplateAsString() throws XException {\n        StringBuffer retString = new StringBuffer();\n        retString.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n        retString.append(Constants.getXMLEncoding());\n        retString.append(\"\\\"?>\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<!DOCTYPE XBUS_Document SYSTEM \\\"output.dtd\\\">\");\n        // The hard-coded refernce to \"output.dtd\" is not correct because the\n        // interfaces were agreed to\n        // use their own specific DTD's (one for input, one for output).\n        // As long as the destination system does not check the validity of the\n        // output xml file against\n        // its DTD, the entry in the file is arbitrary. If it does, an error\n        // will be issued becasue the\n        // used DTD's contain the names of the fields.\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_FUNCTION).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"</\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_DATA).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"</\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        return retString.toString();\n    }\n\n    /**\n     * Returns a W3C document containing an empty AS400ProgramMessage\n     */\n    static public Document getTemplateAsDocument() throws XException {\n        return XMLHelper.parseXML(getTemplateAsString(), null, null);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400ProgramSenderTest0.java",
		"test_prompt": "// AS400ProgramSenderTest0.java\npackage net.sf.xbus.technical.as400;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.ProgramParameter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400ProgramSender}.\n* It contains ten unit test cases for the {@link AS400ProgramSender#execute(String, Object)} method.\n*/\nclass AS400ProgramSenderTest0 {"
	},
	{
		"original_code": "// AS400ProgramSender.java\npackage net.sf.xbus.technical.as400;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.ProgramParameter;\n\n/**\n * The <code>AS400ProgramSender</code> calls a program on an AS400 and gives\n * back the result.\n * <p>\n */\npublic class AS400ProgramSender extends AS400FileBase implements Sender, ObjectSender {\n\n    public static final String CALLTYPE_SINGLE = \"Single\";\n\n    public static final String CALLTYPE_MULTI = \"Multi\";\n\n    private static final String TAG_INPUT = \"Input\";\n\n    private static final String TAG_OUTPUT = \"Output\";\n\n    private static final String TAG_FIELD = \"Field\";\n\n    private static final String ATTRIBUTE_NAME = \"Name\";\n\n    private static final String ATTRIBUTE_VALUE = \"Value\";\n\n    private static final String ATTRIBUTE_FORMAT = \"Format\";\n\n    private static final String ATTRIBUTE_LENGTH = \"Length\";\n\n    private static final String FORMAT_ALPHA = \"alpha\";\n\n    private static final String FORMAT_NUM = \"num\";\n\n    private static final String FORMAT_DATE = \"date\";\n\n    /**\n     * Interface reference in the xBus\n     */\n    private XBUSSystem mDestination = null;\n\n    /**\n     * Declaration of input parameters for program\n     */\n    private List mInputFields = null;\n\n    /**\n     * Declaration of output parameters\n     */\n    private List mOutputFields = null;\n\n    /**\n     * Length of output parameter string\n     */\n    private int mOutputLength = 0;\n\n    /**\n     * Input parameter values lined up in a string\n     */\n    private StringBuffer mInputParams;\n\n    /**\n     * Length of counter field for call type \"multiple\"\n     */\n    private int mCountLength;\n\n    /**\n     * Constructs an <code>AS400ProgramSender</code> for a given XBUSSystem\n     *\n     * @param destination XBUSSystem which consists two informations:<br>\n     *            &nbsp;&nbsp;-The name of the system is used to identify the\n     *            system<br>\n     *            &nbsp;&nbsp;-Additionally an adress might be available.\n     */\n    public AS400ProgramSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    // constructor AS400ProgramSender(XBUSSystem destination)\n    /**\n     * Performs the program call on the AS400. Steps to do this:\n     * <ul>\n     * <li>prepare input parameter</li>\n     * <li>call program with input parameters</li>\n     * <li>retrieve result and fromat output parameters\n     *\n     * @param function the path of the called program\n     * @param callData <code>org.w3c.Document</code> containing input\n     *            parameter structure and values and output parameter structure\n     * @return <code>org.w3c.Document</code> containing the output data of the\n     *         AS400 program in the specied structure\n     * @exception XException\n     */\n    public Object execute(String function, Object callData) throws XException {\n        // for result\n        Document response = null;\n        Configuration config = Configuration.getInstance();\n        AS400Connection as400Connection = AS400Connection.getInstance(config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"AS400Name\"));\n        int timeout = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ProgramTimeout\") * 1000;\n        if (timeout == 0) {\n            timeout = Integer.MAX_VALUE;\n        }\n        /*\n\t\t * If there is no real AS400 available, then testdata will be used.\n\t\t */\n        if (as400Connection.isTestSystem()) {\n            return XMLHelper.parseXML(getTestData(function), null, null);\n        }\n        // Conect to the iSeries\n        AS400 as400 = as400Connection.getSystem();\n        // Character converter\n        try {\n            mConverter = new CharConverter(as400.getCcsid());\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        // Determine how to operate\n        String callType = config.getValue(\"AS400Program\", function, \"CallType\");\n        if (!CALLTYPE_SINGLE.equals(callType) && !CALLTYPE_MULTI.equals(callType)) {\n            List params = new Vector();\n            params.add(callType);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"39\", params);\n        }\n        // if (!CALLTYPE_SINGLE.equals(callType) &&\n        // !CALLTYPE_MULTI.equals(callType))\n        if (CALLTYPE_SINGLE.equals(callType)) {\n            // Only one calling step, only one record wil be returned as result\n            // Read the name of the programm from the configuration\n            String programName = config.getValue(\"AS400Program\", function, \"Program\");\n            // Structure for input an (still empty) output parameters\n            ProgramParameter[] parameters = getParametersFromDocument((Document) callData, callType, function, 1, 1);\n            // the program call itself\n            callAS400Program(as400, programName, parameters, timeout);\n            // Get the output values.\n            List outputList = makeOutputFields(as400, parameters, 1);\n            // Place output values in specified XML structure.\n            response = getResponseDocument(function, outputList);\n        } else // then (CALLTYPE_SINGLE.equals(callType))\n        if (CALLTYPE_MULTI.equals(callType)) {\n            // Call multiple times to get entire list of output data\n            // First call will determine amount of returned records.\n            // Next phase is to call (another program) to get each time one\n            // record.\n            // Read the name of the output count determining program from the\n            // configuration\n            String programNameAmount = config.getValue(\"AS400Program\", function, \"ProgramAmount\");\n            // Read the e\n            String programNameData = config.getValue(\"AS400Program\", function, \"ProgramData\");\n            /*\n\t\t\t * First call of the AS400 program to get the amount of rows to be\n\t\t\t * retrieved.\n\t\t\t */\n            // Structure for input an (still empty) output parameters\n            ProgramParameter[] parameters = getParametersFromDocument((Document) callData, callType, function, 1, 1);\n            // The first program call itself\n            callAS400Program(as400, programNameAmount, parameters, timeout);\n            // Number of result records to retrieve in next calling phase\n            int recordAmount = getParameterAsInt(as400, parameters, 1);\n            /*\n\t\t\t * Subsequent calls of the AS400 program to get all rows.\n\t\t\t */\n            // for the result records\n            List outputVector = new Vector();\n            // Loop over all result records - count already known\n            for (int row = 0; row < recordAmount; row++) {\n                // Structure for input an (still empty) output parameters\n                parameters = getParametersFromDocument((Document) callData, callType, function, 2 + row, 1);\n                // The program call itself\n                callAS400Program(as400, programNameData, parameters, timeout);\n                // Retrieve result record and add it to list\n                outputVector.addAll(makeOutputFields(as400, parameters, 1));\n            }\n            // for (int row=0; row<recordAmount; row++)\n            response = getResponseDocument(function, outputVector);\n        }\n        // if (CALLTYPE_MULTI.equals(callType))\n        // Done with the server\n        as400.disconnectService(AS400.COMMAND);\n        return response;\n    }\n\n    // execute(String function, Object callData)\n    /**\n     * Gets one output parameter from the parameterlist as a string.\n     */\n    private String getParameterAsString(AS400 as400, ProgramParameter[] parameters, int position) {\n        byte[] data = parameters[position].getOutputData();\n        return mConverter.byteArrayToString(data);\n    }\n\n    /**\n     * Gets one output parameter from the parameterlist as an integer.\n     */\n    private int getParameterAsInt(AS400 as400, ProgramParameter[] parameters, int position) throws XException {\n        int response = 0;\n        try {\n            response = Integer.parseInt(getParameterAsString(as400, parameters, position));\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        return response;\n    }\n\n    /**\n     * A list of program parameters is created out of the given\n     * <code>org.w3c.document</code>.\n     */\n    private ProgramParameter[] getParametersFromDocument(Document doc, String callType, String function, int callNumber, int numOutputRows) throws XException {\n        ProgramParameter[] parameters = null;\n        parameters = new ProgramParameter[numOutputRows + 1];\n        /*\n\t\t * Filling the input parameter\n\t\t */\n        if (callNumber == 1) {\n            NodeList input = doc.getElementsByTagName(TAG_INPUT);\n            if (input.getLength() != 1) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"41\");\n            }\n            mInputFields = getFields(input.item(0).getChildNodes());\n            mInputParams = new StringBuffer();\n            Field field = null;\n            for (Iterator it = mInputFields.iterator(); it.hasNext(); ) {\n                field = (Field) it.next();\n                if (FORMAT_ALPHA.equals(field.format)) {\n                    if (field.length < field.value.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"42\", params);\n                    }\n                    // if (field.length < field.value.length())\n                    mInputParams.append(field.value);\n                    // Fill in blanks if the value is to short.\n                    for (int j = 0; j < field.length - field.value.length(); j++) {\n                        mInputParams.append(\" \");\n                    }\n                    // for (int j = 0; j < field.length -\n                    // field.value.length(); j++)\n                } else // if (FORMAT_ALPHA.equals(field.format))\n                if (FORMAT_NUM.equals(field.format)) {\n                    // Test if the value is an integer\n                    try {\n                        Integer.parseInt(field.value);\n                    }// try\n                     catch (NumberFormatException e) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        params.add(field.name);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"43\", params);\n                    }\n                    // catch\n                    if (field.length < field.value.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"42\", params);\n                    }\n                    // if (field.length < field.value.length())\n                    // Fill in trailing zeros if the value is too short\n                    for (int j = 0; j < field.length - field.value.length(); j++) {\n                        mInputParams.append(\"0\");\n                    }\n                    // for (int j = 0; j < field.length -\n                    // field.value.length()\n                    mInputParams.append(field.value);\n                } else // if (FORMAT_NUM.equals(field.format))\n                if (FORMAT_DATE.equals(field.format)) {\n                    if (field.value.length() != Constants.AS400_CALL_DATE_FORMAT.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"45\", params);\n                    }\n                    mInputParams.append(field.value);\n                } else // then (FORMAT_DATE.equals(field.format))\n                {\n                    List params = new Vector();\n                    params.add(field.name);\n                    params.add(field.format);\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"46\", params);\n                }\n                // (FORMAT_DATE.equals(field.format))\n            }\n            // for (Iterator it = mInputFields.iterator(); it.hasNext();)\n        } else // if (callNumber==1)\n        if (callNumber == 2)\n            mInputParams.append(XStringSupport.getNumberString(1, mCountLength));\n        else {\n            mInputParams.delete(mInputParams.lastIndexOf(XStringSupport.getNumberString(callNumber - 2, mCountLength)), mInputParams.length());\n            mInputParams.append(XStringSupport.getNumberString(callNumber - 1, mCountLength));\n        }\n        parameters[0] = new ProgramParameter(mConverter.stringToByteArray(mInputParams.toString()));\n        /*\n\t\t * Filling the output parameters\n\t\t */\n        if (callNumber == 1) {\n            NodeList output = doc.getElementsByTagName(TAG_OUTPUT);\n            if (output.getLength() != 1) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"47\");\n            }\n            mOutputFields = getFields(output.item(0).getChildNodes());\n        }\n        if ((CALLTYPE_MULTI.equals(callType)) && callNumber == 1) {\n            Configuration config = Configuration.getInstance();\n            mCountLength = config.getValueAsInt(\"AS400Program\", function, \"CounterLength\");\n            parameters[1] = new ProgramParameter(mCountLength);\n        } else {\n            if (callNumber < 3) {\n                Field field = null;\n                for (Iterator it = mOutputFields.iterator(); it.hasNext(); ) {\n                    field = (Field) it.next();\n                    mOutputLength = mOutputLength + field.length;\n                }\n            }\n            parameters[1] = new ProgramParameter(mOutputLength);\n        }\n        return parameters;\n    }\n\n    /**\n     * Makes a list of fields out of the output parameters of the given\n     * parameter list.\n     */\n    private List makeOutputFields(AS400 as400, ProgramParameter[] parameters, int numRows) throws XException {\n        /*\n\t\t * Since the first parameter is an input parameter, the length of the\n\t\t * parameters array must be larger than numRows\n\t\t */\n        if (parameters.length <= numRows) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"66\");\n        }\n        Vector response = new Vector();\n        Vector row = null;\n        Field field = null;\n        int position = 0;\n        String data = null;\n        for (int i = 1; i <= numRows; i++) {\n            row = new Vector();\n            data = getParameterAsString(as400, parameters, i);\n            for (Iterator it = mOutputFields.iterator(); it.hasNext(); ) {\n                field = (Field) ((Field) it.next()).clone();\n                field.value = data.substring(position, position + field.length).trim();\n                if (FORMAT_NUM.equals(field.format)) {\n                    try {\n                        field.value = String.valueOf(Integer.parseInt(field.value));\n                    } catch (NumberFormatException e) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n                    }\n                }\n                position = position + field.length;\n                row.add(field);\n            }\n            response.add(row);\n        }\n        return response;\n    }\n\n    /**\n     * Creates an <code>org.w3c.Document</code> out of the given list of\n     * output fields\n     */\n    private Document getResponseDocument(String function, List outputLists) throws XException {\n        Document response = getTemplateAsDocument();\n        Element newFunction = response.createElement(Constants.XBUSXMLMESSAGE_FUNCTION);\n        newFunction.appendChild(response.createTextNode(function));\n        NodeList children = response.getElementsByTagName(Constants.XBUSXMLMESSAGE_FUNCTION);\n        if (children.getLength() > 0) {\n            Node oldData = children.item(0);\n            Node father = oldData.getParentNode();\n            father.replaceChild(newFunction, oldData);\n        }\n        Element newData = response.createElement(Constants.XBUSXMLMESSAGE_DATA);\n        List fields = null;\n        Field field = null;\n        Element outputNode = null;\n        Element fieldNode = null;\n        for (Iterator it1 = outputLists.iterator(); it1.hasNext(); ) {\n            fields = (List) it1.next();\n            outputNode = response.createElement(TAG_OUTPUT);\n            newData.appendChild(outputNode);\n            outputNode.appendChild(response.createTextNode(\"\\n\"));\n            for (Iterator it2 = fields.iterator(); it2.hasNext(); ) {\n                field = (Field) it2.next();\n                fieldNode = response.createElement(TAG_FIELD);\n                outputNode.appendChild(fieldNode);\n                fieldNode.setAttribute(ATTRIBUTE_NAME, field.name);\n                fieldNode.setAttribute(ATTRIBUTE_VALUE, field.value);\n                fieldNode.setAttribute(ATTRIBUTE_FORMAT, field.format);\n                if (!FORMAT_DATE.equals(field.format)) {\n                    fieldNode.setAttribute(ATTRIBUTE_LENGTH, String.valueOf(field.length));\n                }\n                outputNode.appendChild(response.createTextNode(\"\\n\"));\n            }\n        }\n        children = response.getElementsByTagName(Constants.XBUSXMLMESSAGE_DATA);\n        if (children.getLength() > 0) {\n            Node oldData = children.item(0);\n            Node father = oldData.getParentNode();\n            father.replaceChild(newData, oldData);\n        }\n        return response;\n    }\n\n    /**\n     * Makes a list of fields for either input or output parameters.\n     */\n    private List getFields(NodeList nodes) throws XException {\n        Vector fields = new Vector();\n        Field field;\n        Node node, name, value, length, format;\n        NamedNodeMap attributes;\n        for (int i = 0; i < nodes.getLength(); i++) {\n            node = nodes.item(i);\n            if ((TAG_FIELD.equals(node.getNodeName())) && (node.getNodeType() == Node.ELEMENT_NODE)) {\n                field = new Field();\n                attributes = node.getAttributes();\n                name = attributes.getNamedItem(ATTRIBUTE_NAME);\n                if (name != null) {\n                    field.name = name.getNodeValue();\n                } else {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"50\");\n                }\n                value = attributes.getNamedItem(ATTRIBUTE_VALUE);\n                if (value != null) {\n                    field.value = value.getNodeValue();\n                } else {\n                    field.value = null;\n                }\n                format = attributes.getNamedItem(ATTRIBUTE_FORMAT);\n                if (format != null) {\n                    field.format = format.getNodeValue();\n                } else {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"51\");\n                }\n                if (FORMAT_DATE.equals(field.format)) {\n                    field.length = Constants.AS400_CALL_DATE_FORMAT.length();\n                } else {\n                    length = attributes.getNamedItem(ATTRIBUTE_LENGTH);\n                    if (length != null) {\n                        try {\n                            field.length = Integer.parseInt(length.getNodeValue());\n                        } catch (NumberFormatException e) {\n                            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n                        }\n                    } else {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"53\");\n                    }\n                }\n                fields.add(field);\n            }\n        }\n        return fields;\n    }\n\n    /**\n     * Reads test data from a file, when there is no AS/400 available.\n     */\n    private String getTestData(String function) throws XException {\n        Trace.info(\"Entering AS400ProgramMessage.getTestData\");\n        String filename;\n        if (\"StockCheck\".equals(function)) {\n            filename = Constants.XBUS_ETC + \"AS400Test\" + Constants.FILE_SEPERATOR + \"StockCheck.xml\";\n        } else if (\"OrderCheck\".equals(function)) {\n            filename = Constants.XBUS_ETC + \"AS400Test\" + Constants.FILE_SEPERATOR + \"OrderCheck.xml\";\n        } else {\n            List params = new Vector();\n            params.add(function);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"54\", params);\n        }\n        String line;\n        StringBuffer testData = new StringBuffer();\n        try {\n            BufferedReader instream = new BufferedReader(new FileReader(new File(filename)));\n            while ((line = instream.readLine()) != null) {\n                testData.append(line);\n                testData.append(Constants.LINE_SEPERATOR);\n            }\n            instream.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        Trace.info(\"Leaving  AS400ProgramMessage.getTestData\");\n        return testData.toString();\n    }\n\n    /**\n     * Acts as a container for the information of one field of either an input\n     * or an output parameter.\n     */\n    class Field implements Cloneable {\n\n        public String name = null;\n\n        public String value = null;\n\n        public int length = 0;\n\n        public String format = null;\n\n        public Object clone() {\n            Field field = new Field();\n            field.name = this.name;\n            field.value = this.value;\n            field.length = this.length;\n            field.format = this.format;\n            return field;\n        }\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n\n    /**\n     * Returns a XML string containing an empty AS400ProgramMessage\n     */\n    static public String getTemplateAsString() throws XException {\n        StringBuffer retString = new StringBuffer();\n        retString.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n        retString.append(Constants.getXMLEncoding());\n        retString.append(\"\\\"?>\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<!DOCTYPE XBUS_Document SYSTEM \\\"output.dtd\\\">\");\n        // The hard-coded refernce to \"output.dtd\" is not correct because the\n        // interfaces were agreed to\n        // use their own specific DTD's (one for input, one for output).\n        // As long as the destination system does not check the validity of the\n        // output xml file against\n        // its DTD, the entry in the file is arbitrary. If it does, an error\n        // will be issued becasue the\n        // used DTD's contain the names of the fields.\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_FUNCTION).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"</\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_DATA).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"</\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        return retString.toString();\n    }\n\n    /**\n     * Returns a W3C document containing an empty AS400ProgramMessage\n     */\n    static public Document getTemplateAsDocument() throws XException {\n        return XMLHelper.parseXML(getTemplateAsString(), null, null);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400ProgramSenderTest1.java",
		"test_prompt": "// AS400ProgramSenderTest1.java\npackage net.sf.xbus.technical.as400;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.ProgramParameter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400ProgramSender}.\n* It contains ten unit test cases for the {@link AS400ProgramSender#getTemplateAsString()} method.\n*/\nclass AS400ProgramSenderTest1 {"
	},
	{
		"original_code": "// AS400ProgramSender.java\npackage net.sf.xbus.technical.as400;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.ProgramParameter;\n\n/**\n * The <code>AS400ProgramSender</code> calls a program on an AS400 and gives\n * back the result.\n * <p>\n */\npublic class AS400ProgramSender extends AS400FileBase implements Sender, ObjectSender {\n\n    public static final String CALLTYPE_SINGLE = \"Single\";\n\n    public static final String CALLTYPE_MULTI = \"Multi\";\n\n    private static final String TAG_INPUT = \"Input\";\n\n    private static final String TAG_OUTPUT = \"Output\";\n\n    private static final String TAG_FIELD = \"Field\";\n\n    private static final String ATTRIBUTE_NAME = \"Name\";\n\n    private static final String ATTRIBUTE_VALUE = \"Value\";\n\n    private static final String ATTRIBUTE_FORMAT = \"Format\";\n\n    private static final String ATTRIBUTE_LENGTH = \"Length\";\n\n    private static final String FORMAT_ALPHA = \"alpha\";\n\n    private static final String FORMAT_NUM = \"num\";\n\n    private static final String FORMAT_DATE = \"date\";\n\n    /**\n     * Interface reference in the xBus\n     */\n    private XBUSSystem mDestination = null;\n\n    /**\n     * Declaration of input parameters for program\n     */\n    private List mInputFields = null;\n\n    /**\n     * Declaration of output parameters\n     */\n    private List mOutputFields = null;\n\n    /**\n     * Length of output parameter string\n     */\n    private int mOutputLength = 0;\n\n    /**\n     * Input parameter values lined up in a string\n     */\n    private StringBuffer mInputParams;\n\n    /**\n     * Length of counter field for call type \"multiple\"\n     */\n    private int mCountLength;\n\n    /**\n     * Constructs an <code>AS400ProgramSender</code> for a given XBUSSystem\n     *\n     * @param destination XBUSSystem which consists two informations:<br>\n     *            &nbsp;&nbsp;-The name of the system is used to identify the\n     *            system<br>\n     *            &nbsp;&nbsp;-Additionally an adress might be available.\n     */\n    public AS400ProgramSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    // constructor AS400ProgramSender(XBUSSystem destination)\n    /**\n     * Performs the program call on the AS400. Steps to do this:\n     * <ul>\n     * <li>prepare input parameter</li>\n     * <li>call program with input parameters</li>\n     * <li>retrieve result and fromat output parameters\n     *\n     * @param function the path of the called program\n     * @param callData <code>org.w3c.Document</code> containing input\n     *            parameter structure and values and output parameter structure\n     * @return <code>org.w3c.Document</code> containing the output data of the\n     *         AS400 program in the specied structure\n     * @exception XException\n     */\n    public Object execute(String function, Object callData) throws XException {\n        // for result\n        Document response = null;\n        Configuration config = Configuration.getInstance();\n        AS400Connection as400Connection = AS400Connection.getInstance(config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"AS400Name\"));\n        int timeout = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"ProgramTimeout\") * 1000;\n        if (timeout == 0) {\n            timeout = Integer.MAX_VALUE;\n        }\n        /*\n\t\t * If there is no real AS400 available, then testdata will be used.\n\t\t */\n        if (as400Connection.isTestSystem()) {\n            return XMLHelper.parseXML(getTestData(function), null, null);\n        }\n        // Conect to the iSeries\n        AS400 as400 = as400Connection.getSystem();\n        // Character converter\n        try {\n            mConverter = new CharConverter(as400.getCcsid());\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        // Determine how to operate\n        String callType = config.getValue(\"AS400Program\", function, \"CallType\");\n        if (!CALLTYPE_SINGLE.equals(callType) && !CALLTYPE_MULTI.equals(callType)) {\n            List params = new Vector();\n            params.add(callType);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"39\", params);\n        }\n        // if (!CALLTYPE_SINGLE.equals(callType) &&\n        // !CALLTYPE_MULTI.equals(callType))\n        if (CALLTYPE_SINGLE.equals(callType)) {\n            // Only one calling step, only one record wil be returned as result\n            // Read the name of the programm from the configuration\n            String programName = config.getValue(\"AS400Program\", function, \"Program\");\n            // Structure for input an (still empty) output parameters\n            ProgramParameter[] parameters = getParametersFromDocument((Document) callData, callType, function, 1, 1);\n            // the program call itself\n            callAS400Program(as400, programName, parameters, timeout);\n            // Get the output values.\n            List outputList = makeOutputFields(as400, parameters, 1);\n            // Place output values in specified XML structure.\n            response = getResponseDocument(function, outputList);\n        } else // then (CALLTYPE_SINGLE.equals(callType))\n        if (CALLTYPE_MULTI.equals(callType)) {\n            // Call multiple times to get entire list of output data\n            // First call will determine amount of returned records.\n            // Next phase is to call (another program) to get each time one\n            // record.\n            // Read the name of the output count determining program from the\n            // configuration\n            String programNameAmount = config.getValue(\"AS400Program\", function, \"ProgramAmount\");\n            // Read the e\n            String programNameData = config.getValue(\"AS400Program\", function, \"ProgramData\");\n            /*\n\t\t\t * First call of the AS400 program to get the amount of rows to be\n\t\t\t * retrieved.\n\t\t\t */\n            // Structure for input an (still empty) output parameters\n            ProgramParameter[] parameters = getParametersFromDocument((Document) callData, callType, function, 1, 1);\n            // The first program call itself\n            callAS400Program(as400, programNameAmount, parameters, timeout);\n            // Number of result records to retrieve in next calling phase\n            int recordAmount = getParameterAsInt(as400, parameters, 1);\n            /*\n\t\t\t * Subsequent calls of the AS400 program to get all rows.\n\t\t\t */\n            // for the result records\n            List outputVector = new Vector();\n            // Loop over all result records - count already known\n            for (int row = 0; row < recordAmount; row++) {\n                // Structure for input an (still empty) output parameters\n                parameters = getParametersFromDocument((Document) callData, callType, function, 2 + row, 1);\n                // The program call itself\n                callAS400Program(as400, programNameData, parameters, timeout);\n                // Retrieve result record and add it to list\n                outputVector.addAll(makeOutputFields(as400, parameters, 1));\n            }\n            // for (int row=0; row<recordAmount; row++)\n            response = getResponseDocument(function, outputVector);\n        }\n        // if (CALLTYPE_MULTI.equals(callType))\n        // Done with the server\n        as400.disconnectService(AS400.COMMAND);\n        return response;\n    }\n\n    // execute(String function, Object callData)\n    /**\n     * Gets one output parameter from the parameterlist as a string.\n     */\n    private String getParameterAsString(AS400 as400, ProgramParameter[] parameters, int position) {\n        byte[] data = parameters[position].getOutputData();\n        return mConverter.byteArrayToString(data);\n    }\n\n    /**\n     * Gets one output parameter from the parameterlist as an integer.\n     */\n    private int getParameterAsInt(AS400 as400, ProgramParameter[] parameters, int position) throws XException {\n        int response = 0;\n        try {\n            response = Integer.parseInt(getParameterAsString(as400, parameters, position));\n        } catch (NumberFormatException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        return response;\n    }\n\n    /**\n     * A list of program parameters is created out of the given\n     * <code>org.w3c.document</code>.\n     */\n    private ProgramParameter[] getParametersFromDocument(Document doc, String callType, String function, int callNumber, int numOutputRows) throws XException {\n        ProgramParameter[] parameters = null;\n        parameters = new ProgramParameter[numOutputRows + 1];\n        /*\n\t\t * Filling the input parameter\n\t\t */\n        if (callNumber == 1) {\n            NodeList input = doc.getElementsByTagName(TAG_INPUT);\n            if (input.getLength() != 1) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"41\");\n            }\n            mInputFields = getFields(input.item(0).getChildNodes());\n            mInputParams = new StringBuffer();\n            Field field = null;\n            for (Iterator it = mInputFields.iterator(); it.hasNext(); ) {\n                field = (Field) it.next();\n                if (FORMAT_ALPHA.equals(field.format)) {\n                    if (field.length < field.value.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"42\", params);\n                    }\n                    // if (field.length < field.value.length())\n                    mInputParams.append(field.value);\n                    // Fill in blanks if the value is to short.\n                    for (int j = 0; j < field.length - field.value.length(); j++) {\n                        mInputParams.append(\" \");\n                    }\n                    // for (int j = 0; j < field.length -\n                    // field.value.length(); j++)\n                } else // if (FORMAT_ALPHA.equals(field.format))\n                if (FORMAT_NUM.equals(field.format)) {\n                    // Test if the value is an integer\n                    try {\n                        Integer.parseInt(field.value);\n                    }// try\n                     catch (NumberFormatException e) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        params.add(field.name);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"43\", params);\n                    }\n                    // catch\n                    if (field.length < field.value.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"42\", params);\n                    }\n                    // if (field.length < field.value.length())\n                    // Fill in trailing zeros if the value is too short\n                    for (int j = 0; j < field.length - field.value.length(); j++) {\n                        mInputParams.append(\"0\");\n                    }\n                    // for (int j = 0; j < field.length -\n                    // field.value.length()\n                    mInputParams.append(field.value);\n                } else // if (FORMAT_NUM.equals(field.format))\n                if (FORMAT_DATE.equals(field.format)) {\n                    if (field.value.length() != Constants.AS400_CALL_DATE_FORMAT.length()) {\n                        List params = new Vector();\n                        params.add(field.name);\n                        params.add(field.value);\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"45\", params);\n                    }\n                    mInputParams.append(field.value);\n                } else // then (FORMAT_DATE.equals(field.format))\n                {\n                    List params = new Vector();\n                    params.add(field.name);\n                    params.add(field.format);\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"46\", params);\n                }\n                // (FORMAT_DATE.equals(field.format))\n            }\n            // for (Iterator it = mInputFields.iterator(); it.hasNext();)\n        } else // if (callNumber==1)\n        if (callNumber == 2)\n            mInputParams.append(XStringSupport.getNumberString(1, mCountLength));\n        else {\n            mInputParams.delete(mInputParams.lastIndexOf(XStringSupport.getNumberString(callNumber - 2, mCountLength)), mInputParams.length());\n            mInputParams.append(XStringSupport.getNumberString(callNumber - 1, mCountLength));\n        }\n        parameters[0] = new ProgramParameter(mConverter.stringToByteArray(mInputParams.toString()));\n        /*\n\t\t * Filling the output parameters\n\t\t */\n        if (callNumber == 1) {\n            NodeList output = doc.getElementsByTagName(TAG_OUTPUT);\n            if (output.getLength() != 1) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"47\");\n            }\n            mOutputFields = getFields(output.item(0).getChildNodes());\n        }\n        if ((CALLTYPE_MULTI.equals(callType)) && callNumber == 1) {\n            Configuration config = Configuration.getInstance();\n            mCountLength = config.getValueAsInt(\"AS400Program\", function, \"CounterLength\");\n            parameters[1] = new ProgramParameter(mCountLength);\n        } else {\n            if (callNumber < 3) {\n                Field field = null;\n                for (Iterator it = mOutputFields.iterator(); it.hasNext(); ) {\n                    field = (Field) it.next();\n                    mOutputLength = mOutputLength + field.length;\n                }\n            }\n            parameters[1] = new ProgramParameter(mOutputLength);\n        }\n        return parameters;\n    }\n\n    /**\n     * Makes a list of fields out of the output parameters of the given\n     * parameter list.\n     */\n    private List makeOutputFields(AS400 as400, ProgramParameter[] parameters, int numRows) throws XException {\n        /*\n\t\t * Since the first parameter is an input parameter, the length of the\n\t\t * parameters array must be larger than numRows\n\t\t */\n        if (parameters.length <= numRows) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"66\");\n        }\n        Vector response = new Vector();\n        Vector row = null;\n        Field field = null;\n        int position = 0;\n        String data = null;\n        for (int i = 1; i <= numRows; i++) {\n            row = new Vector();\n            data = getParameterAsString(as400, parameters, i);\n            for (Iterator it = mOutputFields.iterator(); it.hasNext(); ) {\n                field = (Field) ((Field) it.next()).clone();\n                field.value = data.substring(position, position + field.length).trim();\n                if (FORMAT_NUM.equals(field.format)) {\n                    try {\n                        field.value = String.valueOf(Integer.parseInt(field.value));\n                    } catch (NumberFormatException e) {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n                    }\n                }\n                position = position + field.length;\n                row.add(field);\n            }\n            response.add(row);\n        }\n        return response;\n    }\n\n    /**\n     * Creates an <code>org.w3c.Document</code> out of the given list of\n     * output fields\n     */\n    private Document getResponseDocument(String function, List outputLists) throws XException {\n        Document response = getTemplateAsDocument();\n        Element newFunction = response.createElement(Constants.XBUSXMLMESSAGE_FUNCTION);\n        newFunction.appendChild(response.createTextNode(function));\n        NodeList children = response.getElementsByTagName(Constants.XBUSXMLMESSAGE_FUNCTION);\n        if (children.getLength() > 0) {\n            Node oldData = children.item(0);\n            Node father = oldData.getParentNode();\n            father.replaceChild(newFunction, oldData);\n        }\n        Element newData = response.createElement(Constants.XBUSXMLMESSAGE_DATA);\n        List fields = null;\n        Field field = null;\n        Element outputNode = null;\n        Element fieldNode = null;\n        for (Iterator it1 = outputLists.iterator(); it1.hasNext(); ) {\n            fields = (List) it1.next();\n            outputNode = response.createElement(TAG_OUTPUT);\n            newData.appendChild(outputNode);\n            outputNode.appendChild(response.createTextNode(\"\\n\"));\n            for (Iterator it2 = fields.iterator(); it2.hasNext(); ) {\n                field = (Field) it2.next();\n                fieldNode = response.createElement(TAG_FIELD);\n                outputNode.appendChild(fieldNode);\n                fieldNode.setAttribute(ATTRIBUTE_NAME, field.name);\n                fieldNode.setAttribute(ATTRIBUTE_VALUE, field.value);\n                fieldNode.setAttribute(ATTRIBUTE_FORMAT, field.format);\n                if (!FORMAT_DATE.equals(field.format)) {\n                    fieldNode.setAttribute(ATTRIBUTE_LENGTH, String.valueOf(field.length));\n                }\n                outputNode.appendChild(response.createTextNode(\"\\n\"));\n            }\n        }\n        children = response.getElementsByTagName(Constants.XBUSXMLMESSAGE_DATA);\n        if (children.getLength() > 0) {\n            Node oldData = children.item(0);\n            Node father = oldData.getParentNode();\n            father.replaceChild(newData, oldData);\n        }\n        return response;\n    }\n\n    /**\n     * Makes a list of fields for either input or output parameters.\n     */\n    private List getFields(NodeList nodes) throws XException {\n        Vector fields = new Vector();\n        Field field;\n        Node node, name, value, length, format;\n        NamedNodeMap attributes;\n        for (int i = 0; i < nodes.getLength(); i++) {\n            node = nodes.item(i);\n            if ((TAG_FIELD.equals(node.getNodeName())) && (node.getNodeType() == Node.ELEMENT_NODE)) {\n                field = new Field();\n                attributes = node.getAttributes();\n                name = attributes.getNamedItem(ATTRIBUTE_NAME);\n                if (name != null) {\n                    field.name = name.getNodeValue();\n                } else {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"50\");\n                }\n                value = attributes.getNamedItem(ATTRIBUTE_VALUE);\n                if (value != null) {\n                    field.value = value.getNodeValue();\n                } else {\n                    field.value = null;\n                }\n                format = attributes.getNamedItem(ATTRIBUTE_FORMAT);\n                if (format != null) {\n                    field.format = format.getNodeValue();\n                } else {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"51\");\n                }\n                if (FORMAT_DATE.equals(field.format)) {\n                    field.length = Constants.AS400_CALL_DATE_FORMAT.length();\n                } else {\n                    length = attributes.getNamedItem(ATTRIBUTE_LENGTH);\n                    if (length != null) {\n                        try {\n                            field.length = Integer.parseInt(length.getNodeValue());\n                        } catch (NumberFormatException e) {\n                            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n                        }\n                    } else {\n                        throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"53\");\n                    }\n                }\n                fields.add(field);\n            }\n        }\n        return fields;\n    }\n\n    /**\n     * Reads test data from a file, when there is no AS/400 available.\n     */\n    private String getTestData(String function) throws XException {\n        Trace.info(\"Entering AS400ProgramMessage.getTestData\");\n        String filename;\n        if (\"StockCheck\".equals(function)) {\n            filename = Constants.XBUS_ETC + \"AS400Test\" + Constants.FILE_SEPERATOR + \"StockCheck.xml\";\n        } else if (\"OrderCheck\".equals(function)) {\n            filename = Constants.XBUS_ETC + \"AS400Test\" + Constants.FILE_SEPERATOR + \"OrderCheck.xml\";\n        } else {\n            List params = new Vector();\n            params.add(function);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"54\", params);\n        }\n        String line;\n        StringBuffer testData = new StringBuffer();\n        try {\n            BufferedReader instream = new BufferedReader(new FileReader(new File(filename)));\n            while ((line = instream.readLine()) != null) {\n                testData.append(line);\n                testData.append(Constants.LINE_SEPERATOR);\n            }\n            instream.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n        }\n        Trace.info(\"Leaving  AS400ProgramMessage.getTestData\");\n        return testData.toString();\n    }\n\n    /**\n     * Acts as a container for the information of one field of either an input\n     * or an output parameter.\n     */\n    class Field implements Cloneable {\n\n        public String name = null;\n\n        public String value = null;\n\n        public int length = 0;\n\n        public String format = null;\n\n        public Object clone() {\n            Field field = new Field();\n            field.name = this.name;\n            field.value = this.value;\n            field.length = this.length;\n            field.format = this.format;\n            return field;\n        }\n    }\n\n    public String getType() {\n        return Constants.TYPE_OBJECT;\n    }\n\n    /**\n     * Returns a XML string containing an empty AS400ProgramMessage\n     */\n    static public String getTemplateAsString() throws XException {\n        StringBuffer retString = new StringBuffer();\n        retString.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"\");\n        retString.append(Constants.getXMLEncoding());\n        retString.append(\"\\\"?>\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<!DOCTYPE XBUS_Document SYSTEM \\\"output.dtd\\\">\");\n        // The hard-coded refernce to \"output.dtd\" is not correct because the\n        // interfaces were agreed to\n        // use their own specific DTD's (one for input, one for output).\n        // As long as the destination system does not check the validity of the\n        // output xml file against\n        // its DTD, the entry in the file is arbitrary. If it does, an error\n        // will be issued becasue the\n        // used DTD's contain the names of the fields.\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_FUNCTION).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"</\").append(Constants.XBUSXMLMESSAGE_CALL).append(\">\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"<\").append(Constants.XBUSXMLMESSAGE_DATA).append(\" />\");\n        retString.append(Constants.LINE_SEPERATOR);\n        retString.append(\"</\").append(Constants.XBUSXMLMESSAGE_DOCUMENT).append(\">\");\n        return retString.toString();\n    }\n\n    /**\n     * Returns a W3C document containing an empty AS400ProgramMessage\n     */\n    static public Document getTemplateAsDocument() throws XException {\n        return XMLHelper.parseXML(getTemplateAsString(), null, null);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400ProgramSenderTest2.java",
		"test_prompt": "// AS400ProgramSenderTest2.java\npackage net.sf.xbus.technical.as400;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport net.sf.xbus.technical.ObjectSender;\nimport net.sf.xbus.technical.Sender;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport com.ibm.as400.access.ProgramParameter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400ProgramSender}.\n* It contains ten unit test cases for the {@link AS400ProgramSender#getTemplateAsDocument()} method.\n*/\nclass AS400ProgramSenderTest2 {"
	},
	{
		"original_code": "// AS400Connection.java\npackage net.sf.xbus.technical.as400;\n\nimport java.beans.PropertyVetoException;\nimport java.util.Hashtable;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport com.ibm.as400.access.AS400;\n\n/**\n * <code>AS400Connection</code> manages connections to AS400 machines.\n * <p>\n *\n * It implements the <b>Singleton</b>-Design-Pattern: Named instances of\n * <code>AS400Connection</code> are created for every thread.\n * <p>\n *\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>AS400Connection</td>\n * <td><i>name</i></td>\n * <td>SystemName</td>\n * <td>System name or IP-address of the AS400</td>\n * </tr>\n * <tr>\n * <td>AS400Connection</td>\n * <td><i>name</i></td>\n * <td>User</td>\n * <td>User for accessing the AS400</td>\n * </tr>\n * <tr>\n * <td>AS400Connection</td>\n * <td><i>name</i></td>\n * <td>Password</td>\n * <td>Password for the user</td>\n * </tr>\n * </table>\n */\npublic class AS400Connection {\n\n    private static final String AS400CONNECTION = \"AS400Connection\";\n\n    private static final String SYSTEMNAME = \"SystemName\";\n\n    private static final String USER = \"User\";\n\n    private static final String PASSWORD = \"Password\";\n\n    private static final String TEST_SYSTEM = \"XBUS_TEST\";\n\n    private static Hashtable mAS400Connections = new Hashtable();\n\n    private static final Object classLock = AS400Connection.class;\n\n    private AS400 mSystem = null;\n\n    private boolean mIsTestSystem;\n\n    /**\n     * The constructor is private, instances of <code>AS400Connection</code>\n     * can only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * and the name of the connection as the key.\n     *\n     * @param name more than one AS400 can be connected, differenced by their\n     *            name\n     * @throws XException if something goes wrong\n     */\n    private AS400Connection(String name) throws XException {\n        Configuration config = Configuration.getInstance();\n        String systemName = config.getValue(AS400CONNECTION, name, SYSTEMNAME);\n        String user = config.getValue(AS400CONNECTION, name, USER);\n        String password = config.getValue(AS400CONNECTION, name, PASSWORD);\n        mIsTestSystem = TEST_SYSTEM.equals(systemName);\n        if (!mIsTestSystem) {\n            mSystem = new AS400(systemName, user, password);\n            try {\n                mSystem.setGuiAvailable(false);\n            } catch (PropertyVetoException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n            }\n        }\n        mAS400Connections.put(getKey(name), this);\n    }\n\n    /**\n     * Delivers an instance of <code>AS400Connection</code>.\n     * <p>\n     *\n     * If it is the first call with the given name for the actual thread, a new\n     * <code>AS400Connection</code>-object gets created. Subsequent calls\n     * with the given name in this thread will deliver the object, that has been\n     * created by the first call.\n     *\n     * @param name more than one AS400 can be connected, differenced by their\n     *            name\n     * @throws XException if any error occurs\n     */\n    public static AS400Connection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            AS400Connection as400Connection = (AS400Connection) mAS400Connections.get(getKey(name));\n            if (as400Connection == null) {\n                as400Connection = new AS400Connection(name);\n            }\n            return as400Connection;\n        }\n    }\n\n    /**\n     * Returns the <code>AS400</code> object for the connection.\n     *\n     * @return <code>AS400</code> object for the connection\n     */\n    public AS400 getSystem() {\n        return mSystem;\n    }\n\n    /**\n     * Helper method for writing testdrivers when no AS400 is available.\n     *\n     * @return <code>true</code> if this is not a real AS400\n     */\n    public boolean isTestSystem() {\n        return mIsTestSystem;\n    }\n\n    static private String getKey(String name) {\n        return new StringBuffer().append(Thread.currentThread().getName()).append(name).toString();\n    }\n\n    static public void clear() {\n        mAS400Connections.clear();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400ConnectionTest0.java",
		"test_prompt": "// AS400ConnectionTest0.java\npackage net.sf.xbus.technical.as400;\n\nimport java.beans.PropertyVetoException;\nimport java.util.Hashtable;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport com.ibm.as400.access.AS400;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400Connection}.\n* It contains ten unit test cases for the {@link AS400Connection#getInstance(String)} method.\n*/\nclass AS400ConnectionTest0 {"
	},
	{
		"original_code": "// AS400Connection.java\npackage net.sf.xbus.technical.as400;\n\nimport java.beans.PropertyVetoException;\nimport java.util.Hashtable;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport com.ibm.as400.access.AS400;\n\n/**\n * <code>AS400Connection</code> manages connections to AS400 machines.\n * <p>\n *\n * It implements the <b>Singleton</b>-Design-Pattern: Named instances of\n * <code>AS400Connection</code> are created for every thread.\n * <p>\n *\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>AS400Connection</td>\n * <td><i>name</i></td>\n * <td>SystemName</td>\n * <td>System name or IP-address of the AS400</td>\n * </tr>\n * <tr>\n * <td>AS400Connection</td>\n * <td><i>name</i></td>\n * <td>User</td>\n * <td>User for accessing the AS400</td>\n * </tr>\n * <tr>\n * <td>AS400Connection</td>\n * <td><i>name</i></td>\n * <td>Password</td>\n * <td>Password for the user</td>\n * </tr>\n * </table>\n */\npublic class AS400Connection {\n\n    private static final String AS400CONNECTION = \"AS400Connection\";\n\n    private static final String SYSTEMNAME = \"SystemName\";\n\n    private static final String USER = \"User\";\n\n    private static final String PASSWORD = \"Password\";\n\n    private static final String TEST_SYSTEM = \"XBUS_TEST\";\n\n    private static Hashtable mAS400Connections = new Hashtable();\n\n    private static final Object classLock = AS400Connection.class;\n\n    private AS400 mSystem = null;\n\n    private boolean mIsTestSystem;\n\n    /**\n     * The constructor is private, instances of <code>AS400Connection</code>\n     * can only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * and the name of the connection as the key.\n     *\n     * @param name more than one AS400 can be connected, differenced by their\n     *            name\n     * @throws XException if something goes wrong\n     */\n    private AS400Connection(String name) throws XException {\n        Configuration config = Configuration.getInstance();\n        String systemName = config.getValue(AS400CONNECTION, name, SYSTEMNAME);\n        String user = config.getValue(AS400CONNECTION, name, USER);\n        String password = config.getValue(AS400CONNECTION, name, PASSWORD);\n        mIsTestSystem = TEST_SYSTEM.equals(systemName);\n        if (!mIsTestSystem) {\n            mSystem = new AS400(systemName, user, password);\n            try {\n                mSystem.setGuiAvailable(false);\n            } catch (PropertyVetoException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_AS400, \"0\", e);\n            }\n        }\n        mAS400Connections.put(getKey(name), this);\n    }\n\n    /**\n     * Delivers an instance of <code>AS400Connection</code>.\n     * <p>\n     *\n     * If it is the first call with the given name for the actual thread, a new\n     * <code>AS400Connection</code>-object gets created. Subsequent calls\n     * with the given name in this thread will deliver the object, that has been\n     * created by the first call.\n     *\n     * @param name more than one AS400 can be connected, differenced by their\n     *            name\n     * @throws XException if any error occurs\n     */\n    public static AS400Connection getInstance(String name) throws XException {\n        synchronized (classLock) {\n            AS400Connection as400Connection = (AS400Connection) mAS400Connections.get(getKey(name));\n            if (as400Connection == null) {\n                as400Connection = new AS400Connection(name);\n            }\n            return as400Connection;\n        }\n    }\n\n    /**\n     * Returns the <code>AS400</code> object for the connection.\n     *\n     * @return <code>AS400</code> object for the connection\n     */\n    public AS400 getSystem() {\n        return mSystem;\n    }\n\n    /**\n     * Helper method for writing testdrivers when no AS400 is available.\n     *\n     * @return <code>true</code> if this is not a real AS400\n     */\n    public boolean isTestSystem() {\n        return mIsTestSystem;\n    }\n\n    static private String getKey(String name) {\n        return new StringBuffer().append(Thread.currentThread().getName()).append(name).toString();\n    }\n\n    static public void clear() {\n        mAS400Connections.clear();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/as400/AS400ConnectionTest1.java",
		"test_prompt": "// AS400ConnectionTest1.java\npackage net.sf.xbus.technical.as400;\n\nimport java.beans.PropertyVetoException;\nimport java.util.Hashtable;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport com.ibm.as400.access.AS400;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link AS400Connection}.\n* It contains ten unit test cases for the {@link AS400Connection#isTestSystem()} method.\n*/\nclass AS400ConnectionTest1 {"
	},
	{
		"original_code": "// MQSender.java\npackage net.sf.xbus.technical.mq;\n\nimport javax.jms.JMSException;\nimport javax.jms.QueueSender;\nimport javax.jms.TextMessage;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\n\n/**\n * The <code>MQSender</code> sends a message to a message-queue.\n */\npublic class MQSender implements Sender, TextSender {\n\n    private QueueSender mSender;\n\n    private MQConnection mMQConnection;\n\n    /**\n     * Opens the connection to the queue-manager. It uses the\n     * {@link net.sf.xbus.technical.mq.MQConnection}.\n     */\n    public MQSender(XBUSSystem destination) throws XException {\n        openConnection(destination);\n    }\n\n    /**\n     * Sends the <code>callData</code> to the message-queue.\n     * <code>function</code> is ignored.\n     *\n     * @return <code>null</code>\n     */\n    public String execute(String function, String callData) throws XException {\n        if (callData == null)\n            callData = \"\";\n        try {\n            mSender.setPriority(4);\n            TextMessage message = mMQConnection.createTextMessage();\n            message.setText(callData);\n            mSender.send(message);\n        } catch (JMSException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        }\n        return null;\n    }\n\n    private void openConnection(XBUSSystem destination) throws XException {\n        mMQConnection = MQConnection.getInstance();\n        mSender = mMQConnection.getSender(destination);\n    }\n\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/mq/MQSenderTest.java",
		"test_prompt": "// MQSenderTest.java\npackage net.sf.xbus.technical.mq;\n\nimport javax.jms.JMSException;\nimport javax.jms.QueueSender;\nimport javax.jms.TextMessage;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MQSender}.\n* It contains ten unit test cases for the {@link MQSender#execute(String, String)} method.\n*/\nclass MQSenderTest {"
	},
	{
		"original_code": "// MQConnection.java\npackage net.sf.xbus.technical.mq;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.jms.DeliveryMode;\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.Queue;\nimport javax.jms.QueueBrowser;\nimport javax.jms.QueueConnection;\nimport javax.jms.QueueConnectionFactory;\nimport javax.jms.QueueReceiver;\nimport javax.jms.QueueSender;\nimport javax.jms.QueueSession;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * <code>MQConnection</code> manages connections and sessions for messagequeues.\n * <p>\n *\n * It implements two Design-Patterns:\n * <ol>\n * <li><b>Singleton: </b> An instance of <code>MQConnection</code> is created\n * for every thread. This instance can be fetched with\n * <code>getInstance()</code>.</li>\n * <li><b>Facade: </b> The complexity of creating and managing a connection is\n * capsuled.</li>\n * </ol>\n */\npublic class MQConnection implements TAResource {\n\n    private static Hashtable mMQConnections = new Hashtable();\n\n    private static final Object classLock = MQConnection.class;\n\n    private QueueConnectionFactory mQueueConnectionFactory = null;\n\n    private Context jndiContext = null;\n\n    private String mQueueSuffix = null;\n\n    private QueueSession mSession = null;\n\n    private QueueConnection mConnection = null;\n\n    private Hashtable mReceivers = new Hashtable();\n\n    private Hashtable mBrowsers = new Hashtable();\n\n    private Hashtable mSenders = new Hashtable();\n\n    private Hashtable mQueues = new Hashtable();\n\n    private boolean mIsOpen = false;\n\n    private XBUSSystem mDeleteQueue = null;\n\n    private String mDeleteMessageId = null;\n\n    /**\n     * The constructor is private, instances of <code>MQConnection</code> can\n     * only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * as the key.\n     */\n    private MQConnection() throws XException {\n        Configuration config = Configuration.getInstance();\n        mQueueSuffix = config.getValueOptional(\"Connection\", \"MQ\", \"QueueSuffix\");\n        if (mQueueSuffix == null) {\n            mQueueSuffix = \"\";\n        }\n        open();\n        TAManager taManager = TAManager.getInstance();\n        taManager.registerResource(this);\n        mMQConnections.put(Thread.currentThread().getName(), this);\n    }\n\n    /**\n     * Opens the JMS-QueueSession and JMS-QueueConnection for sending and\n     * receiving messages.\n     */\n    public void open() throws XException {\n        if (!mIsOpen) {\n            jndiContext = null;\n            if (mQueueConnectionFactory == null) {\n                Configuration config = Configuration.getInstance();\n                mQueueConnectionFactory = (QueueConnectionFactory) jndiLookup(config.getValue(\"Connection\", \"MQ\", \"QueueConnectionFactory\"));\n            }\n            try {\n                mConnection = mQueueConnectionFactory.createQueueConnection();\n                mSession = mConnection.createQueueSession(true, Session.AUTO_ACKNOWLEDGE);\n                mConnection.start();\n            } catch (JMSException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n            }\n            mIsOpen = true;\n        }\n    }\n\n    /**\n     * Delivers an instance of <code>MQConnection</code>.\n     * <p>\n     *\n     * If it is the first call for the actual thread, a new\n     * <code>MQConnection</code> -object gets created. Subsequent calls in this\n     * thread will deliver the object, that has been created by the first call.\n     */\n    public static MQConnection getInstance() throws XException {\n        synchronized (classLock) {\n            MQConnection mqConnection = (MQConnection) mMQConnections.get(Thread.currentThread().getName());\n            if (mqConnection == null) {\n                mqConnection = new MQConnection();\n            }\n            return mqConnection;\n        }\n    }\n\n    /**\n     * Commits all actions on the queues associated with this\n     * <code>MQConnection</code> (normally all queues of the current thread).\n     */\n    public void commit() throws XException {\n        try {\n            mSession.commit();\n        } catch (JMSException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        } finally {\n            mDeleteMessageId = null;\n            mDeleteQueue = null;\n        }\n    }\n\n    /**\n     * Performs a rollback for all actions on the queues associated with this\n     * <code>MQConnection</code> (normally all queues of the current thread).\n     */\n    public void rollback() throws XException {\n        if (mIsOpen) {\n            try {\n                mSession.rollback();\n                if (mDeleteQueue != null) {\n                    /*\n\t\t\t\t\t * The first queue entry shall be deleted after writing it\n\t\t\t\t\t * to the DeletedMessageStore, because the OnError\n\t\t\t\t\t * resolution is Delete\n\t\t\t\t\t */\n                    QueueReceiver receiver = getReceiver(mDeleteQueue);\n                    Message message = receiver.receiveNoWait();\n                    if (message.getJMSMessageID().equals(mDeleteMessageId) && DeletedMessageStore.getInstance().writeMessage()) {\n                        mSession.commit();\n                    } else {\n                        mSession.rollback();\n                    }\n                }\n            } catch (JMSException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n            } finally {\n                mDeleteMessageId = null;\n                mDeleteQueue = null;\n            }\n        }\n    }\n\n    /**\n     * Closes the connection.\n     */\n    public void close() throws XException {\n        try {\n            QueueReceiver receiver;\n            for (Enumeration e = mReceivers.elements(); e.hasMoreElements(); ) {\n                receiver = (QueueReceiver) e.nextElement();\n                receiver.close();\n            }\n            mReceivers.clear();\n            QueueSender sender;\n            for (Enumeration e = mSenders.elements(); e.hasMoreElements(); ) {\n                sender = (QueueSender) e.nextElement();\n                sender.close();\n            }\n            mSenders.clear();\n            QueueBrowser browser;\n            for (Enumeration e = mBrowsers.elements(); e.hasMoreElements(); ) {\n                browser = (QueueBrowser) e.nextElement();\n                browser.close();\n            }\n            mBrowsers.clear();\n            mSession.close();\n            mConnection.close();\n            mIsOpen = false;\n            jndiContext = null;\n        } catch (JMSException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        }\n    }\n\n    /**\n     * Initializes the MQConnection.\n     */\n    public void initialize() {\n        mIsOpen = false;\n        mReceivers.clear();\n    }\n\n    /**\n     * Creates and returns a JMS- <code>QueueSender</code> for the given queue.\n     */\n    public QueueSender getSender(XBUSSystem system) throws XException {\n        QueueSender sender = null;\n        String pyhsQueuename = getPhysQueuename(system);\n        Queue queue = getQueue(pyhsQueuename);\n        try {\n            if ((sender = (QueueSender) mSenders.get(pyhsQueuename)) == null) {\n                sender = mSession.createSender(queue);\n                sender.setDeliveryMode(DeliveryMode.PERSISTENT);\n                mSenders.put(pyhsQueuename, sender);\n            }\n        } catch (JMSException e) {\n            Trace.warn(\"Connection may be gone, trying MQConnection.getSender again ...\");\n            mIsOpen = false;\n            open();\n            try {\n                if ((sender = (QueueSender) mSenders.get(pyhsQueuename)) == null) {\n                    sender = mSession.createSender(queue);\n                    sender.setDeliveryMode(DeliveryMode.PERSISTENT);\n                    mSenders.put(pyhsQueuename, sender);\n                }\n            } catch (JMSException exc) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", exc);\n            }\n        }\n        return sender;\n    }\n\n    /**\n     * Creates and returns a JMS- <code>QueueReceiver</code> for the given\n     * queue.\n     *\n     * @param system\n     *            name of an interface\n     *\n     * @return JMS QueueReceiver\n     */\n    public QueueReceiver getReceiver(XBUSSystem system) throws XException {\n        QueueReceiver receiver = null;\n        String pyhsQueuename = getPhysQueuename(system);\n        Queue queue = getQueue(pyhsQueuename);\n        try {\n            if ((receiver = (QueueReceiver) mReceivers.get(pyhsQueuename)) == null) {\n                receiver = mSession.createReceiver(queue);\n                mReceivers.put(pyhsQueuename, receiver);\n            }\n        } catch (JMSException e) {\n            Trace.warn(\"Connection may be gone, trying MQConnection.getReceiver again ...\");\n            mIsOpen = false;\n            open();\n            try {\n                if ((receiver = (QueueReceiver) mReceivers.get(pyhsQueuename)) == null) {\n                    receiver = mSession.createReceiver(queue);\n                    mReceivers.put(pyhsQueuename, receiver);\n                }\n            } catch (JMSException exc) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", exc);\n            }\n        }\n        return receiver;\n    }\n\n    /**\n     * Creates and returns a JMS- <code>QueueBrowser</code> for the given queue.\n     */\n    public QueueBrowser getBrowser(XBUSSystem system) throws XException {\n        QueueBrowser browser = null;\n        String pyhsQueuename = getPhysQueuename(system);\n        Queue queue = getQueue(pyhsQueuename);\n        try {\n            if ((browser = (QueueBrowser) mBrowsers.get(pyhsQueuename)) == null) {\n                browser = mSession.createBrowser(queue);\n                mBrowsers.put(pyhsQueuename, browser);\n            }\n        } catch (JMSException e) {\n            Trace.warn(\"Connection may be gone, trying MQConnection.getBrowser again ...\");\n            mIsOpen = false;\n            open();\n            try {\n                if ((browser = (QueueBrowser) mBrowsers.get(pyhsQueuename)) == null) {\n                    browser = mSession.createBrowser(queue);\n                    mBrowsers.put(pyhsQueuename, browser);\n                }\n            } catch (JMSException exc) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", exc);\n            }\n        }\n        return browser;\n    }\n\n    /**\n     * Creates and returns a JMS- <code>TextMessage</code>.\n     */\n    public TextMessage createTextMessage() throws XException {\n        TextMessage message = null;\n        try {\n            message = mSession.createTextMessage();\n            message.setJMSDeliveryMode(DeliveryMode.PERSISTENT);\n        } catch (JMSException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        }\n        return message;\n    }\n\n    protected void setDeleteInformation(XBUSSystem source, String messageId) {\n        mDeleteQueue = source;\n        mDeleteMessageId = messageId;\n    }\n\n    static public void clear() {\n        mMQConnections.clear();\n    }\n\n    /**\n     * Creates a JNDI InitialContext object if none exists yet. Then looks up\n     * the string argument and returns the associated object.\n     *\n     * @param name\n     *            the name of the object to be looked up\n     *\n     * @return the object bound to <code>name</code>\n     * @throws net.sf.xbus.base.core.XException\n     */\n    private Object jndiLookup(String name) throws XException {\n        Object obj = null;\n        if (jndiContext == null) {\n            jndiContext = createContext();\n        }\n        try {\n            obj = jndiContext.lookup(name);\n        } catch (NamingException e) {\n            Trace.warn(\"Connection maybe gone, trying MQConnection.jndiContext again...\");\n            try {\n                jndiContext = createContext();\n                obj = jndiContext.lookup(name);\n            } catch (NamingException exc) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n            }\n        }\n        return obj;\n    }\n\n    /**\n     * Reads the name of the message queue from the configuration.\n     *\n     * @param system\n     *            the name of the sender/receiver\n     *\n     * @return the name of the message queue\n     */\n    public String getPhysQueuename(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        String physQueuename = config.getValue(Constants.CHAPTER_SYSTEM, system.getName(), \"Queuename\");\n        physQueuename = system.replaceAllMarkers(physQueuename)[0];\n        return new StringBuffer(physQueuename).append(mQueueSuffix).toString();\n    }\n\n    private Context createContext() throws XException {\n        try {\n            Hashtable env = new Hashtable();\n            Configuration config = Configuration.getInstance();\n            String factory = config.getValue(\"Connection\", \"MQ\", \"ContextFactory\");\n            env.put(Context.INITIAL_CONTEXT_FACTORY, factory);\n            String url = config.getValueOptional(\"Connection\", \"MQ\", \"URL\");\n            if (url != null) {\n                env.put(Context.PROVIDER_URL, url);\n            }\n            String user = config.getValueOptional(\"Connection\", \"MQ\", \"User\");\n            if (user != null) {\n                env.put(Context.SECURITY_PRINCIPAL, user);\n            }\n            String password = config.getValueOptional(\"Connection\", \"MQ\", \"Password\");\n            if (password != null) {\n                env.put(Context.SECURITY_CREDENTIALS, password);\n            }\n            String referral = config.getValueOptional(\"Connection\", \"MQ\", \"Referral\");\n            if (referral != null) {\n                env.put(Context.REFERRAL, referral);\n            }\n            String authorative = config.getValueOptional(\"Connection\", \"MQ\", \"Authorative\");\n            if (authorative != null) {\n                env.put(Context.AUTHORITATIVE, authorative);\n            }\n            String batchSize = config.getValueOptional(\"Connection\", \"MQ\", \"BatchSize\");\n            if (batchSize != null) {\n                env.put(Context.BATCHSIZE, batchSize);\n            }\n            String language = config.getValueOptional(\"Connection\", \"MQ\", \"Language\");\n            if (language != null) {\n                env.put(Context.LANGUAGE, language);\n            }\n            String dnsUrl = config.getValueOptional(\"Connection\", \"MQ\", \"DNS_URL\");\n            if (dnsUrl != null) {\n                env.put(Context.DNS_URL, dnsUrl);\n            }\n            String objectFactories = config.getValueOptional(\"Connection\", \"MQ\", \"ObjectFactories\");\n            if (objectFactories != null) {\n                env.put(Context.OBJECT_FACTORIES, objectFactories);\n            }\n            String securityProtocol = config.getValueOptional(\"Connection\", \"MQ\", \"SecurityProtocol\");\n            if (securityProtocol != null) {\n                env.put(Context.SECURITY_PROTOCOL, securityProtocol);\n            }\n            String securityAuthentication = config.getValueOptional(\"Connection\", \"MQ\", \"SecurityAuthentication\");\n            if (securityAuthentication != null) {\n                env.put(Context.SECURITY_AUTHENTICATION, securityAuthentication);\n            }\n            String stateFactories = config.getValueOptional(\"Connection\", \"MQ\", \"StateFactories\");\n            if (stateFactories != null) {\n                env.put(Context.STATE_FACTORIES, stateFactories);\n            }\n            String urlPkgPrefixes = config.getValueOptional(\"Connection\", \"MQ\", \"URLPkgPrefixes\");\n            if (urlPkgPrefixes != null) {\n                env.put(Context.URL_PKG_PREFIXES, urlPkgPrefixes);\n            }\n            String port = config.getValueOptional(\"Connection\", \"MQ\", \"Port\");\n            if (port != null) {\n                env.put(\"javax.naming.factory.port\", port);\n            }\n            String host = config.getValueOptional(\"Connection\", \"MQ\", \"Host\");\n            if (host != null) {\n                env.put(\"javax.naming.factory.host\", host);\n            }\n            return new InitialContext(env);\n        } catch (NamingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        }\n    }\n\n    private Queue getQueue(String physQueuename) throws XException {\n        Queue queue = (Queue) mQueues.get(physQueuename);\n        if (queue == null) {\n            try {\n                if (Configuration.getInstance().getValue(\"Connection\", \"MQ\", \"ContextFactory\").contains(\"activemq\")) {\n                    /*\n\t\t\t\t\t * Workaround for ActiveMQ dynamic queues\n\t\t\t\t\t */\n                    queue = (Queue) jndiLookup(\"dynamicQueues/\" + physQueuename);\n                } else {\n                    queue = (Queue) jndiLookup(physQueuename);\n                }\n            } catch (XException e1) {\n                try {\n                    Trace.error(\"Creating queue \" + physQueuename);\n                    queue = mSession.createQueue(physQueuename);\n                    mQueues.put(physQueuename, queue);\n                } catch (JMSException e2) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e2);\n                }\n            }\n        }\n        return queue;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/mq/MQConnectionTest0.java",
		"test_prompt": "// MQConnectionTest0.java\npackage net.sf.xbus.technical.mq;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.jms.DeliveryMode;\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.Queue;\nimport javax.jms.QueueBrowser;\nimport javax.jms.QueueConnection;\nimport javax.jms.QueueConnectionFactory;\nimport javax.jms.QueueReceiver;\nimport javax.jms.QueueSender;\nimport javax.jms.QueueSession;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MQConnection}.\n* It contains ten unit test cases for the {@link MQConnection#getInstance()} method.\n*/\nclass MQConnectionTest0 {"
	},
	{
		"original_code": "// MQConnection.java\npackage net.sf.xbus.technical.mq;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.jms.DeliveryMode;\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.Queue;\nimport javax.jms.QueueBrowser;\nimport javax.jms.QueueConnection;\nimport javax.jms.QueueConnectionFactory;\nimport javax.jms.QueueReceiver;\nimport javax.jms.QueueSender;\nimport javax.jms.QueueSession;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\n\n/**\n * <code>MQConnection</code> manages connections and sessions for messagequeues.\n * <p>\n *\n * It implements two Design-Patterns:\n * <ol>\n * <li><b>Singleton: </b> An instance of <code>MQConnection</code> is created\n * for every thread. This instance can be fetched with\n * <code>getInstance()</code>.</li>\n * <li><b>Facade: </b> The complexity of creating and managing a connection is\n * capsuled.</li>\n * </ol>\n */\npublic class MQConnection implements TAResource {\n\n    private static Hashtable mMQConnections = new Hashtable();\n\n    private static final Object classLock = MQConnection.class;\n\n    private QueueConnectionFactory mQueueConnectionFactory = null;\n\n    private Context jndiContext = null;\n\n    private String mQueueSuffix = null;\n\n    private QueueSession mSession = null;\n\n    private QueueConnection mConnection = null;\n\n    private Hashtable mReceivers = new Hashtable();\n\n    private Hashtable mBrowsers = new Hashtable();\n\n    private Hashtable mSenders = new Hashtable();\n\n    private Hashtable mQueues = new Hashtable();\n\n    private boolean mIsOpen = false;\n\n    private XBUSSystem mDeleteQueue = null;\n\n    private String mDeleteMessageId = null;\n\n    /**\n     * The constructor is private, instances of <code>MQConnection</code> can\n     * only be generated via the method <code>getInstance()</code>. Each\n     * instance is put in a <code>Hashtable</code> with the name of the thread\n     * as the key.\n     */\n    private MQConnection() throws XException {\n        Configuration config = Configuration.getInstance();\n        mQueueSuffix = config.getValueOptional(\"Connection\", \"MQ\", \"QueueSuffix\");\n        if (mQueueSuffix == null) {\n            mQueueSuffix = \"\";\n        }\n        open();\n        TAManager taManager = TAManager.getInstance();\n        taManager.registerResource(this);\n        mMQConnections.put(Thread.currentThread().getName(), this);\n    }\n\n    /**\n     * Opens the JMS-QueueSession and JMS-QueueConnection for sending and\n     * receiving messages.\n     */\n    public void open() throws XException {\n        if (!mIsOpen) {\n            jndiContext = null;\n            if (mQueueConnectionFactory == null) {\n                Configuration config = Configuration.getInstance();\n                mQueueConnectionFactory = (QueueConnectionFactory) jndiLookup(config.getValue(\"Connection\", \"MQ\", \"QueueConnectionFactory\"));\n            }\n            try {\n                mConnection = mQueueConnectionFactory.createQueueConnection();\n                mSession = mConnection.createQueueSession(true, Session.AUTO_ACKNOWLEDGE);\n                mConnection.start();\n            } catch (JMSException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n            }\n            mIsOpen = true;\n        }\n    }\n\n    /**\n     * Delivers an instance of <code>MQConnection</code>.\n     * <p>\n     *\n     * If it is the first call for the actual thread, a new\n     * <code>MQConnection</code> -object gets created. Subsequent calls in this\n     * thread will deliver the object, that has been created by the first call.\n     */\n    public static MQConnection getInstance() throws XException {\n        synchronized (classLock) {\n            MQConnection mqConnection = (MQConnection) mMQConnections.get(Thread.currentThread().getName());\n            if (mqConnection == null) {\n                mqConnection = new MQConnection();\n            }\n            return mqConnection;\n        }\n    }\n\n    /**\n     * Commits all actions on the queues associated with this\n     * <code>MQConnection</code> (normally all queues of the current thread).\n     */\n    public void commit() throws XException {\n        try {\n            mSession.commit();\n        } catch (JMSException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        } finally {\n            mDeleteMessageId = null;\n            mDeleteQueue = null;\n        }\n    }\n\n    /**\n     * Performs a rollback for all actions on the queues associated with this\n     * <code>MQConnection</code> (normally all queues of the current thread).\n     */\n    public void rollback() throws XException {\n        if (mIsOpen) {\n            try {\n                mSession.rollback();\n                if (mDeleteQueue != null) {\n                    /*\n\t\t\t\t\t * The first queue entry shall be deleted after writing it\n\t\t\t\t\t * to the DeletedMessageStore, because the OnError\n\t\t\t\t\t * resolution is Delete\n\t\t\t\t\t */\n                    QueueReceiver receiver = getReceiver(mDeleteQueue);\n                    Message message = receiver.receiveNoWait();\n                    if (message.getJMSMessageID().equals(mDeleteMessageId) && DeletedMessageStore.getInstance().writeMessage()) {\n                        mSession.commit();\n                    } else {\n                        mSession.rollback();\n                    }\n                }\n            } catch (JMSException e) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n            } finally {\n                mDeleteMessageId = null;\n                mDeleteQueue = null;\n            }\n        }\n    }\n\n    /**\n     * Closes the connection.\n     */\n    public void close() throws XException {\n        try {\n            QueueReceiver receiver;\n            for (Enumeration e = mReceivers.elements(); e.hasMoreElements(); ) {\n                receiver = (QueueReceiver) e.nextElement();\n                receiver.close();\n            }\n            mReceivers.clear();\n            QueueSender sender;\n            for (Enumeration e = mSenders.elements(); e.hasMoreElements(); ) {\n                sender = (QueueSender) e.nextElement();\n                sender.close();\n            }\n            mSenders.clear();\n            QueueBrowser browser;\n            for (Enumeration e = mBrowsers.elements(); e.hasMoreElements(); ) {\n                browser = (QueueBrowser) e.nextElement();\n                browser.close();\n            }\n            mBrowsers.clear();\n            mSession.close();\n            mConnection.close();\n            mIsOpen = false;\n            jndiContext = null;\n        } catch (JMSException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        }\n    }\n\n    /**\n     * Initializes the MQConnection.\n     */\n    public void initialize() {\n        mIsOpen = false;\n        mReceivers.clear();\n    }\n\n    /**\n     * Creates and returns a JMS- <code>QueueSender</code> for the given queue.\n     */\n    public QueueSender getSender(XBUSSystem system) throws XException {\n        QueueSender sender = null;\n        String pyhsQueuename = getPhysQueuename(system);\n        Queue queue = getQueue(pyhsQueuename);\n        try {\n            if ((sender = (QueueSender) mSenders.get(pyhsQueuename)) == null) {\n                sender = mSession.createSender(queue);\n                sender.setDeliveryMode(DeliveryMode.PERSISTENT);\n                mSenders.put(pyhsQueuename, sender);\n            }\n        } catch (JMSException e) {\n            Trace.warn(\"Connection may be gone, trying MQConnection.getSender again ...\");\n            mIsOpen = false;\n            open();\n            try {\n                if ((sender = (QueueSender) mSenders.get(pyhsQueuename)) == null) {\n                    sender = mSession.createSender(queue);\n                    sender.setDeliveryMode(DeliveryMode.PERSISTENT);\n                    mSenders.put(pyhsQueuename, sender);\n                }\n            } catch (JMSException exc) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", exc);\n            }\n        }\n        return sender;\n    }\n\n    /**\n     * Creates and returns a JMS- <code>QueueReceiver</code> for the given\n     * queue.\n     *\n     * @param system\n     *            name of an interface\n     *\n     * @return JMS QueueReceiver\n     */\n    public QueueReceiver getReceiver(XBUSSystem system) throws XException {\n        QueueReceiver receiver = null;\n        String pyhsQueuename = getPhysQueuename(system);\n        Queue queue = getQueue(pyhsQueuename);\n        try {\n            if ((receiver = (QueueReceiver) mReceivers.get(pyhsQueuename)) == null) {\n                receiver = mSession.createReceiver(queue);\n                mReceivers.put(pyhsQueuename, receiver);\n            }\n        } catch (JMSException e) {\n            Trace.warn(\"Connection may be gone, trying MQConnection.getReceiver again ...\");\n            mIsOpen = false;\n            open();\n            try {\n                if ((receiver = (QueueReceiver) mReceivers.get(pyhsQueuename)) == null) {\n                    receiver = mSession.createReceiver(queue);\n                    mReceivers.put(pyhsQueuename, receiver);\n                }\n            } catch (JMSException exc) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", exc);\n            }\n        }\n        return receiver;\n    }\n\n    /**\n     * Creates and returns a JMS- <code>QueueBrowser</code> for the given queue.\n     */\n    public QueueBrowser getBrowser(XBUSSystem system) throws XException {\n        QueueBrowser browser = null;\n        String pyhsQueuename = getPhysQueuename(system);\n        Queue queue = getQueue(pyhsQueuename);\n        try {\n            if ((browser = (QueueBrowser) mBrowsers.get(pyhsQueuename)) == null) {\n                browser = mSession.createBrowser(queue);\n                mBrowsers.put(pyhsQueuename, browser);\n            }\n        } catch (JMSException e) {\n            Trace.warn(\"Connection may be gone, trying MQConnection.getBrowser again ...\");\n            mIsOpen = false;\n            open();\n            try {\n                if ((browser = (QueueBrowser) mBrowsers.get(pyhsQueuename)) == null) {\n                    browser = mSession.createBrowser(queue);\n                    mBrowsers.put(pyhsQueuename, browser);\n                }\n            } catch (JMSException exc) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", exc);\n            }\n        }\n        return browser;\n    }\n\n    /**\n     * Creates and returns a JMS- <code>TextMessage</code>.\n     */\n    public TextMessage createTextMessage() throws XException {\n        TextMessage message = null;\n        try {\n            message = mSession.createTextMessage();\n            message.setJMSDeliveryMode(DeliveryMode.PERSISTENT);\n        } catch (JMSException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        }\n        return message;\n    }\n\n    protected void setDeleteInformation(XBUSSystem source, String messageId) {\n        mDeleteQueue = source;\n        mDeleteMessageId = messageId;\n    }\n\n    static public void clear() {\n        mMQConnections.clear();\n    }\n\n    /**\n     * Creates a JNDI InitialContext object if none exists yet. Then looks up\n     * the string argument and returns the associated object.\n     *\n     * @param name\n     *            the name of the object to be looked up\n     *\n     * @return the object bound to <code>name</code>\n     * @throws net.sf.xbus.base.core.XException\n     */\n    private Object jndiLookup(String name) throws XException {\n        Object obj = null;\n        if (jndiContext == null) {\n            jndiContext = createContext();\n        }\n        try {\n            obj = jndiContext.lookup(name);\n        } catch (NamingException e) {\n            Trace.warn(\"Connection maybe gone, trying MQConnection.jndiContext again...\");\n            try {\n                jndiContext = createContext();\n                obj = jndiContext.lookup(name);\n            } catch (NamingException exc) {\n                throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n            }\n        }\n        return obj;\n    }\n\n    /**\n     * Reads the name of the message queue from the configuration.\n     *\n     * @param system\n     *            the name of the sender/receiver\n     *\n     * @return the name of the message queue\n     */\n    public String getPhysQueuename(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        String physQueuename = config.getValue(Constants.CHAPTER_SYSTEM, system.getName(), \"Queuename\");\n        physQueuename = system.replaceAllMarkers(physQueuename)[0];\n        return new StringBuffer(physQueuename).append(mQueueSuffix).toString();\n    }\n\n    private Context createContext() throws XException {\n        try {\n            Hashtable env = new Hashtable();\n            Configuration config = Configuration.getInstance();\n            String factory = config.getValue(\"Connection\", \"MQ\", \"ContextFactory\");\n            env.put(Context.INITIAL_CONTEXT_FACTORY, factory);\n            String url = config.getValueOptional(\"Connection\", \"MQ\", \"URL\");\n            if (url != null) {\n                env.put(Context.PROVIDER_URL, url);\n            }\n            String user = config.getValueOptional(\"Connection\", \"MQ\", \"User\");\n            if (user != null) {\n                env.put(Context.SECURITY_PRINCIPAL, user);\n            }\n            String password = config.getValueOptional(\"Connection\", \"MQ\", \"Password\");\n            if (password != null) {\n                env.put(Context.SECURITY_CREDENTIALS, password);\n            }\n            String referral = config.getValueOptional(\"Connection\", \"MQ\", \"Referral\");\n            if (referral != null) {\n                env.put(Context.REFERRAL, referral);\n            }\n            String authorative = config.getValueOptional(\"Connection\", \"MQ\", \"Authorative\");\n            if (authorative != null) {\n                env.put(Context.AUTHORITATIVE, authorative);\n            }\n            String batchSize = config.getValueOptional(\"Connection\", \"MQ\", \"BatchSize\");\n            if (batchSize != null) {\n                env.put(Context.BATCHSIZE, batchSize);\n            }\n            String language = config.getValueOptional(\"Connection\", \"MQ\", \"Language\");\n            if (language != null) {\n                env.put(Context.LANGUAGE, language);\n            }\n            String dnsUrl = config.getValueOptional(\"Connection\", \"MQ\", \"DNS_URL\");\n            if (dnsUrl != null) {\n                env.put(Context.DNS_URL, dnsUrl);\n            }\n            String objectFactories = config.getValueOptional(\"Connection\", \"MQ\", \"ObjectFactories\");\n            if (objectFactories != null) {\n                env.put(Context.OBJECT_FACTORIES, objectFactories);\n            }\n            String securityProtocol = config.getValueOptional(\"Connection\", \"MQ\", \"SecurityProtocol\");\n            if (securityProtocol != null) {\n                env.put(Context.SECURITY_PROTOCOL, securityProtocol);\n            }\n            String securityAuthentication = config.getValueOptional(\"Connection\", \"MQ\", \"SecurityAuthentication\");\n            if (securityAuthentication != null) {\n                env.put(Context.SECURITY_AUTHENTICATION, securityAuthentication);\n            }\n            String stateFactories = config.getValueOptional(\"Connection\", \"MQ\", \"StateFactories\");\n            if (stateFactories != null) {\n                env.put(Context.STATE_FACTORIES, stateFactories);\n            }\n            String urlPkgPrefixes = config.getValueOptional(\"Connection\", \"MQ\", \"URLPkgPrefixes\");\n            if (urlPkgPrefixes != null) {\n                env.put(Context.URL_PKG_PREFIXES, urlPkgPrefixes);\n            }\n            String port = config.getValueOptional(\"Connection\", \"MQ\", \"Port\");\n            if (port != null) {\n                env.put(\"javax.naming.factory.port\", port);\n            }\n            String host = config.getValueOptional(\"Connection\", \"MQ\", \"Host\");\n            if (host != null) {\n                env.put(\"javax.naming.factory.host\", host);\n            }\n            return new InitialContext(env);\n        } catch (NamingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e);\n        }\n    }\n\n    private Queue getQueue(String physQueuename) throws XException {\n        Queue queue = (Queue) mQueues.get(physQueuename);\n        if (queue == null) {\n            try {\n                if (Configuration.getInstance().getValue(\"Connection\", \"MQ\", \"ContextFactory\").contains(\"activemq\")) {\n                    /*\n\t\t\t\t\t * Workaround for ActiveMQ dynamic queues\n\t\t\t\t\t */\n                    queue = (Queue) jndiLookup(\"dynamicQueues/\" + physQueuename);\n                } else {\n                    queue = (Queue) jndiLookup(physQueuename);\n                }\n            } catch (XException e1) {\n                try {\n                    Trace.error(\"Creating queue \" + physQueuename);\n                    queue = mSession.createQueue(physQueuename);\n                    mQueues.put(physQueuename, queue);\n                } catch (JMSException e2) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_MQ, \"0\", e2);\n                }\n            }\n        }\n        return queue;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/mq/MQConnectionTest1.java",
		"test_prompt": "// MQConnectionTest1.java\npackage net.sf.xbus.technical.mq;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.jms.DeliveryMode;\nimport javax.jms.JMSException;\nimport javax.jms.Message;\nimport javax.jms.Queue;\nimport javax.jms.QueueBrowser;\nimport javax.jms.QueueConnection;\nimport javax.jms.QueueConnectionFactory;\nimport javax.jms.QueueReceiver;\nimport javax.jms.QueueSender;\nimport javax.jms.QueueSession;\nimport javax.jms.Session;\nimport javax.jms.TextMessage;\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.TAResource;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.deletedMessageStore.DeletedMessageStore;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MQConnection}.\n* It contains ten unit test cases for the {@link MQConnection#createTextMessage()} method.\n*/\nclass MQConnectionTest1 {"
	},
	{
		"original_code": "// SocketSender.java\npackage net.sf.xbus.technical.socket;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\n\n/**\n * The <code>SocketSender</code> sends a message to a socket. No response is\n * given back.\n */\npublic class SocketSender implements Sender, TextSender {\n\n    XBUSSystem mDestination = null;\n\n    String mHost = null;\n\n    int mPort;\n\n    /**\n     * The constructor stores the destination.\n     *\n     * @param destination name of the interface definition\n     */\n    public SocketSender(XBUSSystem destination) {\n        mDestination = destination;\n    }\n\n    /**\n     * @see net.sf.xbus.technical.TextSender#execute(java.lang.String,\n     *      java.lang.String)\n     *\n     * @param function ignored\n     */\n    public String execute(String function, String callData) throws XException {\n        Socket outSocket = null;\n        PrintWriter out = null;\n        if (callData == null)\n            callData = \"\";\n        try {\n            Configuration config = Configuration.getInstance();\n            mHost = config.getValue(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Host\");\n            mPort = config.getValueAsInt(Constants.CHAPTER_SYSTEM, mDestination.getName(), \"Port\");\n            outSocket = new Socket(mHost, mPort);\n            out = new PrintWriter(outSocket.getOutputStream(), true);\n            out.print(callData);\n            out.close();\n            outSocket.close();\n        } catch (UnknownHostException e) {\n            List params = new Vector(2);\n            params.add(mHost);\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_SOCKET, \"1\", e, params);\n        } catch (IOException e) {\n            List params = new Vector(2);\n            params.add(mHost);\n            params.add(String.valueOf(mPort));\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_TECHNICAL, Constants.PACKAGE_TECHNICAL_SOCKET, \"2\", e, params);\n        }\n        return null;\n    }\n\n    public String getType() {\n        return Constants.TYPE_TEXT;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/technical/socket/SocketSenderTest.java",
		"test_prompt": "// SocketSenderTest.java\npackage net.sf.xbus.technical.socket;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.technical.Sender;\nimport net.sf.xbus.technical.TextSender;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SocketSender}.\n* It contains ten unit test cases for the {@link SocketSender#execute(String, String)} method.\n*/\nclass SocketSenderTest {"
	},
	{
		"original_code": "// Journal.java\npackage net.sf.xbus.base.journal;\n\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\n\n/**\n * <code>Journal</code> writes information about the activities of the\n * middleware.\n * <p>\n *\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td>Write</td>\n * <td><i>system.getName()</i>.Send</td>\n * <td>true, if sending data to this system shall be written.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td>Write</td>\n * <td><i>system.getName()</i>.Receive</td>\n * <td>true, if receiving data from this system shall be written.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td><i>Implementation</i></td>\n * <td><i>Class</i></td>\n * <td>Name of the Java-class that shall do the writing.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td><i>MessageLength</i></td>\n * <td><i>Bytes</i></td>\n * <td>Maximum number of bytes for request- and response-message.</td>\n * </tr>\n * </table>\n */\npublic class Journal {\n\n    static private boolean mInitialized = false;\n\n    static private String mJournalClass = null;\n\n    private JournalInterface mJournal;\n\n    /**\n     * Writes a middleware-activity. An activity can be:\n     * <ul>\n     * <li>A message has been received and processed.</li>\n     * <li>A message has been send to a neighbor-system.</li>\n     * </ul>\n     * <p>\n     * The {@link net.sf.xbus.base.core.config.Configuration} stores, which\n     * activities are written. All other activities are ignored.\n     * <p>\n     *\n     * @param type <b>R</b>: message has been received, <b>S</b>: message has\n     *            been send\n     * @param system The name of the system, from which the message has been\n     *            received or where the message has been sent to.\n     * @param message The {@link Message}-object that represents the data of\n     *            the message.\n     */\n    public void log(char type, XBUSSystem system, Message message) throws XException {\n        if (!mInitialized) {\n            Journal.initialize();\n        }\n        if (mJournal == null) {\n            mJournal = (JournalInterface) ReflectionSupport.createObject(mJournalClass);\n        }\n        Configuration config = Configuration.getInstance();\n        /* Find out, if this event has to be logged. */\n        boolean doIt;\n        if (type == 'S') {\n            doIt = config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"Journal.Send\");\n        } else if (type == 'R') {\n            doIt = config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"Journal.Receive\");\n        } else {\n            List params = new Vector();\n            params.add(String.valueOf(type));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_JOURNAL, \"2\", params);\n        }\n        if (doIt) {\n            if (!mInitialized) {\n                initialize();\n            }\n            mJournal.log(type, system, message);\n        }\n    }\n\n    /**\n     * Commits the database.\n     */\n    public void commit() throws XException {\n        if (!mInitialized) {\n            initialize();\n        }\n        mJournal.commit();\n    }\n\n    /**\n     * The given <code>Date</code> is converted to a string. The format of the\n     * string is specified in\n     * {@link net.sf.xbus.base.core.Constants#DATE_FORMAT}.\n     */\n    static public String formatDate(java.util.Date in) {\n        if (in == null) {\n            return \"<null>\";\n        }\n        SimpleDateFormat formatter = Constants.getDateFormat();\n        return formatter.format(in);\n    }\n\n    /**\n     * Shortens either the request-message or the response-message to a length\n     * specified in the {@link net.sf.xbus.base.core.config.Configuration}.\n     *\n     * @param message The {@link Message}-object that contains the data of the\n     *            message.\n     * @param system The name of the system, from which the message has been\n     *            received or where the message has been sent to.\n     * @param request true: the request-message will be shortened, false: the\n     *            response-message will be shortened.\n     * @return the shortened message\n     */\n    static public String formatText(Message message, XBUSSystem system, boolean request) throws XException {\n        String retString = null;\n        Configuration config = Configuration.getInstance();\n        int length = config.getValueAsInt(\"Base\", \"Journal\", \"MessageLength\");\n        /*\n\t\t * When the length should be 0, we must not format anything.\n\t\t */\n        if (length == 0) {\n            return null;\n        }\n        boolean textMessageFound = false;\n        boolean objectMessageFound = false;\n        Class[] interfaces = message.getClass().getInterfaces();\n        for (int i = 0; i < interfaces.length; i++) {\n            if (interfaces[i].getName().equals(\"net.sf.xbus.protocol.TextMessage\")) {\n                textMessageFound = true;\n            } else if (interfaces[i].getName().equals(\"net.sf.xbus.protocol.ObjectMessage\")) {\n                objectMessageFound = true;\n            }\n        }\n        if (textMessageFound) {\n            if (request) {\n                retString = formatString(((TextMessage) message).getRequestText(system), length);\n            } else {\n                retString = formatString(((TextMessage) message).getResponseText(), length);\n            }\n        } else if (objectMessageFound) {\n            if (request) {\n                Object obj = ((ObjectMessage) message).getRequestObject(system);\n                if (obj != null) {\n                    retString = formatString(obj.toString(), length);\n                }\n            } else {\n                Object obj = ((ObjectMessage) message).getResponseObject();\n                if (obj != null) {\n                    retString = formatString(obj.toString(), length);\n                }\n            }\n        }\n        return retString;\n    }\n\n    static public void initialize() throws XException {\n        Configuration config = Configuration.getInstance();\n        String journalClassShort = config.getValue(\"Base\", \"Journal\", \"Implementation\");\n        mJournalClass = Configuration.getClass(\"Journal\", journalClassShort);\n        mInitialized = true;\n    }\n\n    /**\n     * Shortens the input-string.\n     */\n    static private String formatString(String in, int length) {\n        if (in == null) {\n            return \"<null>\";\n        }\n        String tmp;\n        if ((length >= 0) && (in.length() > length)) {\n            tmp = in.substring(0, length);\n        } else {\n            tmp = in;\n        }\n        return tmp;\n    }\n\n    static public String removeLinefeeds(String text) {\n        if (text != null) {\n            text = text.replaceAll(\"\\n\", \"\");\n            return text.replaceAll(\"\\r\", \"\");\n        } else {\n            return text;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/journal/JournalTest0.java",
		"test_prompt": "// JournalTest0.java\npackage net.sf.xbus.base.journal;\n\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Journal}.\n* It contains ten unit test cases for the {@link Journal#formatDate(java.util.Date)} method.\n*/\nclass JournalTest0 {"
	},
	{
		"original_code": "// Journal.java\npackage net.sf.xbus.base.journal;\n\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\n\n/**\n * <code>Journal</code> writes information about the activities of the\n * middleware.\n * <p>\n *\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td>Write</td>\n * <td><i>system.getName()</i>.Send</td>\n * <td>true, if sending data to this system shall be written.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td>Write</td>\n * <td><i>system.getName()</i>.Receive</td>\n * <td>true, if receiving data from this system shall be written.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td><i>Implementation</i></td>\n * <td><i>Class</i></td>\n * <td>Name of the Java-class that shall do the writing.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td><i>MessageLength</i></td>\n * <td><i>Bytes</i></td>\n * <td>Maximum number of bytes for request- and response-message.</td>\n * </tr>\n * </table>\n */\npublic class Journal {\n\n    static private boolean mInitialized = false;\n\n    static private String mJournalClass = null;\n\n    private JournalInterface mJournal;\n\n    /**\n     * Writes a middleware-activity. An activity can be:\n     * <ul>\n     * <li>A message has been received and processed.</li>\n     * <li>A message has been send to a neighbor-system.</li>\n     * </ul>\n     * <p>\n     * The {@link net.sf.xbus.base.core.config.Configuration} stores, which\n     * activities are written. All other activities are ignored.\n     * <p>\n     *\n     * @param type <b>R</b>: message has been received, <b>S</b>: message has\n     *            been send\n     * @param system The name of the system, from which the message has been\n     *            received or where the message has been sent to.\n     * @param message The {@link Message}-object that represents the data of\n     *            the message.\n     */\n    public void log(char type, XBUSSystem system, Message message) throws XException {\n        if (!mInitialized) {\n            Journal.initialize();\n        }\n        if (mJournal == null) {\n            mJournal = (JournalInterface) ReflectionSupport.createObject(mJournalClass);\n        }\n        Configuration config = Configuration.getInstance();\n        /* Find out, if this event has to be logged. */\n        boolean doIt;\n        if (type == 'S') {\n            doIt = config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"Journal.Send\");\n        } else if (type == 'R') {\n            doIt = config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"Journal.Receive\");\n        } else {\n            List params = new Vector();\n            params.add(String.valueOf(type));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_JOURNAL, \"2\", params);\n        }\n        if (doIt) {\n            if (!mInitialized) {\n                initialize();\n            }\n            mJournal.log(type, system, message);\n        }\n    }\n\n    /**\n     * Commits the database.\n     */\n    public void commit() throws XException {\n        if (!mInitialized) {\n            initialize();\n        }\n        mJournal.commit();\n    }\n\n    /**\n     * The given <code>Date</code> is converted to a string. The format of the\n     * string is specified in\n     * {@link net.sf.xbus.base.core.Constants#DATE_FORMAT}.\n     */\n    static public String formatDate(java.util.Date in) {\n        if (in == null) {\n            return \"<null>\";\n        }\n        SimpleDateFormat formatter = Constants.getDateFormat();\n        return formatter.format(in);\n    }\n\n    /**\n     * Shortens either the request-message or the response-message to a length\n     * specified in the {@link net.sf.xbus.base.core.config.Configuration}.\n     *\n     * @param message The {@link Message}-object that contains the data of the\n     *            message.\n     * @param system The name of the system, from which the message has been\n     *            received or where the message has been sent to.\n     * @param request true: the request-message will be shortened, false: the\n     *            response-message will be shortened.\n     * @return the shortened message\n     */\n    static public String formatText(Message message, XBUSSystem system, boolean request) throws XException {\n        String retString = null;\n        Configuration config = Configuration.getInstance();\n        int length = config.getValueAsInt(\"Base\", \"Journal\", \"MessageLength\");\n        /*\n\t\t * When the length should be 0, we must not format anything.\n\t\t */\n        if (length == 0) {\n            return null;\n        }\n        boolean textMessageFound = false;\n        boolean objectMessageFound = false;\n        Class[] interfaces = message.getClass().getInterfaces();\n        for (int i = 0; i < interfaces.length; i++) {\n            if (interfaces[i].getName().equals(\"net.sf.xbus.protocol.TextMessage\")) {\n                textMessageFound = true;\n            } else if (interfaces[i].getName().equals(\"net.sf.xbus.protocol.ObjectMessage\")) {\n                objectMessageFound = true;\n            }\n        }\n        if (textMessageFound) {\n            if (request) {\n                retString = formatString(((TextMessage) message).getRequestText(system), length);\n            } else {\n                retString = formatString(((TextMessage) message).getResponseText(), length);\n            }\n        } else if (objectMessageFound) {\n            if (request) {\n                Object obj = ((ObjectMessage) message).getRequestObject(system);\n                if (obj != null) {\n                    retString = formatString(obj.toString(), length);\n                }\n            } else {\n                Object obj = ((ObjectMessage) message).getResponseObject();\n                if (obj != null) {\n                    retString = formatString(obj.toString(), length);\n                }\n            }\n        }\n        return retString;\n    }\n\n    static public void initialize() throws XException {\n        Configuration config = Configuration.getInstance();\n        String journalClassShort = config.getValue(\"Base\", \"Journal\", \"Implementation\");\n        mJournalClass = Configuration.getClass(\"Journal\", journalClassShort);\n        mInitialized = true;\n    }\n\n    /**\n     * Shortens the input-string.\n     */\n    static private String formatString(String in, int length) {\n        if (in == null) {\n            return \"<null>\";\n        }\n        String tmp;\n        if ((length >= 0) && (in.length() > length)) {\n            tmp = in.substring(0, length);\n        } else {\n            tmp = in;\n        }\n        return tmp;\n    }\n\n    static public String removeLinefeeds(String text) {\n        if (text != null) {\n            text = text.replaceAll(\"\\n\", \"\");\n            return text.replaceAll(\"\\r\", \"\");\n        } else {\n            return text;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/journal/JournalTest1.java",
		"test_prompt": "// JournalTest1.java\npackage net.sf.xbus.base.journal;\n\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Journal}.\n* It contains ten unit test cases for the {@link Journal#formatText(Message, XBUSSystem, boolean)} method.\n*/\nclass JournalTest1 {"
	},
	{
		"original_code": "// Journal.java\npackage net.sf.xbus.base.journal;\n\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\n\n/**\n * <code>Journal</code> writes information about the activities of the\n * middleware.\n * <p>\n *\n * <b>Configuration:</b>\n * <p>\n * <table border>\n * <tr>\n * <th>Chapter</th>\n * <th>Section</th>\n * <th>Key</th>\n * <th>Content</th>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td>Write</td>\n * <td><i>system.getName()</i>.Send</td>\n * <td>true, if sending data to this system shall be written.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td>Write</td>\n * <td><i>system.getName()</i>.Receive</td>\n * <td>true, if receiving data from this system shall be written.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td><i>Implementation</i></td>\n * <td><i>Class</i></td>\n * <td>Name of the Java-class that shall do the writing.</td>\n * </tr>\n * <tr>\n * <td>Journal</td>\n * <td><i>MessageLength</i></td>\n * <td><i>Bytes</i></td>\n * <td>Maximum number of bytes for request- and response-message.</td>\n * </tr>\n * </table>\n */\npublic class Journal {\n\n    static private boolean mInitialized = false;\n\n    static private String mJournalClass = null;\n\n    private JournalInterface mJournal;\n\n    /**\n     * Writes a middleware-activity. An activity can be:\n     * <ul>\n     * <li>A message has been received and processed.</li>\n     * <li>A message has been send to a neighbor-system.</li>\n     * </ul>\n     * <p>\n     * The {@link net.sf.xbus.base.core.config.Configuration} stores, which\n     * activities are written. All other activities are ignored.\n     * <p>\n     *\n     * @param type <b>R</b>: message has been received, <b>S</b>: message has\n     *            been send\n     * @param system The name of the system, from which the message has been\n     *            received or where the message has been sent to.\n     * @param message The {@link Message}-object that represents the data of\n     *            the message.\n     */\n    public void log(char type, XBUSSystem system, Message message) throws XException {\n        if (!mInitialized) {\n            Journal.initialize();\n        }\n        if (mJournal == null) {\n            mJournal = (JournalInterface) ReflectionSupport.createObject(mJournalClass);\n        }\n        Configuration config = Configuration.getInstance();\n        /* Find out, if this event has to be logged. */\n        boolean doIt;\n        if (type == 'S') {\n            doIt = config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"Journal.Send\");\n        } else if (type == 'R') {\n            doIt = config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"Journal.Receive\");\n        } else {\n            List params = new Vector();\n            params.add(String.valueOf(type));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_JOURNAL, \"2\", params);\n        }\n        if (doIt) {\n            if (!mInitialized) {\n                initialize();\n            }\n            mJournal.log(type, system, message);\n        }\n    }\n\n    /**\n     * Commits the database.\n     */\n    public void commit() throws XException {\n        if (!mInitialized) {\n            initialize();\n        }\n        mJournal.commit();\n    }\n\n    /**\n     * The given <code>Date</code> is converted to a string. The format of the\n     * string is specified in\n     * {@link net.sf.xbus.base.core.Constants#DATE_FORMAT}.\n     */\n    static public String formatDate(java.util.Date in) {\n        if (in == null) {\n            return \"<null>\";\n        }\n        SimpleDateFormat formatter = Constants.getDateFormat();\n        return formatter.format(in);\n    }\n\n    /**\n     * Shortens either the request-message or the response-message to a length\n     * specified in the {@link net.sf.xbus.base.core.config.Configuration}.\n     *\n     * @param message The {@link Message}-object that contains the data of the\n     *            message.\n     * @param system The name of the system, from which the message has been\n     *            received or where the message has been sent to.\n     * @param request true: the request-message will be shortened, false: the\n     *            response-message will be shortened.\n     * @return the shortened message\n     */\n    static public String formatText(Message message, XBUSSystem system, boolean request) throws XException {\n        String retString = null;\n        Configuration config = Configuration.getInstance();\n        int length = config.getValueAsInt(\"Base\", \"Journal\", \"MessageLength\");\n        /*\n\t\t * When the length should be 0, we must not format anything.\n\t\t */\n        if (length == 0) {\n            return null;\n        }\n        boolean textMessageFound = false;\n        boolean objectMessageFound = false;\n        Class[] interfaces = message.getClass().getInterfaces();\n        for (int i = 0; i < interfaces.length; i++) {\n            if (interfaces[i].getName().equals(\"net.sf.xbus.protocol.TextMessage\")) {\n                textMessageFound = true;\n            } else if (interfaces[i].getName().equals(\"net.sf.xbus.protocol.ObjectMessage\")) {\n                objectMessageFound = true;\n            }\n        }\n        if (textMessageFound) {\n            if (request) {\n                retString = formatString(((TextMessage) message).getRequestText(system), length);\n            } else {\n                retString = formatString(((TextMessage) message).getResponseText(), length);\n            }\n        } else if (objectMessageFound) {\n            if (request) {\n                Object obj = ((ObjectMessage) message).getRequestObject(system);\n                if (obj != null) {\n                    retString = formatString(obj.toString(), length);\n                }\n            } else {\n                Object obj = ((ObjectMessage) message).getResponseObject();\n                if (obj != null) {\n                    retString = formatString(obj.toString(), length);\n                }\n            }\n        }\n        return retString;\n    }\n\n    static public void initialize() throws XException {\n        Configuration config = Configuration.getInstance();\n        String journalClassShort = config.getValue(\"Base\", \"Journal\", \"Implementation\");\n        mJournalClass = Configuration.getClass(\"Journal\", journalClassShort);\n        mInitialized = true;\n    }\n\n    /**\n     * Shortens the input-string.\n     */\n    static private String formatString(String in, int length) {\n        if (in == null) {\n            return \"<null>\";\n        }\n        String tmp;\n        if ((length >= 0) && (in.length() > length)) {\n            tmp = in.substring(0, length);\n        } else {\n            tmp = in;\n        }\n        return tmp;\n    }\n\n    static public String removeLinefeeds(String text) {\n        if (text != null) {\n            text = text.replaceAll(\"\\n\", \"\");\n            return text.replaceAll(\"\\r\", \"\");\n        } else {\n            return text;\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/journal/JournalTest2.java",
		"test_prompt": "// JournalTest2.java\npackage net.sf.xbus.base.journal;\n\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.protocol.Message;\nimport net.sf.xbus.protocol.ObjectMessage;\nimport net.sf.xbus.protocol.TextMessage;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Journal}.\n* It contains ten unit test cases for the {@link Journal#removeLinefeeds(String)} method.\n*/\nclass JournalTest2 {"
	},
	{
		"original_code": "// FileAcceptor.java\npackage net.sf.xbus.base.xbussystem;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * Class <code>FileAcceptor</code> implements <code>FilenameFilter</code>\n * interface to filter filenames.<br>\n * Its instances are used to filter directory listings in the\n * {@link java.io.File#list(java.io.FilenameFilter)}method. All file names in\n * the returned array must satisfy this filter.\n * <p>\n * <i>Note:</i>&nbsp;A name satisfies the filter if and only if the value true\n * results when the {@link #accept(File, String)} method is invoked on this\n * abstract pathname and the name of a file or directory in the directory that\n * it denotes.\n * <p>\n *\n * @author Fleckenstein\n */\npublic class FileAcceptor implements FilenameFilter {\n\n    /**\n     * Stores the name of the file before separator(WILDCARD)\n     */\n    String mPrefix = null;\n\n    /**\n     * Stores the name of the file after separator(WILDCARD) or empty string if\n     * the name ends with separator(WILDCARD)\n     */\n    String mPostfix = null;\n\n    /**\n     * Stores all replacements(WILDCARDS)\n     */\n    Vector mReplacements = new Vector();\n\n    /**\n     * Initializes new Filename filter for the given abstract pathname with\n     * checking it on observance of a Separator(WILDCARD) and storing the prefix\n     * and postfix of this filename in to class variables.\n     *\n     * @param pathname abstract path name to be filtered\n     * @exception XException if the filename doesn't contain a seperator or has\n     *                more than one seperator\n     */\n    public FileAcceptor(String pathname) throws XException {\n        // store the name of the file or directory denoted by this abstract\n        // pathname.\n        // This is just the last name in the pathname's name sequence.\n        String filename = new File(pathname).getName();\n        // check if this name contains one and only one WILDCARD\n        int seperatorIndex = filename.indexOf(XBUSSystem.FILENAME_WILDCARD);\n        if (seperatorIndex < 0) {\n            List params = new Vector();\n            params.add(filename);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"1\", params);\n        }\n        // if (seperatorIndex < 0)\n        if (seperatorIndex != filename.lastIndexOf(XBUSSystem.FILENAME_WILDCARD)) {\n            List params = new Vector();\n            params.add(filename);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"2\", params);\n        }\n        // if (seperatorIndex !=\n        // filename.lastIndexOf(XBUSSystem.FILENAME_WILDCARD))\n        // save prefix (name before WILDCARD) and postfix (name after WILDCARD\n        // or \"\" if the filename ends with the WILDCARD) in class variablen\n        mPrefix = filename.substring(0, seperatorIndex);\n        if (filename.length() > seperatorIndex + XBUSSystem.FILENAME_WILDCARD.length()) {\n            mPostfix = filename.substring(seperatorIndex + XBUSSystem.FILENAME_WILDCARD.length(), filename.length());\n        } else // then (filename.length()\n        {\n            mPostfix = \"\";\n        }\n        // else (filename.length()\n    }\n\n    // FileAcceptor(String pathname)\n    /**\n     * Tests whether or not the specified file should be included in a file\n     * list. If the file is satisfyd this filter, that stores this method the\n     * placeholder to be replace late (substring between prefix and postfix) in\n     * vector.\n     *\n     * @see java.io.FilenameFilter#accept(File, String)\n     * @param dir the directory in which the file was found.\n     * @param filename the name of the file to be tested\n     * @return true if and only if filename should be included in the file list;\n     *         false otherwise.\n     */\n    public boolean accept(File dir, String filename) {\n        boolean result = false;\n        if (filename.startsWith(mPrefix) && filename.endsWith(mPostfix)) {\n            // File name is matches the pattern.\n            mReplacements.add(filename.substring(mPrefix.length(), filename.lastIndexOf(mPostfix)));\n            result = true;\n        }\n        // if (filename.startsWith(mPrefix) && filename.endsWith(mPostfix))\n        return result;\n    }\n\n    // accept(File dir, String filename)\n    /**\n     * Returns the list with all replacements (WILDCARDS)\n     *\n     * @return list with all replacements\n     */\n    public List getReplacements() {\n        return mReplacements;\n    }\n    // getReplacements()\n}\n// FileAcceptor\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xbussystem/FileAcceptorTest.java",
		"test_prompt": "// FileAcceptorTest.java\npackage net.sf.xbus.base.xbussystem;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FileAcceptor}.\n* It contains ten unit test cases for the {@link FileAcceptor#accept(File, String)} method.\n*/\nclass FileAcceptorTest {"
	},
	{
		"original_code": "// XBUSSystem.java\npackage net.sf.xbus.base.xbussystem;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * <code>XBUSSystem</code> is the representation of any neighbor-systems\n * respectively their interfaces. It consists of two informations:\n * <p>\n * <ul>\n * <li>The name of the system is used to identify the system.\n * <li>Additionally an adress might be available.\n * </ul>\n */\npublic class XBUSSystem {\n\n    public static final String FILENAME_WILDCARD = \"$WILDCARD$\";\n\n    public static final String FILENAME_WILDCARD_XML = \"WILDCARD\";\n\n    private static final String ADDITIONAL_ADDRESS = \"AddressImplementation\";\n\n    private static final String TIMESTAMP = \"$TIMESTAMP$\";\n\n    /**\n     * Holds all address informations of the neighbor-system. Each address\n     * stored as value against its typ.\n     * <p>\n     * <i>Possible addresses: </i> <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value(Example)</th>\n     * </tr>\n     * <tr>\n     * <td>AddressImplementation</td>\n     * <td>Test/Wholesale/std$DEALERNUMBER$.cnf</td>\n     * </tr>\n     * <tr>\n     * <td>WILDCARD</td>\n     * <td>parts</td>\n     * </tr>\n     * <tr>\n     * <td><i>example: </i>user</td>\n     * <td>KS</td>\n     * </tr>\n     * </table>\n     */\n    private Hashtable mAddresses = new Hashtable();\n\n    /**\n     * Is a braodcast requested for all recorded addtional addresses when\n     * sending data to this system?\n     */\n    private boolean mBroadcast;\n\n    /**\n     * Name of the neighbor-system\n     */\n    private String mName = null;\n\n    /**\n     * Holds all AdditionalAddress objects of this neighbor-system. Each object\n     * stored as value against the name of this neigbor-system.\n     * <p>\n     * <i>Example: </i> <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value</th>\n     * </tr>\n     * <tr>\n     * <td>PartsOrderAutoline</td>\n     * <td>new Dealer()</td>\n     * </tr>\n     * </table\n     */\n    private static Hashtable mAdditionalAddressImplementations = new Hashtable();\n\n    /**\n     * <code>mMinAge</code> can be used to filter data sources due to their\n     * age to ignore all those, which are too fresh. This can be used for access\n     * synchronisation: Putting in the maximum time for constructing a file\n     * ensures that the file transfer does not start while during writing the\n     * file. The value is in milliseconds.\n     */\n    private int mMinAge;\n\n    /**\n     * <code>mMaxAge</code> can be used to filter data sources due to their\n     * age to ignore all those, which are too old. This can be used for ignoring\n     * outdated data sources from former failed data transfers. The value is in\n     * milliseconds.\n     */\n    private int mMaxAge;\n\n    /**\n     * Constructs the <code>XBUSSystem</code> without an address.\n     *\n     * @param name name of the neighbor-system\n     */\n    public XBUSSystem(String name) throws XException {\n        mName = name;\n        // Look for the (optional) restrictions to data source age.\n        Configuration config = Configuration.getInstance();\n        mMinAge = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, name, \"MinAge\") * 1000;\n        mMaxAge = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, name, \"MaxAge\") * 1000;\n    }\n\n    // XBUSSystem(String name)\n    /**\n     * Constructs the <code>XBUSSystem</code> from the name fo the\n     * neighbor-system and all address informations for this system\n     *\n     * @param name name of the neighbor-system\n     * @param addresses name of the address\n     */\n    public XBUSSystem(String name, Hashtable addresses) throws XException {\n        this(name);\n        mAddresses = addresses;\n    }\n\n    // XBUSSystem(String name, Hashtable addresses)\n    /**\n     * Constructs the <code>XBUSSystem</code> from the name fo the\n     * neighbor-system and all address informations for this system and the flag\n     * if a broadcast is requested to this system. The addresses do not\n     * necessarily contain the reference to additional address information\n     * necessary for a broadcast.\n     *\n     * @param name name of the neighbor-system\n     * @param addresses name of the address\n     * @param broadcast is broadcast to be done when sending?\n     */\n    public XBUSSystem(String name, Hashtable addresses, boolean broadcast) throws XException {\n        this(name, addresses);\n        mBroadcast = broadcast;\n    }\n\n    // XBUSSystem(String name, Hashtable addresses, boolean broadcast)\n    /**\n     * Returns the name of the neighbor-system.\n     *\n     * @return name of the neighbor-system\n     */\n    public String getName() {\n        return mName;\n    }\n\n    // getName()\n    /**\n     * Returns all address informations of the neighbor-system. Each address\n     * stored as value against its typ.\n     * <p>\n     * <i>Example: </i>\n     * <p>\n     * <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value</th>\n     * </tr>\n     * <tr>\n     * <td>AddressImplementation</td>\n     * <td>Test/Wholesale/std$DEALERNUMBER$.cnf</td>\n     * </tr>\n     * <tr>\n     * <td>WILDCARD</td>\n     * <td>parts</td>\n     * </tr>\n     * <tr>\n     * <td>user</td>\n     * <td>KS</td>\n     * </tr>\n     * </table>\n     *\n     * @return all addresses of the neighbor-system\n     */\n    public Hashtable getAddresses() {\n        return mAddresses;\n    }\n\n    // getAddresses()\n    /**\n     * Sets all address informations for the neighbor-system.\n     *\n     * @param addresses Hashtable of the addresses\n     */\n    /*\n\t * private void setAddresses(Hashtable addresses) { mAddresses = addresses; } //\n\t * setAddresses(Hashtable addresses)\n\t */\n    /**\n     * Sets one address information of the neighbor-system.\n     *\n     * @param name typ of additional information\n     * @param address additional inrformation eventually containing markers with\n     *            the format <code>$key$</code>.\n     */\n    public void setAddress(String name, String address) {\n        mAddresses.put(name, address);\n    }\n\n    // setAddress(String name, String address)\n    /**\n     * <dl>\n     * <dt>Returns the concatenation of name and all addresses of the\n     * neighbor-system by <b>\"_\" </b> separated.\n     * <dd><i>Example: </i>&nbsp;&nbsp;&nbsp;PartsOrderAutoline_12345\n     * <p>\n     * <dt>If no address information is found, the name of the neighbor-system\n     * will be returned. <br>\n     * <dd><i>Example: </i>&nbsp;&nbsp;&nbsp;PartsOrderAutoline\n     * <p>\n     * </dl>\n     *\n     * @return concatenation of name and all addresses of the neighbor-system or\n     *         only name if addresses are not exist\n     */\n    public String getCompleteName() {\n        String retString;\n        if (mAddresses.isEmpty()) {\n            retString = mName;\n        } else {\n            StringBuffer retStringBuffer = new StringBuffer(mName);\n            for (Enumeration e = mAddresses.keys(); e.hasMoreElements(); ) {\n                retStringBuffer.append(\"_\");\n                retStringBuffer.append(mAddresses.get(e.nextElement()));\n            }\n            retString = retStringBuffer.toString();\n        }\n        return retString;\n    }\n\n    // getCompleteName()\n    /**\n     * Is a braodcast requested for all recorded addtional addresses when\n     * sending data to this system?\n     */\n    public boolean getBroadcast() {\n        return mBroadcast;\n    }\n\n    // getBroadcast()\n    /**\n     * Get the maximal age of the data source. The value is in milliseconds.\n     */\n    public int getMaxAge() {\n        return mMaxAge;\n    }\n\n    // getMaxAge()\n    /**\n     * Get the minimal age of the data source. The value is in milliseconds.\n     */\n    public int getMinAge() {\n        return mMinAge;\n    }\n\n    // getMinAge()\n    /**\n     * The given text may contain place markers which will be replaced with\n     * their actual values. Three types of markers are possible:\n     * <ul>\n     * <li>Additional informations which have been set with the\n     * {@link #setAddress(String, String)}method. The key set there is\n     * interpreted as a marker with the format <code>$key$</code>.\n     * <li>WILDCARD separator\n     * <li>Markers for informations on the address. These markers will be\n     * replaced with their actual values for the address of the neighbor-system.\n     * <br>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the interface {@link AdditionalAddress}.<br/>A\n     * broadcast is possible in sending using the addtional address information.\n     * That is the reason for the array return type. Withoout braoadcast only\n     * the first array element is filled.\n     * </ul>\n     * <p>\n     * <b><i>Note: </i> </b>If no marker is found, the text will be returned\n     * without modifications.\n     *\n     * @param text text containing markers\n     * @return text array with replacements for markers or without modifications\n     *         if no marker is found.\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public String[] replaceAllMarkers(String text) throws XException {\n        text = XStringSupport.replaceAll(text, TIMESTAMP, Constants.getDateAsString());\n        /*\n\t\t * 1. Search if a marker in the table of additional values is found. If\n\t\t * yes, replace it.\n\t\t */\n        String key = null;\n        String marker = null;\n        for (Enumeration e = mAddresses.keys(); e.hasMoreElements(); ) {\n            key = (String) e.nextElement();\n            if (!key.equals(ADDITIONAL_ADDRESS) && !key.equals(FILENAME_WILDCARD)) {\n                marker = \"$\" + key + \"$\";\n                if (text.indexOf(marker) >= 0) {\n                    text = text.replaceAll(marker, (String) mAddresses.get(key));\n                }\n            }\n        }\n        /*\n\t\t * 2. Search if a WILDCARD separator in the table is found. If yes,\n\t\t * replace it\n\t\t */\n        if (mAddresses.containsKey(FILENAME_WILDCARD)) {\n            if (text.indexOf(FILENAME_WILDCARD) >= 0) {\n                text = XStringSupport.replaceAll(text, FILENAME_WILDCARD, (String) mAddresses.get(FILENAME_WILDCARD));\n            }\n        }\n        /*\n\t\t * 3. If the XBUSSystem contains an address information, replace markers\n\t\t * for this address.\n\t\t */\n        if (mAddresses.containsKey(ADDITIONAL_ADDRESS)) {\n            AdditionalAddress addAddress = getAdditionalAddressImplementation(getName());\n            if (addAddress.hasMarker(text)) {\n                // The string contains a marker for additional address\n                // information.\n                if (mBroadcast) {\n                    // For broadcast construct one string for each addiotinal\n                    // address.\n                    List addAddresses = addAddress.getAddresses();\n                    int quantAddresses = addAddresses.size();\n                    if (quantAddresses < 1) {\n                        // No additional addresses specified in configuration.\n                        List params = new Vector();\n                        params.add(mName);\n                        params.add(text);\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"5\", params);\n                    }\n                    // if (quantAddresses<1)\n                    String[] result = new String[quantAddresses];\n                    for (int i = 0; i < quantAddresses; i++) result[i] = addAddress.replaceMarker(text, (String) addAddresses.get(i));\n                    return result;\n                } else // then (mBroadcast)\n                {\n                    // Simple addtional address without broadcast.\n                    String[] result = { addAddress.replaceMarker(text, (String) mAddresses.get(ADDITIONAL_ADDRESS)) };\n                    return result;\n                }\n                // else (mBroadcast)\n            } else // then addAddress.hasMarker(text)\n            {\n                // No addtional address marker.\n                String[] result = { text };\n                return result;\n            }\n            // else (addAddress.hasMarker(text))\n        } else // then (mAddresses.containsKey(ADDITIONAL_ADDRESS))\n        {\n            // No addtional address at all.\n            String[] result = { text };\n            return result;\n        }\n        // else (mAddresses.containsKey(ADDITIONAL_ADDRESS))\n    }\n\n    // replaceAllMarkers(String text)\n    /**\n     * Returns the concatenation of name and address of the neighbor-system.\n     *\n     * @see #getCompleteName()\n     * @return concatenation of name and address of the neighbor-system or only\n     *         name if address is not exist\n     */\n    public String toString() {\n        return getCompleteName();\n    }\n\n    // toString()\n    /**\n     * Returns a list of <code>XBUSSystems</code>, generated through the\n     * replacing of all possible place markers.\n     * <p>\n     * <b><i>Note: </i> </b>If there are no place markers in the given text,\n     * only one system with an empty address is in that list.\n     *\n     * @param name the name of the system\n     * @param text eventually containing place markers\n     * @return list of <code>XBUSSystems</code>\n     * @exception XException if any error occurs\n     */\n    static public List getSystems(String name, String text) throws XException {\n        /*\n\t\t * 1. check if the given text contains place markers for informations on\n\t\t * the address, then store list of all configured addresses\n\t\t */\n        Vector additionalAddresses = null;\n        if (hasAdditionalAddressMarker(name, text)) {\n            additionalAddresses = new Vector();\n            List addresses = getAdditionalAddresses(name);\n            for (Iterator it = addresses.iterator(); it.hasNext(); ) {\n                additionalAddresses.add(it.next());\n            }\n        }\n        /*\n\t\t * 2. check if the given text contains WILDCARD separator\n\t\t * \n\t\t */\n        List addressVector = null;\n        Hashtable addressTable = null;\n        if (text.indexOf(XBUSSystem.FILENAME_WILDCARD) >= 0) {\n            // there is no additional informations yet\n            if ((additionalAddresses == null) || (additionalAddresses.isEmpty())) {\n                FileAcceptor acceptor = new FileAcceptor(text);\n                // get an array of strings naming the files and directories in\n                // the directory\n                // denoted by this abstract pathname that were accepted by the\n                // FileAcceptor filter.\n                String[] dummy = new File(text).getParentFile().list(acceptor);\n                String message = \"Found files\";\n                if (dummy != null)\n                    for (int i = 0; i < dummy.length; i++) message = message + \" \" + dummy[i];\n                // save all replacements (wildcards) in vector\n                addressVector = acceptor.getReplacements();\n            } else {\n                addressTable = new Hashtable();\n                // get additional address implementation for this system\n                AdditionalAddress additionalAddressImpl = getAdditionalAddressImplementation(name);\n                // replace place markers in each address\n                for (Iterator it = additionalAddresses.iterator(); it.hasNext(); ) {\n                    String additionalAddress = (String) it.next();\n                    String filename = additionalAddressImpl.replaceMarker(text, additionalAddress);\n                    // initializte filename filter for this filename\n                    FileAcceptor acceptor = new FileAcceptor(filename);\n                    // get an array of strings naming the files and directories\n                    // in the directory denoted by this abstract pathname that\n                    // were accepted by the FileAcceptor filter.\n                    String[] dummy = new File(filename).getParentFile().list(acceptor);\n                    String message = \"Found files\";\n                    for (int i = 0; dummy != null && i < dummy.length; i++) message = message + \" \" + dummy[i];\n                    addressTable.put(additionalAddress, acceptor.getReplacements());\n                }\n            }\n        }\n        /*\n\t\t * 3. construct a system vector a: put each address with its type in\n\t\t * hashtable b: encapsulate this table with name of the system in\n\t\t * XBUSSystem object c: and store this object in vector\n\t\t */\n        Vector retSystems = new Vector();\n        // there are only wildcards\n        if (addressVector != null) {\n            for (Iterator it = addressVector.iterator(); it.hasNext(); ) {\n                Hashtable addresses = new Hashtable();\n                addresses.put(FILENAME_WILDCARD, it.next());\n                retSystems.add(new XBUSSystem(name, addresses));\n            }\n        } else // there are also address implementations\n        if (addressTable != null) {\n            for (Enumeration e = addressTable.keys(); e.hasMoreElements(); ) {\n                String additionalAddress = (String) e.nextElement();\n                List wildcardReplacements = (List) addressTable.get(additionalAddress);\n                for (Iterator it = wildcardReplacements.iterator(); it.hasNext(); ) {\n                    Hashtable addresses = new Hashtable();\n                    addresses.put(ADDITIONAL_ADDRESS, additionalAddress);\n                    addresses.put(FILENAME_WILDCARD, it.next());\n                    retSystems.add(new XBUSSystem(name, addresses));\n                }\n            }\n        } else // if only additional address implementation exist\n        if (additionalAddresses != null) {\n            for (Iterator it = additionalAddresses.iterator(); it.hasNext(); ) {\n                Hashtable addresses = new Hashtable();\n                addresses.put(ADDITIONAL_ADDRESS, it.next());\n                retSystems.add(new XBUSSystem(name, addresses));\n            }\n        } else // there is no addresses exist\n        {\n            retSystems.add(new XBUSSystem(name));\n        }\n        return retSystems;\n    }\n\n    /**\n     * Tests if the given text contains place markers for informations on the\n     * address.\n     * <p>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the {@link net.sf.xbus.base.AdditionalAddress}\n     * interface.\n     *\n     * @see #getAdditionalAddressImplementation(String)\n     * @param systemNAme name of the system\n     * @param text text eventually containing markers\n     * @return true if text contains markers; false otherwise\n     * @exception XException if any error occurs\n     */\n    static private boolean hasAdditionalAddressMarker(String systemName, String text) throws XException {\n        AdditionalAddress additionalAddressImplementation = getAdditionalAddressImplementation(systemName);\n        if (additionalAddressImplementation != null) {\n            return additionalAddressImplementation.hasMarker(text);\n        } else {\n            return false;\n        }\n    }\n\n    // hasAdditionalAddressMarker(String systemName,String text)\n    /**\n     * Returns a list of all configured addresses for the given system name.\n     * <p>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the {@link net.sf.xbus.base.AdditionalAddress}\n     * interface.\n     *\n     * @see #getAdditionalAddressImplementation(String)\n     * @param systemName the name of the system\n     * @return list of addresses\n     * @exception XException if any error occurs\n     */\n    static private List getAdditionalAddresses(String systemName) throws XException {\n        return getAdditionalAddressImplementation(systemName).getAddresses();\n    }\n\n    // getAdditionalAddresses(String systemName)\n    /**\n     * Gets the address implementation ({@link AdditionalAddress}) for the\n     * given system name.\n     * <p>\n     * <b><i>Note: </i> </b> If there is no address implementation for the\n     * given system created yet, then creates this method one first. <br>\n     * Address implementation name is read from the configuration: <br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>System_ </b> <i>SystemName\n     * </i> <b>_AddressImplementation </b> <br>\n     * If there is no implementation for the address is provided with this\n     * system, there must be a global entry used.: <br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n     * <b>Base_System_AddressImplementation </b>\n     *\n     * @param systemName the name of the system\n     * @return address implementation ({@link AdditionalAddress}) for the\n     *         given system name\n     * @exception XException if any error occurs\n     */\n    public static AdditionalAddress getAdditionalAddressImplementation(String systemName) throws XException {\n        if (!mAdditionalAddressImplementations.contains(systemName)) {\n            /*\n\t\t\t * If there is no address implementation for the current system\n\t\t\t * created yet, we will create it and put it in the Hashtable.\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            /*\n\t\t\t * If an implementation for the address is provided with the system,\n\t\t\t * than this implementation is getting used.\n\t\t\t */\n            String addressImplementationNameShort = config.getValueOptional(Constants.CHAPTER_SYSTEM, systemName, ADDITIONAL_ADDRESS);\n            if (addressImplementationNameShort == null) {\n                /*\n\t\t\t\t * If there is no system specific implementation, there maybe is\n\t\t\t\t * a global entry.\n\t\t\t\t */\n                addressImplementationNameShort = config.getValueOptional(\"Base\", Constants.CHAPTER_SYSTEM, ADDITIONAL_ADDRESS);\n            }\n            if (addressImplementationNameShort != null) {\n                String addressImplementationName = Configuration.getClass(\"AdressImplementation\", addressImplementationNameShort);\n                mAdditionalAddressImplementations.put(systemName, ReflectionSupport.createObject(addressImplementationName));\n            }\n        }\n        return (AdditionalAddress) mAdditionalAddressImplementations.get(systemName);\n    }\n\n    // getAdditionalAddressImplementation(String systemName)\n    /**\n     * Check if the given address string does contain a reference to addtional\n     * address information. Update the list of addresses and broadcast flag\n     * accordingly.\n     *\n     * @param text the address text (e.g. file path)\n     */\n    public void getBroadcastData(String text) throws XException {\n        if (hasAdditionalAddressMarker(mName, text))\n            // Reference to additional addresses given.\n            mAddresses.put(ADDITIONAL_ADDRESS, \"broadcast\");\n        else\n            // No reference to additional addresses given.\n            mBroadcast = false;\n    }\n    // getBroadcastData(String text)\n}\n// XBUSSystem\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xbussystem/XBUSSystemTest0.java",
		"test_prompt": "// XBUSSystemTest0.java\npackage net.sf.xbus.base.xbussystem;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XBUSSystem}.\n* It contains ten unit test cases for the {@link XBUSSystem#replaceAllMarkers(String)} method.\n*/\nclass XBUSSystemTest0 {"
	},
	{
		"original_code": "// XBUSSystem.java\npackage net.sf.xbus.base.xbussystem;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * <code>XBUSSystem</code> is the representation of any neighbor-systems\n * respectively their interfaces. It consists of two informations:\n * <p>\n * <ul>\n * <li>The name of the system is used to identify the system.\n * <li>Additionally an adress might be available.\n * </ul>\n */\npublic class XBUSSystem {\n\n    public static final String FILENAME_WILDCARD = \"$WILDCARD$\";\n\n    public static final String FILENAME_WILDCARD_XML = \"WILDCARD\";\n\n    private static final String ADDITIONAL_ADDRESS = \"AddressImplementation\";\n\n    private static final String TIMESTAMP = \"$TIMESTAMP$\";\n\n    /**\n     * Holds all address informations of the neighbor-system. Each address\n     * stored as value against its typ.\n     * <p>\n     * <i>Possible addresses: </i> <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value(Example)</th>\n     * </tr>\n     * <tr>\n     * <td>AddressImplementation</td>\n     * <td>Test/Wholesale/std$DEALERNUMBER$.cnf</td>\n     * </tr>\n     * <tr>\n     * <td>WILDCARD</td>\n     * <td>parts</td>\n     * </tr>\n     * <tr>\n     * <td><i>example: </i>user</td>\n     * <td>KS</td>\n     * </tr>\n     * </table>\n     */\n    private Hashtable mAddresses = new Hashtable();\n\n    /**\n     * Is a braodcast requested for all recorded addtional addresses when\n     * sending data to this system?\n     */\n    private boolean mBroadcast;\n\n    /**\n     * Name of the neighbor-system\n     */\n    private String mName = null;\n\n    /**\n     * Holds all AdditionalAddress objects of this neighbor-system. Each object\n     * stored as value against the name of this neigbor-system.\n     * <p>\n     * <i>Example: </i> <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value</th>\n     * </tr>\n     * <tr>\n     * <td>PartsOrderAutoline</td>\n     * <td>new Dealer()</td>\n     * </tr>\n     * </table\n     */\n    private static Hashtable mAdditionalAddressImplementations = new Hashtable();\n\n    /**\n     * <code>mMinAge</code> can be used to filter data sources due to their\n     * age to ignore all those, which are too fresh. This can be used for access\n     * synchronisation: Putting in the maximum time for constructing a file\n     * ensures that the file transfer does not start while during writing the\n     * file. The value is in milliseconds.\n     */\n    private int mMinAge;\n\n    /**\n     * <code>mMaxAge</code> can be used to filter data sources due to their\n     * age to ignore all those, which are too old. This can be used for ignoring\n     * outdated data sources from former failed data transfers. The value is in\n     * milliseconds.\n     */\n    private int mMaxAge;\n\n    /**\n     * Constructs the <code>XBUSSystem</code> without an address.\n     *\n     * @param name name of the neighbor-system\n     */\n    public XBUSSystem(String name) throws XException {\n        mName = name;\n        // Look for the (optional) restrictions to data source age.\n        Configuration config = Configuration.getInstance();\n        mMinAge = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, name, \"MinAge\") * 1000;\n        mMaxAge = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, name, \"MaxAge\") * 1000;\n    }\n\n    // XBUSSystem(String name)\n    /**\n     * Constructs the <code>XBUSSystem</code> from the name fo the\n     * neighbor-system and all address informations for this system\n     *\n     * @param name name of the neighbor-system\n     * @param addresses name of the address\n     */\n    public XBUSSystem(String name, Hashtable addresses) throws XException {\n        this(name);\n        mAddresses = addresses;\n    }\n\n    // XBUSSystem(String name, Hashtable addresses)\n    /**\n     * Constructs the <code>XBUSSystem</code> from the name fo the\n     * neighbor-system and all address informations for this system and the flag\n     * if a broadcast is requested to this system. The addresses do not\n     * necessarily contain the reference to additional address information\n     * necessary for a broadcast.\n     *\n     * @param name name of the neighbor-system\n     * @param addresses name of the address\n     * @param broadcast is broadcast to be done when sending?\n     */\n    public XBUSSystem(String name, Hashtable addresses, boolean broadcast) throws XException {\n        this(name, addresses);\n        mBroadcast = broadcast;\n    }\n\n    // XBUSSystem(String name, Hashtable addresses, boolean broadcast)\n    /**\n     * Returns the name of the neighbor-system.\n     *\n     * @return name of the neighbor-system\n     */\n    public String getName() {\n        return mName;\n    }\n\n    // getName()\n    /**\n     * Returns all address informations of the neighbor-system. Each address\n     * stored as value against its typ.\n     * <p>\n     * <i>Example: </i>\n     * <p>\n     * <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value</th>\n     * </tr>\n     * <tr>\n     * <td>AddressImplementation</td>\n     * <td>Test/Wholesale/std$DEALERNUMBER$.cnf</td>\n     * </tr>\n     * <tr>\n     * <td>WILDCARD</td>\n     * <td>parts</td>\n     * </tr>\n     * <tr>\n     * <td>user</td>\n     * <td>KS</td>\n     * </tr>\n     * </table>\n     *\n     * @return all addresses of the neighbor-system\n     */\n    public Hashtable getAddresses() {\n        return mAddresses;\n    }\n\n    // getAddresses()\n    /**\n     * Sets all address informations for the neighbor-system.\n     *\n     * @param addresses Hashtable of the addresses\n     */\n    /*\n\t * private void setAddresses(Hashtable addresses) { mAddresses = addresses; } //\n\t * setAddresses(Hashtable addresses)\n\t */\n    /**\n     * Sets one address information of the neighbor-system.\n     *\n     * @param name typ of additional information\n     * @param address additional inrformation eventually containing markers with\n     *            the format <code>$key$</code>.\n     */\n    public void setAddress(String name, String address) {\n        mAddresses.put(name, address);\n    }\n\n    // setAddress(String name, String address)\n    /**\n     * <dl>\n     * <dt>Returns the concatenation of name and all addresses of the\n     * neighbor-system by <b>\"_\" </b> separated.\n     * <dd><i>Example: </i>&nbsp;&nbsp;&nbsp;PartsOrderAutoline_12345\n     * <p>\n     * <dt>If no address information is found, the name of the neighbor-system\n     * will be returned. <br>\n     * <dd><i>Example: </i>&nbsp;&nbsp;&nbsp;PartsOrderAutoline\n     * <p>\n     * </dl>\n     *\n     * @return concatenation of name and all addresses of the neighbor-system or\n     *         only name if addresses are not exist\n     */\n    public String getCompleteName() {\n        String retString;\n        if (mAddresses.isEmpty()) {\n            retString = mName;\n        } else {\n            StringBuffer retStringBuffer = new StringBuffer(mName);\n            for (Enumeration e = mAddresses.keys(); e.hasMoreElements(); ) {\n                retStringBuffer.append(\"_\");\n                retStringBuffer.append(mAddresses.get(e.nextElement()));\n            }\n            retString = retStringBuffer.toString();\n        }\n        return retString;\n    }\n\n    // getCompleteName()\n    /**\n     * Is a braodcast requested for all recorded addtional addresses when\n     * sending data to this system?\n     */\n    public boolean getBroadcast() {\n        return mBroadcast;\n    }\n\n    // getBroadcast()\n    /**\n     * Get the maximal age of the data source. The value is in milliseconds.\n     */\n    public int getMaxAge() {\n        return mMaxAge;\n    }\n\n    // getMaxAge()\n    /**\n     * Get the minimal age of the data source. The value is in milliseconds.\n     */\n    public int getMinAge() {\n        return mMinAge;\n    }\n\n    // getMinAge()\n    /**\n     * The given text may contain place markers which will be replaced with\n     * their actual values. Three types of markers are possible:\n     * <ul>\n     * <li>Additional informations which have been set with the\n     * {@link #setAddress(String, String)}method. The key set there is\n     * interpreted as a marker with the format <code>$key$</code>.\n     * <li>WILDCARD separator\n     * <li>Markers for informations on the address. These markers will be\n     * replaced with their actual values for the address of the neighbor-system.\n     * <br>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the interface {@link AdditionalAddress}.<br/>A\n     * broadcast is possible in sending using the addtional address information.\n     * That is the reason for the array return type. Withoout braoadcast only\n     * the first array element is filled.\n     * </ul>\n     * <p>\n     * <b><i>Note: </i> </b>If no marker is found, the text will be returned\n     * without modifications.\n     *\n     * @param text text containing markers\n     * @return text array with replacements for markers or without modifications\n     *         if no marker is found.\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public String[] replaceAllMarkers(String text) throws XException {\n        text = XStringSupport.replaceAll(text, TIMESTAMP, Constants.getDateAsString());\n        /*\n\t\t * 1. Search if a marker in the table of additional values is found. If\n\t\t * yes, replace it.\n\t\t */\n        String key = null;\n        String marker = null;\n        for (Enumeration e = mAddresses.keys(); e.hasMoreElements(); ) {\n            key = (String) e.nextElement();\n            if (!key.equals(ADDITIONAL_ADDRESS) && !key.equals(FILENAME_WILDCARD)) {\n                marker = \"$\" + key + \"$\";\n                if (text.indexOf(marker) >= 0) {\n                    text = text.replaceAll(marker, (String) mAddresses.get(key));\n                }\n            }\n        }\n        /*\n\t\t * 2. Search if a WILDCARD separator in the table is found. If yes,\n\t\t * replace it\n\t\t */\n        if (mAddresses.containsKey(FILENAME_WILDCARD)) {\n            if (text.indexOf(FILENAME_WILDCARD) >= 0) {\n                text = XStringSupport.replaceAll(text, FILENAME_WILDCARD, (String) mAddresses.get(FILENAME_WILDCARD));\n            }\n        }\n        /*\n\t\t * 3. If the XBUSSystem contains an address information, replace markers\n\t\t * for this address.\n\t\t */\n        if (mAddresses.containsKey(ADDITIONAL_ADDRESS)) {\n            AdditionalAddress addAddress = getAdditionalAddressImplementation(getName());\n            if (addAddress.hasMarker(text)) {\n                // The string contains a marker for additional address\n                // information.\n                if (mBroadcast) {\n                    // For broadcast construct one string for each addiotinal\n                    // address.\n                    List addAddresses = addAddress.getAddresses();\n                    int quantAddresses = addAddresses.size();\n                    if (quantAddresses < 1) {\n                        // No additional addresses specified in configuration.\n                        List params = new Vector();\n                        params.add(mName);\n                        params.add(text);\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"5\", params);\n                    }\n                    // if (quantAddresses<1)\n                    String[] result = new String[quantAddresses];\n                    for (int i = 0; i < quantAddresses; i++) result[i] = addAddress.replaceMarker(text, (String) addAddresses.get(i));\n                    return result;\n                } else // then (mBroadcast)\n                {\n                    // Simple addtional address without broadcast.\n                    String[] result = { addAddress.replaceMarker(text, (String) mAddresses.get(ADDITIONAL_ADDRESS)) };\n                    return result;\n                }\n                // else (mBroadcast)\n            } else // then addAddress.hasMarker(text)\n            {\n                // No addtional address marker.\n                String[] result = { text };\n                return result;\n            }\n            // else (addAddress.hasMarker(text))\n        } else // then (mAddresses.containsKey(ADDITIONAL_ADDRESS))\n        {\n            // No addtional address at all.\n            String[] result = { text };\n            return result;\n        }\n        // else (mAddresses.containsKey(ADDITIONAL_ADDRESS))\n    }\n\n    // replaceAllMarkers(String text)\n    /**\n     * Returns the concatenation of name and address of the neighbor-system.\n     *\n     * @see #getCompleteName()\n     * @return concatenation of name and address of the neighbor-system or only\n     *         name if address is not exist\n     */\n    public String toString() {\n        return getCompleteName();\n    }\n\n    // toString()\n    /**\n     * Returns a list of <code>XBUSSystems</code>, generated through the\n     * replacing of all possible place markers.\n     * <p>\n     * <b><i>Note: </i> </b>If there are no place markers in the given text,\n     * only one system with an empty address is in that list.\n     *\n     * @param name the name of the system\n     * @param text eventually containing place markers\n     * @return list of <code>XBUSSystems</code>\n     * @exception XException if any error occurs\n     */\n    static public List getSystems(String name, String text) throws XException {\n        /*\n\t\t * 1. check if the given text contains place markers for informations on\n\t\t * the address, then store list of all configured addresses\n\t\t */\n        Vector additionalAddresses = null;\n        if (hasAdditionalAddressMarker(name, text)) {\n            additionalAddresses = new Vector();\n            List addresses = getAdditionalAddresses(name);\n            for (Iterator it = addresses.iterator(); it.hasNext(); ) {\n                additionalAddresses.add(it.next());\n            }\n        }\n        /*\n\t\t * 2. check if the given text contains WILDCARD separator\n\t\t * \n\t\t */\n        List addressVector = null;\n        Hashtable addressTable = null;\n        if (text.indexOf(XBUSSystem.FILENAME_WILDCARD) >= 0) {\n            // there is no additional informations yet\n            if ((additionalAddresses == null) || (additionalAddresses.isEmpty())) {\n                FileAcceptor acceptor = new FileAcceptor(text);\n                // get an array of strings naming the files and directories in\n                // the directory\n                // denoted by this abstract pathname that were accepted by the\n                // FileAcceptor filter.\n                String[] dummy = new File(text).getParentFile().list(acceptor);\n                String message = \"Found files\";\n                if (dummy != null)\n                    for (int i = 0; i < dummy.length; i++) message = message + \" \" + dummy[i];\n                // save all replacements (wildcards) in vector\n                addressVector = acceptor.getReplacements();\n            } else {\n                addressTable = new Hashtable();\n                // get additional address implementation for this system\n                AdditionalAddress additionalAddressImpl = getAdditionalAddressImplementation(name);\n                // replace place markers in each address\n                for (Iterator it = additionalAddresses.iterator(); it.hasNext(); ) {\n                    String additionalAddress = (String) it.next();\n                    String filename = additionalAddressImpl.replaceMarker(text, additionalAddress);\n                    // initializte filename filter for this filename\n                    FileAcceptor acceptor = new FileAcceptor(filename);\n                    // get an array of strings naming the files and directories\n                    // in the directory denoted by this abstract pathname that\n                    // were accepted by the FileAcceptor filter.\n                    String[] dummy = new File(filename).getParentFile().list(acceptor);\n                    String message = \"Found files\";\n                    for (int i = 0; dummy != null && i < dummy.length; i++) message = message + \" \" + dummy[i];\n                    addressTable.put(additionalAddress, acceptor.getReplacements());\n                }\n            }\n        }\n        /*\n\t\t * 3. construct a system vector a: put each address with its type in\n\t\t * hashtable b: encapsulate this table with name of the system in\n\t\t * XBUSSystem object c: and store this object in vector\n\t\t */\n        Vector retSystems = new Vector();\n        // there are only wildcards\n        if (addressVector != null) {\n            for (Iterator it = addressVector.iterator(); it.hasNext(); ) {\n                Hashtable addresses = new Hashtable();\n                addresses.put(FILENAME_WILDCARD, it.next());\n                retSystems.add(new XBUSSystem(name, addresses));\n            }\n        } else // there are also address implementations\n        if (addressTable != null) {\n            for (Enumeration e = addressTable.keys(); e.hasMoreElements(); ) {\n                String additionalAddress = (String) e.nextElement();\n                List wildcardReplacements = (List) addressTable.get(additionalAddress);\n                for (Iterator it = wildcardReplacements.iterator(); it.hasNext(); ) {\n                    Hashtable addresses = new Hashtable();\n                    addresses.put(ADDITIONAL_ADDRESS, additionalAddress);\n                    addresses.put(FILENAME_WILDCARD, it.next());\n                    retSystems.add(new XBUSSystem(name, addresses));\n                }\n            }\n        } else // if only additional address implementation exist\n        if (additionalAddresses != null) {\n            for (Iterator it = additionalAddresses.iterator(); it.hasNext(); ) {\n                Hashtable addresses = new Hashtable();\n                addresses.put(ADDITIONAL_ADDRESS, it.next());\n                retSystems.add(new XBUSSystem(name, addresses));\n            }\n        } else // there is no addresses exist\n        {\n            retSystems.add(new XBUSSystem(name));\n        }\n        return retSystems;\n    }\n\n    /**\n     * Tests if the given text contains place markers for informations on the\n     * address.\n     * <p>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the {@link net.sf.xbus.base.AdditionalAddress}\n     * interface.\n     *\n     * @see #getAdditionalAddressImplementation(String)\n     * @param systemNAme name of the system\n     * @param text text eventually containing markers\n     * @return true if text contains markers; false otherwise\n     * @exception XException if any error occurs\n     */\n    static private boolean hasAdditionalAddressMarker(String systemName, String text) throws XException {\n        AdditionalAddress additionalAddressImplementation = getAdditionalAddressImplementation(systemName);\n        if (additionalAddressImplementation != null) {\n            return additionalAddressImplementation.hasMarker(text);\n        } else {\n            return false;\n        }\n    }\n\n    // hasAdditionalAddressMarker(String systemName,String text)\n    /**\n     * Returns a list of all configured addresses for the given system name.\n     * <p>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the {@link net.sf.xbus.base.AdditionalAddress}\n     * interface.\n     *\n     * @see #getAdditionalAddressImplementation(String)\n     * @param systemName the name of the system\n     * @return list of addresses\n     * @exception XException if any error occurs\n     */\n    static private List getAdditionalAddresses(String systemName) throws XException {\n        return getAdditionalAddressImplementation(systemName).getAddresses();\n    }\n\n    // getAdditionalAddresses(String systemName)\n    /**\n     * Gets the address implementation ({@link AdditionalAddress}) for the\n     * given system name.\n     * <p>\n     * <b><i>Note: </i> </b> If there is no address implementation for the\n     * given system created yet, then creates this method one first. <br>\n     * Address implementation name is read from the configuration: <br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>System_ </b> <i>SystemName\n     * </i> <b>_AddressImplementation </b> <br>\n     * If there is no implementation for the address is provided with this\n     * system, there must be a global entry used.: <br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n     * <b>Base_System_AddressImplementation </b>\n     *\n     * @param systemName the name of the system\n     * @return address implementation ({@link AdditionalAddress}) for the\n     *         given system name\n     * @exception XException if any error occurs\n     */\n    public static AdditionalAddress getAdditionalAddressImplementation(String systemName) throws XException {\n        if (!mAdditionalAddressImplementations.contains(systemName)) {\n            /*\n\t\t\t * If there is no address implementation for the current system\n\t\t\t * created yet, we will create it and put it in the Hashtable.\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            /*\n\t\t\t * If an implementation for the address is provided with the system,\n\t\t\t * than this implementation is getting used.\n\t\t\t */\n            String addressImplementationNameShort = config.getValueOptional(Constants.CHAPTER_SYSTEM, systemName, ADDITIONAL_ADDRESS);\n            if (addressImplementationNameShort == null) {\n                /*\n\t\t\t\t * If there is no system specific implementation, there maybe is\n\t\t\t\t * a global entry.\n\t\t\t\t */\n                addressImplementationNameShort = config.getValueOptional(\"Base\", Constants.CHAPTER_SYSTEM, ADDITIONAL_ADDRESS);\n            }\n            if (addressImplementationNameShort != null) {\n                String addressImplementationName = Configuration.getClass(\"AdressImplementation\", addressImplementationNameShort);\n                mAdditionalAddressImplementations.put(systemName, ReflectionSupport.createObject(addressImplementationName));\n            }\n        }\n        return (AdditionalAddress) mAdditionalAddressImplementations.get(systemName);\n    }\n\n    // getAdditionalAddressImplementation(String systemName)\n    /**\n     * Check if the given address string does contain a reference to addtional\n     * address information. Update the list of addresses and broadcast flag\n     * accordingly.\n     *\n     * @param text the address text (e.g. file path)\n     */\n    public void getBroadcastData(String text) throws XException {\n        if (hasAdditionalAddressMarker(mName, text))\n            // Reference to additional addresses given.\n            mAddresses.put(ADDITIONAL_ADDRESS, \"broadcast\");\n        else\n            // No reference to additional addresses given.\n            mBroadcast = false;\n    }\n    // getBroadcastData(String text)\n}\n// XBUSSystem\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xbussystem/XBUSSystemTest1.java",
		"test_prompt": "// XBUSSystemTest1.java\npackage net.sf.xbus.base.xbussystem;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XBUSSystem}.\n* It contains ten unit test cases for the {@link XBUSSystem#getSystems(String, String)} method.\n*/\nclass XBUSSystemTest1 {"
	},
	{
		"original_code": "// XBUSSystem.java\npackage net.sf.xbus.base.xbussystem;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * <code>XBUSSystem</code> is the representation of any neighbor-systems\n * respectively their interfaces. It consists of two informations:\n * <p>\n * <ul>\n * <li>The name of the system is used to identify the system.\n * <li>Additionally an adress might be available.\n * </ul>\n */\npublic class XBUSSystem {\n\n    public static final String FILENAME_WILDCARD = \"$WILDCARD$\";\n\n    public static final String FILENAME_WILDCARD_XML = \"WILDCARD\";\n\n    private static final String ADDITIONAL_ADDRESS = \"AddressImplementation\";\n\n    private static final String TIMESTAMP = \"$TIMESTAMP$\";\n\n    /**\n     * Holds all address informations of the neighbor-system. Each address\n     * stored as value against its typ.\n     * <p>\n     * <i>Possible addresses: </i> <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value(Example)</th>\n     * </tr>\n     * <tr>\n     * <td>AddressImplementation</td>\n     * <td>Test/Wholesale/std$DEALERNUMBER$.cnf</td>\n     * </tr>\n     * <tr>\n     * <td>WILDCARD</td>\n     * <td>parts</td>\n     * </tr>\n     * <tr>\n     * <td><i>example: </i>user</td>\n     * <td>KS</td>\n     * </tr>\n     * </table>\n     */\n    private Hashtable mAddresses = new Hashtable();\n\n    /**\n     * Is a braodcast requested for all recorded addtional addresses when\n     * sending data to this system?\n     */\n    private boolean mBroadcast;\n\n    /**\n     * Name of the neighbor-system\n     */\n    private String mName = null;\n\n    /**\n     * Holds all AdditionalAddress objects of this neighbor-system. Each object\n     * stored as value against the name of this neigbor-system.\n     * <p>\n     * <i>Example: </i> <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value</th>\n     * </tr>\n     * <tr>\n     * <td>PartsOrderAutoline</td>\n     * <td>new Dealer()</td>\n     * </tr>\n     * </table\n     */\n    private static Hashtable mAdditionalAddressImplementations = new Hashtable();\n\n    /**\n     * <code>mMinAge</code> can be used to filter data sources due to their\n     * age to ignore all those, which are too fresh. This can be used for access\n     * synchronisation: Putting in the maximum time for constructing a file\n     * ensures that the file transfer does not start while during writing the\n     * file. The value is in milliseconds.\n     */\n    private int mMinAge;\n\n    /**\n     * <code>mMaxAge</code> can be used to filter data sources due to their\n     * age to ignore all those, which are too old. This can be used for ignoring\n     * outdated data sources from former failed data transfers. The value is in\n     * milliseconds.\n     */\n    private int mMaxAge;\n\n    /**\n     * Constructs the <code>XBUSSystem</code> without an address.\n     *\n     * @param name name of the neighbor-system\n     */\n    public XBUSSystem(String name) throws XException {\n        mName = name;\n        // Look for the (optional) restrictions to data source age.\n        Configuration config = Configuration.getInstance();\n        mMinAge = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, name, \"MinAge\") * 1000;\n        mMaxAge = config.getValueAsIntOptional(Constants.CHAPTER_SYSTEM, name, \"MaxAge\") * 1000;\n    }\n\n    // XBUSSystem(String name)\n    /**\n     * Constructs the <code>XBUSSystem</code> from the name fo the\n     * neighbor-system and all address informations for this system\n     *\n     * @param name name of the neighbor-system\n     * @param addresses name of the address\n     */\n    public XBUSSystem(String name, Hashtable addresses) throws XException {\n        this(name);\n        mAddresses = addresses;\n    }\n\n    // XBUSSystem(String name, Hashtable addresses)\n    /**\n     * Constructs the <code>XBUSSystem</code> from the name fo the\n     * neighbor-system and all address informations for this system and the flag\n     * if a broadcast is requested to this system. The addresses do not\n     * necessarily contain the reference to additional address information\n     * necessary for a broadcast.\n     *\n     * @param name name of the neighbor-system\n     * @param addresses name of the address\n     * @param broadcast is broadcast to be done when sending?\n     */\n    public XBUSSystem(String name, Hashtable addresses, boolean broadcast) throws XException {\n        this(name, addresses);\n        mBroadcast = broadcast;\n    }\n\n    // XBUSSystem(String name, Hashtable addresses, boolean broadcast)\n    /**\n     * Returns the name of the neighbor-system.\n     *\n     * @return name of the neighbor-system\n     */\n    public String getName() {\n        return mName;\n    }\n\n    // getName()\n    /**\n     * Returns all address informations of the neighbor-system. Each address\n     * stored as value against its typ.\n     * <p>\n     * <i>Example: </i>\n     * <p>\n     * <table border>\n     * <tr>\n     * <th>Key</th>\n     * <th>Value</th>\n     * </tr>\n     * <tr>\n     * <td>AddressImplementation</td>\n     * <td>Test/Wholesale/std$DEALERNUMBER$.cnf</td>\n     * </tr>\n     * <tr>\n     * <td>WILDCARD</td>\n     * <td>parts</td>\n     * </tr>\n     * <tr>\n     * <td>user</td>\n     * <td>KS</td>\n     * </tr>\n     * </table>\n     *\n     * @return all addresses of the neighbor-system\n     */\n    public Hashtable getAddresses() {\n        return mAddresses;\n    }\n\n    // getAddresses()\n    /**\n     * Sets all address informations for the neighbor-system.\n     *\n     * @param addresses Hashtable of the addresses\n     */\n    /*\n\t * private void setAddresses(Hashtable addresses) { mAddresses = addresses; } //\n\t * setAddresses(Hashtable addresses)\n\t */\n    /**\n     * Sets one address information of the neighbor-system.\n     *\n     * @param name typ of additional information\n     * @param address additional inrformation eventually containing markers with\n     *            the format <code>$key$</code>.\n     */\n    public void setAddress(String name, String address) {\n        mAddresses.put(name, address);\n    }\n\n    // setAddress(String name, String address)\n    /**\n     * <dl>\n     * <dt>Returns the concatenation of name and all addresses of the\n     * neighbor-system by <b>\"_\" </b> separated.\n     * <dd><i>Example: </i>&nbsp;&nbsp;&nbsp;PartsOrderAutoline_12345\n     * <p>\n     * <dt>If no address information is found, the name of the neighbor-system\n     * will be returned. <br>\n     * <dd><i>Example: </i>&nbsp;&nbsp;&nbsp;PartsOrderAutoline\n     * <p>\n     * </dl>\n     *\n     * @return concatenation of name and all addresses of the neighbor-system or\n     *         only name if addresses are not exist\n     */\n    public String getCompleteName() {\n        String retString;\n        if (mAddresses.isEmpty()) {\n            retString = mName;\n        } else {\n            StringBuffer retStringBuffer = new StringBuffer(mName);\n            for (Enumeration e = mAddresses.keys(); e.hasMoreElements(); ) {\n                retStringBuffer.append(\"_\");\n                retStringBuffer.append(mAddresses.get(e.nextElement()));\n            }\n            retString = retStringBuffer.toString();\n        }\n        return retString;\n    }\n\n    // getCompleteName()\n    /**\n     * Is a braodcast requested for all recorded addtional addresses when\n     * sending data to this system?\n     */\n    public boolean getBroadcast() {\n        return mBroadcast;\n    }\n\n    // getBroadcast()\n    /**\n     * Get the maximal age of the data source. The value is in milliseconds.\n     */\n    public int getMaxAge() {\n        return mMaxAge;\n    }\n\n    // getMaxAge()\n    /**\n     * Get the minimal age of the data source. The value is in milliseconds.\n     */\n    public int getMinAge() {\n        return mMinAge;\n    }\n\n    // getMinAge()\n    /**\n     * The given text may contain place markers which will be replaced with\n     * their actual values. Three types of markers are possible:\n     * <ul>\n     * <li>Additional informations which have been set with the\n     * {@link #setAddress(String, String)}method. The key set there is\n     * interpreted as a marker with the format <code>$key$</code>.\n     * <li>WILDCARD separator\n     * <li>Markers for informations on the address. These markers will be\n     * replaced with their actual values for the address of the neighbor-system.\n     * <br>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the interface {@link AdditionalAddress}.<br/>A\n     * broadcast is possible in sending using the addtional address information.\n     * That is the reason for the array return type. Withoout braoadcast only\n     * the first array element is filled.\n     * </ul>\n     * <p>\n     * <b><i>Note: </i> </b>If no marker is found, the text will be returned\n     * without modifications.\n     *\n     * @param text text containing markers\n     * @return text array with replacements for markers or without modifications\n     *         if no marker is found.\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public String[] replaceAllMarkers(String text) throws XException {\n        text = XStringSupport.replaceAll(text, TIMESTAMP, Constants.getDateAsString());\n        /*\n\t\t * 1. Search if a marker in the table of additional values is found. If\n\t\t * yes, replace it.\n\t\t */\n        String key = null;\n        String marker = null;\n        for (Enumeration e = mAddresses.keys(); e.hasMoreElements(); ) {\n            key = (String) e.nextElement();\n            if (!key.equals(ADDITIONAL_ADDRESS) && !key.equals(FILENAME_WILDCARD)) {\n                marker = \"$\" + key + \"$\";\n                if (text.indexOf(marker) >= 0) {\n                    text = text.replaceAll(marker, (String) mAddresses.get(key));\n                }\n            }\n        }\n        /*\n\t\t * 2. Search if a WILDCARD separator in the table is found. If yes,\n\t\t * replace it\n\t\t */\n        if (mAddresses.containsKey(FILENAME_WILDCARD)) {\n            if (text.indexOf(FILENAME_WILDCARD) >= 0) {\n                text = XStringSupport.replaceAll(text, FILENAME_WILDCARD, (String) mAddresses.get(FILENAME_WILDCARD));\n            }\n        }\n        /*\n\t\t * 3. If the XBUSSystem contains an address information, replace markers\n\t\t * for this address.\n\t\t */\n        if (mAddresses.containsKey(ADDITIONAL_ADDRESS)) {\n            AdditionalAddress addAddress = getAdditionalAddressImplementation(getName());\n            if (addAddress.hasMarker(text)) {\n                // The string contains a marker for additional address\n                // information.\n                if (mBroadcast) {\n                    // For broadcast construct one string for each addiotinal\n                    // address.\n                    List addAddresses = addAddress.getAddresses();\n                    int quantAddresses = addAddresses.size();\n                    if (quantAddresses < 1) {\n                        // No additional addresses specified in configuration.\n                        List params = new Vector();\n                        params.add(mName);\n                        params.add(text);\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"5\", params);\n                    }\n                    // if (quantAddresses<1)\n                    String[] result = new String[quantAddresses];\n                    for (int i = 0; i < quantAddresses; i++) result[i] = addAddress.replaceMarker(text, (String) addAddresses.get(i));\n                    return result;\n                } else // then (mBroadcast)\n                {\n                    // Simple addtional address without broadcast.\n                    String[] result = { addAddress.replaceMarker(text, (String) mAddresses.get(ADDITIONAL_ADDRESS)) };\n                    return result;\n                }\n                // else (mBroadcast)\n            } else // then addAddress.hasMarker(text)\n            {\n                // No addtional address marker.\n                String[] result = { text };\n                return result;\n            }\n            // else (addAddress.hasMarker(text))\n        } else // then (mAddresses.containsKey(ADDITIONAL_ADDRESS))\n        {\n            // No addtional address at all.\n            String[] result = { text };\n            return result;\n        }\n        // else (mAddresses.containsKey(ADDITIONAL_ADDRESS))\n    }\n\n    // replaceAllMarkers(String text)\n    /**\n     * Returns the concatenation of name and address of the neighbor-system.\n     *\n     * @see #getCompleteName()\n     * @return concatenation of name and address of the neighbor-system or only\n     *         name if address is not exist\n     */\n    public String toString() {\n        return getCompleteName();\n    }\n\n    // toString()\n    /**\n     * Returns a list of <code>XBUSSystems</code>, generated through the\n     * replacing of all possible place markers.\n     * <p>\n     * <b><i>Note: </i> </b>If there are no place markers in the given text,\n     * only one system with an empty address is in that list.\n     *\n     * @param name the name of the system\n     * @param text eventually containing place markers\n     * @return list of <code>XBUSSystems</code>\n     * @exception XException if any error occurs\n     */\n    static public List getSystems(String name, String text) throws XException {\n        /*\n\t\t * 1. check if the given text contains place markers for informations on\n\t\t * the address, then store list of all configured addresses\n\t\t */\n        Vector additionalAddresses = null;\n        if (hasAdditionalAddressMarker(name, text)) {\n            additionalAddresses = new Vector();\n            List addresses = getAdditionalAddresses(name);\n            for (Iterator it = addresses.iterator(); it.hasNext(); ) {\n                additionalAddresses.add(it.next());\n            }\n        }\n        /*\n\t\t * 2. check if the given text contains WILDCARD separator\n\t\t * \n\t\t */\n        List addressVector = null;\n        Hashtable addressTable = null;\n        if (text.indexOf(XBUSSystem.FILENAME_WILDCARD) >= 0) {\n            // there is no additional informations yet\n            if ((additionalAddresses == null) || (additionalAddresses.isEmpty())) {\n                FileAcceptor acceptor = new FileAcceptor(text);\n                // get an array of strings naming the files and directories in\n                // the directory\n                // denoted by this abstract pathname that were accepted by the\n                // FileAcceptor filter.\n                String[] dummy = new File(text).getParentFile().list(acceptor);\n                String message = \"Found files\";\n                if (dummy != null)\n                    for (int i = 0; i < dummy.length; i++) message = message + \" \" + dummy[i];\n                // save all replacements (wildcards) in vector\n                addressVector = acceptor.getReplacements();\n            } else {\n                addressTable = new Hashtable();\n                // get additional address implementation for this system\n                AdditionalAddress additionalAddressImpl = getAdditionalAddressImplementation(name);\n                // replace place markers in each address\n                for (Iterator it = additionalAddresses.iterator(); it.hasNext(); ) {\n                    String additionalAddress = (String) it.next();\n                    String filename = additionalAddressImpl.replaceMarker(text, additionalAddress);\n                    // initializte filename filter for this filename\n                    FileAcceptor acceptor = new FileAcceptor(filename);\n                    // get an array of strings naming the files and directories\n                    // in the directory denoted by this abstract pathname that\n                    // were accepted by the FileAcceptor filter.\n                    String[] dummy = new File(filename).getParentFile().list(acceptor);\n                    String message = \"Found files\";\n                    for (int i = 0; dummy != null && i < dummy.length; i++) message = message + \" \" + dummy[i];\n                    addressTable.put(additionalAddress, acceptor.getReplacements());\n                }\n            }\n        }\n        /*\n\t\t * 3. construct a system vector a: put each address with its type in\n\t\t * hashtable b: encapsulate this table with name of the system in\n\t\t * XBUSSystem object c: and store this object in vector\n\t\t */\n        Vector retSystems = new Vector();\n        // there are only wildcards\n        if (addressVector != null) {\n            for (Iterator it = addressVector.iterator(); it.hasNext(); ) {\n                Hashtable addresses = new Hashtable();\n                addresses.put(FILENAME_WILDCARD, it.next());\n                retSystems.add(new XBUSSystem(name, addresses));\n            }\n        } else // there are also address implementations\n        if (addressTable != null) {\n            for (Enumeration e = addressTable.keys(); e.hasMoreElements(); ) {\n                String additionalAddress = (String) e.nextElement();\n                List wildcardReplacements = (List) addressTable.get(additionalAddress);\n                for (Iterator it = wildcardReplacements.iterator(); it.hasNext(); ) {\n                    Hashtable addresses = new Hashtable();\n                    addresses.put(ADDITIONAL_ADDRESS, additionalAddress);\n                    addresses.put(FILENAME_WILDCARD, it.next());\n                    retSystems.add(new XBUSSystem(name, addresses));\n                }\n            }\n        } else // if only additional address implementation exist\n        if (additionalAddresses != null) {\n            for (Iterator it = additionalAddresses.iterator(); it.hasNext(); ) {\n                Hashtable addresses = new Hashtable();\n                addresses.put(ADDITIONAL_ADDRESS, it.next());\n                retSystems.add(new XBUSSystem(name, addresses));\n            }\n        } else // there is no addresses exist\n        {\n            retSystems.add(new XBUSSystem(name));\n        }\n        return retSystems;\n    }\n\n    /**\n     * Tests if the given text contains place markers for informations on the\n     * address.\n     * <p>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the {@link net.sf.xbus.base.AdditionalAddress}\n     * interface.\n     *\n     * @see #getAdditionalAddressImplementation(String)\n     * @param systemNAme name of the system\n     * @param text text eventually containing markers\n     * @return true if text contains markers; false otherwise\n     * @exception XException if any error occurs\n     */\n    static private boolean hasAdditionalAddressMarker(String systemName, String text) throws XException {\n        AdditionalAddress additionalAddressImplementation = getAdditionalAddressImplementation(systemName);\n        if (additionalAddressImplementation != null) {\n            return additionalAddressImplementation.hasMarker(text);\n        } else {\n            return false;\n        }\n    }\n\n    // hasAdditionalAddressMarker(String systemName,String text)\n    /**\n     * Returns a list of all configured addresses for the given system name.\n     * <p>\n     * The implementation of this functionality is realized in a dedicated\n     * class, implementing the {@link net.sf.xbus.base.AdditionalAddress}\n     * interface.\n     *\n     * @see #getAdditionalAddressImplementation(String)\n     * @param systemName the name of the system\n     * @return list of addresses\n     * @exception XException if any error occurs\n     */\n    static private List getAdditionalAddresses(String systemName) throws XException {\n        return getAdditionalAddressImplementation(systemName).getAddresses();\n    }\n\n    // getAdditionalAddresses(String systemName)\n    /**\n     * Gets the address implementation ({@link AdditionalAddress}) for the\n     * given system name.\n     * <p>\n     * <b><i>Note: </i> </b> If there is no address implementation for the\n     * given system created yet, then creates this method one first. <br>\n     * Address implementation name is read from the configuration: <br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>System_ </b> <i>SystemName\n     * </i> <b>_AddressImplementation </b> <br>\n     * If there is no implementation for the address is provided with this\n     * system, there must be a global entry used.: <br>\n     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n     * <b>Base_System_AddressImplementation </b>\n     *\n     * @param systemName the name of the system\n     * @return address implementation ({@link AdditionalAddress}) for the\n     *         given system name\n     * @exception XException if any error occurs\n     */\n    public static AdditionalAddress getAdditionalAddressImplementation(String systemName) throws XException {\n        if (!mAdditionalAddressImplementations.contains(systemName)) {\n            /*\n\t\t\t * If there is no address implementation for the current system\n\t\t\t * created yet, we will create it and put it in the Hashtable.\n\t\t\t */\n            Configuration config = Configuration.getInstance();\n            /*\n\t\t\t * If an implementation for the address is provided with the system,\n\t\t\t * than this implementation is getting used.\n\t\t\t */\n            String addressImplementationNameShort = config.getValueOptional(Constants.CHAPTER_SYSTEM, systemName, ADDITIONAL_ADDRESS);\n            if (addressImplementationNameShort == null) {\n                /*\n\t\t\t\t * If there is no system specific implementation, there maybe is\n\t\t\t\t * a global entry.\n\t\t\t\t */\n                addressImplementationNameShort = config.getValueOptional(\"Base\", Constants.CHAPTER_SYSTEM, ADDITIONAL_ADDRESS);\n            }\n            if (addressImplementationNameShort != null) {\n                String addressImplementationName = Configuration.getClass(\"AdressImplementation\", addressImplementationNameShort);\n                mAdditionalAddressImplementations.put(systemName, ReflectionSupport.createObject(addressImplementationName));\n            }\n        }\n        return (AdditionalAddress) mAdditionalAddressImplementations.get(systemName);\n    }\n\n    // getAdditionalAddressImplementation(String systemName)\n    /**\n     * Check if the given address string does contain a reference to addtional\n     * address information. Update the list of addresses and broadcast flag\n     * accordingly.\n     *\n     * @param text the address text (e.g. file path)\n     */\n    public void getBroadcastData(String text) throws XException {\n        if (hasAdditionalAddressMarker(mName, text))\n            // Reference to additional addresses given.\n            mAddresses.put(ADDITIONAL_ADDRESS, \"broadcast\");\n        else\n            // No reference to additional addresses given.\n            mBroadcast = false;\n    }\n    // getBroadcastData(String text)\n}\n// XBUSSystem\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xbussystem/XBUSSystemTest2.java",
		"test_prompt": "// XBUSSystemTest2.java\npackage net.sf.xbus.base.xbussystem;\n\nimport java.io.File;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.reflection.ReflectionSupport;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XBUSSystem}.\n* It contains ten unit test cases for the {@link XBUSSystem#getAdditionalAddressImplementation(String)} method.\n*/\nclass XBUSSystemTest2 {"
	},
	{
		"original_code": "// CardinalityStrings.java\npackage net.sf.xbus.base.core.strings;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>CardinalityStrings</code> offers some methods for treating\n * cardinality strings like \"1..*\". Allowed cardinality string consist\n * <ul>\n * <li>only of a single strictly positive integer - fixed cardinality</li>\n * <li>of an interval with \"..\" - variable cardinality</li>\n * </ul>\n * In case of an interval the lower bound must be a positive integer (including\n * zero) and the upper bound must be a strictly positive integer or \"*\". \"*\"\n * means \"arbitrary\".\n *\n * @author Stephan D�wel\n */\npublic class CardinalityStrings {\n\n    /**\n     * <code>isCardinalityValid</code> checks if a string is a well-formed\n     * cardinality.\n     *\n     * @param card the string to check\n     * @return <code>true</code> for well-formed cardinality string, otherwise\n     *         <code>false</code>\n     */\n    public static boolean isCardinalityValid(String card) {\n        int dots = card.indexOf(\"..\");\n        // Search for interval dots\n        if (dots == -1)\n            // no interval\n            dots = card.length();\n        // to check everything till the end\n        boolean result = true;\n        if (dots + 2 == card.length())\n            // Dots must be followed by a number or \"*\".\n            result = false;\n        else {\n            // No dots or something behind the dots.\n            try // for conversions to numbers\n            {\n                // A single value or a lower bound must be positive integers.\n                int low = Integer.parseInt(card.substring(0, dots));\n                if (low < 0)\n                    result = false;\n                else if (dots == card.length() && low == 0)\n                    // A single - not interval - value is zero but should be\n                    // strictly positive.\n                    result = false;\n                else {\n                    // Look if there is something behind dots.\n                    if (dots < card.length() - 3 || dots == card.length() - 3 && card.charAt(dots + 2) != '*') {\n                        // Just \"*\" would be fine, but otherwise it must be an\n                        // integer\n                        // not smaller than the lower bound.\n                        int high = Integer.parseInt(card.substring(dots + 2));\n                        if (low > high)\n                            result = false;\n                    } else // if (dots<card.length()-3 || card.charAt(dots+2)!='*')\n                    if (dots == card.length() - 2)\n                        // The dots are the last characters in the string.\n                        result = false;\n                }\n                // else (low<0)\n            }// try\n             catch (NumberFormatException e) {\n                // Single value, lower or upper bound no numbers (upper bound\n                // not \"*\")\n                result = false;\n            }\n            // catch\n        }\n        // else (dots+2==card.length())\n        return result;\n    }\n\n    // isCardinalityValid(String card)\n    /**\n     * <code>isCardinalityInterval</code> checks if a given string is a\n     * cardinatily interval like \"1..*\".\n     *\n     * @param card the string to check\n     * @param isKnownAsValidCardinality Is the string already known as a\n     *            well-formed cardinality specification? Otherwise this fact\n     *            will be checked.\n     * @return <code>true</code> for a well-formed cardinality interval,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isCardinalityInterval(String card, boolean isKnownAsValidCardinality) {\n        if (!isKnownAsValidCardinality)\n            isKnownAsValidCardinality = isCardinalityValid(card);\n        // Ensure that the string is a well-formed cardinality string.\n        if (isKnownAsValidCardinality)\n            isKnownAsValidCardinality = (card.indexOf(\"..\") > -1);\n        // It is an interval iff it contains dots.\n        return isKnownAsValidCardinality;\n    }\n\n    // isCardinalityInterval(String card, boolean isKnownAsValidCardinality)\n    /**\n     * <code>getCardinalityLow</code> extracts the lower bound from a\n     * cardinality string like \"1..*\".\n     *\n     * @param card the cardinality string\n     * @param isKnownAsCardinalityInterval Is the cardinality string already\n     *            known as a well-formed interval specification? Otherwise this\n     *            fact will be checked.\n     * @return the extracted lower bound which must be an positive integer\n     * @throws XException in case of a mal-formed cardinality string or a\n     *             negative lower bound\n     */\n    public static int getCardinalityLow(String card, boolean isKnownAsCardinalityInterval) throws XException {\n        if (!isKnownAsCardinalityInterval)\n            isKnownAsCardinalityInterval = isCardinalityInterval(card, false);\n        // Ensure that the string is a cardinality interval.\n        int result = -1;\n        if (isKnownAsCardinalityInterval)\n            // NumberFormatException already checked\n            result = Integer.parseInt(card.substring(0, card.indexOf(\"..\")));\n        else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_STRINGS, \"1\");\n        }\n        return result;\n    }\n\n    // getCardinalityLow(String card, boolean isKnownAsCardinalityInterval)\n    /**\n     * <code>getCardinalityHigh</code> extracts the upper bound from a\n     * cardinality string like \"1..*\".\n     *\n     * @param card the cardinality string\n     * @param isKnownAsCardinalityInterval Is the cardinality string already\n     *            known as a well-formed interval specification? Otherwise this\n     *            fact will be checked.\n     * @return the extracted upper bound which must be an positive integer,\n     *         <code>Integer.MAX_VALUE</code> in case of a \"*\"\n     * @throws XException in case of a mal-formed cardinality string or a\n     *             negative upper bound\n     */\n    public static int getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval) throws XException {\n        if (!isKnownAsCardinalityInterval)\n            isKnownAsCardinalityInterval = isCardinalityInterval(card, false);\n        // Ensure that the string is a cardinality interval.\n        int result = -1;\n        if (isKnownAsCardinalityInterval) {\n            int dots = card.indexOf(\"..\");\n            if (dots == card.length() - 3 && card.charAt(dots + 2) == '*')\n                // no upper limit\n                result = Integer.MAX_VALUE;\n            else\n                // NumberFormatException already checked\n                result = Integer.parseInt(card.substring(dots + 2));\n        } else\n            // then (isKnownAsCardinalityInterval)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_STRINGS, \"1\");\n        return result;\n    }\n    // getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval)\n}\n// CardinalityStrings\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/strings/CardinalityStringsTest0.java",
		"test_prompt": "// CardinalityStringsTest0.java\npackage net.sf.xbus.base.core.strings;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CardinalityStrings}.\n* It contains ten unit test cases for the {@link CardinalityStrings#isCardinalityValid(String)} method.\n*/\nclass CardinalityStringsTest0 {"
	},
	{
		"original_code": "// CardinalityStrings.java\npackage net.sf.xbus.base.core.strings;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>CardinalityStrings</code> offers some methods for treating\n * cardinality strings like \"1..*\". Allowed cardinality string consist\n * <ul>\n * <li>only of a single strictly positive integer - fixed cardinality</li>\n * <li>of an interval with \"..\" - variable cardinality</li>\n * </ul>\n * In case of an interval the lower bound must be a positive integer (including\n * zero) and the upper bound must be a strictly positive integer or \"*\". \"*\"\n * means \"arbitrary\".\n *\n * @author Stephan D�wel\n */\npublic class CardinalityStrings {\n\n    /**\n     * <code>isCardinalityValid</code> checks if a string is a well-formed\n     * cardinality.\n     *\n     * @param card the string to check\n     * @return <code>true</code> for well-formed cardinality string, otherwise\n     *         <code>false</code>\n     */\n    public static boolean isCardinalityValid(String card) {\n        int dots = card.indexOf(\"..\");\n        // Search for interval dots\n        if (dots == -1)\n            // no interval\n            dots = card.length();\n        // to check everything till the end\n        boolean result = true;\n        if (dots + 2 == card.length())\n            // Dots must be followed by a number or \"*\".\n            result = false;\n        else {\n            // No dots or something behind the dots.\n            try // for conversions to numbers\n            {\n                // A single value or a lower bound must be positive integers.\n                int low = Integer.parseInt(card.substring(0, dots));\n                if (low < 0)\n                    result = false;\n                else if (dots == card.length() && low == 0)\n                    // A single - not interval - value is zero but should be\n                    // strictly positive.\n                    result = false;\n                else {\n                    // Look if there is something behind dots.\n                    if (dots < card.length() - 3 || dots == card.length() - 3 && card.charAt(dots + 2) != '*') {\n                        // Just \"*\" would be fine, but otherwise it must be an\n                        // integer\n                        // not smaller than the lower bound.\n                        int high = Integer.parseInt(card.substring(dots + 2));\n                        if (low > high)\n                            result = false;\n                    } else // if (dots<card.length()-3 || card.charAt(dots+2)!='*')\n                    if (dots == card.length() - 2)\n                        // The dots are the last characters in the string.\n                        result = false;\n                }\n                // else (low<0)\n            }// try\n             catch (NumberFormatException e) {\n                // Single value, lower or upper bound no numbers (upper bound\n                // not \"*\")\n                result = false;\n            }\n            // catch\n        }\n        // else (dots+2==card.length())\n        return result;\n    }\n\n    // isCardinalityValid(String card)\n    /**\n     * <code>isCardinalityInterval</code> checks if a given string is a\n     * cardinatily interval like \"1..*\".\n     *\n     * @param card the string to check\n     * @param isKnownAsValidCardinality Is the string already known as a\n     *            well-formed cardinality specification? Otherwise this fact\n     *            will be checked.\n     * @return <code>true</code> for a well-formed cardinality interval,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isCardinalityInterval(String card, boolean isKnownAsValidCardinality) {\n        if (!isKnownAsValidCardinality)\n            isKnownAsValidCardinality = isCardinalityValid(card);\n        // Ensure that the string is a well-formed cardinality string.\n        if (isKnownAsValidCardinality)\n            isKnownAsValidCardinality = (card.indexOf(\"..\") > -1);\n        // It is an interval iff it contains dots.\n        return isKnownAsValidCardinality;\n    }\n\n    // isCardinalityInterval(String card, boolean isKnownAsValidCardinality)\n    /**\n     * <code>getCardinalityLow</code> extracts the lower bound from a\n     * cardinality string like \"1..*\".\n     *\n     * @param card the cardinality string\n     * @param isKnownAsCardinalityInterval Is the cardinality string already\n     *            known as a well-formed interval specification? Otherwise this\n     *            fact will be checked.\n     * @return the extracted lower bound which must be an positive integer\n     * @throws XException in case of a mal-formed cardinality string or a\n     *             negative lower bound\n     */\n    public static int getCardinalityLow(String card, boolean isKnownAsCardinalityInterval) throws XException {\n        if (!isKnownAsCardinalityInterval)\n            isKnownAsCardinalityInterval = isCardinalityInterval(card, false);\n        // Ensure that the string is a cardinality interval.\n        int result = -1;\n        if (isKnownAsCardinalityInterval)\n            // NumberFormatException already checked\n            result = Integer.parseInt(card.substring(0, card.indexOf(\"..\")));\n        else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_STRINGS, \"1\");\n        }\n        return result;\n    }\n\n    // getCardinalityLow(String card, boolean isKnownAsCardinalityInterval)\n    /**\n     * <code>getCardinalityHigh</code> extracts the upper bound from a\n     * cardinality string like \"1..*\".\n     *\n     * @param card the cardinality string\n     * @param isKnownAsCardinalityInterval Is the cardinality string already\n     *            known as a well-formed interval specification? Otherwise this\n     *            fact will be checked.\n     * @return the extracted upper bound which must be an positive integer,\n     *         <code>Integer.MAX_VALUE</code> in case of a \"*\"\n     * @throws XException in case of a mal-formed cardinality string or a\n     *             negative upper bound\n     */\n    public static int getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval) throws XException {\n        if (!isKnownAsCardinalityInterval)\n            isKnownAsCardinalityInterval = isCardinalityInterval(card, false);\n        // Ensure that the string is a cardinality interval.\n        int result = -1;\n        if (isKnownAsCardinalityInterval) {\n            int dots = card.indexOf(\"..\");\n            if (dots == card.length() - 3 && card.charAt(dots + 2) == '*')\n                // no upper limit\n                result = Integer.MAX_VALUE;\n            else\n                // NumberFormatException already checked\n                result = Integer.parseInt(card.substring(dots + 2));\n        } else\n            // then (isKnownAsCardinalityInterval)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_STRINGS, \"1\");\n        return result;\n    }\n    // getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval)\n}\n// CardinalityStrings\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/strings/CardinalityStringsTest1.java",
		"test_prompt": "// CardinalityStringsTest1.java\npackage net.sf.xbus.base.core.strings;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CardinalityStrings}.\n* It contains ten unit test cases for the {@link CardinalityStrings#isCardinalityInterval(String, boolean)} method.\n*/\nclass CardinalityStringsTest1 {"
	},
	{
		"original_code": "// CardinalityStrings.java\npackage net.sf.xbus.base.core.strings;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>CardinalityStrings</code> offers some methods for treating\n * cardinality strings like \"1..*\". Allowed cardinality string consist\n * <ul>\n * <li>only of a single strictly positive integer - fixed cardinality</li>\n * <li>of an interval with \"..\" - variable cardinality</li>\n * </ul>\n * In case of an interval the lower bound must be a positive integer (including\n * zero) and the upper bound must be a strictly positive integer or \"*\". \"*\"\n * means \"arbitrary\".\n *\n * @author Stephan D�wel\n */\npublic class CardinalityStrings {\n\n    /**\n     * <code>isCardinalityValid</code> checks if a string is a well-formed\n     * cardinality.\n     *\n     * @param card the string to check\n     * @return <code>true</code> for well-formed cardinality string, otherwise\n     *         <code>false</code>\n     */\n    public static boolean isCardinalityValid(String card) {\n        int dots = card.indexOf(\"..\");\n        // Search for interval dots\n        if (dots == -1)\n            // no interval\n            dots = card.length();\n        // to check everything till the end\n        boolean result = true;\n        if (dots + 2 == card.length())\n            // Dots must be followed by a number or \"*\".\n            result = false;\n        else {\n            // No dots or something behind the dots.\n            try // for conversions to numbers\n            {\n                // A single value or a lower bound must be positive integers.\n                int low = Integer.parseInt(card.substring(0, dots));\n                if (low < 0)\n                    result = false;\n                else if (dots == card.length() && low == 0)\n                    // A single - not interval - value is zero but should be\n                    // strictly positive.\n                    result = false;\n                else {\n                    // Look if there is something behind dots.\n                    if (dots < card.length() - 3 || dots == card.length() - 3 && card.charAt(dots + 2) != '*') {\n                        // Just \"*\" would be fine, but otherwise it must be an\n                        // integer\n                        // not smaller than the lower bound.\n                        int high = Integer.parseInt(card.substring(dots + 2));\n                        if (low > high)\n                            result = false;\n                    } else // if (dots<card.length()-3 || card.charAt(dots+2)!='*')\n                    if (dots == card.length() - 2)\n                        // The dots are the last characters in the string.\n                        result = false;\n                }\n                // else (low<0)\n            }// try\n             catch (NumberFormatException e) {\n                // Single value, lower or upper bound no numbers (upper bound\n                // not \"*\")\n                result = false;\n            }\n            // catch\n        }\n        // else (dots+2==card.length())\n        return result;\n    }\n\n    // isCardinalityValid(String card)\n    /**\n     * <code>isCardinalityInterval</code> checks if a given string is a\n     * cardinatily interval like \"1..*\".\n     *\n     * @param card the string to check\n     * @param isKnownAsValidCardinality Is the string already known as a\n     *            well-formed cardinality specification? Otherwise this fact\n     *            will be checked.\n     * @return <code>true</code> for a well-formed cardinality interval,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isCardinalityInterval(String card, boolean isKnownAsValidCardinality) {\n        if (!isKnownAsValidCardinality)\n            isKnownAsValidCardinality = isCardinalityValid(card);\n        // Ensure that the string is a well-formed cardinality string.\n        if (isKnownAsValidCardinality)\n            isKnownAsValidCardinality = (card.indexOf(\"..\") > -1);\n        // It is an interval iff it contains dots.\n        return isKnownAsValidCardinality;\n    }\n\n    // isCardinalityInterval(String card, boolean isKnownAsValidCardinality)\n    /**\n     * <code>getCardinalityLow</code> extracts the lower bound from a\n     * cardinality string like \"1..*\".\n     *\n     * @param card the cardinality string\n     * @param isKnownAsCardinalityInterval Is the cardinality string already\n     *            known as a well-formed interval specification? Otherwise this\n     *            fact will be checked.\n     * @return the extracted lower bound which must be an positive integer\n     * @throws XException in case of a mal-formed cardinality string or a\n     *             negative lower bound\n     */\n    public static int getCardinalityLow(String card, boolean isKnownAsCardinalityInterval) throws XException {\n        if (!isKnownAsCardinalityInterval)\n            isKnownAsCardinalityInterval = isCardinalityInterval(card, false);\n        // Ensure that the string is a cardinality interval.\n        int result = -1;\n        if (isKnownAsCardinalityInterval)\n            // NumberFormatException already checked\n            result = Integer.parseInt(card.substring(0, card.indexOf(\"..\")));\n        else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_STRINGS, \"1\");\n        }\n        return result;\n    }\n\n    // getCardinalityLow(String card, boolean isKnownAsCardinalityInterval)\n    /**\n     * <code>getCardinalityHigh</code> extracts the upper bound from a\n     * cardinality string like \"1..*\".\n     *\n     * @param card the cardinality string\n     * @param isKnownAsCardinalityInterval Is the cardinality string already\n     *            known as a well-formed interval specification? Otherwise this\n     *            fact will be checked.\n     * @return the extracted upper bound which must be an positive integer,\n     *         <code>Integer.MAX_VALUE</code> in case of a \"*\"\n     * @throws XException in case of a mal-formed cardinality string or a\n     *             negative upper bound\n     */\n    public static int getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval) throws XException {\n        if (!isKnownAsCardinalityInterval)\n            isKnownAsCardinalityInterval = isCardinalityInterval(card, false);\n        // Ensure that the string is a cardinality interval.\n        int result = -1;\n        if (isKnownAsCardinalityInterval) {\n            int dots = card.indexOf(\"..\");\n            if (dots == card.length() - 3 && card.charAt(dots + 2) == '*')\n                // no upper limit\n                result = Integer.MAX_VALUE;\n            else\n                // NumberFormatException already checked\n                result = Integer.parseInt(card.substring(dots + 2));\n        } else\n            // then (isKnownAsCardinalityInterval)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_STRINGS, \"1\");\n        return result;\n    }\n    // getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval)\n}\n// CardinalityStrings\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/strings/CardinalityStringsTest2.java",
		"test_prompt": "// CardinalityStringsTest2.java\npackage net.sf.xbus.base.core.strings;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CardinalityStrings}.\n* It contains ten unit test cases for the {@link CardinalityStrings#getCardinalityLow(String, boolean)} method.\n*/\nclass CardinalityStringsTest2 {"
	},
	{
		"original_code": "// CardinalityStrings.java\npackage net.sf.xbus.base.core.strings;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>CardinalityStrings</code> offers some methods for treating\n * cardinality strings like \"1..*\". Allowed cardinality string consist\n * <ul>\n * <li>only of a single strictly positive integer - fixed cardinality</li>\n * <li>of an interval with \"..\" - variable cardinality</li>\n * </ul>\n * In case of an interval the lower bound must be a positive integer (including\n * zero) and the upper bound must be a strictly positive integer or \"*\". \"*\"\n * means \"arbitrary\".\n *\n * @author Stephan D�wel\n */\npublic class CardinalityStrings {\n\n    /**\n     * <code>isCardinalityValid</code> checks if a string is a well-formed\n     * cardinality.\n     *\n     * @param card the string to check\n     * @return <code>true</code> for well-formed cardinality string, otherwise\n     *         <code>false</code>\n     */\n    public static boolean isCardinalityValid(String card) {\n        int dots = card.indexOf(\"..\");\n        // Search for interval dots\n        if (dots == -1)\n            // no interval\n            dots = card.length();\n        // to check everything till the end\n        boolean result = true;\n        if (dots + 2 == card.length())\n            // Dots must be followed by a number or \"*\".\n            result = false;\n        else {\n            // No dots or something behind the dots.\n            try // for conversions to numbers\n            {\n                // A single value or a lower bound must be positive integers.\n                int low = Integer.parseInt(card.substring(0, dots));\n                if (low < 0)\n                    result = false;\n                else if (dots == card.length() && low == 0)\n                    // A single - not interval - value is zero but should be\n                    // strictly positive.\n                    result = false;\n                else {\n                    // Look if there is something behind dots.\n                    if (dots < card.length() - 3 || dots == card.length() - 3 && card.charAt(dots + 2) != '*') {\n                        // Just \"*\" would be fine, but otherwise it must be an\n                        // integer\n                        // not smaller than the lower bound.\n                        int high = Integer.parseInt(card.substring(dots + 2));\n                        if (low > high)\n                            result = false;\n                    } else // if (dots<card.length()-3 || card.charAt(dots+2)!='*')\n                    if (dots == card.length() - 2)\n                        // The dots are the last characters in the string.\n                        result = false;\n                }\n                // else (low<0)\n            }// try\n             catch (NumberFormatException e) {\n                // Single value, lower or upper bound no numbers (upper bound\n                // not \"*\")\n                result = false;\n            }\n            // catch\n        }\n        // else (dots+2==card.length())\n        return result;\n    }\n\n    // isCardinalityValid(String card)\n    /**\n     * <code>isCardinalityInterval</code> checks if a given string is a\n     * cardinatily interval like \"1..*\".\n     *\n     * @param card the string to check\n     * @param isKnownAsValidCardinality Is the string already known as a\n     *            well-formed cardinality specification? Otherwise this fact\n     *            will be checked.\n     * @return <code>true</code> for a well-formed cardinality interval,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isCardinalityInterval(String card, boolean isKnownAsValidCardinality) {\n        if (!isKnownAsValidCardinality)\n            isKnownAsValidCardinality = isCardinalityValid(card);\n        // Ensure that the string is a well-formed cardinality string.\n        if (isKnownAsValidCardinality)\n            isKnownAsValidCardinality = (card.indexOf(\"..\") > -1);\n        // It is an interval iff it contains dots.\n        return isKnownAsValidCardinality;\n    }\n\n    // isCardinalityInterval(String card, boolean isKnownAsValidCardinality)\n    /**\n     * <code>getCardinalityLow</code> extracts the lower bound from a\n     * cardinality string like \"1..*\".\n     *\n     * @param card the cardinality string\n     * @param isKnownAsCardinalityInterval Is the cardinality string already\n     *            known as a well-formed interval specification? Otherwise this\n     *            fact will be checked.\n     * @return the extracted lower bound which must be an positive integer\n     * @throws XException in case of a mal-formed cardinality string or a\n     *             negative lower bound\n     */\n    public static int getCardinalityLow(String card, boolean isKnownAsCardinalityInterval) throws XException {\n        if (!isKnownAsCardinalityInterval)\n            isKnownAsCardinalityInterval = isCardinalityInterval(card, false);\n        // Ensure that the string is a cardinality interval.\n        int result = -1;\n        if (isKnownAsCardinalityInterval)\n            // NumberFormatException already checked\n            result = Integer.parseInt(card.substring(0, card.indexOf(\"..\")));\n        else {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_STRINGS, \"1\");\n        }\n        return result;\n    }\n\n    // getCardinalityLow(String card, boolean isKnownAsCardinalityInterval)\n    /**\n     * <code>getCardinalityHigh</code> extracts the upper bound from a\n     * cardinality string like \"1..*\".\n     *\n     * @param card the cardinality string\n     * @param isKnownAsCardinalityInterval Is the cardinality string already\n     *            known as a well-formed interval specification? Otherwise this\n     *            fact will be checked.\n     * @return the extracted upper bound which must be an positive integer,\n     *         <code>Integer.MAX_VALUE</code> in case of a \"*\"\n     * @throws XException in case of a mal-formed cardinality string or a\n     *             negative upper bound\n     */\n    public static int getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval) throws XException {\n        if (!isKnownAsCardinalityInterval)\n            isKnownAsCardinalityInterval = isCardinalityInterval(card, false);\n        // Ensure that the string is a cardinality interval.\n        int result = -1;\n        if (isKnownAsCardinalityInterval) {\n            int dots = card.indexOf(\"..\");\n            if (dots == card.length() - 3 && card.charAt(dots + 2) == '*')\n                // no upper limit\n                result = Integer.MAX_VALUE;\n            else\n                // NumberFormatException already checked\n                result = Integer.parseInt(card.substring(dots + 2));\n        } else\n            // then (isKnownAsCardinalityInterval)\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_STRINGS, \"1\");\n        return result;\n    }\n    // getCardinalityHigh(String card, boolean isKnownAsCardinalityInterval)\n}\n// CardinalityStrings\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/strings/CardinalityStringsTest3.java",
		"test_prompt": "// CardinalityStringsTest3.java\npackage net.sf.xbus.base.core.strings;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CardinalityStrings}.\n* It contains ten unit test cases for the {@link CardinalityStrings#getCardinalityHigh(String, boolean)} method.\n*/\nclass CardinalityStringsTest3 {"
	},
	{
		"original_code": "// XStringSupport.java\npackage net.sf.xbus.base.core.strings;\n\n/**\n * <code>XStringSupport</code>is a collection of helpful methods concerning\n * string handling.\n *\n * @author Stephan D�wel\n */\npublic class XStringSupport {\n\n    /**\n     * <code>getNumberString</code> constructs a string out of an integer\n     * value. The number representation is decimal. The string is filled with\n     * leading zeros to reach a specified length. In case of negative values,\n     * the zeros are inserted between the minus sign and the number.\n     *\n     * @param number the integer value to be represented as a string\n     * @param length the desired length of the string representation\n     * @return the string representation of <code>number</code>\n     */\n    public static String getNumberString(int number, int length) {\n        // ordinary conversion\n        StringBuffer numString = new StringBuffer();\n        numString.append(number);\n        // length check\n        if (numString.length() > length)\n            throw new IllegalArgumentException(\"Number too long\");\n        // filling in zeros\n        StringBuffer buffer = null;\n        if (length > numString.length()) {\n            buffer = new StringBuffer(length - numString.length());\n            // space for zeros\n            if (number < 0) {\n                // negative number\n                buffer.append('-');\n                numString.deleteCharAt(0);\n                // sign already handled\n            }\n            // if (number<0)\n            // only zeros left to fill in\n            for (int i = 0; i < length - numString.length(); i++) buffer.append('0');\n            // number behind all zeros\n            buffer.append(numString);\n        } else\n            // then (length>numString.length())\n            buffer = numString;\n        return buffer.toString();\n    }\n\n    // getNumberString(int number, int length)\n    /**\n     * <code>successorUsualChars</code> computes the successor string in\n     * lexicographic order. The method set only characters with ASCII codes\n     * between 32 and 126 to ensure that they can be properly displayed. The\n     * successor of other characters is ' ' (ASCII 32).\n     *\n     * @param s the predecessor string\n     * @param lengthFix if set to <code>true</code>, the string length is\n     *            never augmented, in case of an overflow the blank string will\n     *            be returned\n     * @return the successor string (obeying the described constraints)\n     */\n    public static String successorUsualChars(String s, boolean lengthFix) {\n        char[] content = s.toCharArray();\n        boolean overflow = true;\n        // overflow in the actually examined string position\n        for (int i = content.length - 1; overflow && i > -1; i--) {\n            // loop from the string end until the successor is found or\n            // the string begin is reached\n            if (content[i] < 32) {\n                // control character - jum to ' '\n                content[i] = ' ';\n                overflow = false;\n                // successor found\n            } else // if (content[i]<32)\n            if (content[i] > 125)\n                content[i] = ' ';\n            else {\n                // ASCII code between 32 and 125 - augment it by 1\n                content[i]++;\n                overflow = false;\n                // successor found\n            }\n            // else (content[i]>125)\n        }\n        // for (int i=content.length-1; overflow&&i>-1; i--)\n        s = new String(content);\n        if (!lengthFix && overflow)\n            s = ' ' + s;\n        return s;\n    }\n\n    // successorUsualChars(String s, boolean lengthFix)\n    /**\n     * Replaces all occurences of <code>marker</code> in <code>text</code>\n     * with <code>replacement</code>.\n     * <p>\n     * <dl>\n     * <dt><i>Example:</i><br>\n     * <dd><i>before:</i>&nbsp;&nbsp;&nbsp;Input_<b>DEALERNUMBER</b>_<b>WILDCARD</b>.xml<br>\n     * <dd><i>after:</i>&nbsp;&nbsp;&nbsp;&nbsp;Input_<b>12345</b>_<b>parts</b>.xml\n     * </dl>\n     *\n     * @param text text which all occurences of marker must be replaced\n     * @param marker text marker to be replaced\n     * @param replacement replaced text\n     */\n    public static String replaceAll(String text, String marker, String replacement) {\n        int pos;\n        StringBuffer work = new StringBuffer(text);\n        while ((pos = text.indexOf(marker)) >= 0) {\n            work.replace(pos, pos + marker.length(), replacement);\n            text = new String(work);\n        }\n        return new String(work);\n    }\n\n    public static String replaceFirst(String text, String marker, String replacement, int fromPosition) {\n        int pos;\n        StringBuffer work = new StringBuffer(text);\n        if ((pos = text.indexOf(marker, fromPosition)) >= 0) {\n            work.replace(pos, pos + marker.length(), replacement);\n            text = new String(work);\n        }\n        return new String(work);\n    }\n}\n// XStringSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/strings/XStringSupportTest0.java",
		"test_prompt": "// XStringSupportTest0.java\npackage net.sf.xbus.base.core.strings;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XStringSupport}.\n* It contains ten unit test cases for the {@link XStringSupport#getNumberString(int, int)} method.\n*/\nclass XStringSupportTest0 {"
	},
	{
		"original_code": "// XStringSupport.java\npackage net.sf.xbus.base.core.strings;\n\n/**\n * <code>XStringSupport</code>is a collection of helpful methods concerning\n * string handling.\n *\n * @author Stephan D�wel\n */\npublic class XStringSupport {\n\n    /**\n     * <code>getNumberString</code> constructs a string out of an integer\n     * value. The number representation is decimal. The string is filled with\n     * leading zeros to reach a specified length. In case of negative values,\n     * the zeros are inserted between the minus sign and the number.\n     *\n     * @param number the integer value to be represented as a string\n     * @param length the desired length of the string representation\n     * @return the string representation of <code>number</code>\n     */\n    public static String getNumberString(int number, int length) {\n        // ordinary conversion\n        StringBuffer numString = new StringBuffer();\n        numString.append(number);\n        // length check\n        if (numString.length() > length)\n            throw new IllegalArgumentException(\"Number too long\");\n        // filling in zeros\n        StringBuffer buffer = null;\n        if (length > numString.length()) {\n            buffer = new StringBuffer(length - numString.length());\n            // space for zeros\n            if (number < 0) {\n                // negative number\n                buffer.append('-');\n                numString.deleteCharAt(0);\n                // sign already handled\n            }\n            // if (number<0)\n            // only zeros left to fill in\n            for (int i = 0; i < length - numString.length(); i++) buffer.append('0');\n            // number behind all zeros\n            buffer.append(numString);\n        } else\n            // then (length>numString.length())\n            buffer = numString;\n        return buffer.toString();\n    }\n\n    // getNumberString(int number, int length)\n    /**\n     * <code>successorUsualChars</code> computes the successor string in\n     * lexicographic order. The method set only characters with ASCII codes\n     * between 32 and 126 to ensure that they can be properly displayed. The\n     * successor of other characters is ' ' (ASCII 32).\n     *\n     * @param s the predecessor string\n     * @param lengthFix if set to <code>true</code>, the string length is\n     *            never augmented, in case of an overflow the blank string will\n     *            be returned\n     * @return the successor string (obeying the described constraints)\n     */\n    public static String successorUsualChars(String s, boolean lengthFix) {\n        char[] content = s.toCharArray();\n        boolean overflow = true;\n        // overflow in the actually examined string position\n        for (int i = content.length - 1; overflow && i > -1; i--) {\n            // loop from the string end until the successor is found or\n            // the string begin is reached\n            if (content[i] < 32) {\n                // control character - jum to ' '\n                content[i] = ' ';\n                overflow = false;\n                // successor found\n            } else // if (content[i]<32)\n            if (content[i] > 125)\n                content[i] = ' ';\n            else {\n                // ASCII code between 32 and 125 - augment it by 1\n                content[i]++;\n                overflow = false;\n                // successor found\n            }\n            // else (content[i]>125)\n        }\n        // for (int i=content.length-1; overflow&&i>-1; i--)\n        s = new String(content);\n        if (!lengthFix && overflow)\n            s = ' ' + s;\n        return s;\n    }\n\n    // successorUsualChars(String s, boolean lengthFix)\n    /**\n     * Replaces all occurences of <code>marker</code> in <code>text</code>\n     * with <code>replacement</code>.\n     * <p>\n     * <dl>\n     * <dt><i>Example:</i><br>\n     * <dd><i>before:</i>&nbsp;&nbsp;&nbsp;Input_<b>DEALERNUMBER</b>_<b>WILDCARD</b>.xml<br>\n     * <dd><i>after:</i>&nbsp;&nbsp;&nbsp;&nbsp;Input_<b>12345</b>_<b>parts</b>.xml\n     * </dl>\n     *\n     * @param text text which all occurences of marker must be replaced\n     * @param marker text marker to be replaced\n     * @param replacement replaced text\n     */\n    public static String replaceAll(String text, String marker, String replacement) {\n        int pos;\n        StringBuffer work = new StringBuffer(text);\n        while ((pos = text.indexOf(marker)) >= 0) {\n            work.replace(pos, pos + marker.length(), replacement);\n            text = new String(work);\n        }\n        return new String(work);\n    }\n\n    public static String replaceFirst(String text, String marker, String replacement, int fromPosition) {\n        int pos;\n        StringBuffer work = new StringBuffer(text);\n        if ((pos = text.indexOf(marker, fromPosition)) >= 0) {\n            work.replace(pos, pos + marker.length(), replacement);\n            text = new String(work);\n        }\n        return new String(work);\n    }\n}\n// XStringSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/strings/XStringSupportTest1.java",
		"test_prompt": "// XStringSupportTest1.java\npackage net.sf.xbus.base.core.strings;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XStringSupport}.\n* It contains ten unit test cases for the {@link XStringSupport#successorUsualChars(String, boolean)} method.\n*/\nclass XStringSupportTest1 {"
	},
	{
		"original_code": "// XStringSupport.java\npackage net.sf.xbus.base.core.strings;\n\n/**\n * <code>XStringSupport</code>is a collection of helpful methods concerning\n * string handling.\n *\n * @author Stephan D�wel\n */\npublic class XStringSupport {\n\n    /**\n     * <code>getNumberString</code> constructs a string out of an integer\n     * value. The number representation is decimal. The string is filled with\n     * leading zeros to reach a specified length. In case of negative values,\n     * the zeros are inserted between the minus sign and the number.\n     *\n     * @param number the integer value to be represented as a string\n     * @param length the desired length of the string representation\n     * @return the string representation of <code>number</code>\n     */\n    public static String getNumberString(int number, int length) {\n        // ordinary conversion\n        StringBuffer numString = new StringBuffer();\n        numString.append(number);\n        // length check\n        if (numString.length() > length)\n            throw new IllegalArgumentException(\"Number too long\");\n        // filling in zeros\n        StringBuffer buffer = null;\n        if (length > numString.length()) {\n            buffer = new StringBuffer(length - numString.length());\n            // space for zeros\n            if (number < 0) {\n                // negative number\n                buffer.append('-');\n                numString.deleteCharAt(0);\n                // sign already handled\n            }\n            // if (number<0)\n            // only zeros left to fill in\n            for (int i = 0; i < length - numString.length(); i++) buffer.append('0');\n            // number behind all zeros\n            buffer.append(numString);\n        } else\n            // then (length>numString.length())\n            buffer = numString;\n        return buffer.toString();\n    }\n\n    // getNumberString(int number, int length)\n    /**\n     * <code>successorUsualChars</code> computes the successor string in\n     * lexicographic order. The method set only characters with ASCII codes\n     * between 32 and 126 to ensure that they can be properly displayed. The\n     * successor of other characters is ' ' (ASCII 32).\n     *\n     * @param s the predecessor string\n     * @param lengthFix if set to <code>true</code>, the string length is\n     *            never augmented, in case of an overflow the blank string will\n     *            be returned\n     * @return the successor string (obeying the described constraints)\n     */\n    public static String successorUsualChars(String s, boolean lengthFix) {\n        char[] content = s.toCharArray();\n        boolean overflow = true;\n        // overflow in the actually examined string position\n        for (int i = content.length - 1; overflow && i > -1; i--) {\n            // loop from the string end until the successor is found or\n            // the string begin is reached\n            if (content[i] < 32) {\n                // control character - jum to ' '\n                content[i] = ' ';\n                overflow = false;\n                // successor found\n            } else // if (content[i]<32)\n            if (content[i] > 125)\n                content[i] = ' ';\n            else {\n                // ASCII code between 32 and 125 - augment it by 1\n                content[i]++;\n                overflow = false;\n                // successor found\n            }\n            // else (content[i]>125)\n        }\n        // for (int i=content.length-1; overflow&&i>-1; i--)\n        s = new String(content);\n        if (!lengthFix && overflow)\n            s = ' ' + s;\n        return s;\n    }\n\n    // successorUsualChars(String s, boolean lengthFix)\n    /**\n     * Replaces all occurences of <code>marker</code> in <code>text</code>\n     * with <code>replacement</code>.\n     * <p>\n     * <dl>\n     * <dt><i>Example:</i><br>\n     * <dd><i>before:</i>&nbsp;&nbsp;&nbsp;Input_<b>DEALERNUMBER</b>_<b>WILDCARD</b>.xml<br>\n     * <dd><i>after:</i>&nbsp;&nbsp;&nbsp;&nbsp;Input_<b>12345</b>_<b>parts</b>.xml\n     * </dl>\n     *\n     * @param text text which all occurences of marker must be replaced\n     * @param marker text marker to be replaced\n     * @param replacement replaced text\n     */\n    public static String replaceAll(String text, String marker, String replacement) {\n        int pos;\n        StringBuffer work = new StringBuffer(text);\n        while ((pos = text.indexOf(marker)) >= 0) {\n            work.replace(pos, pos + marker.length(), replacement);\n            text = new String(work);\n        }\n        return new String(work);\n    }\n\n    public static String replaceFirst(String text, String marker, String replacement, int fromPosition) {\n        int pos;\n        StringBuffer work = new StringBuffer(text);\n        if ((pos = text.indexOf(marker, fromPosition)) >= 0) {\n            work.replace(pos, pos + marker.length(), replacement);\n            text = new String(work);\n        }\n        return new String(work);\n    }\n}\n// XStringSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/strings/XStringSupportTest2.java",
		"test_prompt": "// XStringSupportTest2.java\npackage net.sf.xbus.base.core.strings;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XStringSupport}.\n* It contains ten unit test cases for the {@link XStringSupport#replaceAll(String, String, String)} method.\n*/\nclass XStringSupportTest2 {"
	},
	{
		"original_code": "// XStringSupport.java\npackage net.sf.xbus.base.core.strings;\n\n/**\n * <code>XStringSupport</code>is a collection of helpful methods concerning\n * string handling.\n *\n * @author Stephan D�wel\n */\npublic class XStringSupport {\n\n    /**\n     * <code>getNumberString</code> constructs a string out of an integer\n     * value. The number representation is decimal. The string is filled with\n     * leading zeros to reach a specified length. In case of negative values,\n     * the zeros are inserted between the minus sign and the number.\n     *\n     * @param number the integer value to be represented as a string\n     * @param length the desired length of the string representation\n     * @return the string representation of <code>number</code>\n     */\n    public static String getNumberString(int number, int length) {\n        // ordinary conversion\n        StringBuffer numString = new StringBuffer();\n        numString.append(number);\n        // length check\n        if (numString.length() > length)\n            throw new IllegalArgumentException(\"Number too long\");\n        // filling in zeros\n        StringBuffer buffer = null;\n        if (length > numString.length()) {\n            buffer = new StringBuffer(length - numString.length());\n            // space for zeros\n            if (number < 0) {\n                // negative number\n                buffer.append('-');\n                numString.deleteCharAt(0);\n                // sign already handled\n            }\n            // if (number<0)\n            // only zeros left to fill in\n            for (int i = 0; i < length - numString.length(); i++) buffer.append('0');\n            // number behind all zeros\n            buffer.append(numString);\n        } else\n            // then (length>numString.length())\n            buffer = numString;\n        return buffer.toString();\n    }\n\n    // getNumberString(int number, int length)\n    /**\n     * <code>successorUsualChars</code> computes the successor string in\n     * lexicographic order. The method set only characters with ASCII codes\n     * between 32 and 126 to ensure that they can be properly displayed. The\n     * successor of other characters is ' ' (ASCII 32).\n     *\n     * @param s the predecessor string\n     * @param lengthFix if set to <code>true</code>, the string length is\n     *            never augmented, in case of an overflow the blank string will\n     *            be returned\n     * @return the successor string (obeying the described constraints)\n     */\n    public static String successorUsualChars(String s, boolean lengthFix) {\n        char[] content = s.toCharArray();\n        boolean overflow = true;\n        // overflow in the actually examined string position\n        for (int i = content.length - 1; overflow && i > -1; i--) {\n            // loop from the string end until the successor is found or\n            // the string begin is reached\n            if (content[i] < 32) {\n                // control character - jum to ' '\n                content[i] = ' ';\n                overflow = false;\n                // successor found\n            } else // if (content[i]<32)\n            if (content[i] > 125)\n                content[i] = ' ';\n            else {\n                // ASCII code between 32 and 125 - augment it by 1\n                content[i]++;\n                overflow = false;\n                // successor found\n            }\n            // else (content[i]>125)\n        }\n        // for (int i=content.length-1; overflow&&i>-1; i--)\n        s = new String(content);\n        if (!lengthFix && overflow)\n            s = ' ' + s;\n        return s;\n    }\n\n    // successorUsualChars(String s, boolean lengthFix)\n    /**\n     * Replaces all occurences of <code>marker</code> in <code>text</code>\n     * with <code>replacement</code>.\n     * <p>\n     * <dl>\n     * <dt><i>Example:</i><br>\n     * <dd><i>before:</i>&nbsp;&nbsp;&nbsp;Input_<b>DEALERNUMBER</b>_<b>WILDCARD</b>.xml<br>\n     * <dd><i>after:</i>&nbsp;&nbsp;&nbsp;&nbsp;Input_<b>12345</b>_<b>parts</b>.xml\n     * </dl>\n     *\n     * @param text text which all occurences of marker must be replaced\n     * @param marker text marker to be replaced\n     * @param replacement replaced text\n     */\n    public static String replaceAll(String text, String marker, String replacement) {\n        int pos;\n        StringBuffer work = new StringBuffer(text);\n        while ((pos = text.indexOf(marker)) >= 0) {\n            work.replace(pos, pos + marker.length(), replacement);\n            text = new String(work);\n        }\n        return new String(work);\n    }\n\n    public static String replaceFirst(String text, String marker, String replacement, int fromPosition) {\n        int pos;\n        StringBuffer work = new StringBuffer(text);\n        if ((pos = text.indexOf(marker, fromPosition)) >= 0) {\n            work.replace(pos, pos + marker.length(), replacement);\n            text = new String(work);\n        }\n        return new String(work);\n    }\n}\n// XStringSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/strings/XStringSupportTest3.java",
		"test_prompt": "// XStringSupportTest3.java\npackage net.sf.xbus.base.core.strings;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XStringSupport}.\n* It contains ten unit test cases for the {@link XStringSupport#replaceFirst(String, String, String, int)} method.\n*/\nclass XStringSupportTest3 {"
	},
	{
		"original_code": "// Formatter.java\npackage net.sf.xbus.base.core.trace;\n\nimport java.util.Date;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * The <code>Formatter</code> ensures, that every line in the trace-protocol\n * has an equal format.\n */\npublic class Formatter {\n\n    /**\n     * Formats a trace-line:\n     * <p>\n     * <code>   Timestamp | Priority | Threadname | Message</code>\n     *\n     * @param message the message to be traced\n     * @param priority the priority after which the messages should be traced\n     * @return String - formatted trace-line\n     * @exception XException if any error occurs\n     */\n    public static String format(String message, int priority) throws XException {\n        String priorityname;\n        String datetime = Constants.getDateFormat().format(new Date());\n        switch(priority) {\n            case 0:\n                priorityname = \"always\";\n                break;\n            case 1:\n                priorityname = \"error \";\n                break;\n            case 2:\n                priorityname = \"warn  \";\n                break;\n            case 3:\n                priorityname = \"info  \";\n                break;\n            case 4:\n                priorityname = \"debug \";\n                break;\n            default:\n                priorityname = \"NA    \";\n        }\n        Configuration config = Configuration.getInstance();\n        int maxLength = config.getValueAsInt(\"Base\", \"Trace\", \"MaxLength\");\n        if ((maxLength >= 0) && (message.length() > maxLength)) {\n            message = message.substring(0, maxLength);\n        }\n        StringBuffer buf = new StringBuffer().append(datetime).append(\" | \").append(priorityname).append(\" | \").append(Thread.currentThread().getName()).append(\" | \").append(message);\n        return buf.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/trace/FormatterTest.java",
		"test_prompt": "// FormatterTest.java\npackage net.sf.xbus.base.core.trace;\n\nimport java.util.Date;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Formatter}.\n* It contains ten unit test cases for the {@link Formatter#format(String, int)} method.\n*/\nclass FormatterTest {"
	},
	{
		"original_code": "// Trace.java\npackage net.sf.xbus.base.core.trace;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * <code>Trace</code> writes program-internal informations to a sink. The most\n * important use of <code>Trace</code> is writing informations, when an error\n * occurs, e.g. the queue-server is not available.\n * <p>\n */\npublic class Trace {\n\n    public static final int DEBUG = 4;\n\n    public static final int INFO = 3;\n\n    public static final int WARN = 2;\n\n    public static final int ERROR = 1;\n\n    public static final int ALWAYS = 0;\n\n    private static final int NOT_INITIALIZED = 9999;\n\n    private static int mTracelevel = NOT_INITIALIZED;\n\n    private static TraceTarget mTarget = null;\n\n    /**\n     * Traces a message object with the ALWAYS priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void always(Object message) {\n        Trace.trace(Trace.ALWAYS, message, null);\n    }\n\n    /**\n     * Traces a message object with the ERROR priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void error(Object message) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        Trace.trace(Trace.ERROR, message, null);\n    }\n\n    /**\n     * Traces a message object with the ERROR priority including the message and\n     * the stack trace of the Throwable t passed as parameter.\n     * <p>\n     * When the <code>Throwable</code> is an <code>XException</code> nothing\n     * happens, because the <code>XException</code> has been traced before.\n     *\n     * @param t the Throwable which shall be traced.\n     */\n    public static void error(Throwable t) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        if (t != null) {\n            /*\n\t\t\t * When the exception is an XException, it has been traced before\n\t\t\t */\n            if (!(t instanceof XException)) {\n                Trace.trace(Trace.ERROR, t.getMessage(), t);\n            }\n        } else {\n            Trace.trace(Trace.ERROR, \"Exception <null> ???\", null);\n        }\n    }\n\n    /**\n     * Traces a message object with the ERROR priority including the stack trace\n     * of the Throwable t passed as parameter.\n     *\n     * @param message the message to be traced\n     * @param t the stack trace of the Throwable\n     */\n    public static void error(Object message, Throwable t) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        Trace.trace(Trace.ERROR, message, t);\n    }\n\n    /**\n     * Traces a message object with the WARN priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void warn(Object message) {\n        if (Trace.mTracelevel < Trace.WARN) {\n            return;\n        }\n        Trace.trace(Trace.WARN, message, null);\n    }\n\n    /**\n     * Traces a message object with the INFO priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void info(Object message) {\n        if (Trace.mTracelevel < Trace.INFO) {\n            return;\n        }\n        Trace.trace(Trace.INFO, message, null);\n    }\n\n    /**\n     * Traces a message object with the DEBUG priority.\n     *\n     * @param message the message to be traced\n     */\n    // public static void debug(Object message)\n    // {\n    // if (Trace.mTracelevel < Trace.DEBUG)\n    // {\n    // return;\n    // }\n    // Trace.trace(Trace.DEBUG, message, null);\n    // }\n    /**\n     * The <code>initialize()</code> method reads the name and the level of\n     * the trace from the <code>Configuration</code> and initializes the\n     * Tracing\n     *\n     * @see Configuration#getValue(String,String,String)\n     */\n    public static void initialize() {\n        try {\n            Integer traceLevel;\n            Configuration config = Configuration.getInstance();\n            traceLevel = new Integer(config.getValue(\"Base\", \"Trace\", \"Level\"));\n            mTracelevel = traceLevel.intValue();\n            String tracerShort = config.getValue(\"Base\", \"Trace\", \"Tracer\");\n            String tracerName = Configuration.getClass(\"Trace\", tracerShort);\n            mTarget = (TraceTarget) Class.forName(tracerName).newInstance();\n            System.out.println(\"Tracing with \" + tracerName);\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    /**\n     * Returns all trace messages as one large string.\n     *\n     * @return String - all trace message\n     */\n    public static String getTrace() {\n        if (!isInitialized()) {\n            Trace.initialize();\n        }\n        String retString = mTarget.getTrace();\n        if (retString == null) {\n            return \"No trace messages found.\";\n        } else {\n            return retString;\n        }\n    }\n\n    /**\n     * Tests if the Tracer is initialized.\n     *\n     * @return boolean - true: Trace is initialized\n     */\n    public static boolean isInitialized() {\n        return (mTracelevel != NOT_INITIALIZED);\n    }\n\n    /**\n     * Writes the <code>message</code> to the sink.\n     *\n     * @param priority the priority after which the messages should be traced\n     * @param message the message to be traced\n     * @param t the stack trace of the Throwable\n     */\n    private static void trace(int priority, Object message, Throwable t) {\n        if (mTracelevel == NOT_INITIALIZED) {\n            Trace.initialize();\n        }\n        if (Trace.mTracelevel >= priority) {\n            mTarget.trace(priority, message, t);\n        }\n    }\n\n    /**\n     * @return current tracelevel\n     */\n    public static int getTracelevel() {\n        return mTracelevel;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/trace/TraceTest0.java",
		"test_prompt": "// TraceTest0.java\npackage net.sf.xbus.base.core.trace;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Trace}.\n* It contains ten unit test cases for the {@link Trace#getTrace()} method.\n*/\nclass TraceTest0 {"
	},
	{
		"original_code": "// Trace.java\npackage net.sf.xbus.base.core.trace;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * <code>Trace</code> writes program-internal informations to a sink. The most\n * important use of <code>Trace</code> is writing informations, when an error\n * occurs, e.g. the queue-server is not available.\n * <p>\n */\npublic class Trace {\n\n    public static final int DEBUG = 4;\n\n    public static final int INFO = 3;\n\n    public static final int WARN = 2;\n\n    public static final int ERROR = 1;\n\n    public static final int ALWAYS = 0;\n\n    private static final int NOT_INITIALIZED = 9999;\n\n    private static int mTracelevel = NOT_INITIALIZED;\n\n    private static TraceTarget mTarget = null;\n\n    /**\n     * Traces a message object with the ALWAYS priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void always(Object message) {\n        Trace.trace(Trace.ALWAYS, message, null);\n    }\n\n    /**\n     * Traces a message object with the ERROR priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void error(Object message) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        Trace.trace(Trace.ERROR, message, null);\n    }\n\n    /**\n     * Traces a message object with the ERROR priority including the message and\n     * the stack trace of the Throwable t passed as parameter.\n     * <p>\n     * When the <code>Throwable</code> is an <code>XException</code> nothing\n     * happens, because the <code>XException</code> has been traced before.\n     *\n     * @param t the Throwable which shall be traced.\n     */\n    public static void error(Throwable t) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        if (t != null) {\n            /*\n\t\t\t * When the exception is an XException, it has been traced before\n\t\t\t */\n            if (!(t instanceof XException)) {\n                Trace.trace(Trace.ERROR, t.getMessage(), t);\n            }\n        } else {\n            Trace.trace(Trace.ERROR, \"Exception <null> ???\", null);\n        }\n    }\n\n    /**\n     * Traces a message object with the ERROR priority including the stack trace\n     * of the Throwable t passed as parameter.\n     *\n     * @param message the message to be traced\n     * @param t the stack trace of the Throwable\n     */\n    public static void error(Object message, Throwable t) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        Trace.trace(Trace.ERROR, message, t);\n    }\n\n    /**\n     * Traces a message object with the WARN priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void warn(Object message) {\n        if (Trace.mTracelevel < Trace.WARN) {\n            return;\n        }\n        Trace.trace(Trace.WARN, message, null);\n    }\n\n    /**\n     * Traces a message object with the INFO priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void info(Object message) {\n        if (Trace.mTracelevel < Trace.INFO) {\n            return;\n        }\n        Trace.trace(Trace.INFO, message, null);\n    }\n\n    /**\n     * Traces a message object with the DEBUG priority.\n     *\n     * @param message the message to be traced\n     */\n    // public static void debug(Object message)\n    // {\n    // if (Trace.mTracelevel < Trace.DEBUG)\n    // {\n    // return;\n    // }\n    // Trace.trace(Trace.DEBUG, message, null);\n    // }\n    /**\n     * The <code>initialize()</code> method reads the name and the level of\n     * the trace from the <code>Configuration</code> and initializes the\n     * Tracing\n     *\n     * @see Configuration#getValue(String,String,String)\n     */\n    public static void initialize() {\n        try {\n            Integer traceLevel;\n            Configuration config = Configuration.getInstance();\n            traceLevel = new Integer(config.getValue(\"Base\", \"Trace\", \"Level\"));\n            mTracelevel = traceLevel.intValue();\n            String tracerShort = config.getValue(\"Base\", \"Trace\", \"Tracer\");\n            String tracerName = Configuration.getClass(\"Trace\", tracerShort);\n            mTarget = (TraceTarget) Class.forName(tracerName).newInstance();\n            System.out.println(\"Tracing with \" + tracerName);\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    /**\n     * Returns all trace messages as one large string.\n     *\n     * @return String - all trace message\n     */\n    public static String getTrace() {\n        if (!isInitialized()) {\n            Trace.initialize();\n        }\n        String retString = mTarget.getTrace();\n        if (retString == null) {\n            return \"No trace messages found.\";\n        } else {\n            return retString;\n        }\n    }\n\n    /**\n     * Tests if the Tracer is initialized.\n     *\n     * @return boolean - true: Trace is initialized\n     */\n    public static boolean isInitialized() {\n        return (mTracelevel != NOT_INITIALIZED);\n    }\n\n    /**\n     * Writes the <code>message</code> to the sink.\n     *\n     * @param priority the priority after which the messages should be traced\n     * @param message the message to be traced\n     * @param t the stack trace of the Throwable\n     */\n    private static void trace(int priority, Object message, Throwable t) {\n        if (mTracelevel == NOT_INITIALIZED) {\n            Trace.initialize();\n        }\n        if (Trace.mTracelevel >= priority) {\n            mTarget.trace(priority, message, t);\n        }\n    }\n\n    /**\n     * @return current tracelevel\n     */\n    public static int getTracelevel() {\n        return mTracelevel;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/trace/TraceTest1.java",
		"test_prompt": "// TraceTest1.java\npackage net.sf.xbus.base.core.trace;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Trace}.\n* It contains ten unit test cases for the {@link Trace#isInitialized()} method.\n*/\nclass TraceTest1 {"
	},
	{
		"original_code": "// Trace.java\npackage net.sf.xbus.base.core.trace;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * <code>Trace</code> writes program-internal informations to a sink. The most\n * important use of <code>Trace</code> is writing informations, when an error\n * occurs, e.g. the queue-server is not available.\n * <p>\n */\npublic class Trace {\n\n    public static final int DEBUG = 4;\n\n    public static final int INFO = 3;\n\n    public static final int WARN = 2;\n\n    public static final int ERROR = 1;\n\n    public static final int ALWAYS = 0;\n\n    private static final int NOT_INITIALIZED = 9999;\n\n    private static int mTracelevel = NOT_INITIALIZED;\n\n    private static TraceTarget mTarget = null;\n\n    /**\n     * Traces a message object with the ALWAYS priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void always(Object message) {\n        Trace.trace(Trace.ALWAYS, message, null);\n    }\n\n    /**\n     * Traces a message object with the ERROR priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void error(Object message) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        Trace.trace(Trace.ERROR, message, null);\n    }\n\n    /**\n     * Traces a message object with the ERROR priority including the message and\n     * the stack trace of the Throwable t passed as parameter.\n     * <p>\n     * When the <code>Throwable</code> is an <code>XException</code> nothing\n     * happens, because the <code>XException</code> has been traced before.\n     *\n     * @param t the Throwable which shall be traced.\n     */\n    public static void error(Throwable t) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        if (t != null) {\n            /*\n\t\t\t * When the exception is an XException, it has been traced before\n\t\t\t */\n            if (!(t instanceof XException)) {\n                Trace.trace(Trace.ERROR, t.getMessage(), t);\n            }\n        } else {\n            Trace.trace(Trace.ERROR, \"Exception <null> ???\", null);\n        }\n    }\n\n    /**\n     * Traces a message object with the ERROR priority including the stack trace\n     * of the Throwable t passed as parameter.\n     *\n     * @param message the message to be traced\n     * @param t the stack trace of the Throwable\n     */\n    public static void error(Object message, Throwable t) {\n        if (Trace.mTracelevel < Trace.ERROR) {\n            return;\n        }\n        Trace.trace(Trace.ERROR, message, t);\n    }\n\n    /**\n     * Traces a message object with the WARN priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void warn(Object message) {\n        if (Trace.mTracelevel < Trace.WARN) {\n            return;\n        }\n        Trace.trace(Trace.WARN, message, null);\n    }\n\n    /**\n     * Traces a message object with the INFO priority.\n     *\n     * @param message the message to be traced\n     */\n    public static void info(Object message) {\n        if (Trace.mTracelevel < Trace.INFO) {\n            return;\n        }\n        Trace.trace(Trace.INFO, message, null);\n    }\n\n    /**\n     * Traces a message object with the DEBUG priority.\n     *\n     * @param message the message to be traced\n     */\n    // public static void debug(Object message)\n    // {\n    // if (Trace.mTracelevel < Trace.DEBUG)\n    // {\n    // return;\n    // }\n    // Trace.trace(Trace.DEBUG, message, null);\n    // }\n    /**\n     * The <code>initialize()</code> method reads the name and the level of\n     * the trace from the <code>Configuration</code> and initializes the\n     * Tracing\n     *\n     * @see Configuration#getValue(String,String,String)\n     */\n    public static void initialize() {\n        try {\n            Integer traceLevel;\n            Configuration config = Configuration.getInstance();\n            traceLevel = new Integer(config.getValue(\"Base\", \"Trace\", \"Level\"));\n            mTracelevel = traceLevel.intValue();\n            String tracerShort = config.getValue(\"Base\", \"Trace\", \"Tracer\");\n            String tracerName = Configuration.getClass(\"Trace\", tracerShort);\n            mTarget = (TraceTarget) Class.forName(tracerName).newInstance();\n            System.out.println(\"Tracing with \" + tracerName);\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    /**\n     * Returns all trace messages as one large string.\n     *\n     * @return String - all trace message\n     */\n    public static String getTrace() {\n        if (!isInitialized()) {\n            Trace.initialize();\n        }\n        String retString = mTarget.getTrace();\n        if (retString == null) {\n            return \"No trace messages found.\";\n        } else {\n            return retString;\n        }\n    }\n\n    /**\n     * Tests if the Tracer is initialized.\n     *\n     * @return boolean - true: Trace is initialized\n     */\n    public static boolean isInitialized() {\n        return (mTracelevel != NOT_INITIALIZED);\n    }\n\n    /**\n     * Writes the <code>message</code> to the sink.\n     *\n     * @param priority the priority after which the messages should be traced\n     * @param message the message to be traced\n     * @param t the stack trace of the Throwable\n     */\n    private static void trace(int priority, Object message, Throwable t) {\n        if (mTracelevel == NOT_INITIALIZED) {\n            Trace.initialize();\n        }\n        if (Trace.mTracelevel >= priority) {\n            mTarget.trace(priority, message, t);\n        }\n    }\n\n    /**\n     * @return current tracelevel\n     */\n    public static int getTracelevel() {\n        return mTracelevel;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/trace/TraceTest2.java",
		"test_prompt": "// TraceTest2.java\npackage net.sf.xbus.base.core.trace;\n\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Trace}.\n* It contains ten unit test cases for the {@link Trace#getTracelevel()} method.\n*/\nclass TraceTest2 {"
	},
	{
		"original_code": "// ASCIITokenizer.java\npackage net.sf.xbus.base.core;\n\n/**\n * A StringTokenizer, that conveniently tokenizes a ASCII-file The main\n * difference to its base class is, that it doesn�t count the delimiters as\n * tokens in method countTokens() and that its methods nextElement() and\n * nextToken() don�t return a delimiter, but an empty Object/String if there are\n * two delimiters next to each other.\n *\n * @see java.util.StringTokenizer\n * @author Martin Sturzenhecker\n */\npublic class ASCIITokenizer extends java.util.StringTokenizer {\n\n    /**\n     * The string to be tokenized\n     */\n    private String string;\n\n    /**\n     * The delimiters\n     */\n    private String delims;\n\n    /**\n     * Creates a new instance of <code>ASCIIOfferTokenizer</code>\n     *\n     * @param str String to be tokenized\n     * @param delim String separator\n     */\n    public ASCIITokenizer(String str, String delim) {\n        super(str, delim, true);\n        this.string = str;\n        this.delims = delim;\n    }\n\n    /**\n     * Creates a new instance of <code>ASCIIOfferTokenizer</code>\n     *\n     * @param str String to be tokenized\n     * @param delim String separator\n     * @param returnTokens boolean: shall the delimiters be returned?\n     */\n    private ASCIITokenizer(String str, String delim, boolean returnTokens) {\n        super(str, delim, returnTokens);\n        this.string = str;\n        this.delims = delim;\n    }\n\n    /**\n     * Counts the number of tokens in the string to be tokenized\n     * <p>\n     * The delimiters are <b>not</b> counted unlike in class StringTokenizer\n     *\n     * @return int - the number of tokens without the delimiters\n     */\n    public int countTokens() {\n        // toky exists for counting purposes only. It�s the same as the current\n        // Tokenizer\n        ASCIITokenizer toky = new ASCIITokenizer(this.string, this.delims, true);\n        int count = 0;\n        String last = \"\";\n        while (toky.hasMoreTokens()) {\n            last = toky.nextToken();\n            count++;\n        }\n        return (this.getDelimiters().indexOf(last) >= 0 ? count + 1 : count);\n    }\n\n    /**\n     * Returns the delimiters of this tokenizer\n     *\n     * @return String -the delimiters of this tokenizer\n     */\n    public java.lang.String getDelimiters() {\n        return delims;\n    }\n\n    /**\n     * Returns the string to be tokenized\n     *\n     * @return String to be tokenized\n     */\n    public java.lang.String getStr() {\n        return string;\n    }\n\n    /**\n     * Returns the next element of the string to be tokenized\n     * <p>\n     * It does quite the same as the method <code>nextToken()</code> but it\n     * returns an <code>Object</code> instead of a String\n     *\n     * @return Object - the next element of the string\n     * @see #nextToken()\n     */\n    public Object nextElement() {\n        return this.nextToken();\n    }\n\n    /**\n     * Returns the next token of the string to be tokenized\n     *\n     * @return String - the next token of the string\n     */\n    public String nextToken() {\n        String tmp;\n        /* if there are more tokens get next one, else the last token is empty */\n        tmp = (this.hasMoreTokens() ? super.nextToken() : \"\");\n        /* tmp is a delimiter -> the currentToken is empty */\n        if (this.getDelimiters().indexOf(tmp) >= 0) {\n            tmp = \"\";\n        } else /*\n\t\t * tmp is not a delimiter and the String has more tokens -> the\n\t\t * currentToken is not empty\n\t\t */\n        if (this.hasMoreTokens()) {\n            // This is a delimiter for sure.\n            super.nextToken();\n        } else /*\n\t\t * tmp is not a delimiter and the token is the last one -> the\n\t\t * currentToken is not empty\n\t\t */\n        {\n            /*\n\t\t\t *  do nothing\n\t\t\t */\n        }\n        return tmp;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/ASCIITokenizerTest0.java",
		"test_prompt": "// ASCIITokenizerTest0.java\npackage net.sf.xbus.base.core;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASCIITokenizer}.\n* It contains ten unit test cases for the {@link ASCIITokenizer#countTokens()} method.\n*/\nclass ASCIITokenizerTest0 {"
	},
	{
		"original_code": "// ASCIITokenizer.java\npackage net.sf.xbus.base.core;\n\n/**\n * A StringTokenizer, that conveniently tokenizes a ASCII-file The main\n * difference to its base class is, that it doesn�t count the delimiters as\n * tokens in method countTokens() and that its methods nextElement() and\n * nextToken() don�t return a delimiter, but an empty Object/String if there are\n * two delimiters next to each other.\n *\n * @see java.util.StringTokenizer\n * @author Martin Sturzenhecker\n */\npublic class ASCIITokenizer extends java.util.StringTokenizer {\n\n    /**\n     * The string to be tokenized\n     */\n    private String string;\n\n    /**\n     * The delimiters\n     */\n    private String delims;\n\n    /**\n     * Creates a new instance of <code>ASCIIOfferTokenizer</code>\n     *\n     * @param str String to be tokenized\n     * @param delim String separator\n     */\n    public ASCIITokenizer(String str, String delim) {\n        super(str, delim, true);\n        this.string = str;\n        this.delims = delim;\n    }\n\n    /**\n     * Creates a new instance of <code>ASCIIOfferTokenizer</code>\n     *\n     * @param str String to be tokenized\n     * @param delim String separator\n     * @param returnTokens boolean: shall the delimiters be returned?\n     */\n    private ASCIITokenizer(String str, String delim, boolean returnTokens) {\n        super(str, delim, returnTokens);\n        this.string = str;\n        this.delims = delim;\n    }\n\n    /**\n     * Counts the number of tokens in the string to be tokenized\n     * <p>\n     * The delimiters are <b>not</b> counted unlike in class StringTokenizer\n     *\n     * @return int - the number of tokens without the delimiters\n     */\n    public int countTokens() {\n        // toky exists for counting purposes only. It�s the same as the current\n        // Tokenizer\n        ASCIITokenizer toky = new ASCIITokenizer(this.string, this.delims, true);\n        int count = 0;\n        String last = \"\";\n        while (toky.hasMoreTokens()) {\n            last = toky.nextToken();\n            count++;\n        }\n        return (this.getDelimiters().indexOf(last) >= 0 ? count + 1 : count);\n    }\n\n    /**\n     * Returns the delimiters of this tokenizer\n     *\n     * @return String -the delimiters of this tokenizer\n     */\n    public java.lang.String getDelimiters() {\n        return delims;\n    }\n\n    /**\n     * Returns the string to be tokenized\n     *\n     * @return String to be tokenized\n     */\n    public java.lang.String getStr() {\n        return string;\n    }\n\n    /**\n     * Returns the next element of the string to be tokenized\n     * <p>\n     * It does quite the same as the method <code>nextToken()</code> but it\n     * returns an <code>Object</code> instead of a String\n     *\n     * @return Object - the next element of the string\n     * @see #nextToken()\n     */\n    public Object nextElement() {\n        return this.nextToken();\n    }\n\n    /**\n     * Returns the next token of the string to be tokenized\n     *\n     * @return String - the next token of the string\n     */\n    public String nextToken() {\n        String tmp;\n        /* if there are more tokens get next one, else the last token is empty */\n        tmp = (this.hasMoreTokens() ? super.nextToken() : \"\");\n        /* tmp is a delimiter -> the currentToken is empty */\n        if (this.getDelimiters().indexOf(tmp) >= 0) {\n            tmp = \"\";\n        } else /*\n\t\t * tmp is not a delimiter and the String has more tokens -> the\n\t\t * currentToken is not empty\n\t\t */\n        if (this.hasMoreTokens()) {\n            // This is a delimiter for sure.\n            super.nextToken();\n        } else /*\n\t\t * tmp is not a delimiter and the token is the last one -> the\n\t\t * currentToken is not empty\n\t\t */\n        {\n            /*\n\t\t\t *  do nothing\n\t\t\t */\n        }\n        return tmp;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/ASCIITokenizerTest1.java",
		"test_prompt": "// ASCIITokenizerTest1.java\npackage net.sf.xbus.base.core;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASCIITokenizer}.\n* It contains ten unit test cases for the {@link ASCIITokenizer#nextElement()} method.\n*/\nclass ASCIITokenizerTest1 {"
	},
	{
		"original_code": "// ASCIITokenizer.java\npackage net.sf.xbus.base.core;\n\n/**\n * A StringTokenizer, that conveniently tokenizes a ASCII-file The main\n * difference to its base class is, that it doesn�t count the delimiters as\n * tokens in method countTokens() and that its methods nextElement() and\n * nextToken() don�t return a delimiter, but an empty Object/String if there are\n * two delimiters next to each other.\n *\n * @see java.util.StringTokenizer\n * @author Martin Sturzenhecker\n */\npublic class ASCIITokenizer extends java.util.StringTokenizer {\n\n    /**\n     * The string to be tokenized\n     */\n    private String string;\n\n    /**\n     * The delimiters\n     */\n    private String delims;\n\n    /**\n     * Creates a new instance of <code>ASCIIOfferTokenizer</code>\n     *\n     * @param str String to be tokenized\n     * @param delim String separator\n     */\n    public ASCIITokenizer(String str, String delim) {\n        super(str, delim, true);\n        this.string = str;\n        this.delims = delim;\n    }\n\n    /**\n     * Creates a new instance of <code>ASCIIOfferTokenizer</code>\n     *\n     * @param str String to be tokenized\n     * @param delim String separator\n     * @param returnTokens boolean: shall the delimiters be returned?\n     */\n    private ASCIITokenizer(String str, String delim, boolean returnTokens) {\n        super(str, delim, returnTokens);\n        this.string = str;\n        this.delims = delim;\n    }\n\n    /**\n     * Counts the number of tokens in the string to be tokenized\n     * <p>\n     * The delimiters are <b>not</b> counted unlike in class StringTokenizer\n     *\n     * @return int - the number of tokens without the delimiters\n     */\n    public int countTokens() {\n        // toky exists for counting purposes only. It�s the same as the current\n        // Tokenizer\n        ASCIITokenizer toky = new ASCIITokenizer(this.string, this.delims, true);\n        int count = 0;\n        String last = \"\";\n        while (toky.hasMoreTokens()) {\n            last = toky.nextToken();\n            count++;\n        }\n        return (this.getDelimiters().indexOf(last) >= 0 ? count + 1 : count);\n    }\n\n    /**\n     * Returns the delimiters of this tokenizer\n     *\n     * @return String -the delimiters of this tokenizer\n     */\n    public java.lang.String getDelimiters() {\n        return delims;\n    }\n\n    /**\n     * Returns the string to be tokenized\n     *\n     * @return String to be tokenized\n     */\n    public java.lang.String getStr() {\n        return string;\n    }\n\n    /**\n     * Returns the next element of the string to be tokenized\n     * <p>\n     * It does quite the same as the method <code>nextToken()</code> but it\n     * returns an <code>Object</code> instead of a String\n     *\n     * @return Object - the next element of the string\n     * @see #nextToken()\n     */\n    public Object nextElement() {\n        return this.nextToken();\n    }\n\n    /**\n     * Returns the next token of the string to be tokenized\n     *\n     * @return String - the next token of the string\n     */\n    public String nextToken() {\n        String tmp;\n        /* if there are more tokens get next one, else the last token is empty */\n        tmp = (this.hasMoreTokens() ? super.nextToken() : \"\");\n        /* tmp is a delimiter -> the currentToken is empty */\n        if (this.getDelimiters().indexOf(tmp) >= 0) {\n            tmp = \"\";\n        } else /*\n\t\t * tmp is not a delimiter and the String has more tokens -> the\n\t\t * currentToken is not empty\n\t\t */\n        if (this.hasMoreTokens()) {\n            // This is a delimiter for sure.\n            super.nextToken();\n        } else /*\n\t\t * tmp is not a delimiter and the token is the last one -> the\n\t\t * currentToken is not empty\n\t\t */\n        {\n            /*\n\t\t\t *  do nothing\n\t\t\t */\n        }\n        return tmp;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/ASCIITokenizerTest2.java",
		"test_prompt": "// ASCIITokenizerTest2.java\npackage net.sf.xbus.base.core;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ASCIITokenizer}.\n* It contains ten unit test cases for the {@link ASCIITokenizer#nextToken()} method.\n*/\nclass ASCIITokenizerTest2 {"
	},
	{
		"original_code": "// Configuration.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * This class reads program parameters from different sources and makes them\n * accessible. The entries of the configuration are organized in a three-level\n * hierarchie:\n * <p>\n * <ul>\n * <li>The <b>chapter </b> is the top level. Often you will find names of\n * components or classes at this level.</li>\n * <li>Every chapter contains one or more <b>sections </b></li>\n * <li><b>Keys </b> are at the bottom of the hierarchie, beyond the sections.\n * </ul>\n *\n * The <code>Configuration</code> implements the <b>Singleton </b>\n * Design-Pattern.\n * <p>\n *\n * Up to now, only the Java- <code>Properties</code> can be used as a source\n * for the configuration. Other sources like XML-files or a database are\n * prepared.\n */\npublic class Configuration {\n\n    public static final String STANDARD_CONFIG = \"standard\";\n\n    private static final String XBUS_HOME = \"$XBUS_HOME$\";\n\n    public static final String VARIABLE_PREFIX = \"$VARIABLE_\";\n\n    public static final String VARIABLE_END = \"$\";\n\n    public static final String MAPPING_DEFAULT = \"Default\";\n\n    // private static Configuration mSingleInstance = null;\n    private static Hashtable mInstances = new Hashtable();\n\n    private static final Object classLock = Configuration.class;\n\n    private Hashtable mCache = null;\n\n    private ConfigSource mSource = null;\n\n    /**\n     * The constructor is private. Instances of <code>Configuration</code> can\n     * only be accessed via the method <code>getInstance()</code>.\n     *\n     * @param source the source of the properties.\n     * @exception XException if any error occurs\n     */\n    private Configuration(String source) {\n        /*\n\t\t * Check if XBUS_HOME is set. This is done here, because loading the\n\t\t * configuration will be the first point, where XBUS_HOME is used.\n\t\t */\n        if (Constants.XBUS_HOME == null) {\n            System.out.println(\"I_00_000_2 XBUS_HOME has not been set!\");\n            System.exit(1);\n        }\n        /*\n\t\t * Initialize the source of the configuration entries.\n\t\t */\n        mSource = new PropertiesSource(source);\n    }\n\n    // Configuration(String source)\n    /**\n     * Returns an instance of the standard <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance() throws XException {\n        return getInstance(STANDARD_CONFIG);\n    }\n\n    // getInstance()\n    /**\n     * Returns a named instance of the <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @param source the source of the properties.\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance(String source) throws XException {\n        synchronized (classLock) {\n            Configuration instance = (Configuration) mInstances.get(source);\n            if (instance == null) {\n                instance = new Configuration(source);\n                instance.readCache();\n                mInstances.put(source, instance);\n            }\n            // if (instance == null)\n            return instance;\n        }\n    }\n\n    // getInstance(String source)\n    /**\n     * Creates an updated instance of the standard <code>Configuration</code>.\n     *\n     * @exception XException if any error occurs\n     */\n    public static void refresh() throws XException {\n        refresh(STANDARD_CONFIG);\n    }\n\n    // refresh()\n    /**\n     * Creates an updated instance of the named <code>Configuration</code>.\n     *\n     * @param source the source of the properties\n     * @exception XException if any error occurs\n     */\n    public static void refresh(String source) throws XException {\n        mInstances.remove(source);\n        getInstance(source);\n    }\n\n    // refresh(String source)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry can not be found, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if the entry in configuration is not exist or any\n     *                error occurs\n     */\n    public String getValue(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        return returnString;\n    }\n\n    // getValue(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as an integer. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not an integer, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key *\n     * @exception XException if the entry in configuratiuon is not exist or it\n     *                is not an integer\n     */\n    public int getValueAsInt(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        try // for casting to XException\n        {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsInt(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an integer. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an integer, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public int getValueAsIntOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsIntOptional(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an long value. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an long value, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public long getValueAsLongOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            long retLong = Long.parseLong(returnString);\n            return retLong;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"5\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsLongOptional(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as a boolean. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not a boolean, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>boolean </i> for the given chapter, section and key\n     * @exception XException if the entry in the configuration is not exist or\n     *                it is not a boolean value\n     */\n    public boolean getValueAsBoolean(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBoolean(String chapter,String section,String key)\n    /**\n     * Returns the optional value of an entry as a boolean. All three parameters\n     * have to contain values.\n     * <p>\n     * If the desired entry can not be found, false is returned. If the value is\n     * not a boolean, a <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as boolean for the given chapter, section and key. <br>\n     *         If the entry in the configuration is not found, false is\n     *         returned.\n     * @exception XException if the entry is not a boolean value or any error\n     *                occurs\n     */\n    public boolean getValueAsBooleanOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return false;\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBooleanOptional(String chapter,String section,String key)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry is not in the configuration, <code>null</code>\n     * will be returned.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as string for the given chapter,section and key or null if\n     *         the desired value is not found in the configuration\n     */\n    public String getValueOptional(String chapter, String section, String key) {\n        return getValueInternal(chapter, section, key);\n    }\n\n    // getValueOptional(String chapter, String section, String key)\n    /**\n     * Returns a list of all chapters.\n     *\n     * @return List with chapters\n     * @exception XException if any error occurs\n     */\n    public List getChapters() {\n        TreeSet chapters = new TreeSet(mCache.keySet());\n        return new Vector(chapters);\n    }\n\n    // getChapters()\n    /**\n     * Returns a list of all sections for the given chapter\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @return List of all sections for the given chapter or null wenn no\n     *         sections are found\n     * @exception XException if any error occurs\n     */\n    public List getSections(String chapter) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        TreeSet sectionSet = new TreeSet(sections.keySet());\n        return new Vector(sectionSet);\n    }\n\n    // getSections(String chapter)\n    /**\n     * Returns a map of all keys and their values for the given chapter and\n     * section.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @return Map of all keys and their values for the given chapter and\n     *         section or <i>null </i> wenn no keys are found\n     * @exception XException if any error occurs\n     */\n    public Map getKeysAndValues(String chapter, String section) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(section);\n        if (keys != null) {\n            return new TreeMap(keys);\n        } else {\n            return null;\n        }\n    }\n\n    // getKeysAndValues(String chapter, String section)\n    /**\n     * Returns a value for the given chapter, section and key.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if any error occurs\n     */\n    private String getValueInternal(String chapter, String section, String key) {\n        Hashtable sectTable = (Hashtable) mCache.get(chapter);\n        if (sectTable == null) {\n            return null;\n        }\n        // if (sectTable == null)\n        Hashtable keyTable = (Hashtable) sectTable.get(section);\n        if (keyTable == null) {\n            return null;\n        }\n        // if (keyTable == null)\n        return (String) keyTable.get(key);\n    }\n\n    // getValueInternal(String chapter, String section, String key)\n    /**\n     * This method is used by {@link #getInstance()}and by\n     * {@link #getInstance(String)}for reading all entries from a source and\n     * filling a three-level hierarchie hashtable.\n     *\n     * @see net.sf.xbus.base.core.config.PropertiesSource#readCache()\n     * @exception XException if any error occurs\n     */\n    private void readCache() throws XException {\n        mCache = mSource.readCache();\n        replaceVariables(mCache);\n    }\n\n    // readCache()\n    /**\n     * Replaces XBUS_HOME and variables with the key\n     * <code>Base_Variable_xxx</code> in all entries of the current\n     * configuration.\n     */\n    private void replaceVariables(Hashtable cache) throws XException {\n        Map variables = getVariables(cache);\n        for (Enumeration chapters = cache.elements(); chapters.hasMoreElements(); ) {\n            Hashtable chapter = (Hashtable) chapters.nextElement();\n            for (Enumeration sections = chapter.elements(); sections.hasMoreElements(); ) {\n                Hashtable section = (Hashtable) sections.nextElement();\n                for (Enumeration keys = section.keys(); keys.hasMoreElements(); ) {\n                    String key = (String) keys.nextElement();\n                    String value = (String) section.get(key);\n                    /*\n\t\t\t\t\t * Replace further variables\n\t\t\t\t\t */\n                    int variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                    if (variablePosNew >= 0) {\n                        int variablePosOld = -99999;\n                        String variable = null;\n                        Set variablesKeySet = null;\n                        while ((variablePosNew >= 0) && (variablePosOld != variablePosNew)) {\n                            variablePosOld = variablePosNew;\n                            if (variables == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            variablesKeySet = variables.keySet();\n                            if (variablesKeySet == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            String variablesKey = null;\n                            for (Iterator it = variablesKeySet.iterator(); it.hasNext(); ) {\n                                variablesKey = (String) it.next();\n                                variable = (String) variables.get(variablesKey);\n                                if (value.indexOf(variablesKey) >= 0) {\n                                    value = XStringSupport.replaceAll(value, variablesKey, variable);\n                                }\n                            }\n                            variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                        }\n                        if (variablePosOld == variablePosNew) {\n                            /*\n\t\t\t\t\t\t\t * Found same variable again => variable cannot be\n\t\t\t\t\t\t\t * replaced\n\t\t\t\t\t\t\t */\n                            List params = new Vector();\n                            params.add(new Integer(variablePosOld));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"3\", params);\n                        }\n                    }\n                    /*\n\t\t\t\t\t * Replace XBUS_HOME\n\t\t\t\t\t */\n                    if (value.indexOf(XBUS_HOME) >= 0) {\n                        value = XStringSupport.replaceAll(value, XBUS_HOME, Constants.XBUS_HOME);\n                    }\n                    section.put(key, value);\n                }\n            }\n        }\n    }\n\n    private Map getVariables(Hashtable cache) {\n        Hashtable sections = (Hashtable) cache.get(Constants.CHAPTER_BASE);\n        Map variablesConf = null;\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(\"Variable\");\n        if (keys != null) {\n            variablesConf = new TreeMap(keys);\n        } else {\n            return null;\n        }\n        Map variablesNew = new Hashtable();\n        if (variablesConf != null) {\n            String key = null;\n            String variable = null;\n            for (Iterator it = variablesConf.keySet().iterator(); it.hasNext(); ) {\n                key = (String) it.next();\n                variable = (String) variablesConf.get(key);\n                key = new StringBuffer(VARIABLE_PREFIX).append(key).append(VARIABLE_END).toString();\n                variablesNew.put(key, variable);\n            }\n        }\n        return variablesNew;\n    }\n\n    /**\n     * Returns an entry of the class table.\n     *\n     * @see #getValue(String, String, String)\n     * @param type The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b>\n     * @param name The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b> and this\n     *            section\n     * @return Value as String for the given type and name\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getClass(String type, String name) throws XException {\n        return Configuration.getInstance(\"xbus\").getValue(\"Class\", type, name);\n    }\n\n    // getClass(String type, String name)\n    /**\n     * Returns an entry of the mapping table.\n     *\n     * @see #getValue(String, String, String)\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return Value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMapping(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValue(\"Mapping\", section, key);\n    }\n\n    // getMapping(String section, String key)\n    /**\n     * Returns an entry of the mapping table or <code>null</code> if it\n     * doesn't exist.\n     *\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMappingOptional(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValueOptional(\"Mapping\", section, key);\n    }\n\n    /**\n     * @param section\n     */\n    public static String getMappingDefault(String section) throws XException {\n        return getMapping(section, Configuration.MAPPING_DEFAULT);\n    }\n    // getMapping(String section, String key)\n}\n// Configuration\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/config/ConfigurationTest0.java",
		"test_prompt": "// ConfigurationTest0.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Configuration}.\n* It contains ten unit test cases for the {@link Configuration#getInstance()} method.\n*/\nclass ConfigurationTest0 {"
	},
	{
		"original_code": "// Configuration.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * This class reads program parameters from different sources and makes them\n * accessible. The entries of the configuration are organized in a three-level\n * hierarchie:\n * <p>\n * <ul>\n * <li>The <b>chapter </b> is the top level. Often you will find names of\n * components or classes at this level.</li>\n * <li>Every chapter contains one or more <b>sections </b></li>\n * <li><b>Keys </b> are at the bottom of the hierarchie, beyond the sections.\n * </ul>\n *\n * The <code>Configuration</code> implements the <b>Singleton </b>\n * Design-Pattern.\n * <p>\n *\n * Up to now, only the Java- <code>Properties</code> can be used as a source\n * for the configuration. Other sources like XML-files or a database are\n * prepared.\n */\npublic class Configuration {\n\n    public static final String STANDARD_CONFIG = \"standard\";\n\n    private static final String XBUS_HOME = \"$XBUS_HOME$\";\n\n    public static final String VARIABLE_PREFIX = \"$VARIABLE_\";\n\n    public static final String VARIABLE_END = \"$\";\n\n    public static final String MAPPING_DEFAULT = \"Default\";\n\n    // private static Configuration mSingleInstance = null;\n    private static Hashtable mInstances = new Hashtable();\n\n    private static final Object classLock = Configuration.class;\n\n    private Hashtable mCache = null;\n\n    private ConfigSource mSource = null;\n\n    /**\n     * The constructor is private. Instances of <code>Configuration</code> can\n     * only be accessed via the method <code>getInstance()</code>.\n     *\n     * @param source the source of the properties.\n     * @exception XException if any error occurs\n     */\n    private Configuration(String source) {\n        /*\n\t\t * Check if XBUS_HOME is set. This is done here, because loading the\n\t\t * configuration will be the first point, where XBUS_HOME is used.\n\t\t */\n        if (Constants.XBUS_HOME == null) {\n            System.out.println(\"I_00_000_2 XBUS_HOME has not been set!\");\n            System.exit(1);\n        }\n        /*\n\t\t * Initialize the source of the configuration entries.\n\t\t */\n        mSource = new PropertiesSource(source);\n    }\n\n    // Configuration(String source)\n    /**\n     * Returns an instance of the standard <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance() throws XException {\n        return getInstance(STANDARD_CONFIG);\n    }\n\n    // getInstance()\n    /**\n     * Returns a named instance of the <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @param source the source of the properties.\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance(String source) throws XException {\n        synchronized (classLock) {\n            Configuration instance = (Configuration) mInstances.get(source);\n            if (instance == null) {\n                instance = new Configuration(source);\n                instance.readCache();\n                mInstances.put(source, instance);\n            }\n            // if (instance == null)\n            return instance;\n        }\n    }\n\n    // getInstance(String source)\n    /**\n     * Creates an updated instance of the standard <code>Configuration</code>.\n     *\n     * @exception XException if any error occurs\n     */\n    public static void refresh() throws XException {\n        refresh(STANDARD_CONFIG);\n    }\n\n    // refresh()\n    /**\n     * Creates an updated instance of the named <code>Configuration</code>.\n     *\n     * @param source the source of the properties\n     * @exception XException if any error occurs\n     */\n    public static void refresh(String source) throws XException {\n        mInstances.remove(source);\n        getInstance(source);\n    }\n\n    // refresh(String source)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry can not be found, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if the entry in configuration is not exist or any\n     *                error occurs\n     */\n    public String getValue(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        return returnString;\n    }\n\n    // getValue(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as an integer. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not an integer, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key *\n     * @exception XException if the entry in configuratiuon is not exist or it\n     *                is not an integer\n     */\n    public int getValueAsInt(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        try // for casting to XException\n        {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsInt(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an integer. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an integer, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public int getValueAsIntOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsIntOptional(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an long value. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an long value, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public long getValueAsLongOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            long retLong = Long.parseLong(returnString);\n            return retLong;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"5\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsLongOptional(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as a boolean. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not a boolean, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>boolean </i> for the given chapter, section and key\n     * @exception XException if the entry in the configuration is not exist or\n     *                it is not a boolean value\n     */\n    public boolean getValueAsBoolean(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBoolean(String chapter,String section,String key)\n    /**\n     * Returns the optional value of an entry as a boolean. All three parameters\n     * have to contain values.\n     * <p>\n     * If the desired entry can not be found, false is returned. If the value is\n     * not a boolean, a <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as boolean for the given chapter, section and key. <br>\n     *         If the entry in the configuration is not found, false is\n     *         returned.\n     * @exception XException if the entry is not a boolean value or any error\n     *                occurs\n     */\n    public boolean getValueAsBooleanOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return false;\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBooleanOptional(String chapter,String section,String key)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry is not in the configuration, <code>null</code>\n     * will be returned.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as string for the given chapter,section and key or null if\n     *         the desired value is not found in the configuration\n     */\n    public String getValueOptional(String chapter, String section, String key) {\n        return getValueInternal(chapter, section, key);\n    }\n\n    // getValueOptional(String chapter, String section, String key)\n    /**\n     * Returns a list of all chapters.\n     *\n     * @return List with chapters\n     * @exception XException if any error occurs\n     */\n    public List getChapters() {\n        TreeSet chapters = new TreeSet(mCache.keySet());\n        return new Vector(chapters);\n    }\n\n    // getChapters()\n    /**\n     * Returns a list of all sections for the given chapter\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @return List of all sections for the given chapter or null wenn no\n     *         sections are found\n     * @exception XException if any error occurs\n     */\n    public List getSections(String chapter) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        TreeSet sectionSet = new TreeSet(sections.keySet());\n        return new Vector(sectionSet);\n    }\n\n    // getSections(String chapter)\n    /**\n     * Returns a map of all keys and their values for the given chapter and\n     * section.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @return Map of all keys and their values for the given chapter and\n     *         section or <i>null </i> wenn no keys are found\n     * @exception XException if any error occurs\n     */\n    public Map getKeysAndValues(String chapter, String section) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(section);\n        if (keys != null) {\n            return new TreeMap(keys);\n        } else {\n            return null;\n        }\n    }\n\n    // getKeysAndValues(String chapter, String section)\n    /**\n     * Returns a value for the given chapter, section and key.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if any error occurs\n     */\n    private String getValueInternal(String chapter, String section, String key) {\n        Hashtable sectTable = (Hashtable) mCache.get(chapter);\n        if (sectTable == null) {\n            return null;\n        }\n        // if (sectTable == null)\n        Hashtable keyTable = (Hashtable) sectTable.get(section);\n        if (keyTable == null) {\n            return null;\n        }\n        // if (keyTable == null)\n        return (String) keyTable.get(key);\n    }\n\n    // getValueInternal(String chapter, String section, String key)\n    /**\n     * This method is used by {@link #getInstance()}and by\n     * {@link #getInstance(String)}for reading all entries from a source and\n     * filling a three-level hierarchie hashtable.\n     *\n     * @see net.sf.xbus.base.core.config.PropertiesSource#readCache()\n     * @exception XException if any error occurs\n     */\n    private void readCache() throws XException {\n        mCache = mSource.readCache();\n        replaceVariables(mCache);\n    }\n\n    // readCache()\n    /**\n     * Replaces XBUS_HOME and variables with the key\n     * <code>Base_Variable_xxx</code> in all entries of the current\n     * configuration.\n     */\n    private void replaceVariables(Hashtable cache) throws XException {\n        Map variables = getVariables(cache);\n        for (Enumeration chapters = cache.elements(); chapters.hasMoreElements(); ) {\n            Hashtable chapter = (Hashtable) chapters.nextElement();\n            for (Enumeration sections = chapter.elements(); sections.hasMoreElements(); ) {\n                Hashtable section = (Hashtable) sections.nextElement();\n                for (Enumeration keys = section.keys(); keys.hasMoreElements(); ) {\n                    String key = (String) keys.nextElement();\n                    String value = (String) section.get(key);\n                    /*\n\t\t\t\t\t * Replace further variables\n\t\t\t\t\t */\n                    int variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                    if (variablePosNew >= 0) {\n                        int variablePosOld = -99999;\n                        String variable = null;\n                        Set variablesKeySet = null;\n                        while ((variablePosNew >= 0) && (variablePosOld != variablePosNew)) {\n                            variablePosOld = variablePosNew;\n                            if (variables == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            variablesKeySet = variables.keySet();\n                            if (variablesKeySet == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            String variablesKey = null;\n                            for (Iterator it = variablesKeySet.iterator(); it.hasNext(); ) {\n                                variablesKey = (String) it.next();\n                                variable = (String) variables.get(variablesKey);\n                                if (value.indexOf(variablesKey) >= 0) {\n                                    value = XStringSupport.replaceAll(value, variablesKey, variable);\n                                }\n                            }\n                            variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                        }\n                        if (variablePosOld == variablePosNew) {\n                            /*\n\t\t\t\t\t\t\t * Found same variable again => variable cannot be\n\t\t\t\t\t\t\t * replaced\n\t\t\t\t\t\t\t */\n                            List params = new Vector();\n                            params.add(new Integer(variablePosOld));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"3\", params);\n                        }\n                    }\n                    /*\n\t\t\t\t\t * Replace XBUS_HOME\n\t\t\t\t\t */\n                    if (value.indexOf(XBUS_HOME) >= 0) {\n                        value = XStringSupport.replaceAll(value, XBUS_HOME, Constants.XBUS_HOME);\n                    }\n                    section.put(key, value);\n                }\n            }\n        }\n    }\n\n    private Map getVariables(Hashtable cache) {\n        Hashtable sections = (Hashtable) cache.get(Constants.CHAPTER_BASE);\n        Map variablesConf = null;\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(\"Variable\");\n        if (keys != null) {\n            variablesConf = new TreeMap(keys);\n        } else {\n            return null;\n        }\n        Map variablesNew = new Hashtable();\n        if (variablesConf != null) {\n            String key = null;\n            String variable = null;\n            for (Iterator it = variablesConf.keySet().iterator(); it.hasNext(); ) {\n                key = (String) it.next();\n                variable = (String) variablesConf.get(key);\n                key = new StringBuffer(VARIABLE_PREFIX).append(key).append(VARIABLE_END).toString();\n                variablesNew.put(key, variable);\n            }\n        }\n        return variablesNew;\n    }\n\n    /**\n     * Returns an entry of the class table.\n     *\n     * @see #getValue(String, String, String)\n     * @param type The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b>\n     * @param name The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b> and this\n     *            section\n     * @return Value as String for the given type and name\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getClass(String type, String name) throws XException {\n        return Configuration.getInstance(\"xbus\").getValue(\"Class\", type, name);\n    }\n\n    // getClass(String type, String name)\n    /**\n     * Returns an entry of the mapping table.\n     *\n     * @see #getValue(String, String, String)\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return Value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMapping(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValue(\"Mapping\", section, key);\n    }\n\n    // getMapping(String section, String key)\n    /**\n     * Returns an entry of the mapping table or <code>null</code> if it\n     * doesn't exist.\n     *\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMappingOptional(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValueOptional(\"Mapping\", section, key);\n    }\n\n    /**\n     * @param section\n     */\n    public static String getMappingDefault(String section) throws XException {\n        return getMapping(section, Configuration.MAPPING_DEFAULT);\n    }\n    // getMapping(String section, String key)\n}\n// Configuration\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/config/ConfigurationTest1.java",
		"test_prompt": "// ConfigurationTest1.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Configuration}.\n* It contains ten unit test cases for the {@link Configuration#getInstance(String)} method.\n*/\nclass ConfigurationTest1 {"
	},
	{
		"original_code": "// Configuration.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * This class reads program parameters from different sources and makes them\n * accessible. The entries of the configuration are organized in a three-level\n * hierarchie:\n * <p>\n * <ul>\n * <li>The <b>chapter </b> is the top level. Often you will find names of\n * components or classes at this level.</li>\n * <li>Every chapter contains one or more <b>sections </b></li>\n * <li><b>Keys </b> are at the bottom of the hierarchie, beyond the sections.\n * </ul>\n *\n * The <code>Configuration</code> implements the <b>Singleton </b>\n * Design-Pattern.\n * <p>\n *\n * Up to now, only the Java- <code>Properties</code> can be used as a source\n * for the configuration. Other sources like XML-files or a database are\n * prepared.\n */\npublic class Configuration {\n\n    public static final String STANDARD_CONFIG = \"standard\";\n\n    private static final String XBUS_HOME = \"$XBUS_HOME$\";\n\n    public static final String VARIABLE_PREFIX = \"$VARIABLE_\";\n\n    public static final String VARIABLE_END = \"$\";\n\n    public static final String MAPPING_DEFAULT = \"Default\";\n\n    // private static Configuration mSingleInstance = null;\n    private static Hashtable mInstances = new Hashtable();\n\n    private static final Object classLock = Configuration.class;\n\n    private Hashtable mCache = null;\n\n    private ConfigSource mSource = null;\n\n    /**\n     * The constructor is private. Instances of <code>Configuration</code> can\n     * only be accessed via the method <code>getInstance()</code>.\n     *\n     * @param source the source of the properties.\n     * @exception XException if any error occurs\n     */\n    private Configuration(String source) {\n        /*\n\t\t * Check if XBUS_HOME is set. This is done here, because loading the\n\t\t * configuration will be the first point, where XBUS_HOME is used.\n\t\t */\n        if (Constants.XBUS_HOME == null) {\n            System.out.println(\"I_00_000_2 XBUS_HOME has not been set!\");\n            System.exit(1);\n        }\n        /*\n\t\t * Initialize the source of the configuration entries.\n\t\t */\n        mSource = new PropertiesSource(source);\n    }\n\n    // Configuration(String source)\n    /**\n     * Returns an instance of the standard <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance() throws XException {\n        return getInstance(STANDARD_CONFIG);\n    }\n\n    // getInstance()\n    /**\n     * Returns a named instance of the <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @param source the source of the properties.\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance(String source) throws XException {\n        synchronized (classLock) {\n            Configuration instance = (Configuration) mInstances.get(source);\n            if (instance == null) {\n                instance = new Configuration(source);\n                instance.readCache();\n                mInstances.put(source, instance);\n            }\n            // if (instance == null)\n            return instance;\n        }\n    }\n\n    // getInstance(String source)\n    /**\n     * Creates an updated instance of the standard <code>Configuration</code>.\n     *\n     * @exception XException if any error occurs\n     */\n    public static void refresh() throws XException {\n        refresh(STANDARD_CONFIG);\n    }\n\n    // refresh()\n    /**\n     * Creates an updated instance of the named <code>Configuration</code>.\n     *\n     * @param source the source of the properties\n     * @exception XException if any error occurs\n     */\n    public static void refresh(String source) throws XException {\n        mInstances.remove(source);\n        getInstance(source);\n    }\n\n    // refresh(String source)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry can not be found, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if the entry in configuration is not exist or any\n     *                error occurs\n     */\n    public String getValue(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        return returnString;\n    }\n\n    // getValue(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as an integer. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not an integer, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key *\n     * @exception XException if the entry in configuratiuon is not exist or it\n     *                is not an integer\n     */\n    public int getValueAsInt(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        try // for casting to XException\n        {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsInt(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an integer. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an integer, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public int getValueAsIntOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsIntOptional(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an long value. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an long value, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public long getValueAsLongOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            long retLong = Long.parseLong(returnString);\n            return retLong;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"5\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsLongOptional(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as a boolean. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not a boolean, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>boolean </i> for the given chapter, section and key\n     * @exception XException if the entry in the configuration is not exist or\n     *                it is not a boolean value\n     */\n    public boolean getValueAsBoolean(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBoolean(String chapter,String section,String key)\n    /**\n     * Returns the optional value of an entry as a boolean. All three parameters\n     * have to contain values.\n     * <p>\n     * If the desired entry can not be found, false is returned. If the value is\n     * not a boolean, a <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as boolean for the given chapter, section and key. <br>\n     *         If the entry in the configuration is not found, false is\n     *         returned.\n     * @exception XException if the entry is not a boolean value or any error\n     *                occurs\n     */\n    public boolean getValueAsBooleanOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return false;\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBooleanOptional(String chapter,String section,String key)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry is not in the configuration, <code>null</code>\n     * will be returned.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as string for the given chapter,section and key or null if\n     *         the desired value is not found in the configuration\n     */\n    public String getValueOptional(String chapter, String section, String key) {\n        return getValueInternal(chapter, section, key);\n    }\n\n    // getValueOptional(String chapter, String section, String key)\n    /**\n     * Returns a list of all chapters.\n     *\n     * @return List with chapters\n     * @exception XException if any error occurs\n     */\n    public List getChapters() {\n        TreeSet chapters = new TreeSet(mCache.keySet());\n        return new Vector(chapters);\n    }\n\n    // getChapters()\n    /**\n     * Returns a list of all sections for the given chapter\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @return List of all sections for the given chapter or null wenn no\n     *         sections are found\n     * @exception XException if any error occurs\n     */\n    public List getSections(String chapter) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        TreeSet sectionSet = new TreeSet(sections.keySet());\n        return new Vector(sectionSet);\n    }\n\n    // getSections(String chapter)\n    /**\n     * Returns a map of all keys and their values for the given chapter and\n     * section.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @return Map of all keys and their values for the given chapter and\n     *         section or <i>null </i> wenn no keys are found\n     * @exception XException if any error occurs\n     */\n    public Map getKeysAndValues(String chapter, String section) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(section);\n        if (keys != null) {\n            return new TreeMap(keys);\n        } else {\n            return null;\n        }\n    }\n\n    // getKeysAndValues(String chapter, String section)\n    /**\n     * Returns a value for the given chapter, section and key.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if any error occurs\n     */\n    private String getValueInternal(String chapter, String section, String key) {\n        Hashtable sectTable = (Hashtable) mCache.get(chapter);\n        if (sectTable == null) {\n            return null;\n        }\n        // if (sectTable == null)\n        Hashtable keyTable = (Hashtable) sectTable.get(section);\n        if (keyTable == null) {\n            return null;\n        }\n        // if (keyTable == null)\n        return (String) keyTable.get(key);\n    }\n\n    // getValueInternal(String chapter, String section, String key)\n    /**\n     * This method is used by {@link #getInstance()}and by\n     * {@link #getInstance(String)}for reading all entries from a source and\n     * filling a three-level hierarchie hashtable.\n     *\n     * @see net.sf.xbus.base.core.config.PropertiesSource#readCache()\n     * @exception XException if any error occurs\n     */\n    private void readCache() throws XException {\n        mCache = mSource.readCache();\n        replaceVariables(mCache);\n    }\n\n    // readCache()\n    /**\n     * Replaces XBUS_HOME and variables with the key\n     * <code>Base_Variable_xxx</code> in all entries of the current\n     * configuration.\n     */\n    private void replaceVariables(Hashtable cache) throws XException {\n        Map variables = getVariables(cache);\n        for (Enumeration chapters = cache.elements(); chapters.hasMoreElements(); ) {\n            Hashtable chapter = (Hashtable) chapters.nextElement();\n            for (Enumeration sections = chapter.elements(); sections.hasMoreElements(); ) {\n                Hashtable section = (Hashtable) sections.nextElement();\n                for (Enumeration keys = section.keys(); keys.hasMoreElements(); ) {\n                    String key = (String) keys.nextElement();\n                    String value = (String) section.get(key);\n                    /*\n\t\t\t\t\t * Replace further variables\n\t\t\t\t\t */\n                    int variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                    if (variablePosNew >= 0) {\n                        int variablePosOld = -99999;\n                        String variable = null;\n                        Set variablesKeySet = null;\n                        while ((variablePosNew >= 0) && (variablePosOld != variablePosNew)) {\n                            variablePosOld = variablePosNew;\n                            if (variables == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            variablesKeySet = variables.keySet();\n                            if (variablesKeySet == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            String variablesKey = null;\n                            for (Iterator it = variablesKeySet.iterator(); it.hasNext(); ) {\n                                variablesKey = (String) it.next();\n                                variable = (String) variables.get(variablesKey);\n                                if (value.indexOf(variablesKey) >= 0) {\n                                    value = XStringSupport.replaceAll(value, variablesKey, variable);\n                                }\n                            }\n                            variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                        }\n                        if (variablePosOld == variablePosNew) {\n                            /*\n\t\t\t\t\t\t\t * Found same variable again => variable cannot be\n\t\t\t\t\t\t\t * replaced\n\t\t\t\t\t\t\t */\n                            List params = new Vector();\n                            params.add(new Integer(variablePosOld));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"3\", params);\n                        }\n                    }\n                    /*\n\t\t\t\t\t * Replace XBUS_HOME\n\t\t\t\t\t */\n                    if (value.indexOf(XBUS_HOME) >= 0) {\n                        value = XStringSupport.replaceAll(value, XBUS_HOME, Constants.XBUS_HOME);\n                    }\n                    section.put(key, value);\n                }\n            }\n        }\n    }\n\n    private Map getVariables(Hashtable cache) {\n        Hashtable sections = (Hashtable) cache.get(Constants.CHAPTER_BASE);\n        Map variablesConf = null;\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(\"Variable\");\n        if (keys != null) {\n            variablesConf = new TreeMap(keys);\n        } else {\n            return null;\n        }\n        Map variablesNew = new Hashtable();\n        if (variablesConf != null) {\n            String key = null;\n            String variable = null;\n            for (Iterator it = variablesConf.keySet().iterator(); it.hasNext(); ) {\n                key = (String) it.next();\n                variable = (String) variablesConf.get(key);\n                key = new StringBuffer(VARIABLE_PREFIX).append(key).append(VARIABLE_END).toString();\n                variablesNew.put(key, variable);\n            }\n        }\n        return variablesNew;\n    }\n\n    /**\n     * Returns an entry of the class table.\n     *\n     * @see #getValue(String, String, String)\n     * @param type The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b>\n     * @param name The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b> and this\n     *            section\n     * @return Value as String for the given type and name\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getClass(String type, String name) throws XException {\n        return Configuration.getInstance(\"xbus\").getValue(\"Class\", type, name);\n    }\n\n    // getClass(String type, String name)\n    /**\n     * Returns an entry of the mapping table.\n     *\n     * @see #getValue(String, String, String)\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return Value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMapping(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValue(\"Mapping\", section, key);\n    }\n\n    // getMapping(String section, String key)\n    /**\n     * Returns an entry of the mapping table or <code>null</code> if it\n     * doesn't exist.\n     *\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMappingOptional(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValueOptional(\"Mapping\", section, key);\n    }\n\n    /**\n     * @param section\n     */\n    public static String getMappingDefault(String section) throws XException {\n        return getMapping(section, Configuration.MAPPING_DEFAULT);\n    }\n    // getMapping(String section, String key)\n}\n// Configuration\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/config/ConfigurationTest2.java",
		"test_prompt": "// ConfigurationTest2.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Configuration}.\n* It contains ten unit test cases for the {@link Configuration#getClass(String, String)} method.\n*/\nclass ConfigurationTest2 {"
	},
	{
		"original_code": "// Configuration.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * This class reads program parameters from different sources and makes them\n * accessible. The entries of the configuration are organized in a three-level\n * hierarchie:\n * <p>\n * <ul>\n * <li>The <b>chapter </b> is the top level. Often you will find names of\n * components or classes at this level.</li>\n * <li>Every chapter contains one or more <b>sections </b></li>\n * <li><b>Keys </b> are at the bottom of the hierarchie, beyond the sections.\n * </ul>\n *\n * The <code>Configuration</code> implements the <b>Singleton </b>\n * Design-Pattern.\n * <p>\n *\n * Up to now, only the Java- <code>Properties</code> can be used as a source\n * for the configuration. Other sources like XML-files or a database are\n * prepared.\n */\npublic class Configuration {\n\n    public static final String STANDARD_CONFIG = \"standard\";\n\n    private static final String XBUS_HOME = \"$XBUS_HOME$\";\n\n    public static final String VARIABLE_PREFIX = \"$VARIABLE_\";\n\n    public static final String VARIABLE_END = \"$\";\n\n    public static final String MAPPING_DEFAULT = \"Default\";\n\n    // private static Configuration mSingleInstance = null;\n    private static Hashtable mInstances = new Hashtable();\n\n    private static final Object classLock = Configuration.class;\n\n    private Hashtable mCache = null;\n\n    private ConfigSource mSource = null;\n\n    /**\n     * The constructor is private. Instances of <code>Configuration</code> can\n     * only be accessed via the method <code>getInstance()</code>.\n     *\n     * @param source the source of the properties.\n     * @exception XException if any error occurs\n     */\n    private Configuration(String source) {\n        /*\n\t\t * Check if XBUS_HOME is set. This is done here, because loading the\n\t\t * configuration will be the first point, where XBUS_HOME is used.\n\t\t */\n        if (Constants.XBUS_HOME == null) {\n            System.out.println(\"I_00_000_2 XBUS_HOME has not been set!\");\n            System.exit(1);\n        }\n        /*\n\t\t * Initialize the source of the configuration entries.\n\t\t */\n        mSource = new PropertiesSource(source);\n    }\n\n    // Configuration(String source)\n    /**\n     * Returns an instance of the standard <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance() throws XException {\n        return getInstance(STANDARD_CONFIG);\n    }\n\n    // getInstance()\n    /**\n     * Returns a named instance of the <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @param source the source of the properties.\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance(String source) throws XException {\n        synchronized (classLock) {\n            Configuration instance = (Configuration) mInstances.get(source);\n            if (instance == null) {\n                instance = new Configuration(source);\n                instance.readCache();\n                mInstances.put(source, instance);\n            }\n            // if (instance == null)\n            return instance;\n        }\n    }\n\n    // getInstance(String source)\n    /**\n     * Creates an updated instance of the standard <code>Configuration</code>.\n     *\n     * @exception XException if any error occurs\n     */\n    public static void refresh() throws XException {\n        refresh(STANDARD_CONFIG);\n    }\n\n    // refresh()\n    /**\n     * Creates an updated instance of the named <code>Configuration</code>.\n     *\n     * @param source the source of the properties\n     * @exception XException if any error occurs\n     */\n    public static void refresh(String source) throws XException {\n        mInstances.remove(source);\n        getInstance(source);\n    }\n\n    // refresh(String source)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry can not be found, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if the entry in configuration is not exist or any\n     *                error occurs\n     */\n    public String getValue(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        return returnString;\n    }\n\n    // getValue(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as an integer. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not an integer, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key *\n     * @exception XException if the entry in configuratiuon is not exist or it\n     *                is not an integer\n     */\n    public int getValueAsInt(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        try // for casting to XException\n        {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsInt(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an integer. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an integer, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public int getValueAsIntOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsIntOptional(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an long value. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an long value, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public long getValueAsLongOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            long retLong = Long.parseLong(returnString);\n            return retLong;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"5\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsLongOptional(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as a boolean. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not a boolean, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>boolean </i> for the given chapter, section and key\n     * @exception XException if the entry in the configuration is not exist or\n     *                it is not a boolean value\n     */\n    public boolean getValueAsBoolean(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBoolean(String chapter,String section,String key)\n    /**\n     * Returns the optional value of an entry as a boolean. All three parameters\n     * have to contain values.\n     * <p>\n     * If the desired entry can not be found, false is returned. If the value is\n     * not a boolean, a <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as boolean for the given chapter, section and key. <br>\n     *         If the entry in the configuration is not found, false is\n     *         returned.\n     * @exception XException if the entry is not a boolean value or any error\n     *                occurs\n     */\n    public boolean getValueAsBooleanOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return false;\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBooleanOptional(String chapter,String section,String key)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry is not in the configuration, <code>null</code>\n     * will be returned.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as string for the given chapter,section and key or null if\n     *         the desired value is not found in the configuration\n     */\n    public String getValueOptional(String chapter, String section, String key) {\n        return getValueInternal(chapter, section, key);\n    }\n\n    // getValueOptional(String chapter, String section, String key)\n    /**\n     * Returns a list of all chapters.\n     *\n     * @return List with chapters\n     * @exception XException if any error occurs\n     */\n    public List getChapters() {\n        TreeSet chapters = new TreeSet(mCache.keySet());\n        return new Vector(chapters);\n    }\n\n    // getChapters()\n    /**\n     * Returns a list of all sections for the given chapter\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @return List of all sections for the given chapter or null wenn no\n     *         sections are found\n     * @exception XException if any error occurs\n     */\n    public List getSections(String chapter) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        TreeSet sectionSet = new TreeSet(sections.keySet());\n        return new Vector(sectionSet);\n    }\n\n    // getSections(String chapter)\n    /**\n     * Returns a map of all keys and their values for the given chapter and\n     * section.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @return Map of all keys and their values for the given chapter and\n     *         section or <i>null </i> wenn no keys are found\n     * @exception XException if any error occurs\n     */\n    public Map getKeysAndValues(String chapter, String section) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(section);\n        if (keys != null) {\n            return new TreeMap(keys);\n        } else {\n            return null;\n        }\n    }\n\n    // getKeysAndValues(String chapter, String section)\n    /**\n     * Returns a value for the given chapter, section and key.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if any error occurs\n     */\n    private String getValueInternal(String chapter, String section, String key) {\n        Hashtable sectTable = (Hashtable) mCache.get(chapter);\n        if (sectTable == null) {\n            return null;\n        }\n        // if (sectTable == null)\n        Hashtable keyTable = (Hashtable) sectTable.get(section);\n        if (keyTable == null) {\n            return null;\n        }\n        // if (keyTable == null)\n        return (String) keyTable.get(key);\n    }\n\n    // getValueInternal(String chapter, String section, String key)\n    /**\n     * This method is used by {@link #getInstance()}and by\n     * {@link #getInstance(String)}for reading all entries from a source and\n     * filling a three-level hierarchie hashtable.\n     *\n     * @see net.sf.xbus.base.core.config.PropertiesSource#readCache()\n     * @exception XException if any error occurs\n     */\n    private void readCache() throws XException {\n        mCache = mSource.readCache();\n        replaceVariables(mCache);\n    }\n\n    // readCache()\n    /**\n     * Replaces XBUS_HOME and variables with the key\n     * <code>Base_Variable_xxx</code> in all entries of the current\n     * configuration.\n     */\n    private void replaceVariables(Hashtable cache) throws XException {\n        Map variables = getVariables(cache);\n        for (Enumeration chapters = cache.elements(); chapters.hasMoreElements(); ) {\n            Hashtable chapter = (Hashtable) chapters.nextElement();\n            for (Enumeration sections = chapter.elements(); sections.hasMoreElements(); ) {\n                Hashtable section = (Hashtable) sections.nextElement();\n                for (Enumeration keys = section.keys(); keys.hasMoreElements(); ) {\n                    String key = (String) keys.nextElement();\n                    String value = (String) section.get(key);\n                    /*\n\t\t\t\t\t * Replace further variables\n\t\t\t\t\t */\n                    int variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                    if (variablePosNew >= 0) {\n                        int variablePosOld = -99999;\n                        String variable = null;\n                        Set variablesKeySet = null;\n                        while ((variablePosNew >= 0) && (variablePosOld != variablePosNew)) {\n                            variablePosOld = variablePosNew;\n                            if (variables == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            variablesKeySet = variables.keySet();\n                            if (variablesKeySet == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            String variablesKey = null;\n                            for (Iterator it = variablesKeySet.iterator(); it.hasNext(); ) {\n                                variablesKey = (String) it.next();\n                                variable = (String) variables.get(variablesKey);\n                                if (value.indexOf(variablesKey) >= 0) {\n                                    value = XStringSupport.replaceAll(value, variablesKey, variable);\n                                }\n                            }\n                            variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                        }\n                        if (variablePosOld == variablePosNew) {\n                            /*\n\t\t\t\t\t\t\t * Found same variable again => variable cannot be\n\t\t\t\t\t\t\t * replaced\n\t\t\t\t\t\t\t */\n                            List params = new Vector();\n                            params.add(new Integer(variablePosOld));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"3\", params);\n                        }\n                    }\n                    /*\n\t\t\t\t\t * Replace XBUS_HOME\n\t\t\t\t\t */\n                    if (value.indexOf(XBUS_HOME) >= 0) {\n                        value = XStringSupport.replaceAll(value, XBUS_HOME, Constants.XBUS_HOME);\n                    }\n                    section.put(key, value);\n                }\n            }\n        }\n    }\n\n    private Map getVariables(Hashtable cache) {\n        Hashtable sections = (Hashtable) cache.get(Constants.CHAPTER_BASE);\n        Map variablesConf = null;\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(\"Variable\");\n        if (keys != null) {\n            variablesConf = new TreeMap(keys);\n        } else {\n            return null;\n        }\n        Map variablesNew = new Hashtable();\n        if (variablesConf != null) {\n            String key = null;\n            String variable = null;\n            for (Iterator it = variablesConf.keySet().iterator(); it.hasNext(); ) {\n                key = (String) it.next();\n                variable = (String) variablesConf.get(key);\n                key = new StringBuffer(VARIABLE_PREFIX).append(key).append(VARIABLE_END).toString();\n                variablesNew.put(key, variable);\n            }\n        }\n        return variablesNew;\n    }\n\n    /**\n     * Returns an entry of the class table.\n     *\n     * @see #getValue(String, String, String)\n     * @param type The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b>\n     * @param name The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b> and this\n     *            section\n     * @return Value as String for the given type and name\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getClass(String type, String name) throws XException {\n        return Configuration.getInstance(\"xbus\").getValue(\"Class\", type, name);\n    }\n\n    // getClass(String type, String name)\n    /**\n     * Returns an entry of the mapping table.\n     *\n     * @see #getValue(String, String, String)\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return Value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMapping(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValue(\"Mapping\", section, key);\n    }\n\n    // getMapping(String section, String key)\n    /**\n     * Returns an entry of the mapping table or <code>null</code> if it\n     * doesn't exist.\n     *\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMappingOptional(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValueOptional(\"Mapping\", section, key);\n    }\n\n    /**\n     * @param section\n     */\n    public static String getMappingDefault(String section) throws XException {\n        return getMapping(section, Configuration.MAPPING_DEFAULT);\n    }\n    // getMapping(String section, String key)\n}\n// Configuration\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/config/ConfigurationTest3.java",
		"test_prompt": "// ConfigurationTest3.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Configuration}.\n* It contains ten unit test cases for the {@link Configuration#getMapping(String, String)} method.\n*/\nclass ConfigurationTest3 {"
	},
	{
		"original_code": "// Configuration.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * This class reads program parameters from different sources and makes them\n * accessible. The entries of the configuration are organized in a three-level\n * hierarchie:\n * <p>\n * <ul>\n * <li>The <b>chapter </b> is the top level. Often you will find names of\n * components or classes at this level.</li>\n * <li>Every chapter contains one or more <b>sections </b></li>\n * <li><b>Keys </b> are at the bottom of the hierarchie, beyond the sections.\n * </ul>\n *\n * The <code>Configuration</code> implements the <b>Singleton </b>\n * Design-Pattern.\n * <p>\n *\n * Up to now, only the Java- <code>Properties</code> can be used as a source\n * for the configuration. Other sources like XML-files or a database are\n * prepared.\n */\npublic class Configuration {\n\n    public static final String STANDARD_CONFIG = \"standard\";\n\n    private static final String XBUS_HOME = \"$XBUS_HOME$\";\n\n    public static final String VARIABLE_PREFIX = \"$VARIABLE_\";\n\n    public static final String VARIABLE_END = \"$\";\n\n    public static final String MAPPING_DEFAULT = \"Default\";\n\n    // private static Configuration mSingleInstance = null;\n    private static Hashtable mInstances = new Hashtable();\n\n    private static final Object classLock = Configuration.class;\n\n    private Hashtable mCache = null;\n\n    private ConfigSource mSource = null;\n\n    /**\n     * The constructor is private. Instances of <code>Configuration</code> can\n     * only be accessed via the method <code>getInstance()</code>.\n     *\n     * @param source the source of the properties.\n     * @exception XException if any error occurs\n     */\n    private Configuration(String source) {\n        /*\n\t\t * Check if XBUS_HOME is set. This is done here, because loading the\n\t\t * configuration will be the first point, where XBUS_HOME is used.\n\t\t */\n        if (Constants.XBUS_HOME == null) {\n            System.out.println(\"I_00_000_2 XBUS_HOME has not been set!\");\n            System.exit(1);\n        }\n        /*\n\t\t * Initialize the source of the configuration entries.\n\t\t */\n        mSource = new PropertiesSource(source);\n    }\n\n    // Configuration(String source)\n    /**\n     * Returns an instance of the standard <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance() throws XException {\n        return getInstance(STANDARD_CONFIG);\n    }\n\n    // getInstance()\n    /**\n     * Returns a named instance of the <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @param source the source of the properties.\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance(String source) throws XException {\n        synchronized (classLock) {\n            Configuration instance = (Configuration) mInstances.get(source);\n            if (instance == null) {\n                instance = new Configuration(source);\n                instance.readCache();\n                mInstances.put(source, instance);\n            }\n            // if (instance == null)\n            return instance;\n        }\n    }\n\n    // getInstance(String source)\n    /**\n     * Creates an updated instance of the standard <code>Configuration</code>.\n     *\n     * @exception XException if any error occurs\n     */\n    public static void refresh() throws XException {\n        refresh(STANDARD_CONFIG);\n    }\n\n    // refresh()\n    /**\n     * Creates an updated instance of the named <code>Configuration</code>.\n     *\n     * @param source the source of the properties\n     * @exception XException if any error occurs\n     */\n    public static void refresh(String source) throws XException {\n        mInstances.remove(source);\n        getInstance(source);\n    }\n\n    // refresh(String source)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry can not be found, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if the entry in configuration is not exist or any\n     *                error occurs\n     */\n    public String getValue(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        return returnString;\n    }\n\n    // getValue(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as an integer. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not an integer, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key *\n     * @exception XException if the entry in configuratiuon is not exist or it\n     *                is not an integer\n     */\n    public int getValueAsInt(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        try // for casting to XException\n        {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsInt(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an integer. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an integer, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public int getValueAsIntOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsIntOptional(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an long value. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an long value, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public long getValueAsLongOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            long retLong = Long.parseLong(returnString);\n            return retLong;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"5\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsLongOptional(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as a boolean. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not a boolean, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>boolean </i> for the given chapter, section and key\n     * @exception XException if the entry in the configuration is not exist or\n     *                it is not a boolean value\n     */\n    public boolean getValueAsBoolean(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBoolean(String chapter,String section,String key)\n    /**\n     * Returns the optional value of an entry as a boolean. All three parameters\n     * have to contain values.\n     * <p>\n     * If the desired entry can not be found, false is returned. If the value is\n     * not a boolean, a <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as boolean for the given chapter, section and key. <br>\n     *         If the entry in the configuration is not found, false is\n     *         returned.\n     * @exception XException if the entry is not a boolean value or any error\n     *                occurs\n     */\n    public boolean getValueAsBooleanOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return false;\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBooleanOptional(String chapter,String section,String key)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry is not in the configuration, <code>null</code>\n     * will be returned.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as string for the given chapter,section and key or null if\n     *         the desired value is not found in the configuration\n     */\n    public String getValueOptional(String chapter, String section, String key) {\n        return getValueInternal(chapter, section, key);\n    }\n\n    // getValueOptional(String chapter, String section, String key)\n    /**\n     * Returns a list of all chapters.\n     *\n     * @return List with chapters\n     * @exception XException if any error occurs\n     */\n    public List getChapters() {\n        TreeSet chapters = new TreeSet(mCache.keySet());\n        return new Vector(chapters);\n    }\n\n    // getChapters()\n    /**\n     * Returns a list of all sections for the given chapter\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @return List of all sections for the given chapter or null wenn no\n     *         sections are found\n     * @exception XException if any error occurs\n     */\n    public List getSections(String chapter) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        TreeSet sectionSet = new TreeSet(sections.keySet());\n        return new Vector(sectionSet);\n    }\n\n    // getSections(String chapter)\n    /**\n     * Returns a map of all keys and their values for the given chapter and\n     * section.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @return Map of all keys and their values for the given chapter and\n     *         section or <i>null </i> wenn no keys are found\n     * @exception XException if any error occurs\n     */\n    public Map getKeysAndValues(String chapter, String section) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(section);\n        if (keys != null) {\n            return new TreeMap(keys);\n        } else {\n            return null;\n        }\n    }\n\n    // getKeysAndValues(String chapter, String section)\n    /**\n     * Returns a value for the given chapter, section and key.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if any error occurs\n     */\n    private String getValueInternal(String chapter, String section, String key) {\n        Hashtable sectTable = (Hashtable) mCache.get(chapter);\n        if (sectTable == null) {\n            return null;\n        }\n        // if (sectTable == null)\n        Hashtable keyTable = (Hashtable) sectTable.get(section);\n        if (keyTable == null) {\n            return null;\n        }\n        // if (keyTable == null)\n        return (String) keyTable.get(key);\n    }\n\n    // getValueInternal(String chapter, String section, String key)\n    /**\n     * This method is used by {@link #getInstance()}and by\n     * {@link #getInstance(String)}for reading all entries from a source and\n     * filling a three-level hierarchie hashtable.\n     *\n     * @see net.sf.xbus.base.core.config.PropertiesSource#readCache()\n     * @exception XException if any error occurs\n     */\n    private void readCache() throws XException {\n        mCache = mSource.readCache();\n        replaceVariables(mCache);\n    }\n\n    // readCache()\n    /**\n     * Replaces XBUS_HOME and variables with the key\n     * <code>Base_Variable_xxx</code> in all entries of the current\n     * configuration.\n     */\n    private void replaceVariables(Hashtable cache) throws XException {\n        Map variables = getVariables(cache);\n        for (Enumeration chapters = cache.elements(); chapters.hasMoreElements(); ) {\n            Hashtable chapter = (Hashtable) chapters.nextElement();\n            for (Enumeration sections = chapter.elements(); sections.hasMoreElements(); ) {\n                Hashtable section = (Hashtable) sections.nextElement();\n                for (Enumeration keys = section.keys(); keys.hasMoreElements(); ) {\n                    String key = (String) keys.nextElement();\n                    String value = (String) section.get(key);\n                    /*\n\t\t\t\t\t * Replace further variables\n\t\t\t\t\t */\n                    int variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                    if (variablePosNew >= 0) {\n                        int variablePosOld = -99999;\n                        String variable = null;\n                        Set variablesKeySet = null;\n                        while ((variablePosNew >= 0) && (variablePosOld != variablePosNew)) {\n                            variablePosOld = variablePosNew;\n                            if (variables == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            variablesKeySet = variables.keySet();\n                            if (variablesKeySet == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            String variablesKey = null;\n                            for (Iterator it = variablesKeySet.iterator(); it.hasNext(); ) {\n                                variablesKey = (String) it.next();\n                                variable = (String) variables.get(variablesKey);\n                                if (value.indexOf(variablesKey) >= 0) {\n                                    value = XStringSupport.replaceAll(value, variablesKey, variable);\n                                }\n                            }\n                            variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                        }\n                        if (variablePosOld == variablePosNew) {\n                            /*\n\t\t\t\t\t\t\t * Found same variable again => variable cannot be\n\t\t\t\t\t\t\t * replaced\n\t\t\t\t\t\t\t */\n                            List params = new Vector();\n                            params.add(new Integer(variablePosOld));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"3\", params);\n                        }\n                    }\n                    /*\n\t\t\t\t\t * Replace XBUS_HOME\n\t\t\t\t\t */\n                    if (value.indexOf(XBUS_HOME) >= 0) {\n                        value = XStringSupport.replaceAll(value, XBUS_HOME, Constants.XBUS_HOME);\n                    }\n                    section.put(key, value);\n                }\n            }\n        }\n    }\n\n    private Map getVariables(Hashtable cache) {\n        Hashtable sections = (Hashtable) cache.get(Constants.CHAPTER_BASE);\n        Map variablesConf = null;\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(\"Variable\");\n        if (keys != null) {\n            variablesConf = new TreeMap(keys);\n        } else {\n            return null;\n        }\n        Map variablesNew = new Hashtable();\n        if (variablesConf != null) {\n            String key = null;\n            String variable = null;\n            for (Iterator it = variablesConf.keySet().iterator(); it.hasNext(); ) {\n                key = (String) it.next();\n                variable = (String) variablesConf.get(key);\n                key = new StringBuffer(VARIABLE_PREFIX).append(key).append(VARIABLE_END).toString();\n                variablesNew.put(key, variable);\n            }\n        }\n        return variablesNew;\n    }\n\n    /**\n     * Returns an entry of the class table.\n     *\n     * @see #getValue(String, String, String)\n     * @param type The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b>\n     * @param name The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b> and this\n     *            section\n     * @return Value as String for the given type and name\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getClass(String type, String name) throws XException {\n        return Configuration.getInstance(\"xbus\").getValue(\"Class\", type, name);\n    }\n\n    // getClass(String type, String name)\n    /**\n     * Returns an entry of the mapping table.\n     *\n     * @see #getValue(String, String, String)\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return Value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMapping(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValue(\"Mapping\", section, key);\n    }\n\n    // getMapping(String section, String key)\n    /**\n     * Returns an entry of the mapping table or <code>null</code> if it\n     * doesn't exist.\n     *\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMappingOptional(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValueOptional(\"Mapping\", section, key);\n    }\n\n    /**\n     * @param section\n     */\n    public static String getMappingDefault(String section) throws XException {\n        return getMapping(section, Configuration.MAPPING_DEFAULT);\n    }\n    // getMapping(String section, String key)\n}\n// Configuration\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/config/ConfigurationTest4.java",
		"test_prompt": "// ConfigurationTest4.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Configuration}.\n* It contains ten unit test cases for the {@link Configuration#getMappingOptional(String, String)} method.\n*/\nclass ConfigurationTest4 {"
	},
	{
		"original_code": "// Configuration.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\n\n/**\n * This class reads program parameters from different sources and makes them\n * accessible. The entries of the configuration are organized in a three-level\n * hierarchie:\n * <p>\n * <ul>\n * <li>The <b>chapter </b> is the top level. Often you will find names of\n * components or classes at this level.</li>\n * <li>Every chapter contains one or more <b>sections </b></li>\n * <li><b>Keys </b> are at the bottom of the hierarchie, beyond the sections.\n * </ul>\n *\n * The <code>Configuration</code> implements the <b>Singleton </b>\n * Design-Pattern.\n * <p>\n *\n * Up to now, only the Java- <code>Properties</code> can be used as a source\n * for the configuration. Other sources like XML-files or a database are\n * prepared.\n */\npublic class Configuration {\n\n    public static final String STANDARD_CONFIG = \"standard\";\n\n    private static final String XBUS_HOME = \"$XBUS_HOME$\";\n\n    public static final String VARIABLE_PREFIX = \"$VARIABLE_\";\n\n    public static final String VARIABLE_END = \"$\";\n\n    public static final String MAPPING_DEFAULT = \"Default\";\n\n    // private static Configuration mSingleInstance = null;\n    private static Hashtable mInstances = new Hashtable();\n\n    private static final Object classLock = Configuration.class;\n\n    private Hashtable mCache = null;\n\n    private ConfigSource mSource = null;\n\n    /**\n     * The constructor is private. Instances of <code>Configuration</code> can\n     * only be accessed via the method <code>getInstance()</code>.\n     *\n     * @param source the source of the properties.\n     * @exception XException if any error occurs\n     */\n    private Configuration(String source) {\n        /*\n\t\t * Check if XBUS_HOME is set. This is done here, because loading the\n\t\t * configuration will be the first point, where XBUS_HOME is used.\n\t\t */\n        if (Constants.XBUS_HOME == null) {\n            System.out.println(\"I_00_000_2 XBUS_HOME has not been set!\");\n            System.exit(1);\n        }\n        /*\n\t\t * Initialize the source of the configuration entries.\n\t\t */\n        mSource = new PropertiesSource(source);\n    }\n\n    // Configuration(String source)\n    /**\n     * Returns an instance of the standard <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance() throws XException {\n        return getInstance(STANDARD_CONFIG);\n    }\n\n    // getInstance()\n    /**\n     * Returns a named instance of the <code>Configuration</code>.\n     * <p>\n     * The first call creates a new <code>Configuration</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @param source the source of the properties.\n     * @return Configuration - instance of the standard\n     *         <code>Configuration</code>\n     * @exception XException if any error occurs\n     */\n    public static Configuration getInstance(String source) throws XException {\n        synchronized (classLock) {\n            Configuration instance = (Configuration) mInstances.get(source);\n            if (instance == null) {\n                instance = new Configuration(source);\n                instance.readCache();\n                mInstances.put(source, instance);\n            }\n            // if (instance == null)\n            return instance;\n        }\n    }\n\n    // getInstance(String source)\n    /**\n     * Creates an updated instance of the standard <code>Configuration</code>.\n     *\n     * @exception XException if any error occurs\n     */\n    public static void refresh() throws XException {\n        refresh(STANDARD_CONFIG);\n    }\n\n    // refresh()\n    /**\n     * Creates an updated instance of the named <code>Configuration</code>.\n     *\n     * @param source the source of the properties\n     * @exception XException if any error occurs\n     */\n    public static void refresh(String source) throws XException {\n        mInstances.remove(source);\n        getInstance(source);\n    }\n\n    // refresh(String source)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry can not be found, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if the entry in configuration is not exist or any\n     *                error occurs\n     */\n    public String getValue(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        return returnString;\n    }\n\n    // getValue(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as an integer. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not an integer, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key *\n     * @exception XException if the entry in configuratiuon is not exist or it\n     *                is not an integer\n     */\n    public int getValueAsInt(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        // if (returnString == null)\n        try // for casting to XException\n        {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsInt(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an integer. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an integer, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public int getValueAsIntOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            int retInt = Integer.parseInt(returnString);\n            return retInt;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"3\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsIntOptional(String chapter, String section, String key)\n    /**\n     * Returns the optional value of an entry as an long value. All three\n     * parameters have to contain values.\n     * <p>\n     * If the desired entry is not an long value, a <code>XException</code> is\n     * thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>int </i> for the given chapter, section and key <br>\n     *         If the entry in the configuration is not found, <code>0</code>\n     *         is returned.\n     * @exception XException if the entry is not an integer\n     */\n    public long getValueAsLongOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return 0;\n        }\n        // if (returnString == null)\n        try {\n            long retLong = Long.parseLong(returnString);\n            return retLong;\n        } catch (NumberFormatException e) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"5\", params);\n        }\n        // catch (NumberFormatException e)\n    }\n\n    // getValueAsLongOptional(String chapter, String section, String key)\n    /**\n     * Returns the value of an entry as a boolean. All three parameters have to\n     * contain values.\n     * <p>\n     * If the desired entry can not be found or the value is not a boolean, a\n     * <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as <i>boolean </i> for the given chapter, section and key\n     * @exception XException if the entry in the configuration is not exist or\n     *                it is not a boolean value\n     */\n    public boolean getValueAsBoolean(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"1\", params);\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBoolean(String chapter,String section,String key)\n    /**\n     * Returns the optional value of an entry as a boolean. All three parameters\n     * have to contain values.\n     * <p>\n     * If the desired entry can not be found, false is returned. If the value is\n     * not a boolean, a <code>XException</code> is thrown.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as boolean for the given chapter, section and key. <br>\n     *         If the entry in the configuration is not found, false is\n     *         returned.\n     * @exception XException if the entry is not a boolean value or any error\n     *                occurs\n     */\n    public boolean getValueAsBooleanOptional(String chapter, String section, String key) throws XException {\n        String returnString = getValueInternal(chapter, section, key);\n        if (returnString == null) {\n            return false;\n        }\n        if (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase())) {\n            return true;\n        } else // then\n        // (Constants.CONFIGURATION_TRUE.toUpperCase().equals(returnString.toUpperCase()))\n        if (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase())) {\n            return false;\n        } else // else then\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n        {\n            List params = new Vector();\n            params.add(chapter);\n            params.add(section);\n            params.add(key);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"7\", params);\n        }\n        // else\n        // (Constants.CONFIGURATION_FALSE.toUpperCase().equals(returnString.toUpperCase()))\n    }\n\n    // getValueAsBooleanOptional(String chapter,String section,String key)\n    /**\n     * Returns the value of an entry. All three parameters have to contain\n     * values.\n     * <p>\n     * If the desired entry is not in the configuration, <code>null</code>\n     * will be returned.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as string for the given chapter,section and key or null if\n     *         the desired value is not found in the configuration\n     */\n    public String getValueOptional(String chapter, String section, String key) {\n        return getValueInternal(chapter, section, key);\n    }\n\n    // getValueOptional(String chapter, String section, String key)\n    /**\n     * Returns a list of all chapters.\n     *\n     * @return List with chapters\n     * @exception XException if any error occurs\n     */\n    public List getChapters() {\n        TreeSet chapters = new TreeSet(mCache.keySet());\n        return new Vector(chapters);\n    }\n\n    // getChapters()\n    /**\n     * Returns a list of all sections for the given chapter\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @return List of all sections for the given chapter or null wenn no\n     *         sections are found\n     * @exception XException if any error occurs\n     */\n    public List getSections(String chapter) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        TreeSet sectionSet = new TreeSet(sections.keySet());\n        return new Vector(sectionSet);\n    }\n\n    // getSections(String chapter)\n    /**\n     * Returns a map of all keys and their values for the given chapter and\n     * section.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @return Map of all keys and their values for the given chapter and\n     *         section or <i>null </i> wenn no keys are found\n     * @exception XException if any error occurs\n     */\n    public Map getKeysAndValues(String chapter, String section) {\n        Hashtable sections = (Hashtable) mCache.get(chapter);\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(section);\n        if (keys != null) {\n            return new TreeMap(keys);\n        } else {\n            return null;\n        }\n    }\n\n    // getKeysAndValues(String chapter, String section)\n    /**\n     * Returns a value for the given chapter, section and key.\n     *\n     * @param chapter The first level from the three-level hierarchie hashtable\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to this chapter\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to these chapter and section\n     * @return Value as String for the given chapter, section and key\n     * @exception XException if any error occurs\n     */\n    private String getValueInternal(String chapter, String section, String key) {\n        Hashtable sectTable = (Hashtable) mCache.get(chapter);\n        if (sectTable == null) {\n            return null;\n        }\n        // if (sectTable == null)\n        Hashtable keyTable = (Hashtable) sectTable.get(section);\n        if (keyTable == null) {\n            return null;\n        }\n        // if (keyTable == null)\n        return (String) keyTable.get(key);\n    }\n\n    // getValueInternal(String chapter, String section, String key)\n    /**\n     * This method is used by {@link #getInstance()}and by\n     * {@link #getInstance(String)}for reading all entries from a source and\n     * filling a three-level hierarchie hashtable.\n     *\n     * @see net.sf.xbus.base.core.config.PropertiesSource#readCache()\n     * @exception XException if any error occurs\n     */\n    private void readCache() throws XException {\n        mCache = mSource.readCache();\n        replaceVariables(mCache);\n    }\n\n    // readCache()\n    /**\n     * Replaces XBUS_HOME and variables with the key\n     * <code>Base_Variable_xxx</code> in all entries of the current\n     * configuration.\n     */\n    private void replaceVariables(Hashtable cache) throws XException {\n        Map variables = getVariables(cache);\n        for (Enumeration chapters = cache.elements(); chapters.hasMoreElements(); ) {\n            Hashtable chapter = (Hashtable) chapters.nextElement();\n            for (Enumeration sections = chapter.elements(); sections.hasMoreElements(); ) {\n                Hashtable section = (Hashtable) sections.nextElement();\n                for (Enumeration keys = section.keys(); keys.hasMoreElements(); ) {\n                    String key = (String) keys.nextElement();\n                    String value = (String) section.get(key);\n                    /*\n\t\t\t\t\t * Replace further variables\n\t\t\t\t\t */\n                    int variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                    if (variablePosNew >= 0) {\n                        int variablePosOld = -99999;\n                        String variable = null;\n                        Set variablesKeySet = null;\n                        while ((variablePosNew >= 0) && (variablePosOld != variablePosNew)) {\n                            variablePosOld = variablePosNew;\n                            if (variables == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            variablesKeySet = variables.keySet();\n                            if (variablesKeySet == null) {\n                                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"4\");\n                            }\n                            String variablesKey = null;\n                            for (Iterator it = variablesKeySet.iterator(); it.hasNext(); ) {\n                                variablesKey = (String) it.next();\n                                variable = (String) variables.get(variablesKey);\n                                if (value.indexOf(variablesKey) >= 0) {\n                                    value = XStringSupport.replaceAll(value, variablesKey, variable);\n                                }\n                            }\n                            variablePosNew = value.indexOf(VARIABLE_PREFIX);\n                        }\n                        if (variablePosOld == variablePosNew) {\n                            /*\n\t\t\t\t\t\t\t * Found same variable again => variable cannot be\n\t\t\t\t\t\t\t * replaced\n\t\t\t\t\t\t\t */\n                            List params = new Vector();\n                            params.add(new Integer(variablePosOld));\n                            params.add(value);\n                            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_XBUSSYSTEM, \"3\", params);\n                        }\n                    }\n                    /*\n\t\t\t\t\t * Replace XBUS_HOME\n\t\t\t\t\t */\n                    if (value.indexOf(XBUS_HOME) >= 0) {\n                        value = XStringSupport.replaceAll(value, XBUS_HOME, Constants.XBUS_HOME);\n                    }\n                    section.put(key, value);\n                }\n            }\n        }\n    }\n\n    private Map getVariables(Hashtable cache) {\n        Hashtable sections = (Hashtable) cache.get(Constants.CHAPTER_BASE);\n        Map variablesConf = null;\n        if (sections == null) {\n            return null;\n        }\n        // if (sections == null)\n        Hashtable keys = (Hashtable) sections.get(\"Variable\");\n        if (keys != null) {\n            variablesConf = new TreeMap(keys);\n        } else {\n            return null;\n        }\n        Map variablesNew = new Hashtable();\n        if (variablesConf != null) {\n            String key = null;\n            String variable = null;\n            for (Iterator it = variablesConf.keySet().iterator(); it.hasNext(); ) {\n                key = (String) it.next();\n                variable = (String) variablesConf.get(key);\n                key = new StringBuffer(VARIABLE_PREFIX).append(key).append(VARIABLE_END).toString();\n                variablesNew.put(key, variable);\n            }\n        }\n        return variablesNew;\n    }\n\n    /**\n     * Returns an entry of the class table.\n     *\n     * @see #getValue(String, String, String)\n     * @param type The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b>\n     * @param name The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Class </i> </b> and this\n     *            section\n     * @return Value as String for the given type and name\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getClass(String type, String name) throws XException {\n        return Configuration.getInstance(\"xbus\").getValue(\"Class\", type, name);\n    }\n\n    // getClass(String type, String name)\n    /**\n     * Returns an entry of the mapping table.\n     *\n     * @see #getValue(String, String, String)\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return Value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMapping(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValue(\"Mapping\", section, key);\n    }\n\n    // getMapping(String section, String key)\n    /**\n     * Returns an entry of the mapping table or <code>null</code> if it\n     * doesn't exist.\n     *\n     * @param section The second level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b>\n     * @param key The bottom level from the three-level hierarchie hashtable\n     *            that belongs to the chapter: <b><i>Mapping </i> </b> and this\n     *            section\n     * @return value for the given section and key\n     * @exception XException if the entry is not found or any error occurs\n     */\n    public static String getMappingOptional(String section, String key) throws XException {\n        return Configuration.getInstance(\"mapping\").getValueOptional(\"Mapping\", section, key);\n    }\n\n    /**\n     * @param section\n     */\n    public static String getMappingDefault(String section) throws XException {\n        return getMapping(section, Configuration.MAPPING_DEFAULT);\n    }\n    // getMapping(String section, String key)\n}\n// Configuration\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/config/ConfigurationTest5.java",
		"test_prompt": "// ConfigurationTest5.java\npackage net.sf.xbus.base.core.config;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Configuration}.\n* It contains ten unit test cases for the {@link Configuration#getMappingDefault(String)} method.\n*/\nclass ConfigurationTest5 {"
	},
	{
		"original_code": "// PropertiesSource.java\npackage net.sf.xbus.base.core.config;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FilenameFilter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * This is the implementation of a {@link ConfigSource} wich uses the Java-<code>Properties</code>.\n * <p>\n *\n * To map the hierarchy of the\n * {@link net.sf.xbus.base.core.config.Configuration}, the keys of the\n * properties must consist of three parts divided by \"_\"\n * (e.g.System_MQ_Timeout).\n */\npublic class PropertiesSource implements ConfigSource {\n\n    private static final String DELIMITER = \"_\";\n\n    private static final String POSTFIX = \".conf\";\n\n    private String mPrefix = null;\n\n    /**\n     * The constructor builds the name of the properties-file:\n     * <code>%XBUS_HOME%/etc/<i>source</i>.conf</code>\n     * <p>\n     *\n     * Program which uses this class must be started with:\n     * <code>java -Dxbus.home=\"%XBUS_HOME%\"</code>\n     *\n     * @param source the property source\n     * @exception XException if any error occurs\n     */\n    public PropertiesSource(String source) {\n        if (source == null) {\n            System.out.println(\"I_00_001_2 Source must not be <null>\");\n            System.exit(1);\n        }\n        mPrefix = source;\n    }\n\n    /**\n     * Reads the properties and fills a three-level hierarchie hashtable\n     * suitable for the {@link net.sf.xbus.base.core.config.Configuration}.\n     *\n     * @return Hashtable - three-level hierarchie hashtable\n     *         <ol>\n     *         <li>level consists of the chapters as the keys and the hashtable\n     *         as value</li>\n     *         <li>level consists of the names of sections as the keys and a\n     *         hashtable as value</li>\n     *         <li>level consists of the name of keys and their values as\n     *         Strings</li>\n     *         </ol>\n     * @exception XException if any error occurs\n     */\n    public Hashtable readCache() {\n        String key, value;\n        Vector cacheKeys;\n        Hashtable cache = new Hashtable();\n        Properties props = new Properties();\n        addProperties(props, mPrefix, Constants.XBUS_ETC);\n        addProperties(props, mPrefix, Constants.XBUS_PLUGIN_ETC);\n        for (Enumeration e = props.propertyNames(); e.hasMoreElements(); ) {\n            key = (String) e.nextElement();\n            value = props.getProperty(key);\n            cacheKeys = splitKey(key);\n            cache = putCache(cache, cacheKeys, value);\n        }\n        return cache;\n    }\n\n    /**\n     * Load the properties from a file.\n     *\n     * @param filename the name of the properties file\n     * @exception XException if any error occurs\n     */\n    private void addProperties(Properties props, String prefix, String directory) {\n        File etcDir = new File(directory);\n        String[] configFiles = etcDir.list(new PropertiesFilter());\n        /*\n\t\t * Check wether at least one config file in XBUS/etc could be found.\n\t\t */\n        if ((Constants.XBUS_ETC.equals(directory)) && (Configuration.STANDARD_CONFIG.equals(mPrefix)) && ((configFiles == null) || (configFiles.length == 0))) {\n            System.out.println(\"I_00_001_2 No configuration file \" + prefix + \"*.conf\" + \" exists, maybe XBUS_HOME is not set properly\");\n            System.exit(1);\n        }\n        for (int i = 0; (configFiles != null) && (i < configFiles.length); i++) {\n            FileInputStream instream;\n            Properties newProps = new Properties();\n            try {\n                instream = new FileInputStream(directory + configFiles[i]);\n                newProps.load(instream);\n                instream.close();\n            } catch (java.io.FileNotFoundException e) {\n                System.out.println(\"I_00_001_2 File \" + directory + configFiles[i] + \" doesn't exist\");\n                System.exit(1);\n            } catch (java.io.IOException e) {\n                System.out.println(\"I_00_001_2 IOException while reading file  \" + directory + configFiles[i]);\n                e.printStackTrace();\n                System.exit(1);\n            }\n            /*\n\t\t\t * Move all elements of currently loaded properties to the complete\n\t\t\t * set\n\t\t\t */\n            String key = null;\n            for (Enumeration keys = newProps.keys(); keys.hasMoreElements(); ) {\n                key = (String) keys.nextElement();\n                /*\n\t\t\t\t * Detection of collisions\n\t\t\t\t */\n                if (props.containsKey(key)) {\n                    System.out.println(\"I_00_001_5 Key \" + key + \" has already been inserted\");\n                    System.exit(1);\n                }\n                props.put(key, newProps.get(key));\n            }\n        }\n    }\n\n    /**\n     * Converts the key of the property suitable for the Configuration, i.e.\n     * removes separators from it and saves three elements in the vector.\n     *\n     * @param key the key of the properties (must consist of three parts\n     *            separated be \"_\")\n     * @return Vector - vector with 3 elements: chapter,section,key\n     * @exception XException if any error occurs\n     */\n    private Vector splitKey(String key) {\n        StringTokenizer st = new StringTokenizer(key, PropertiesSource.DELIMITER);\n        String token;\n        Vector tmp = new Vector();\n        while (st.hasMoreTokens()) {\n            token = st.nextToken();\n            tmp.add(token);\n        }\n        if (tmp.size() != 3) {\n            System.out.println(\"I_00_001_4 Wrong format of key \" + key);\n            System.exit(1);\n        }\n        return tmp;\n    }\n\n    /**\n     * Adds new entry to the hashtable.\n     *\n     * @param cache the old three-level hierarchie hashtable\n     * @param cacheKeys the vector with new elements (chapter,section,key)\n     * @param value the new value\n     * @return Hashtable - three-level hierarchie hashtable\n     *         <p>\n     *         <ol>\n     *         <li>level consists of the chapters as the keys and the hashtable\n     *         as value</li>\n     *         <li>level consists of the names of sections as the keys and a\n     *         hashtable as value</li>\n     *         <li>level consists of the name of keys and their values as\n     *         Strings</li>\n     *         </ol>\n     */\n    private Hashtable putCache(Hashtable cache, Vector cacheKeys, String value) {\n        Hashtable sectionTable = null;\n        boolean newChapter = false;\n        Hashtable keyTable = null;\n        boolean newSection = false;\n        String chapter = ((String) cacheKeys.elementAt(0));\n        String section = ((String) cacheKeys.elementAt(1));\n        String cacheKey = ((String) cacheKeys.elementAt(2));\n        sectionTable = (Hashtable) cache.get(chapter);\n        if (sectionTable == null) {\n            sectionTable = new Hashtable();\n            newChapter = true;\n        }\n        keyTable = (Hashtable) sectionTable.get(section);\n        if (keyTable == null) {\n            keyTable = new Hashtable();\n            newSection = true;\n        }\n        keyTable.put(cacheKey, value.trim());\n        if (newSection) {\n            sectionTable.put(section, keyTable);\n        }\n        if (newChapter) {\n            cache.put(chapter, sectionTable);\n        }\n        return cache;\n    }\n\n    /**\n     * The internal class <code>PropertiesFilter</code> checks wether files\n     * are wanted Properties or not.\n     */\n    private class PropertiesFilter implements FilenameFilter {\n\n        /*\n\t\t * (non-Javadoc)\n\t\t * \n\t\t * @see java.io.FilenameFilter#accept(java.io.File, java.lang.String)\n\t\t */\n        public boolean accept(File dir, String filename) {\n            if ((filename.startsWith(mPrefix)) && (filename.endsWith(POSTFIX))) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/config/PropertiesSourceTest.java",
		"test_prompt": "// PropertiesSourceTest.java\npackage net.sf.xbus.base.core.config;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FilenameFilter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Properties;\nimport java.util.StringTokenizer;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link PropertiesSource}.\n* It contains ten unit test cases for the {@link PropertiesSource#readCache()} method.\n*/\nclass PropertiesSourceTest {"
	},
	{
		"original_code": "// MessageHandler.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FilenameFilter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * A <code>Message</code> is selected from a properties file.\n * <p>\n * The message result is a String.<br>\n * The clear regulation of the message is reached by a key. The key is described\n * in * {@link net.sf.xbus.base.core.XException XException} documentation page.\n * </p>\n *\n * @author Lars Messner\n */\npublic class MessageHandler {\n\n    private static Hashtable mInstances = new Hashtable();\n\n    private static final Object classLock = Configuration.class;\n\n    private Hashtable mMessages = null;\n\n    /**\n     * On the basis of the key get the message of the properties file.\n     *\n     * @param key contain char and/or int for the definitly designation of the\n     *            message\n     * @param params contain a list of the inspected parameters\n     * @return messageText contain the message from the properties file\n     */\n    public String getMessage(String key, List params) {\n        String messageText = null;\n        messageText = getMessageOptional(key, params);\n        if (messageText == null) {\n            messageText = \"Key: \" + key + \" not found in message file\";\n            Trace.error(messageText);\n        }\n        // if (messageText == null)\n        return messageText;\n    }\n\n    /**\n     * On the basis of the key get the message of the properties file.\n     *\n     * @param key contain char and/or int for the definitly designation of the\n     *            message\n     * @param params contain a list of the inspected parameters\n     * @return messageText contain the message from the properties file\n     */\n    public String getMessageOptional(String key, List params) {\n        String messageText = null;\n        if (mMessages == null) {\n            return null;\n        }\n        // if (mMessages == null)\n        // gets the message of the key\n        messageText = (String) mMessages.get(key);\n        if (messageText == null) {\n            return null;\n        }\n        int counter = 1;\n        if (params != null) {\n            String paramText = null;\n            Object paramObject = null;\n            // if there is a type of \"$x$\"\n            for (Iterator it = params.iterator(); it.hasNext(); ) {\n                paramObject = it.next();\n                if (paramObject != null) {\n                    paramText = paramObject.toString();\n                } else {\n                    paramText = \"<null>\";\n                }\n                String paramCounter = \"$\" + counter + \"$\";\n                if (messageText.indexOf(paramCounter) >= 0) {\n                    messageText = XStringSupport.replaceAll(messageText, paramCounter, paramText);\n                    counter++;\n                }\n                // if (messageText.indexOf(paramCounter) >= 0)\n            }\n            // for (Iterator it = params.iterator(); it.hasNext();)\n        }\n        // if (params != null)\n        return messageText;\n    }\n\n    /**\n     * Returns a named instance of the <code>Message</code>.\n     * <p>\n     * The first call creates a new <code>Message</code> and reads all\n     * entries. Following calls will return the object, that has been created by\n     * the first call.\n     *\n     * @param basename the basename of the properties file.\n     * @return MessageHandler - instance of<code>MessageHandler</code>\n     */\n    public static MessageHandler getInstance(String basename) {\n        synchronized (classLock) {\n            MessageHandler instance = (MessageHandler) mInstances.get(basename);\n            if (instance == null) {\n                instance = new MessageHandler(basename);\n                mInstances.put(basename, instance);\n            }\n            // if (instance == null)\n            return instance;\n        }\n    }\n\n    /**\n     * The constructor is private. Instances of <code>Message</code> can only\n     * be accessed via the method <code>getInstance()</code>.\n     *\n     * @param basename the name of the properties.\n     */\n    private MessageHandler(String basename) {\n        mMessages = new Hashtable();\n        addMessages(basename, Constants.XBUS_ETC);\n        addMessages(basename, Constants.XBUS_PLUGIN_ETC);\n    }\n\n    private void addMessages(String basename, String dir) {\n        // the language for the properties file is english\n        Locale locale = Locale.ENGLISH;\n        String prefix = basename;\n        String postfix = \"_\" + locale.toString() + \".properties\";\n        File dirFile = new File(dir);\n        String[] messagesFiles = dirFile.list(new MessagesFilter(prefix, postfix));\n        for (int i = 0; (messagesFiles != null) && (i < messagesFiles.length); i++) {\n            FileInputStream instream;\n            Properties newProps = new Properties();\n            try {\n                instream = new FileInputStream(dir + messagesFiles[i]);\n                newProps.load(instream);\n                instream.close();\n            } catch (java.io.FileNotFoundException e) {\n                System.out.println(\"Cannot find messagefile\");\n                System.exit(1);\n            } catch (java.io.IOException e) {\n                System.out.println(\"Cannot find messagefile\");\n                System.exit(1);\n            }\n            /*\n\t\t\t * Move all elements of currently loaded properties to the complete\n\t\t\t * set\n\t\t\t */\n            String key = null;\n            for (Enumeration keys = newProps.keys(); keys.hasMoreElements(); ) {\n                key = (String) keys.nextElement();\n                mMessages.put(key, newProps.get(key));\n            }\n        }\n    }\n\n    /**\n     * The internal class <code>MessagesFilter</code> checks wether files are\n     * wanted Messages or not.\n     */\n    static private class MessagesFilter implements FilenameFilter {\n\n        private String mPrefix = null;\n\n        private String mPostfix = null;\n\n        public MessagesFilter(String prefix, String postfix) {\n            mPrefix = prefix;\n            mPostfix = postfix;\n        }\n\n        /*\n\t\t * (non-Javadoc)\n\t\t * \n\t\t * @see java.io.FilenameFilter#accept(java.io.File, java.lang.String)\n\t\t */\n        public boolean accept(File dir, String filename) {\n            if ((filename.startsWith(mPrefix)) && (filename.endsWith(mPostfix))) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/MessageHandlerTest.java",
		"test_prompt": "// MessageHandlerTest.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FilenameFilter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Properties;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.strings.XStringSupport;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link MessageHandler}.\n* It contains ten unit test cases for the {@link MessageHandler#getInstance(String)} method.\n*/\nclass MessageHandlerTest {"
	},
	{
		"original_code": "// XByteArraySupport.java\npackage net.sf.xbus.base.core.bytearrays;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>XByteArraySupport</code> gives some support in manipulating byte\n * arrays.\n *\n * @author Stephan D�wel\n */\npublic class XByteArraySupport {\n\n    /**\n     * <code>subArray</code> extracts a byte array from another.\n     *\n     * @param array the complete byte array\n     * @param pos the starting position for extracting\n     * @param length the length of extracted sub-array\n     * @return the extracted sub-array\n     * @throws XException in case of unpossible <code>pos</code> or\n     *             <code>length</code> values\n     */\n    public static byte[] subArray(byte[] array, int pos, int length) throws XException {\n        byte[] retArray = new byte[length];\n        try {\n            for (int i = 0; i < length; i++) retArray[i] = array[pos + i];\n        }// try\n         catch (IndexOutOfBoundsException e) {\n            Vector params = new Vector(3);\n            params.add(new Integer(pos));\n            params.add(new Integer(length));\n            params.add(new Integer(array.length));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_COREBASE_BYTEARRAYS, \"1\");\n        }\n        // catch (IndexOutOfBoundsException e)\n        return retArray;\n    }\n\n    // subArray(byte[] array, int pos, int length)\n    /**\n     * @param inObject must be an <code>InputStream</code>\n     * @return the content of the InputStread as a byte array\n     */\n    static public byte[] transformToByteArray(Object inObject) throws XException {\n        InputStream is = (InputStream) inObject;\n        // The stream content is read in block of size:\n        final int blocksize = 1024;\n        // Number of bytes read in one block.\n        int bytesRead = 0;\n        // Total number of bytes read.\n        int byteArrayLength = 0;\n        // The list of read blocks - content and length for each block.\n        Vector blocks = new Vector();\n        // Content and length for a single block.\n        Object[] block = null;\n        // Byte butter for reading a block.\n        byte[] ba = new byte[blocksize];\n        try // For casting to XException.\n        {\n            // Reading first block\n            bytesRead = is.read(ba);\n            while (bytesRead != -1) {\n                // Loop until end of stream.\n                // The read block.\n                block = new Object[2];\n                block[0] = ba;\n                block[1] = new Integer(bytesRead);\n                byteArrayLength += bytesRead;\n                blocks.add(block);\n                // Read next block.\n                ba = new byte[blocksize];\n                bytesRead = is.read(ba);\n            }\n            // while (bytesRead!=-1)\n        }// try\n         catch (IOException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_COREBASE_BYTEARRAYS, \"0\", e);\n        }\n        // catch\n        // Put everything together into one byte array.\n        ba = new byte[byteArrayLength];\n        int offset = 0;\n        for (int i = 0; i < blocks.size(); i++) {\n            bytesRead = ((Integer) ((Object[]) blocks.get(i))[1]).intValue();\n            for (int j = 0; j < bytesRead; j++) ba[offset + j] = ((byte[]) ((Object[]) blocks.get(i))[0])[j];\n            offset += bytesRead;\n        }\n        // for (int i=0; i<blocks.size(); i++)\n        return ba;\n    }\n    // transformToByteArray(Object inObject)\n}\n// XByteArraySupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/bytearrays/XByteArraySupportTest0.java",
		"test_prompt": "// XByteArraySupportTest0.java\npackage net.sf.xbus.base.core.bytearrays;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XByteArraySupport}.\n* It contains ten unit test cases for the {@link XByteArraySupport#subArray(byte[], int, int)} method.\n*/\nclass XByteArraySupportTest0 {"
	},
	{
		"original_code": "// XByteArraySupport.java\npackage net.sf.xbus.base.core.bytearrays;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>XByteArraySupport</code> gives some support in manipulating byte\n * arrays.\n *\n * @author Stephan D�wel\n */\npublic class XByteArraySupport {\n\n    /**\n     * <code>subArray</code> extracts a byte array from another.\n     *\n     * @param array the complete byte array\n     * @param pos the starting position for extracting\n     * @param length the length of extracted sub-array\n     * @return the extracted sub-array\n     * @throws XException in case of unpossible <code>pos</code> or\n     *             <code>length</code> values\n     */\n    public static byte[] subArray(byte[] array, int pos, int length) throws XException {\n        byte[] retArray = new byte[length];\n        try {\n            for (int i = 0; i < length; i++) retArray[i] = array[pos + i];\n        }// try\n         catch (IndexOutOfBoundsException e) {\n            Vector params = new Vector(3);\n            params.add(new Integer(pos));\n            params.add(new Integer(length));\n            params.add(new Integer(array.length));\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_COREBASE_BYTEARRAYS, \"1\");\n        }\n        // catch (IndexOutOfBoundsException e)\n        return retArray;\n    }\n\n    // subArray(byte[] array, int pos, int length)\n    /**\n     * @param inObject must be an <code>InputStream</code>\n     * @return the content of the InputStread as a byte array\n     */\n    static public byte[] transformToByteArray(Object inObject) throws XException {\n        InputStream is = (InputStream) inObject;\n        // The stream content is read in block of size:\n        final int blocksize = 1024;\n        // Number of bytes read in one block.\n        int bytesRead = 0;\n        // Total number of bytes read.\n        int byteArrayLength = 0;\n        // The list of read blocks - content and length for each block.\n        Vector blocks = new Vector();\n        // Content and length for a single block.\n        Object[] block = null;\n        // Byte butter for reading a block.\n        byte[] ba = new byte[blocksize];\n        try // For casting to XException.\n        {\n            // Reading first block\n            bytesRead = is.read(ba);\n            while (bytesRead != -1) {\n                // Loop until end of stream.\n                // The read block.\n                block = new Object[2];\n                block[0] = ba;\n                block[1] = new Integer(bytesRead);\n                byteArrayLength += bytesRead;\n                blocks.add(block);\n                // Read next block.\n                ba = new byte[blocksize];\n                bytesRead = is.read(ba);\n            }\n            // while (bytesRead!=-1)\n        }// try\n         catch (IOException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_COREBASE_BYTEARRAYS, \"0\", e);\n        }\n        // catch\n        // Put everything together into one byte array.\n        ba = new byte[byteArrayLength];\n        int offset = 0;\n        for (int i = 0; i < blocks.size(); i++) {\n            bytesRead = ((Integer) ((Object[]) blocks.get(i))[1]).intValue();\n            for (int j = 0; j < bytesRead; j++) ba[offset + j] = ((byte[]) ((Object[]) blocks.get(i))[0])[j];\n            offset += bytesRead;\n        }\n        // for (int i=0; i<blocks.size(); i++)\n        return ba;\n    }\n    // transformToByteArray(Object inObject)\n}\n// XByteArraySupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/bytearrays/XByteArraySupportTest1.java",
		"test_prompt": "// XByteArraySupportTest1.java\npackage net.sf.xbus.base.core.bytearrays;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XByteArraySupport}.\n* It contains ten unit test cases for the {@link XByteArraySupport#transformToByteArray(Object)} method.\n*/\nclass XByteArraySupportTest1 {"
	},
	{
		"original_code": "// XIntSupport.java\npackage net.sf.xbus.base.core.arithmetic;\n\n/**\n * <code>XIntSupport</code> is a collection of helpful methods concerning\n * integer handling.\n *\n * @author Stephan D�wel\n */\npublic class XIntSupport {\n\n    /**\n     * <code>calculateLength</code> computes the length of an integer in\n     * respect to a given radix. The implementation is simple: dividing in loop.\n     *\n     * @param value the integer for which to compute the length\n     * @param radix the radix for length computation\n     * @return minimum 1\n     */\n    public static int calculateLength(long value, int radix) {\n        int length = 1;\n        if (value < 0)\n            value *= -1;\n        while (value / radix > 0) {\n            value /= radix;\n            length++;\n        }\n        // while (value/radix>0)\n        return length;\n    }\n    // calculateLength(int value, int radix)\n}\n// XIntSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/arithmetic/XIntSupportTest.java",
		"test_prompt": "// XIntSupportTest.java\npackage net.sf.xbus.base.core.arithmetic;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XIntSupport}.\n* It contains ten unit test cases for the {@link XIntSupport#calculateLength(long, int)} method.\n*/\nclass XIntSupportTest {"
	},
	{
		"original_code": "// TAManager.java\npackage net.sf.xbus.base.core;\n\nimport java.util.Enumeration;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * <code>TAManager</code> manages transactions.\n * <p>\n *\n * It implements the <b>Singleton </b> Design-Patterns: An instance of\n * <code>TAManager</code> is created for every thread. This instance can be\n * fetched with <code>getInstance()</code>.\n */\npublic class TAManager {\n\n    private static Hashtable mTAManagers = new Hashtable();\n\n    private static final Object classLock = TAManager.class;\n\n    private HashSet mResources;\n\n    /**\n     * The constructor is private, instances of <code>TAManager</code> can\n     * only be generated by the method <code>getInstance()</code>.\n     * <p>\n     *\n     * Each instance is put in a <code>Hashtable</code> with the name of the\n     * thread as the key.\n     */\n    private TAManager() {\n        mResources = new HashSet();\n        mTAManagers.put(Thread.currentThread().getName(), this);\n    }\n\n    // TAManager()\n    /**\n     * Delivers an instance of <code>TAManager</code>.\n     * <p>\n     * If it is the first call for the actual thread, a new\n     * <code>TAManager</code> -object will be created. Subsequent calls in\n     * this thread will deliver the object, that has been created by the first\n     * call.\n     *\n     * @return TAManager - instance of TAManager\n     */\n    public static TAManager getInstance() {\n        synchronized (classLock) {\n            TAManager taManager = (TAManager) mTAManagers.get(Thread.currentThread().getName());\n            if (taManager == null) {\n                taManager = new TAManager();\n            }\n            // if (taManager == null)\n            return taManager;\n        }\n    }\n\n    // getInstance()\n    /**\n     * All resources, that should be managed, have to be registered to this\n     * manager. The resource should be open at this point.\n     *\n     * @param resource Resource of the transaction, that should be managed.\n     */\n    public void registerResource(TAResource resource) {\n        mResources.add(resource);\n    }\n\n    /**\n     * Removes a resource from the list of registered resources.\n     *\n     * @param resource Resource of the transaction, that should be removed.\n     */\n    public void removeResource(TAResource resource) {\n        if (!mResources.remove(resource)) {\n            Trace.info(\"Resource hasn't been registered.\");\n        }\n        // if (!mResources.remove(resource))\n    }\n\n    // removeResource(TAResource resource)\n    /**\n     * Initializes a transaction. All registered resources will be opened.\n     *\n     * @throws XException if opening one ressource throws an XException.\n     */\n    public void begin() throws XException {\n        for (Iterator it = mResources.iterator(); it.hasNext(); ) {\n            TAResource resource = (TAResource) (it.next());\n            resource.open();\n        }\n    }\n\n    /**\n     * Commits all actions on the registered resources and closes the resources.\n     */\n    public void commit() {\n        HashSet copyRessources = (HashSet) mResources.clone();\n        for (Iterator it = copyRessources.iterator(); it.hasNext(); ) {\n            TAResource resource = (TAResource) (it.next());\n            try {\n                resource.commit();\n            } catch (XException e) {\n                Trace.always(\"Error during commit !!!\");\n            }\n            // resource.close();\n        }\n        // for (Iterator it = copyRessources.iterator(); it.hasNext(); )\n    }\n\n    /**\n     * Performs a rollback for all actions on the registered resources and\n     * closes the resources.\n     */\n    public void rollback() {\n        HashSet copyRessources = (HashSet) mResources.clone();\n        for (Iterator it = copyRessources.iterator(); it.hasNext(); ) {\n            TAResource resource = (TAResource) (it.next());\n            try {\n                resource.rollback();\n            } catch (XException e) {\n                Trace.always(\"Error during rollback !!!\");\n            }\n            // resource.close();\n        }\n        // for (Iterator it = copyRessources.iterator(); it.hasNext(); )\n    }\n\n    // rollback()\n    /**\n     * Closes all registered resources.\n     */\n    public void close() {\n        HashSet copyRessources = (HashSet) mResources.clone();\n        for (Iterator it = copyRessources.iterator(); it.hasNext(); ) {\n            TAResource resource = (TAResource) (it.next());\n            try {\n                resource.close();\n            } catch (XException e) {\n                Trace.warn(e.getMessage());\n            }\n        }\n    }\n\n    public void clearManager() {\n        // close();\n        mResources.clear();\n    }\n\n    static public void clear() {\n        for (Enumeration e = mTAManagers.keys(); e.hasMoreElements(); ) {\n            TAManager mgr = (TAManager) mTAManagers.get(e.nextElement());\n            mgr.clearManager();\n        }\n    }\n}\n// TAManager\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/TAManagerTest.java",
		"test_prompt": "// TAManagerTest.java\npackage net.sf.xbus.base.core;\n\nimport java.util.Enumeration;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TAManager}.\n* It contains ten unit test cases for the {@link TAManager#getInstance()} method.\n*/\nclass TAManagerTest {"
	},
	{
		"original_code": "// XException.java\npackage net.sf.xbus.base.core;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.sql.SQLException;\nimport java.util.Hashtable;\nimport java.util.List;\nimport javax.naming.NamingException;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.xml.sax.SAXParseException;\n\n/**\n * All errors that occur while processing a request are handled by throwing a\n * <code>XException</code>. Because nearly all methods possibly throw a\n * <code>XException</code>, only a few points (eg. the receivers) have to\n * catch and handle it.\n */\npublic class XException extends Exception {\n\n    private static Hashtable mExceptionInformation = new Hashtable();\n\n    private String mMessageText = null;\n\n    /**\n     * Constructs a <code>XException</code> and traces the\n     * <code>message</code> and the backtrace.\n     *\n     * @param location indicates wether this is an internal or an external\n     *            problem\n     * @param layer indicates the layer where the error has occurred\n     * @param Package indicates the package where the error has occurred\n     * @param number to identify the error\n     */\n    public XException(String location, String layer, String Package, String number) {\n        traceException(location, layer, Package, number, null);\n    }\n\n    /**\n     * Constructs a <code>XException</code> and traces the\n     * <code>message</code> and the backtrace.\n     *\n     * @param location indicates wether this is an internal or an external\n     *            problem\n     * @param layer indicates the layer where the error has occurred\n     * @param Package indicates the package where the error has occurred\n     * @param number to identify the error\n     * @param params a list of values to be included in the message\n     */\n    public XException(String location, String layer, String Package, String number, List params) {\n        traceException(location, layer, Package, number, params);\n    }\n\n    /**\n     * Constructs a <code>XException</code> and traces the\n     * <code>Throwable</code> and the backtrace.\n     *\n     * @param location indicates wether this is an internal or an external\n     *            problem\n     * @param layer indicates the layer where the error has occurred\n     * @param Package indicates the package where the error has occurred\n     * @param number to identify the error\n     * @param t contains the thrown Exception.\n     * @param params list of parameters to be inclueded in the message\n     */\n    public XException(String location, String layer, String Package, String number, Throwable t, List params) {\n        super(t.getMessage());\n        traceException(location, layer, Package, number, t, params);\n    }\n\n    /**\n     * Constructs a <code>XException</code> and traces the\n     * <code>Throwable</code> and the backtrace.\n     *\n     * @param location indicates wether this is an internal or an external\n     *            problem\n     * @param layer indicates the layer where the error has occurred\n     * @param Package indicates the package where the error has occurred\n     * @param number to identify the error\n     * @param t contains the thrown Exception.\n     */\n    public XException(String location, String layer, String Package, String number, Throwable t) {\n        super(t.getMessage());\n        traceException(location, layer, Package, number, t, null);\n    }\n\n    /**\n     * @return the message string of this instance (which may be null).\n     */\n    public String getMessage() {\n        return mMessageText;\n    }\n\n    /**\n     * @return a more detailed information about the last thrown XException.\n     */\n    public static String getExceptionInformation() {\n        return (String) mExceptionInformation.get(Thread.currentThread().getName());\n    }\n\n    /**\n     * Sets the information for the current XException\n     *\n     * @param message the message of this XException\n     * @param t the thrown Exception.\n     */\n    public static void setExceptionInformation(String message, Throwable t) {\n        if (t == null) {\n            mExceptionInformation.put(Thread.currentThread().getName(), message);\n        } else // if (t == null)\n        {\n            mExceptionInformation.put(Thread.currentThread().getName(), new StringBuffer().append(message).append(Constants.LINE_SEPERATOR).append(Constants.LINE_SEPERATOR).append(getStackTraceAsString(t)).toString());\n        }\n    }\n\n    /**\n     * Removes information about previous exceptions.\n     */\n    public static void clearExceptionInformation() {\n        mExceptionInformation = new Hashtable();\n    }\n\n    /**\n     * Returns the stacktrace of the given <code>Throwable</code> as a string.\n     *\n     * @param t the thrown Exception.\n     */\n    private static String getStackTraceAsString(Throwable t) {\n        String retString = null;\n        try {\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            PrintStream printStream = new PrintStream(outStream);\n            t.printStackTrace(printStream);\n            retString = outStream.toString();\n            printStream.close();\n            outStream.close();\n        } catch (IOException e) {\n            /*\n\t\t\t * do nothing\n\t\t\t */\n        }\n        return retString;\n    }\n\n    private void traceException(String Location, String Layer, String Package, String Number, List params) {\n        String basename = \"errors\";\n        String key = Location + \"_\" + Layer + \"_\" + Package + \"_\" + Number;\n        MessageHandler msg = MessageHandler.getInstance(basename);\n        String messageText = msg.getMessage(key, params);\n        if (Trace.isInitialized()) {\n            Trace.error(\"Exception caught: \" + key + \" \" + messageText, this);\n        } else // if (Trace.isInitialized())\n        {\n            System.out.println(\"Exception caught: \" + key + \" \" + messageText);\n            printStackTrace();\n        }\n        messageText = key + \" \" + messageText;\n        setExceptionInformation(messageText, this);\n        mMessageText = messageText;\n    }\n\n    private void traceException(String Location, String Layer, String Package, String Number, Throwable t, List params) {\n        /*\n\t\t * When the exception is an XException, it has been traced before\n\t\t */\n        if (!this.getClass().equals(t.getClass())) {\n            String basename = \"errors\";\n            String key = Location + \"_\" + Layer + \"_\" + Package + \"_\" + Number;\n            MessageHandler msg = MessageHandler.getInstance(basename);\n            String messageText = msg.getMessageOptional(key, params);\n            if (messageText == null) {\n                messageText = t.getMessage();\n                if ((messageText == null) && (t.getCause() != null)) {\n                    /*\n\t\t\t\t\t * When the Exception has no message, maybe its cause has\n\t\t\t\t\t * one\n\t\t\t\t\t */\n                    messageText = t.getCause().getMessage();\n                }\n                if (messageText == null) {\n                    /*\n\t\t\t\t\t * If messageText is still null, the name of the Throwable\n\t\t\t\t\t * class is used\n\t\t\t\t\t */\n                    messageText = t.getClass().getName();\n                }\n            }\n            // if (messageText == null)\n            if (Trace.isInitialized()) {\n                Trace.error(\"Exception caught: \" + key + \" \" + messageText, t);\n                traceAdditionalInfo(t);\n            } else // if (Trace.isInitialized())\n            {\n                System.out.println(\"Exception caught: \" + key + \" \" + messageText);\n                t.printStackTrace();\n            }\n            messageText = key + \" \" + messageText;\n            setExceptionInformation(messageText, t);\n            mMessageText = messageText;\n        } else // if (!this.getClass().equals(t.getClass()))\n        {\n            mMessageText = t.getMessage();\n        }\n    }\n\n    private void traceAdditionalInfo(Throwable t) {\n        if (t instanceof NamingException) {\n            Trace.error(\"Resolved Name\t : \" + ((NamingException) t).getResolvedName());\n            Trace.error(\"Resolved Object : \" + ((NamingException) t).getResolvedObj());\n            Trace.error(\"Remaining Name  : \" + ((NamingException) t).getRemainingName());\n            Trace.error(\"Explanation : \" + ((NamingException) t).getExplanation());\n        } else if (t instanceof SQLException) {\n            Trace.error(\"SQLState : \" + ((SQLException) t).getSQLState());\n            Trace.error(\"Errorcode: \" + ((SQLException) t).getErrorCode());\n        } else if (t instanceof SAXParseException) {\n            Trace.error(\"Parsing error occurred at line \" + ((SAXParseException) t).getLineNumber() + \", column \" + ((SAXParseException) t).getColumnNumber());\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/XExceptionTest.java",
		"test_prompt": "// XExceptionTest.java\npackage net.sf.xbus.base.core;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.sql.SQLException;\nimport java.util.Hashtable;\nimport java.util.List;\nimport javax.naming.NamingException;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.xml.sax.SAXParseException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XException}.\n* It contains ten unit test cases for the {@link XException#getExceptionInformation()} method.\n*/\nclass XExceptionTest {"
	},
	{
		"original_code": "// FutureResult.java\n/*\n * Originally written by Doug Lea and released into the public domain. This may\n * be used for any purposes whatsoever without acknowledgment. Thanks for the\n * assistance and support of Sun Microsystems Labs, and everyone contributing,\n * testing, and using this code.\n */\npackage net.sf.xbus.base.core.timeoutcall;\n\nimport java.lang.reflect.InvocationTargetException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * A class maintaining a single reference variable serving as the result of an\n * operation. The result cannot be accessed until it has been set.\n * <p>\n * <b>Sample Usage</b>\n * <p>\n *\n * <pre>\n *  class ImageRenderer { Image render(byte[] raw); }\n *  class App {\n *    Executor executor = ...\n *    ImageRenderer renderer = ...\n *    void display(byte[] rawimage) {\n *      try {\n *        FutureResult futureImage = new FutureResult();\n *        Runnable command = futureImage.setter(new Callable() {\n *           public Object call() { return renderer.render(rawImage); }\n *        });\n *        executor.execute(command);\n *        drawBorders();             // do other things while executing\n *        drawCaption();\n *        drawImage((Image)(futureImage.get())); // use future\n *      }\n *      catch (InterruptedException ex) { return; }\n *      catch (InvocationTargetException ex) { cleanup(); return; }\n *    }\n *  }\n * </pre>\n *\n * <p>[<a\n * href=\"http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html\">\n * Introduction to this package. </a>]\n */\npublic class FutureResult {\n\n    /**\n     * The result of the operation *\n     */\n    protected Object value_ = null;\n\n    /**\n     * Status -- true after first set *\n     */\n    protected boolean ready_ = false;\n\n    /**\n     * the exception encountered by operation producing result *\n     */\n    // protected InvocationTargetException exception_ = null;\n    protected XException exception_ = null;\n\n    /**\n     * Create an initially unset FutureResult\n     */\n    public FutureResult() {\n        /*\n\t\t * do nothing\n\t\t */\n    }\n\n    /**\n     * Return a Runnable object that, when run, will set the result value.\n     *\n     * @param function - a Callable object whose result will be held by this\n     *            FutureResult.\n     * @return A Runnable object that, when run, will call the function and\n     *         (eventually) set the result.\n     */\n    public Runnable setter(final Callable function) {\n        return new Runnable() {\n\n            public void run() {\n                try {\n                    set(function.call());\n                } catch (Throwable ex) {\n                    setException(ex);\n                }\n            }\n        };\n    }\n\n    /**\n     * internal utility: either get the value or throw the exception *\n     */\n    protected Object doGet() throws XException {\n        if (exception_ != null)\n            throw exception_;\n        else\n            return value_;\n    }\n\n    /**\n     * Access the reference, waiting if necessary until it is ready.\n     *\n     * @return current value\n     * @exception InterruptedException if current thread has been interrupted\n     * @exception InvocationTargetException if the operation producing the value\n     *                encountered an exception.\n     */\n    public synchronized Object get() throws InterruptedException, XException {\n        while (!ready_) wait();\n        return doGet();\n    }\n\n    /**\n     * Wait at most msecs to access the reference.\n     *\n     * @return current value\n     * @exception TimeoutException if not ready after msecs\n     * @exception InterruptedException if current thread has been interrupted\n     * @exception InvocationTargetException if the operation producing the value\n     *                encountered an exception.\n     */\n    public synchronized Object timedGet(long msecs) throws TimeoutException, InterruptedException, XException {\n        long startTime = (msecs <= 0) ? 0 : System.currentTimeMillis();\n        long waitTime = msecs;\n        if (ready_)\n            return doGet();\n        else if (waitTime <= 0)\n            throw new TimeoutException(msecs);\n        else {\n            for (; ; ) {\n                wait(waitTime);\n                if (ready_)\n                    return doGet();\n                else {\n                    waitTime = msecs - (System.currentTimeMillis() - startTime);\n                    if (waitTime <= 0)\n                        throw new TimeoutException(msecs);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set the reference, and signal that it is ready. It is not considered an\n     * error to set the value more than once, but it is not something you would\n     * normally want to do.\n     *\n     * @param newValue The value that will be returned by a subsequent get();\n     */\n    public synchronized void set(Object newValue) {\n        value_ = newValue;\n        ready_ = true;\n        notifyAll();\n    }\n\n    /**\n     * Set the exception field, also setting ready status.\n     *\n     * @param ex The exception. It will be reported out wrapped within an\n     *            InvocationTargetException\n     */\n    public synchronized void setException(Throwable ex) {\n        // exception_ = new InvocationTargetException(ex);\n        exception_ = new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_TIMEOUTCALL, \"2\", ex);\n        ready_ = true;\n        notifyAll();\n    }\n\n    /**\n     * Get the exception, or null if there isn't one (yet). This does not wait\n     * until the future is ready, so should ordinarily only be called if you\n     * know it is.\n     *\n     * @return the exception encountered by the operation setting the future,\n     *         wrapped in an InvocationTargetException\n     */\n    public synchronized XException getException() {\n        return exception_;\n    }\n\n    /**\n     * Return whether the reference or exception have been set.\n     *\n     * @return true if has been set. else false\n     */\n    public synchronized boolean isReady() {\n        return ready_;\n    }\n\n    /**\n     * Access the reference, even if not ready\n     *\n     * @return current value\n     */\n    public synchronized Object peek() {\n        return value_;\n    }\n\n    /**\n     * Clear the value and exception and set to not-ready, allowing this\n     * FutureResult to be reused. This is not particularly recommended and must\n     * be done only when you know that no other object is depending on the\n     * properties of this FutureResult.\n     */\n    public synchronized void clear() {\n        value_ = null;\n        exception_ = null;\n        ready_ = false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/timeoutcall/FutureResultTest0.java",
		"test_prompt": "// FutureResultTest0.java\npackage net.sf.xbus.base.core.timeoutcall;\n\nimport java.lang.reflect.InvocationTargetException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FutureResult}.\n* It contains ten unit test cases for the {@link FutureResult#timedGet(long)} method.\n*/\nclass FutureResultTest0 {"
	},
	{
		"original_code": "// FutureResult.java\n/*\n * Originally written by Doug Lea and released into the public domain. This may\n * be used for any purposes whatsoever without acknowledgment. Thanks for the\n * assistance and support of Sun Microsystems Labs, and everyone contributing,\n * testing, and using this code.\n */\npackage net.sf.xbus.base.core.timeoutcall;\n\nimport java.lang.reflect.InvocationTargetException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * A class maintaining a single reference variable serving as the result of an\n * operation. The result cannot be accessed until it has been set.\n * <p>\n * <b>Sample Usage</b>\n * <p>\n *\n * <pre>\n *  class ImageRenderer { Image render(byte[] raw); }\n *  class App {\n *    Executor executor = ...\n *    ImageRenderer renderer = ...\n *    void display(byte[] rawimage) {\n *      try {\n *        FutureResult futureImage = new FutureResult();\n *        Runnable command = futureImage.setter(new Callable() {\n *           public Object call() { return renderer.render(rawImage); }\n *        });\n *        executor.execute(command);\n *        drawBorders();             // do other things while executing\n *        drawCaption();\n *        drawImage((Image)(futureImage.get())); // use future\n *      }\n *      catch (InterruptedException ex) { return; }\n *      catch (InvocationTargetException ex) { cleanup(); return; }\n *    }\n *  }\n * </pre>\n *\n * <p>[<a\n * href=\"http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html\">\n * Introduction to this package. </a>]\n */\npublic class FutureResult {\n\n    /**\n     * The result of the operation *\n     */\n    protected Object value_ = null;\n\n    /**\n     * Status -- true after first set *\n     */\n    protected boolean ready_ = false;\n\n    /**\n     * the exception encountered by operation producing result *\n     */\n    // protected InvocationTargetException exception_ = null;\n    protected XException exception_ = null;\n\n    /**\n     * Create an initially unset FutureResult\n     */\n    public FutureResult() {\n        /*\n\t\t * do nothing\n\t\t */\n    }\n\n    /**\n     * Return a Runnable object that, when run, will set the result value.\n     *\n     * @param function - a Callable object whose result will be held by this\n     *            FutureResult.\n     * @return A Runnable object that, when run, will call the function and\n     *         (eventually) set the result.\n     */\n    public Runnable setter(final Callable function) {\n        return new Runnable() {\n\n            public void run() {\n                try {\n                    set(function.call());\n                } catch (Throwable ex) {\n                    setException(ex);\n                }\n            }\n        };\n    }\n\n    /**\n     * internal utility: either get the value or throw the exception *\n     */\n    protected Object doGet() throws XException {\n        if (exception_ != null)\n            throw exception_;\n        else\n            return value_;\n    }\n\n    /**\n     * Access the reference, waiting if necessary until it is ready.\n     *\n     * @return current value\n     * @exception InterruptedException if current thread has been interrupted\n     * @exception InvocationTargetException if the operation producing the value\n     *                encountered an exception.\n     */\n    public synchronized Object get() throws InterruptedException, XException {\n        while (!ready_) wait();\n        return doGet();\n    }\n\n    /**\n     * Wait at most msecs to access the reference.\n     *\n     * @return current value\n     * @exception TimeoutException if not ready after msecs\n     * @exception InterruptedException if current thread has been interrupted\n     * @exception InvocationTargetException if the operation producing the value\n     *                encountered an exception.\n     */\n    public synchronized Object timedGet(long msecs) throws TimeoutException, InterruptedException, XException {\n        long startTime = (msecs <= 0) ? 0 : System.currentTimeMillis();\n        long waitTime = msecs;\n        if (ready_)\n            return doGet();\n        else if (waitTime <= 0)\n            throw new TimeoutException(msecs);\n        else {\n            for (; ; ) {\n                wait(waitTime);\n                if (ready_)\n                    return doGet();\n                else {\n                    waitTime = msecs - (System.currentTimeMillis() - startTime);\n                    if (waitTime <= 0)\n                        throw new TimeoutException(msecs);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set the reference, and signal that it is ready. It is not considered an\n     * error to set the value more than once, but it is not something you would\n     * normally want to do.\n     *\n     * @param newValue The value that will be returned by a subsequent get();\n     */\n    public synchronized void set(Object newValue) {\n        value_ = newValue;\n        ready_ = true;\n        notifyAll();\n    }\n\n    /**\n     * Set the exception field, also setting ready status.\n     *\n     * @param ex The exception. It will be reported out wrapped within an\n     *            InvocationTargetException\n     */\n    public synchronized void setException(Throwable ex) {\n        // exception_ = new InvocationTargetException(ex);\n        exception_ = new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_TIMEOUTCALL, \"2\", ex);\n        ready_ = true;\n        notifyAll();\n    }\n\n    /**\n     * Get the exception, or null if there isn't one (yet). This does not wait\n     * until the future is ready, so should ordinarily only be called if you\n     * know it is.\n     *\n     * @return the exception encountered by the operation setting the future,\n     *         wrapped in an InvocationTargetException\n     */\n    public synchronized XException getException() {\n        return exception_;\n    }\n\n    /**\n     * Return whether the reference or exception have been set.\n     *\n     * @return true if has been set. else false\n     */\n    public synchronized boolean isReady() {\n        return ready_;\n    }\n\n    /**\n     * Access the reference, even if not ready\n     *\n     * @return current value\n     */\n    public synchronized Object peek() {\n        return value_;\n    }\n\n    /**\n     * Clear the value and exception and set to not-ready, allowing this\n     * FutureResult to be reused. This is not particularly recommended and must\n     * be done only when you know that no other object is depending on the\n     * properties of this FutureResult.\n     */\n    public synchronized void clear() {\n        value_ = null;\n        exception_ = null;\n        ready_ = false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/timeoutcall/FutureResultTest1.java",
		"test_prompt": "// FutureResultTest1.java\npackage net.sf.xbus.base.core.timeoutcall;\n\nimport java.lang.reflect.InvocationTargetException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FutureResult}.\n* It contains ten unit test cases for the {@link FutureResult#isReady()} method.\n*/\nclass FutureResultTest1 {"
	},
	{
		"original_code": "// FutureResult.java\n/*\n * Originally written by Doug Lea and released into the public domain. This may\n * be used for any purposes whatsoever without acknowledgment. Thanks for the\n * assistance and support of Sun Microsystems Labs, and everyone contributing,\n * testing, and using this code.\n */\npackage net.sf.xbus.base.core.timeoutcall;\n\nimport java.lang.reflect.InvocationTargetException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * A class maintaining a single reference variable serving as the result of an\n * operation. The result cannot be accessed until it has been set.\n * <p>\n * <b>Sample Usage</b>\n * <p>\n *\n * <pre>\n *  class ImageRenderer { Image render(byte[] raw); }\n *  class App {\n *    Executor executor = ...\n *    ImageRenderer renderer = ...\n *    void display(byte[] rawimage) {\n *      try {\n *        FutureResult futureImage = new FutureResult();\n *        Runnable command = futureImage.setter(new Callable() {\n *           public Object call() { return renderer.render(rawImage); }\n *        });\n *        executor.execute(command);\n *        drawBorders();             // do other things while executing\n *        drawCaption();\n *        drawImage((Image)(futureImage.get())); // use future\n *      }\n *      catch (InterruptedException ex) { return; }\n *      catch (InvocationTargetException ex) { cleanup(); return; }\n *    }\n *  }\n * </pre>\n *\n * <p>[<a\n * href=\"http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html\">\n * Introduction to this package. </a>]\n */\npublic class FutureResult {\n\n    /**\n     * The result of the operation *\n     */\n    protected Object value_ = null;\n\n    /**\n     * Status -- true after first set *\n     */\n    protected boolean ready_ = false;\n\n    /**\n     * the exception encountered by operation producing result *\n     */\n    // protected InvocationTargetException exception_ = null;\n    protected XException exception_ = null;\n\n    /**\n     * Create an initially unset FutureResult\n     */\n    public FutureResult() {\n        /*\n\t\t * do nothing\n\t\t */\n    }\n\n    /**\n     * Return a Runnable object that, when run, will set the result value.\n     *\n     * @param function - a Callable object whose result will be held by this\n     *            FutureResult.\n     * @return A Runnable object that, when run, will call the function and\n     *         (eventually) set the result.\n     */\n    public Runnable setter(final Callable function) {\n        return new Runnable() {\n\n            public void run() {\n                try {\n                    set(function.call());\n                } catch (Throwable ex) {\n                    setException(ex);\n                }\n            }\n        };\n    }\n\n    /**\n     * internal utility: either get the value or throw the exception *\n     */\n    protected Object doGet() throws XException {\n        if (exception_ != null)\n            throw exception_;\n        else\n            return value_;\n    }\n\n    /**\n     * Access the reference, waiting if necessary until it is ready.\n     *\n     * @return current value\n     * @exception InterruptedException if current thread has been interrupted\n     * @exception InvocationTargetException if the operation producing the value\n     *                encountered an exception.\n     */\n    public synchronized Object get() throws InterruptedException, XException {\n        while (!ready_) wait();\n        return doGet();\n    }\n\n    /**\n     * Wait at most msecs to access the reference.\n     *\n     * @return current value\n     * @exception TimeoutException if not ready after msecs\n     * @exception InterruptedException if current thread has been interrupted\n     * @exception InvocationTargetException if the operation producing the value\n     *                encountered an exception.\n     */\n    public synchronized Object timedGet(long msecs) throws TimeoutException, InterruptedException, XException {\n        long startTime = (msecs <= 0) ? 0 : System.currentTimeMillis();\n        long waitTime = msecs;\n        if (ready_)\n            return doGet();\n        else if (waitTime <= 0)\n            throw new TimeoutException(msecs);\n        else {\n            for (; ; ) {\n                wait(waitTime);\n                if (ready_)\n                    return doGet();\n                else {\n                    waitTime = msecs - (System.currentTimeMillis() - startTime);\n                    if (waitTime <= 0)\n                        throw new TimeoutException(msecs);\n                }\n            }\n        }\n    }\n\n    /**\n     * Set the reference, and signal that it is ready. It is not considered an\n     * error to set the value more than once, but it is not something you would\n     * normally want to do.\n     *\n     * @param newValue The value that will be returned by a subsequent get();\n     */\n    public synchronized void set(Object newValue) {\n        value_ = newValue;\n        ready_ = true;\n        notifyAll();\n    }\n\n    /**\n     * Set the exception field, also setting ready status.\n     *\n     * @param ex The exception. It will be reported out wrapped within an\n     *            InvocationTargetException\n     */\n    public synchronized void setException(Throwable ex) {\n        // exception_ = new InvocationTargetException(ex);\n        exception_ = new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_TIMEOUTCALL, \"2\", ex);\n        ready_ = true;\n        notifyAll();\n    }\n\n    /**\n     * Get the exception, or null if there isn't one (yet). This does not wait\n     * until the future is ready, so should ordinarily only be called if you\n     * know it is.\n     *\n     * @return the exception encountered by the operation setting the future,\n     *         wrapped in an InvocationTargetException\n     */\n    public synchronized XException getException() {\n        return exception_;\n    }\n\n    /**\n     * Return whether the reference or exception have been set.\n     *\n     * @return true if has been set. else false\n     */\n    public synchronized boolean isReady() {\n        return ready_;\n    }\n\n    /**\n     * Access the reference, even if not ready\n     *\n     * @return current value\n     */\n    public synchronized Object peek() {\n        return value_;\n    }\n\n    /**\n     * Clear the value and exception and set to not-ready, allowing this\n     * FutureResult to be reused. This is not particularly recommended and must\n     * be done only when you know that no other object is depending on the\n     * properties of this FutureResult.\n     */\n    public synchronized void clear() {\n        value_ = null;\n        exception_ = null;\n        ready_ = false;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/timeoutcall/FutureResultTest2.java",
		"test_prompt": "// FutureResultTest2.java\npackage net.sf.xbus.base.core.timeoutcall;\n\nimport java.lang.reflect.InvocationTargetException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link FutureResult}.\n* It contains ten unit test cases for the {@link FutureResult#peek()} method.\n*/\nclass FutureResultTest2 {"
	},
	{
		"original_code": "// TimedCallable.java\n/*\n * Originally written by Joseph Bowbeer and released into the public domain.\n * This may be used for any purposes whatsoever without acknowledgment.\n * \n * Originally part of jozart.swingutils. Adapted by Doug Lea for\n * util.concurrent.\n */\npackage net.sf.xbus.base.core.timeoutcall;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * TimedCallable runs a Callable function for a given length of time. The\n * function is run in its own thread. If the function completes in time, its\n * result is returned; otherwise the thread is interrupted and an\n * InterruptedException is thrown.\n * <p>\n * Note: TimedCallable will always return within the given time limit (modulo\n * timer inaccuracies), but whether or not the worker thread stops in a timely\n * fashion depends on the interrupt handling in the Callable function's\n * implementation.\n *\n * @author Joseph Bowbeer\n * @version 1.0\n *\n * <p>[<a\n * href=\"http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html\">\n * Introduction to this package. </a>]\n */\npublic class TimedCallable extends ThreadFactoryUser implements Callable {\n\n    private final Callable function;\n\n    private final long millis;\n\n    private Thread mThread = null;\n\n    public TimedCallable(Callable function, long millis) {\n        this.function = function;\n        this.millis = millis;\n    }\n\n    public Object call() throws XException {\n        FutureResult result = new FutureResult();\n        mThread = getThreadFactory().newThread(result.setter(function));\n        mThread.start();\n        try {\n            return result.timedGet(millis);\n        } catch (InterruptedException e) {\n            /*\n\t\t\t * Stop thread if we were interrupted or timed-out while waiting for\n\t\t\t * the result.\n\t\t\t */\n            // mThread.stop();\n            mThread.interrupt();\n            function.stop();\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_TIMEOUTCALL, \"1\");\n        }\n        // catch (InvocationTargetException e)\n        // {\n        // throw new XException(\n        // Constants.LOCATION_INTERN,\n        // Constants.LAYER_COREBASE,\n        // Constants.PACKAGE_COREBASE_TIMEOUTCALL,\n        // \"0\",\n        // e);\n        // }\n    }\n\n    public void stop() {\n        /*\n\t\t * do nothing\n\t\t */\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/timeoutcall/TimedCallableTest.java",
		"test_prompt": "// TimedCallableTest.java\npackage net.sf.xbus.base.core.timeoutcall;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TimedCallable}.\n* It contains ten unit test cases for the {@link TimedCallable#call()} method.\n*/\nclass TimedCallableTest {"
	},
	{
		"original_code": "// Constants.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Definition of various constants, used by all classes.\n */\npublic class Constants {\n\n    /**\n     * Reads the encoding for XML data in the configuration and returns it. When\n     * no encoding is found, the value UTF-8 is returned.\n     *\n     * @return encoding for XML data\n     * @throws XException\n     *             when something goes wrong\n     */\n    public static final String getXMLEncoding() throws XException {\n        String encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"XML\", \"Encoding\");\n        if (encoding != null) {\n            return encoding;\n        } else {\n            encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"Encoding\", \"XML\");\n            if (encoding != null) {\n                return encoding;\n            } else {\n                return \"UTF-8\";\n            }\n        }\n    }\n\n    public static final String RC_OK = \"RC_OK\";\n\n    public static final String RC_NOK = \"RC_NOK\";\n\n    public static final String CONFIGURATION_TRUE = \"true\";\n\n    public static final String CONFIGURATION_FALSE = \"false\";\n\n    public static final String TYPE_TEXT = \"Text\";\n\n    public static final String TYPE_OBJECT = \"Object\";\n\n    public static final String TYPE_BINARY = \"Binary\";\n\n    public static final String TYPE_XML = \"XML\";\n\n    public static final int IFCONTENTCLASS_BYTEARRAYLIST = 0;\n\n    public static final int IFCONTENTCLASS_STRING = 1;\n\n    public static final String XBUSXMLMESSAGE_DOCUMENT = \"XBUS_Document\";\n\n    public static final String XBUSXMLMESSAGE_CALL = \"XBUS_Call\";\n\n    public static final String XBUSXMLMESSAGE_DATA = \"XBUS_Data\";\n\n    public static final String XBUSXMLMESSAGE_ID = \"Id\";\n\n    public static final String XBUSXMLMESSAGE_FUNCTION = \"Function\";\n\n    public static final String XBUSXMLMESSAGE_SOURCE = \"Source\";\n\n    public static final String XBUSXMLMESSAGE_ADDRESS = \"Address\";\n\n    public static final String XBUSXMLMESSAGE_TIMESTAMP = \"Timestamp\";\n\n    public static final String XBUSXMLMESSAGE_RETURNCODE = \"Returncode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORCODE = \"Errorcode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORTEXT = \"Errortext\";\n\n    public static final String LINE_SEPERATOR = System.getProperty(\"line.separator\");\n\n    public static final byte NEWLINE = 10;\n\n    public static final byte CARRIAGE_RETURN = 13;\n\n    /**\n     * <code>getLineSeperator</code> returns the line break representation for\n     * a specified platform.\n     *\n     * @param platform\n     *            the platform, for which the line break is needed\n     */\n    public static String getLineSeperator(String platform) throws XException {\n        String result = null;\n        if (platform.equals(\"Unix\"))\n            result = \"\\n\";\n        else if (platform.equals(\"Windows\"))\n            result = \"\\r\\n\";\n        else {\n            List params = new Vector();\n            params.add(platform);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"20\", params);\n        }\n        // else\n        return result;\n    }\n\n    // getLineSeperator(String platform)\n    public static final String FILE_SEPERATOR = File.separator;\n\n    public static final String XBUS_HOME = System.getProperty(\"xbus.home\");\n\n    public static final String XBUS_ETC = XBUS_HOME + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String XBUS_LOG = XBUS_HOME + FILE_SEPERATOR + \"log\" + FILE_SEPERATOR;\n\n    public static final String XBUS_PLUGIN_ETC = XBUS_HOME + FILE_SEPERATOR + \"plugin\" + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss,SSS\";\n\n    public static final String FILE_NAME_DATE_FORMAT = \".yyyyMMddHHmmssSSS\";\n\n    public static final String AS400_DATE_FORMAT = \"yyyyMMdd\";\n\n    // must be up to 10 characters long\n    public static final String AS400_CALL_DATE_FORMAT = \"ddMMyyyy\";\n\n    private static SimpleDateFormat dateFormat = null;\n\n    /**\n     * Constructs and gets a SimpleDateFormat using the default pattern using\n     * the given {@link #DATE_FORMAT}\n     *\n     * @return SimpleDateFormat\n     */\n    public static final SimpleDateFormat getDateFormat() {\n        if (dateFormat == null) {\n            dateFormat = new SimpleDateFormat(Constants.DATE_FORMAT);\n        }\n        return dateFormat;\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #FILE_NAME_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String\n     */\n    public static final String getDateAsString() {\n        return new SimpleDateFormat(Constants.FILE_NAME_DATE_FORMAT).format(new Date());\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #AS400_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String must be up to 10 characters long\n     */\n    public static final String getAS400DateFormat() {\n        return new SimpleDateFormat(Constants.AS400_DATE_FORMAT).format(new Date());\n    }\n\n    public static final String QUEUE_DUMP_DELIMITER = \"|||||nextMessage|||||\";\n\n    // Configuration\n    public static final String CHAPTER_SYSTEM = \"System\";\n\n    public static final String CHAPTER_BASE = \"Base\";\n\n    public static final String KEY_FILENAME = \"Filename\";\n\n    public static final String KEY_SEND_RESOL = \"ConflictResolution\";\n\n    public static final String KEY_ENCODING = \"Encoding\";\n\n    public static final String KEY_RECEIVE_RESOL = \"FinalResolution\";\n\n    public static final String KEY_CSV_HAS_HEADER = \"HasHeader\";\n\n    public static final String KEY_CSV_QUOTE_CHAR = \"QuoteChar\";\n\n    public static final String KEY_CSV_FIELD_SEPARATOR = \"FieldSeparator\";\n\n    public static final String KEY_CSV_ALWAYS_QUOTE = \"AlwaysQuote\";\n\n    public static final String KEY_CSV_DESCRIPTION_FILE = \"DescriptionFile\";\n\n    // FileSender\n    public static final String SYS_ENCODING = System.getProperty(\"file.encoding\");\n\n    public static final String WRITE_APPEND = \"Append\";\n\n    public static final String WRITE_OVERWRITE = \"Overwrite\";\n\n    public static final String WRITE_ERROR = \"Error\";\n\n    public static final String WRITE_RENAME = \"Rename\";\n\n    public static final int BLKSIZ = 32768;\n\n    public static final String TEMP_SUFFIX = \"xTmp\";\n\n    public static final String BACKUP_SUFFIX = \".save\";\n\n    // FileReceiver\n    public static final String READ_PRESERVE = \"Preserve\";\n\n    public static final String READ_RENAME = \"Rename\";\n\n    public static final String READ_DELETE = \"Delete\";\n\n    public static final String READ_DELETEFILE = \"DeleteFile\";\n\n    public static final String READ_DELETEMEMBER = \"DeleteMember\";\n\n    public static final String READ_CALLPROGRAM = \"CallProgram\";\n\n    public static final String RENAME_SUFFIX = \".back\";\n\n    public static final String READ_ERROR = \"Error\";\n\n    public static final String READ_IGNORE = \"Ignore\";\n\n    public static final String READ_PROCESS = \"Process\";\n\n    // XException - Location\n    public static final String LOCATION_INTERN = \"I\";\n\n    public static final String LOCATION_EXTERN = \"E\";\n\n    // XException - Layer\n    public static final String LAYER_COREBASE = \"00\";\n\n    public static final String LAYER_TECHNICAL = \"01\";\n\n    public static final String LAYER_PROTOCOL = \"02\";\n\n    public static final String LAYER_APPLICATION = \"03\";\n\n    public static final String LAYER_BASE = \"04\";\n\n    public static final String LAYER_ADMIN = \"05\";\n\n    public static final String LAYER_BOOTSTRAP = \"06\";\n\n    // XException - Technical Package\n    public static final String PACKAGE_TECHNICAL_TECHNICAL = \"000\";\n\n    public static final String PACKAGE_TECHNICAL_FILE = \"001\";\n\n    public static final String PACKAGE_TECHNICAL_AS400 = \"002\";\n\n    public static final String PACKAGE_TECHNICAL_DATABASE = \"003\";\n\n    public static final String PACKAGE_TECHNICAL_HTTP = \"004\";\n\n    public static final String PACKAGE_TECHNICAL_MQ = \"005\";\n\n    public static final String PACKAGE_TECHNICAL_JAVA = \"006\";\n\n    public static final String PACKAGE_TECHNICAL_MAIL = \"007\";\n\n    public static final String PACKAGE_TECHNICAL_SOCKET = \"008\";\n\n    public static final String PACKAGE_TECHNICAL_MISC = \"009\";\n\n    public static final String PACKAGE_TECHNICAL_FTP = \"010\";\n\n    public static final String PACKAGE_TECHNICAL_LDAP = \"011\";\n\n    // XException - Protocol Package\n    public static final String PACKAGE_PROTOCOL_PROTOCOL = \"000\";\n\n    public static final String PACKAGE_PROTOCOL_AS400 = \"001\";\n\n    public static final String PACKAGE_PROTOCOL_BYTEARRAYLIST = \"002\";\n\n    public static final String PACKAGE_PROTOCOL_RECORDS = \"003\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLEOBJECT = \"004\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLETEXT = \"005\";\n\n    public static final String PACKAGE_PROTOCOL_SOAP = \"006\";\n\n    public static final String PACKAGE_PROTOCOL_XML = \"007\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLE = \"008\";\n\n    public static final String PACKAGE_PROTOCOL_CSV = \"009\";\n\n    // XException - Application Package\n    public static final String PACKAGE_APPLICATION_ROUTER = \"001\";\n\n    public static final String PACKAGE_APPLICATION_ADAPTER = \"002\";\n\n    public static final String PACKAGE_APPLICATION_APPLICATIONFACTORY = \"003\";\n\n    // XException - Base Package\n    public static final String PACKAGE_BASE_NOTIFYERROR = \"001\";\n\n    public static final String PACKAGE_BASE_JOURNAL = \"002\";\n\n    public static final String PACKAGE_BASE_XBUSSYSTEM = \"003\";\n\n    public static final String PACKAGE_BASE_DELETEDMESSAGESTORE = \"004\";\n\n    // XException - Admin Package\n    public static final String PACKAGE_ADMIN_ADMIN = \"000\";\n\n    public static final String PACKAGE_ADMIN_JMX = \"001\";\n\n    public static final String PACKAGE_ADMIN_HTML = \"002\";\n\n    public static final String PACKAGE_ADMIN_SOAP = \"003\";\n\n    // XException - Core Base Package\n    public static final String PACKAGE_COREBASE_COREBASE = \"000\";\n\n    public static final String PACKAGE_COREBASE_CONFIG = \"001\";\n\n    public static final String PACKAGE_COREBASE_TRACE = \"002\";\n\n    public static final String PACKAGE_COREBASE_TIMEOUTCALL = \"003\";\n\n    public static final String PACKAGE_COREBASE_XML = \"004\";\n\n    public static final String PACKAGE_COREBASE_STRINGS = \"005\";\n\n    public static final String PACKAGE_COREBASE_ARITHMETIC = \"006\";\n\n    public static final String PACKAGE_COREBASE_REFLECTION = \"007\";\n\n    public static final String PACKAGE_COREBASE_BYTEARRAYS = \"008\";\n\n    // XException - Bootstrap Package\n    public static final String PACKAGE_BOOTSTRAP_BOOTSTRAP = \"000\";\n\n    // XException for Examples\n    public static final String LAYER_SAMPLE = \"99\";\n\n    public static final String PACKAGE_SAMPLE_SAMPLE = \"888\";\n\n    // XException for TestDriver\n    public static final String LAYER_TESTDRIVER = \"99\";\n\n    public static final String PACKAGE_TESTDRIVER_TESTDRIVER = \"999\";\n\n    public static final String POSTPROCESSING_PERSYSTEM = \"perSystem\";\n\n    public static final String POSTPROCESSING_FINAL = \"final\";\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/ConstantsTest0.java",
		"test_prompt": "// ConstantsTest0.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Constants}.\n* It contains ten unit test cases for the {@link Constants#getXMLEncoding()} method.\n*/\nclass ConstantsTest0 {"
	},
	{
		"original_code": "// Constants.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Definition of various constants, used by all classes.\n */\npublic class Constants {\n\n    /**\n     * Reads the encoding for XML data in the configuration and returns it. When\n     * no encoding is found, the value UTF-8 is returned.\n     *\n     * @return encoding for XML data\n     * @throws XException\n     *             when something goes wrong\n     */\n    public static final String getXMLEncoding() throws XException {\n        String encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"XML\", \"Encoding\");\n        if (encoding != null) {\n            return encoding;\n        } else {\n            encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"Encoding\", \"XML\");\n            if (encoding != null) {\n                return encoding;\n            } else {\n                return \"UTF-8\";\n            }\n        }\n    }\n\n    public static final String RC_OK = \"RC_OK\";\n\n    public static final String RC_NOK = \"RC_NOK\";\n\n    public static final String CONFIGURATION_TRUE = \"true\";\n\n    public static final String CONFIGURATION_FALSE = \"false\";\n\n    public static final String TYPE_TEXT = \"Text\";\n\n    public static final String TYPE_OBJECT = \"Object\";\n\n    public static final String TYPE_BINARY = \"Binary\";\n\n    public static final String TYPE_XML = \"XML\";\n\n    public static final int IFCONTENTCLASS_BYTEARRAYLIST = 0;\n\n    public static final int IFCONTENTCLASS_STRING = 1;\n\n    public static final String XBUSXMLMESSAGE_DOCUMENT = \"XBUS_Document\";\n\n    public static final String XBUSXMLMESSAGE_CALL = \"XBUS_Call\";\n\n    public static final String XBUSXMLMESSAGE_DATA = \"XBUS_Data\";\n\n    public static final String XBUSXMLMESSAGE_ID = \"Id\";\n\n    public static final String XBUSXMLMESSAGE_FUNCTION = \"Function\";\n\n    public static final String XBUSXMLMESSAGE_SOURCE = \"Source\";\n\n    public static final String XBUSXMLMESSAGE_ADDRESS = \"Address\";\n\n    public static final String XBUSXMLMESSAGE_TIMESTAMP = \"Timestamp\";\n\n    public static final String XBUSXMLMESSAGE_RETURNCODE = \"Returncode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORCODE = \"Errorcode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORTEXT = \"Errortext\";\n\n    public static final String LINE_SEPERATOR = System.getProperty(\"line.separator\");\n\n    public static final byte NEWLINE = 10;\n\n    public static final byte CARRIAGE_RETURN = 13;\n\n    /**\n     * <code>getLineSeperator</code> returns the line break representation for\n     * a specified platform.\n     *\n     * @param platform\n     *            the platform, for which the line break is needed\n     */\n    public static String getLineSeperator(String platform) throws XException {\n        String result = null;\n        if (platform.equals(\"Unix\"))\n            result = \"\\n\";\n        else if (platform.equals(\"Windows\"))\n            result = \"\\r\\n\";\n        else {\n            List params = new Vector();\n            params.add(platform);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"20\", params);\n        }\n        // else\n        return result;\n    }\n\n    // getLineSeperator(String platform)\n    public static final String FILE_SEPERATOR = File.separator;\n\n    public static final String XBUS_HOME = System.getProperty(\"xbus.home\");\n\n    public static final String XBUS_ETC = XBUS_HOME + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String XBUS_LOG = XBUS_HOME + FILE_SEPERATOR + \"log\" + FILE_SEPERATOR;\n\n    public static final String XBUS_PLUGIN_ETC = XBUS_HOME + FILE_SEPERATOR + \"plugin\" + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss,SSS\";\n\n    public static final String FILE_NAME_DATE_FORMAT = \".yyyyMMddHHmmssSSS\";\n\n    public static final String AS400_DATE_FORMAT = \"yyyyMMdd\";\n\n    // must be up to 10 characters long\n    public static final String AS400_CALL_DATE_FORMAT = \"ddMMyyyy\";\n\n    private static SimpleDateFormat dateFormat = null;\n\n    /**\n     * Constructs and gets a SimpleDateFormat using the default pattern using\n     * the given {@link #DATE_FORMAT}\n     *\n     * @return SimpleDateFormat\n     */\n    public static final SimpleDateFormat getDateFormat() {\n        if (dateFormat == null) {\n            dateFormat = new SimpleDateFormat(Constants.DATE_FORMAT);\n        }\n        return dateFormat;\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #FILE_NAME_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String\n     */\n    public static final String getDateAsString() {\n        return new SimpleDateFormat(Constants.FILE_NAME_DATE_FORMAT).format(new Date());\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #AS400_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String must be up to 10 characters long\n     */\n    public static final String getAS400DateFormat() {\n        return new SimpleDateFormat(Constants.AS400_DATE_FORMAT).format(new Date());\n    }\n\n    public static final String QUEUE_DUMP_DELIMITER = \"|||||nextMessage|||||\";\n\n    // Configuration\n    public static final String CHAPTER_SYSTEM = \"System\";\n\n    public static final String CHAPTER_BASE = \"Base\";\n\n    public static final String KEY_FILENAME = \"Filename\";\n\n    public static final String KEY_SEND_RESOL = \"ConflictResolution\";\n\n    public static final String KEY_ENCODING = \"Encoding\";\n\n    public static final String KEY_RECEIVE_RESOL = \"FinalResolution\";\n\n    public static final String KEY_CSV_HAS_HEADER = \"HasHeader\";\n\n    public static final String KEY_CSV_QUOTE_CHAR = \"QuoteChar\";\n\n    public static final String KEY_CSV_FIELD_SEPARATOR = \"FieldSeparator\";\n\n    public static final String KEY_CSV_ALWAYS_QUOTE = \"AlwaysQuote\";\n\n    public static final String KEY_CSV_DESCRIPTION_FILE = \"DescriptionFile\";\n\n    // FileSender\n    public static final String SYS_ENCODING = System.getProperty(\"file.encoding\");\n\n    public static final String WRITE_APPEND = \"Append\";\n\n    public static final String WRITE_OVERWRITE = \"Overwrite\";\n\n    public static final String WRITE_ERROR = \"Error\";\n\n    public static final String WRITE_RENAME = \"Rename\";\n\n    public static final int BLKSIZ = 32768;\n\n    public static final String TEMP_SUFFIX = \"xTmp\";\n\n    public static final String BACKUP_SUFFIX = \".save\";\n\n    // FileReceiver\n    public static final String READ_PRESERVE = \"Preserve\";\n\n    public static final String READ_RENAME = \"Rename\";\n\n    public static final String READ_DELETE = \"Delete\";\n\n    public static final String READ_DELETEFILE = \"DeleteFile\";\n\n    public static final String READ_DELETEMEMBER = \"DeleteMember\";\n\n    public static final String READ_CALLPROGRAM = \"CallProgram\";\n\n    public static final String RENAME_SUFFIX = \".back\";\n\n    public static final String READ_ERROR = \"Error\";\n\n    public static final String READ_IGNORE = \"Ignore\";\n\n    public static final String READ_PROCESS = \"Process\";\n\n    // XException - Location\n    public static final String LOCATION_INTERN = \"I\";\n\n    public static final String LOCATION_EXTERN = \"E\";\n\n    // XException - Layer\n    public static final String LAYER_COREBASE = \"00\";\n\n    public static final String LAYER_TECHNICAL = \"01\";\n\n    public static final String LAYER_PROTOCOL = \"02\";\n\n    public static final String LAYER_APPLICATION = \"03\";\n\n    public static final String LAYER_BASE = \"04\";\n\n    public static final String LAYER_ADMIN = \"05\";\n\n    public static final String LAYER_BOOTSTRAP = \"06\";\n\n    // XException - Technical Package\n    public static final String PACKAGE_TECHNICAL_TECHNICAL = \"000\";\n\n    public static final String PACKAGE_TECHNICAL_FILE = \"001\";\n\n    public static final String PACKAGE_TECHNICAL_AS400 = \"002\";\n\n    public static final String PACKAGE_TECHNICAL_DATABASE = \"003\";\n\n    public static final String PACKAGE_TECHNICAL_HTTP = \"004\";\n\n    public static final String PACKAGE_TECHNICAL_MQ = \"005\";\n\n    public static final String PACKAGE_TECHNICAL_JAVA = \"006\";\n\n    public static final String PACKAGE_TECHNICAL_MAIL = \"007\";\n\n    public static final String PACKAGE_TECHNICAL_SOCKET = \"008\";\n\n    public static final String PACKAGE_TECHNICAL_MISC = \"009\";\n\n    public static final String PACKAGE_TECHNICAL_FTP = \"010\";\n\n    public static final String PACKAGE_TECHNICAL_LDAP = \"011\";\n\n    // XException - Protocol Package\n    public static final String PACKAGE_PROTOCOL_PROTOCOL = \"000\";\n\n    public static final String PACKAGE_PROTOCOL_AS400 = \"001\";\n\n    public static final String PACKAGE_PROTOCOL_BYTEARRAYLIST = \"002\";\n\n    public static final String PACKAGE_PROTOCOL_RECORDS = \"003\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLEOBJECT = \"004\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLETEXT = \"005\";\n\n    public static final String PACKAGE_PROTOCOL_SOAP = \"006\";\n\n    public static final String PACKAGE_PROTOCOL_XML = \"007\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLE = \"008\";\n\n    public static final String PACKAGE_PROTOCOL_CSV = \"009\";\n\n    // XException - Application Package\n    public static final String PACKAGE_APPLICATION_ROUTER = \"001\";\n\n    public static final String PACKAGE_APPLICATION_ADAPTER = \"002\";\n\n    public static final String PACKAGE_APPLICATION_APPLICATIONFACTORY = \"003\";\n\n    // XException - Base Package\n    public static final String PACKAGE_BASE_NOTIFYERROR = \"001\";\n\n    public static final String PACKAGE_BASE_JOURNAL = \"002\";\n\n    public static final String PACKAGE_BASE_XBUSSYSTEM = \"003\";\n\n    public static final String PACKAGE_BASE_DELETEDMESSAGESTORE = \"004\";\n\n    // XException - Admin Package\n    public static final String PACKAGE_ADMIN_ADMIN = \"000\";\n\n    public static final String PACKAGE_ADMIN_JMX = \"001\";\n\n    public static final String PACKAGE_ADMIN_HTML = \"002\";\n\n    public static final String PACKAGE_ADMIN_SOAP = \"003\";\n\n    // XException - Core Base Package\n    public static final String PACKAGE_COREBASE_COREBASE = \"000\";\n\n    public static final String PACKAGE_COREBASE_CONFIG = \"001\";\n\n    public static final String PACKAGE_COREBASE_TRACE = \"002\";\n\n    public static final String PACKAGE_COREBASE_TIMEOUTCALL = \"003\";\n\n    public static final String PACKAGE_COREBASE_XML = \"004\";\n\n    public static final String PACKAGE_COREBASE_STRINGS = \"005\";\n\n    public static final String PACKAGE_COREBASE_ARITHMETIC = \"006\";\n\n    public static final String PACKAGE_COREBASE_REFLECTION = \"007\";\n\n    public static final String PACKAGE_COREBASE_BYTEARRAYS = \"008\";\n\n    // XException - Bootstrap Package\n    public static final String PACKAGE_BOOTSTRAP_BOOTSTRAP = \"000\";\n\n    // XException for Examples\n    public static final String LAYER_SAMPLE = \"99\";\n\n    public static final String PACKAGE_SAMPLE_SAMPLE = \"888\";\n\n    // XException for TestDriver\n    public static final String LAYER_TESTDRIVER = \"99\";\n\n    public static final String PACKAGE_TESTDRIVER_TESTDRIVER = \"999\";\n\n    public static final String POSTPROCESSING_PERSYSTEM = \"perSystem\";\n\n    public static final String POSTPROCESSING_FINAL = \"final\";\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/ConstantsTest1.java",
		"test_prompt": "// ConstantsTest1.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Constants}.\n* It contains ten unit test cases for the {@link Constants#getLineSeperator(String)} method.\n*/\nclass ConstantsTest1 {"
	},
	{
		"original_code": "// Constants.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Definition of various constants, used by all classes.\n */\npublic class Constants {\n\n    /**\n     * Reads the encoding for XML data in the configuration and returns it. When\n     * no encoding is found, the value UTF-8 is returned.\n     *\n     * @return encoding for XML data\n     * @throws XException\n     *             when something goes wrong\n     */\n    public static final String getXMLEncoding() throws XException {\n        String encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"XML\", \"Encoding\");\n        if (encoding != null) {\n            return encoding;\n        } else {\n            encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"Encoding\", \"XML\");\n            if (encoding != null) {\n                return encoding;\n            } else {\n                return \"UTF-8\";\n            }\n        }\n    }\n\n    public static final String RC_OK = \"RC_OK\";\n\n    public static final String RC_NOK = \"RC_NOK\";\n\n    public static final String CONFIGURATION_TRUE = \"true\";\n\n    public static final String CONFIGURATION_FALSE = \"false\";\n\n    public static final String TYPE_TEXT = \"Text\";\n\n    public static final String TYPE_OBJECT = \"Object\";\n\n    public static final String TYPE_BINARY = \"Binary\";\n\n    public static final String TYPE_XML = \"XML\";\n\n    public static final int IFCONTENTCLASS_BYTEARRAYLIST = 0;\n\n    public static final int IFCONTENTCLASS_STRING = 1;\n\n    public static final String XBUSXMLMESSAGE_DOCUMENT = \"XBUS_Document\";\n\n    public static final String XBUSXMLMESSAGE_CALL = \"XBUS_Call\";\n\n    public static final String XBUSXMLMESSAGE_DATA = \"XBUS_Data\";\n\n    public static final String XBUSXMLMESSAGE_ID = \"Id\";\n\n    public static final String XBUSXMLMESSAGE_FUNCTION = \"Function\";\n\n    public static final String XBUSXMLMESSAGE_SOURCE = \"Source\";\n\n    public static final String XBUSXMLMESSAGE_ADDRESS = \"Address\";\n\n    public static final String XBUSXMLMESSAGE_TIMESTAMP = \"Timestamp\";\n\n    public static final String XBUSXMLMESSAGE_RETURNCODE = \"Returncode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORCODE = \"Errorcode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORTEXT = \"Errortext\";\n\n    public static final String LINE_SEPERATOR = System.getProperty(\"line.separator\");\n\n    public static final byte NEWLINE = 10;\n\n    public static final byte CARRIAGE_RETURN = 13;\n\n    /**\n     * <code>getLineSeperator</code> returns the line break representation for\n     * a specified platform.\n     *\n     * @param platform\n     *            the platform, for which the line break is needed\n     */\n    public static String getLineSeperator(String platform) throws XException {\n        String result = null;\n        if (platform.equals(\"Unix\"))\n            result = \"\\n\";\n        else if (platform.equals(\"Windows\"))\n            result = \"\\r\\n\";\n        else {\n            List params = new Vector();\n            params.add(platform);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"20\", params);\n        }\n        // else\n        return result;\n    }\n\n    // getLineSeperator(String platform)\n    public static final String FILE_SEPERATOR = File.separator;\n\n    public static final String XBUS_HOME = System.getProperty(\"xbus.home\");\n\n    public static final String XBUS_ETC = XBUS_HOME + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String XBUS_LOG = XBUS_HOME + FILE_SEPERATOR + \"log\" + FILE_SEPERATOR;\n\n    public static final String XBUS_PLUGIN_ETC = XBUS_HOME + FILE_SEPERATOR + \"plugin\" + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss,SSS\";\n\n    public static final String FILE_NAME_DATE_FORMAT = \".yyyyMMddHHmmssSSS\";\n\n    public static final String AS400_DATE_FORMAT = \"yyyyMMdd\";\n\n    // must be up to 10 characters long\n    public static final String AS400_CALL_DATE_FORMAT = \"ddMMyyyy\";\n\n    private static SimpleDateFormat dateFormat = null;\n\n    /**\n     * Constructs and gets a SimpleDateFormat using the default pattern using\n     * the given {@link #DATE_FORMAT}\n     *\n     * @return SimpleDateFormat\n     */\n    public static final SimpleDateFormat getDateFormat() {\n        if (dateFormat == null) {\n            dateFormat = new SimpleDateFormat(Constants.DATE_FORMAT);\n        }\n        return dateFormat;\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #FILE_NAME_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String\n     */\n    public static final String getDateAsString() {\n        return new SimpleDateFormat(Constants.FILE_NAME_DATE_FORMAT).format(new Date());\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #AS400_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String must be up to 10 characters long\n     */\n    public static final String getAS400DateFormat() {\n        return new SimpleDateFormat(Constants.AS400_DATE_FORMAT).format(new Date());\n    }\n\n    public static final String QUEUE_DUMP_DELIMITER = \"|||||nextMessage|||||\";\n\n    // Configuration\n    public static final String CHAPTER_SYSTEM = \"System\";\n\n    public static final String CHAPTER_BASE = \"Base\";\n\n    public static final String KEY_FILENAME = \"Filename\";\n\n    public static final String KEY_SEND_RESOL = \"ConflictResolution\";\n\n    public static final String KEY_ENCODING = \"Encoding\";\n\n    public static final String KEY_RECEIVE_RESOL = \"FinalResolution\";\n\n    public static final String KEY_CSV_HAS_HEADER = \"HasHeader\";\n\n    public static final String KEY_CSV_QUOTE_CHAR = \"QuoteChar\";\n\n    public static final String KEY_CSV_FIELD_SEPARATOR = \"FieldSeparator\";\n\n    public static final String KEY_CSV_ALWAYS_QUOTE = \"AlwaysQuote\";\n\n    public static final String KEY_CSV_DESCRIPTION_FILE = \"DescriptionFile\";\n\n    // FileSender\n    public static final String SYS_ENCODING = System.getProperty(\"file.encoding\");\n\n    public static final String WRITE_APPEND = \"Append\";\n\n    public static final String WRITE_OVERWRITE = \"Overwrite\";\n\n    public static final String WRITE_ERROR = \"Error\";\n\n    public static final String WRITE_RENAME = \"Rename\";\n\n    public static final int BLKSIZ = 32768;\n\n    public static final String TEMP_SUFFIX = \"xTmp\";\n\n    public static final String BACKUP_SUFFIX = \".save\";\n\n    // FileReceiver\n    public static final String READ_PRESERVE = \"Preserve\";\n\n    public static final String READ_RENAME = \"Rename\";\n\n    public static final String READ_DELETE = \"Delete\";\n\n    public static final String READ_DELETEFILE = \"DeleteFile\";\n\n    public static final String READ_DELETEMEMBER = \"DeleteMember\";\n\n    public static final String READ_CALLPROGRAM = \"CallProgram\";\n\n    public static final String RENAME_SUFFIX = \".back\";\n\n    public static final String READ_ERROR = \"Error\";\n\n    public static final String READ_IGNORE = \"Ignore\";\n\n    public static final String READ_PROCESS = \"Process\";\n\n    // XException - Location\n    public static final String LOCATION_INTERN = \"I\";\n\n    public static final String LOCATION_EXTERN = \"E\";\n\n    // XException - Layer\n    public static final String LAYER_COREBASE = \"00\";\n\n    public static final String LAYER_TECHNICAL = \"01\";\n\n    public static final String LAYER_PROTOCOL = \"02\";\n\n    public static final String LAYER_APPLICATION = \"03\";\n\n    public static final String LAYER_BASE = \"04\";\n\n    public static final String LAYER_ADMIN = \"05\";\n\n    public static final String LAYER_BOOTSTRAP = \"06\";\n\n    // XException - Technical Package\n    public static final String PACKAGE_TECHNICAL_TECHNICAL = \"000\";\n\n    public static final String PACKAGE_TECHNICAL_FILE = \"001\";\n\n    public static final String PACKAGE_TECHNICAL_AS400 = \"002\";\n\n    public static final String PACKAGE_TECHNICAL_DATABASE = \"003\";\n\n    public static final String PACKAGE_TECHNICAL_HTTP = \"004\";\n\n    public static final String PACKAGE_TECHNICAL_MQ = \"005\";\n\n    public static final String PACKAGE_TECHNICAL_JAVA = \"006\";\n\n    public static final String PACKAGE_TECHNICAL_MAIL = \"007\";\n\n    public static final String PACKAGE_TECHNICAL_SOCKET = \"008\";\n\n    public static final String PACKAGE_TECHNICAL_MISC = \"009\";\n\n    public static final String PACKAGE_TECHNICAL_FTP = \"010\";\n\n    public static final String PACKAGE_TECHNICAL_LDAP = \"011\";\n\n    // XException - Protocol Package\n    public static final String PACKAGE_PROTOCOL_PROTOCOL = \"000\";\n\n    public static final String PACKAGE_PROTOCOL_AS400 = \"001\";\n\n    public static final String PACKAGE_PROTOCOL_BYTEARRAYLIST = \"002\";\n\n    public static final String PACKAGE_PROTOCOL_RECORDS = \"003\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLEOBJECT = \"004\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLETEXT = \"005\";\n\n    public static final String PACKAGE_PROTOCOL_SOAP = \"006\";\n\n    public static final String PACKAGE_PROTOCOL_XML = \"007\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLE = \"008\";\n\n    public static final String PACKAGE_PROTOCOL_CSV = \"009\";\n\n    // XException - Application Package\n    public static final String PACKAGE_APPLICATION_ROUTER = \"001\";\n\n    public static final String PACKAGE_APPLICATION_ADAPTER = \"002\";\n\n    public static final String PACKAGE_APPLICATION_APPLICATIONFACTORY = \"003\";\n\n    // XException - Base Package\n    public static final String PACKAGE_BASE_NOTIFYERROR = \"001\";\n\n    public static final String PACKAGE_BASE_JOURNAL = \"002\";\n\n    public static final String PACKAGE_BASE_XBUSSYSTEM = \"003\";\n\n    public static final String PACKAGE_BASE_DELETEDMESSAGESTORE = \"004\";\n\n    // XException - Admin Package\n    public static final String PACKAGE_ADMIN_ADMIN = \"000\";\n\n    public static final String PACKAGE_ADMIN_JMX = \"001\";\n\n    public static final String PACKAGE_ADMIN_HTML = \"002\";\n\n    public static final String PACKAGE_ADMIN_SOAP = \"003\";\n\n    // XException - Core Base Package\n    public static final String PACKAGE_COREBASE_COREBASE = \"000\";\n\n    public static final String PACKAGE_COREBASE_CONFIG = \"001\";\n\n    public static final String PACKAGE_COREBASE_TRACE = \"002\";\n\n    public static final String PACKAGE_COREBASE_TIMEOUTCALL = \"003\";\n\n    public static final String PACKAGE_COREBASE_XML = \"004\";\n\n    public static final String PACKAGE_COREBASE_STRINGS = \"005\";\n\n    public static final String PACKAGE_COREBASE_ARITHMETIC = \"006\";\n\n    public static final String PACKAGE_COREBASE_REFLECTION = \"007\";\n\n    public static final String PACKAGE_COREBASE_BYTEARRAYS = \"008\";\n\n    // XException - Bootstrap Package\n    public static final String PACKAGE_BOOTSTRAP_BOOTSTRAP = \"000\";\n\n    // XException for Examples\n    public static final String LAYER_SAMPLE = \"99\";\n\n    public static final String PACKAGE_SAMPLE_SAMPLE = \"888\";\n\n    // XException for TestDriver\n    public static final String LAYER_TESTDRIVER = \"99\";\n\n    public static final String PACKAGE_TESTDRIVER_TESTDRIVER = \"999\";\n\n    public static final String POSTPROCESSING_PERSYSTEM = \"perSystem\";\n\n    public static final String POSTPROCESSING_FINAL = \"final\";\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/ConstantsTest2.java",
		"test_prompt": "// ConstantsTest2.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Constants}.\n* It contains ten unit test cases for the {@link Constants#getDateFormat()} method.\n*/\nclass ConstantsTest2 {"
	},
	{
		"original_code": "// Constants.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Definition of various constants, used by all classes.\n */\npublic class Constants {\n\n    /**\n     * Reads the encoding for XML data in the configuration and returns it. When\n     * no encoding is found, the value UTF-8 is returned.\n     *\n     * @return encoding for XML data\n     * @throws XException\n     *             when something goes wrong\n     */\n    public static final String getXMLEncoding() throws XException {\n        String encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"XML\", \"Encoding\");\n        if (encoding != null) {\n            return encoding;\n        } else {\n            encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"Encoding\", \"XML\");\n            if (encoding != null) {\n                return encoding;\n            } else {\n                return \"UTF-8\";\n            }\n        }\n    }\n\n    public static final String RC_OK = \"RC_OK\";\n\n    public static final String RC_NOK = \"RC_NOK\";\n\n    public static final String CONFIGURATION_TRUE = \"true\";\n\n    public static final String CONFIGURATION_FALSE = \"false\";\n\n    public static final String TYPE_TEXT = \"Text\";\n\n    public static final String TYPE_OBJECT = \"Object\";\n\n    public static final String TYPE_BINARY = \"Binary\";\n\n    public static final String TYPE_XML = \"XML\";\n\n    public static final int IFCONTENTCLASS_BYTEARRAYLIST = 0;\n\n    public static final int IFCONTENTCLASS_STRING = 1;\n\n    public static final String XBUSXMLMESSAGE_DOCUMENT = \"XBUS_Document\";\n\n    public static final String XBUSXMLMESSAGE_CALL = \"XBUS_Call\";\n\n    public static final String XBUSXMLMESSAGE_DATA = \"XBUS_Data\";\n\n    public static final String XBUSXMLMESSAGE_ID = \"Id\";\n\n    public static final String XBUSXMLMESSAGE_FUNCTION = \"Function\";\n\n    public static final String XBUSXMLMESSAGE_SOURCE = \"Source\";\n\n    public static final String XBUSXMLMESSAGE_ADDRESS = \"Address\";\n\n    public static final String XBUSXMLMESSAGE_TIMESTAMP = \"Timestamp\";\n\n    public static final String XBUSXMLMESSAGE_RETURNCODE = \"Returncode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORCODE = \"Errorcode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORTEXT = \"Errortext\";\n\n    public static final String LINE_SEPERATOR = System.getProperty(\"line.separator\");\n\n    public static final byte NEWLINE = 10;\n\n    public static final byte CARRIAGE_RETURN = 13;\n\n    /**\n     * <code>getLineSeperator</code> returns the line break representation for\n     * a specified platform.\n     *\n     * @param platform\n     *            the platform, for which the line break is needed\n     */\n    public static String getLineSeperator(String platform) throws XException {\n        String result = null;\n        if (platform.equals(\"Unix\"))\n            result = \"\\n\";\n        else if (platform.equals(\"Windows\"))\n            result = \"\\r\\n\";\n        else {\n            List params = new Vector();\n            params.add(platform);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"20\", params);\n        }\n        // else\n        return result;\n    }\n\n    // getLineSeperator(String platform)\n    public static final String FILE_SEPERATOR = File.separator;\n\n    public static final String XBUS_HOME = System.getProperty(\"xbus.home\");\n\n    public static final String XBUS_ETC = XBUS_HOME + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String XBUS_LOG = XBUS_HOME + FILE_SEPERATOR + \"log\" + FILE_SEPERATOR;\n\n    public static final String XBUS_PLUGIN_ETC = XBUS_HOME + FILE_SEPERATOR + \"plugin\" + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss,SSS\";\n\n    public static final String FILE_NAME_DATE_FORMAT = \".yyyyMMddHHmmssSSS\";\n\n    public static final String AS400_DATE_FORMAT = \"yyyyMMdd\";\n\n    // must be up to 10 characters long\n    public static final String AS400_CALL_DATE_FORMAT = \"ddMMyyyy\";\n\n    private static SimpleDateFormat dateFormat = null;\n\n    /**\n     * Constructs and gets a SimpleDateFormat using the default pattern using\n     * the given {@link #DATE_FORMAT}\n     *\n     * @return SimpleDateFormat\n     */\n    public static final SimpleDateFormat getDateFormat() {\n        if (dateFormat == null) {\n            dateFormat = new SimpleDateFormat(Constants.DATE_FORMAT);\n        }\n        return dateFormat;\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #FILE_NAME_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String\n     */\n    public static final String getDateAsString() {\n        return new SimpleDateFormat(Constants.FILE_NAME_DATE_FORMAT).format(new Date());\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #AS400_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String must be up to 10 characters long\n     */\n    public static final String getAS400DateFormat() {\n        return new SimpleDateFormat(Constants.AS400_DATE_FORMAT).format(new Date());\n    }\n\n    public static final String QUEUE_DUMP_DELIMITER = \"|||||nextMessage|||||\";\n\n    // Configuration\n    public static final String CHAPTER_SYSTEM = \"System\";\n\n    public static final String CHAPTER_BASE = \"Base\";\n\n    public static final String KEY_FILENAME = \"Filename\";\n\n    public static final String KEY_SEND_RESOL = \"ConflictResolution\";\n\n    public static final String KEY_ENCODING = \"Encoding\";\n\n    public static final String KEY_RECEIVE_RESOL = \"FinalResolution\";\n\n    public static final String KEY_CSV_HAS_HEADER = \"HasHeader\";\n\n    public static final String KEY_CSV_QUOTE_CHAR = \"QuoteChar\";\n\n    public static final String KEY_CSV_FIELD_SEPARATOR = \"FieldSeparator\";\n\n    public static final String KEY_CSV_ALWAYS_QUOTE = \"AlwaysQuote\";\n\n    public static final String KEY_CSV_DESCRIPTION_FILE = \"DescriptionFile\";\n\n    // FileSender\n    public static final String SYS_ENCODING = System.getProperty(\"file.encoding\");\n\n    public static final String WRITE_APPEND = \"Append\";\n\n    public static final String WRITE_OVERWRITE = \"Overwrite\";\n\n    public static final String WRITE_ERROR = \"Error\";\n\n    public static final String WRITE_RENAME = \"Rename\";\n\n    public static final int BLKSIZ = 32768;\n\n    public static final String TEMP_SUFFIX = \"xTmp\";\n\n    public static final String BACKUP_SUFFIX = \".save\";\n\n    // FileReceiver\n    public static final String READ_PRESERVE = \"Preserve\";\n\n    public static final String READ_RENAME = \"Rename\";\n\n    public static final String READ_DELETE = \"Delete\";\n\n    public static final String READ_DELETEFILE = \"DeleteFile\";\n\n    public static final String READ_DELETEMEMBER = \"DeleteMember\";\n\n    public static final String READ_CALLPROGRAM = \"CallProgram\";\n\n    public static final String RENAME_SUFFIX = \".back\";\n\n    public static final String READ_ERROR = \"Error\";\n\n    public static final String READ_IGNORE = \"Ignore\";\n\n    public static final String READ_PROCESS = \"Process\";\n\n    // XException - Location\n    public static final String LOCATION_INTERN = \"I\";\n\n    public static final String LOCATION_EXTERN = \"E\";\n\n    // XException - Layer\n    public static final String LAYER_COREBASE = \"00\";\n\n    public static final String LAYER_TECHNICAL = \"01\";\n\n    public static final String LAYER_PROTOCOL = \"02\";\n\n    public static final String LAYER_APPLICATION = \"03\";\n\n    public static final String LAYER_BASE = \"04\";\n\n    public static final String LAYER_ADMIN = \"05\";\n\n    public static final String LAYER_BOOTSTRAP = \"06\";\n\n    // XException - Technical Package\n    public static final String PACKAGE_TECHNICAL_TECHNICAL = \"000\";\n\n    public static final String PACKAGE_TECHNICAL_FILE = \"001\";\n\n    public static final String PACKAGE_TECHNICAL_AS400 = \"002\";\n\n    public static final String PACKAGE_TECHNICAL_DATABASE = \"003\";\n\n    public static final String PACKAGE_TECHNICAL_HTTP = \"004\";\n\n    public static final String PACKAGE_TECHNICAL_MQ = \"005\";\n\n    public static final String PACKAGE_TECHNICAL_JAVA = \"006\";\n\n    public static final String PACKAGE_TECHNICAL_MAIL = \"007\";\n\n    public static final String PACKAGE_TECHNICAL_SOCKET = \"008\";\n\n    public static final String PACKAGE_TECHNICAL_MISC = \"009\";\n\n    public static final String PACKAGE_TECHNICAL_FTP = \"010\";\n\n    public static final String PACKAGE_TECHNICAL_LDAP = \"011\";\n\n    // XException - Protocol Package\n    public static final String PACKAGE_PROTOCOL_PROTOCOL = \"000\";\n\n    public static final String PACKAGE_PROTOCOL_AS400 = \"001\";\n\n    public static final String PACKAGE_PROTOCOL_BYTEARRAYLIST = \"002\";\n\n    public static final String PACKAGE_PROTOCOL_RECORDS = \"003\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLEOBJECT = \"004\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLETEXT = \"005\";\n\n    public static final String PACKAGE_PROTOCOL_SOAP = \"006\";\n\n    public static final String PACKAGE_PROTOCOL_XML = \"007\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLE = \"008\";\n\n    public static final String PACKAGE_PROTOCOL_CSV = \"009\";\n\n    // XException - Application Package\n    public static final String PACKAGE_APPLICATION_ROUTER = \"001\";\n\n    public static final String PACKAGE_APPLICATION_ADAPTER = \"002\";\n\n    public static final String PACKAGE_APPLICATION_APPLICATIONFACTORY = \"003\";\n\n    // XException - Base Package\n    public static final String PACKAGE_BASE_NOTIFYERROR = \"001\";\n\n    public static final String PACKAGE_BASE_JOURNAL = \"002\";\n\n    public static final String PACKAGE_BASE_XBUSSYSTEM = \"003\";\n\n    public static final String PACKAGE_BASE_DELETEDMESSAGESTORE = \"004\";\n\n    // XException - Admin Package\n    public static final String PACKAGE_ADMIN_ADMIN = \"000\";\n\n    public static final String PACKAGE_ADMIN_JMX = \"001\";\n\n    public static final String PACKAGE_ADMIN_HTML = \"002\";\n\n    public static final String PACKAGE_ADMIN_SOAP = \"003\";\n\n    // XException - Core Base Package\n    public static final String PACKAGE_COREBASE_COREBASE = \"000\";\n\n    public static final String PACKAGE_COREBASE_CONFIG = \"001\";\n\n    public static final String PACKAGE_COREBASE_TRACE = \"002\";\n\n    public static final String PACKAGE_COREBASE_TIMEOUTCALL = \"003\";\n\n    public static final String PACKAGE_COREBASE_XML = \"004\";\n\n    public static final String PACKAGE_COREBASE_STRINGS = \"005\";\n\n    public static final String PACKAGE_COREBASE_ARITHMETIC = \"006\";\n\n    public static final String PACKAGE_COREBASE_REFLECTION = \"007\";\n\n    public static final String PACKAGE_COREBASE_BYTEARRAYS = \"008\";\n\n    // XException - Bootstrap Package\n    public static final String PACKAGE_BOOTSTRAP_BOOTSTRAP = \"000\";\n\n    // XException for Examples\n    public static final String LAYER_SAMPLE = \"99\";\n\n    public static final String PACKAGE_SAMPLE_SAMPLE = \"888\";\n\n    // XException for TestDriver\n    public static final String LAYER_TESTDRIVER = \"99\";\n\n    public static final String PACKAGE_TESTDRIVER_TESTDRIVER = \"999\";\n\n    public static final String POSTPROCESSING_PERSYSTEM = \"perSystem\";\n\n    public static final String POSTPROCESSING_FINAL = \"final\";\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/ConstantsTest3.java",
		"test_prompt": "// ConstantsTest3.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Constants}.\n* It contains ten unit test cases for the {@link Constants#getDateAsString()} method.\n*/\nclass ConstantsTest3 {"
	},
	{
		"original_code": "// Constants.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Definition of various constants, used by all classes.\n */\npublic class Constants {\n\n    /**\n     * Reads the encoding for XML data in the configuration and returns it. When\n     * no encoding is found, the value UTF-8 is returned.\n     *\n     * @return encoding for XML data\n     * @throws XException\n     *             when something goes wrong\n     */\n    public static final String getXMLEncoding() throws XException {\n        String encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"XML\", \"Encoding\");\n        if (encoding != null) {\n            return encoding;\n        } else {\n            encoding = Configuration.getInstance().getValueOptional(CHAPTER_BASE, \"Encoding\", \"XML\");\n            if (encoding != null) {\n                return encoding;\n            } else {\n                return \"UTF-8\";\n            }\n        }\n    }\n\n    public static final String RC_OK = \"RC_OK\";\n\n    public static final String RC_NOK = \"RC_NOK\";\n\n    public static final String CONFIGURATION_TRUE = \"true\";\n\n    public static final String CONFIGURATION_FALSE = \"false\";\n\n    public static final String TYPE_TEXT = \"Text\";\n\n    public static final String TYPE_OBJECT = \"Object\";\n\n    public static final String TYPE_BINARY = \"Binary\";\n\n    public static final String TYPE_XML = \"XML\";\n\n    public static final int IFCONTENTCLASS_BYTEARRAYLIST = 0;\n\n    public static final int IFCONTENTCLASS_STRING = 1;\n\n    public static final String XBUSXMLMESSAGE_DOCUMENT = \"XBUS_Document\";\n\n    public static final String XBUSXMLMESSAGE_CALL = \"XBUS_Call\";\n\n    public static final String XBUSXMLMESSAGE_DATA = \"XBUS_Data\";\n\n    public static final String XBUSXMLMESSAGE_ID = \"Id\";\n\n    public static final String XBUSXMLMESSAGE_FUNCTION = \"Function\";\n\n    public static final String XBUSXMLMESSAGE_SOURCE = \"Source\";\n\n    public static final String XBUSXMLMESSAGE_ADDRESS = \"Address\";\n\n    public static final String XBUSXMLMESSAGE_TIMESTAMP = \"Timestamp\";\n\n    public static final String XBUSXMLMESSAGE_RETURNCODE = \"Returncode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORCODE = \"Errorcode\";\n\n    public static final String XBUSXMLMESSAGE_ERRORTEXT = \"Errortext\";\n\n    public static final String LINE_SEPERATOR = System.getProperty(\"line.separator\");\n\n    public static final byte NEWLINE = 10;\n\n    public static final byte CARRIAGE_RETURN = 13;\n\n    /**\n     * <code>getLineSeperator</code> returns the line break representation for\n     * a specified platform.\n     *\n     * @param platform\n     *            the platform, for which the line break is needed\n     */\n    public static String getLineSeperator(String platform) throws XException {\n        String result = null;\n        if (platform.equals(\"Unix\"))\n            result = \"\\n\";\n        else if (platform.equals(\"Windows\"))\n            result = \"\\r\\n\";\n        else {\n            List params = new Vector();\n            params.add(platform);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_COREBASE, \"20\", params);\n        }\n        // else\n        return result;\n    }\n\n    // getLineSeperator(String platform)\n    public static final String FILE_SEPERATOR = File.separator;\n\n    public static final String XBUS_HOME = System.getProperty(\"xbus.home\");\n\n    public static final String XBUS_ETC = XBUS_HOME + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String XBUS_LOG = XBUS_HOME + FILE_SEPERATOR + \"log\" + FILE_SEPERATOR;\n\n    public static final String XBUS_PLUGIN_ETC = XBUS_HOME + FILE_SEPERATOR + \"plugin\" + FILE_SEPERATOR + \"etc\" + FILE_SEPERATOR;\n\n    public static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss,SSS\";\n\n    public static final String FILE_NAME_DATE_FORMAT = \".yyyyMMddHHmmssSSS\";\n\n    public static final String AS400_DATE_FORMAT = \"yyyyMMdd\";\n\n    // must be up to 10 characters long\n    public static final String AS400_CALL_DATE_FORMAT = \"ddMMyyyy\";\n\n    private static SimpleDateFormat dateFormat = null;\n\n    /**\n     * Constructs and gets a SimpleDateFormat using the default pattern using\n     * the given {@link #DATE_FORMAT}\n     *\n     * @return SimpleDateFormat\n     */\n    public static final SimpleDateFormat getDateFormat() {\n        if (dateFormat == null) {\n            dateFormat = new SimpleDateFormat(Constants.DATE_FORMAT);\n        }\n        return dateFormat;\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #FILE_NAME_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String\n     */\n    public static final String getDateAsString() {\n        return new SimpleDateFormat(Constants.FILE_NAME_DATE_FORMAT).format(new Date());\n    }\n\n    /**\n     * Constructs a SimpleDateFormat using the default pattern using the given\n     * {@link #AS400_DATE_FORMAT} and gets it into a String\n     *\n     * @return act.Date as String must be up to 10 characters long\n     */\n    public static final String getAS400DateFormat() {\n        return new SimpleDateFormat(Constants.AS400_DATE_FORMAT).format(new Date());\n    }\n\n    public static final String QUEUE_DUMP_DELIMITER = \"|||||nextMessage|||||\";\n\n    // Configuration\n    public static final String CHAPTER_SYSTEM = \"System\";\n\n    public static final String CHAPTER_BASE = \"Base\";\n\n    public static final String KEY_FILENAME = \"Filename\";\n\n    public static final String KEY_SEND_RESOL = \"ConflictResolution\";\n\n    public static final String KEY_ENCODING = \"Encoding\";\n\n    public static final String KEY_RECEIVE_RESOL = \"FinalResolution\";\n\n    public static final String KEY_CSV_HAS_HEADER = \"HasHeader\";\n\n    public static final String KEY_CSV_QUOTE_CHAR = \"QuoteChar\";\n\n    public static final String KEY_CSV_FIELD_SEPARATOR = \"FieldSeparator\";\n\n    public static final String KEY_CSV_ALWAYS_QUOTE = \"AlwaysQuote\";\n\n    public static final String KEY_CSV_DESCRIPTION_FILE = \"DescriptionFile\";\n\n    // FileSender\n    public static final String SYS_ENCODING = System.getProperty(\"file.encoding\");\n\n    public static final String WRITE_APPEND = \"Append\";\n\n    public static final String WRITE_OVERWRITE = \"Overwrite\";\n\n    public static final String WRITE_ERROR = \"Error\";\n\n    public static final String WRITE_RENAME = \"Rename\";\n\n    public static final int BLKSIZ = 32768;\n\n    public static final String TEMP_SUFFIX = \"xTmp\";\n\n    public static final String BACKUP_SUFFIX = \".save\";\n\n    // FileReceiver\n    public static final String READ_PRESERVE = \"Preserve\";\n\n    public static final String READ_RENAME = \"Rename\";\n\n    public static final String READ_DELETE = \"Delete\";\n\n    public static final String READ_DELETEFILE = \"DeleteFile\";\n\n    public static final String READ_DELETEMEMBER = \"DeleteMember\";\n\n    public static final String READ_CALLPROGRAM = \"CallProgram\";\n\n    public static final String RENAME_SUFFIX = \".back\";\n\n    public static final String READ_ERROR = \"Error\";\n\n    public static final String READ_IGNORE = \"Ignore\";\n\n    public static final String READ_PROCESS = \"Process\";\n\n    // XException - Location\n    public static final String LOCATION_INTERN = \"I\";\n\n    public static final String LOCATION_EXTERN = \"E\";\n\n    // XException - Layer\n    public static final String LAYER_COREBASE = \"00\";\n\n    public static final String LAYER_TECHNICAL = \"01\";\n\n    public static final String LAYER_PROTOCOL = \"02\";\n\n    public static final String LAYER_APPLICATION = \"03\";\n\n    public static final String LAYER_BASE = \"04\";\n\n    public static final String LAYER_ADMIN = \"05\";\n\n    public static final String LAYER_BOOTSTRAP = \"06\";\n\n    // XException - Technical Package\n    public static final String PACKAGE_TECHNICAL_TECHNICAL = \"000\";\n\n    public static final String PACKAGE_TECHNICAL_FILE = \"001\";\n\n    public static final String PACKAGE_TECHNICAL_AS400 = \"002\";\n\n    public static final String PACKAGE_TECHNICAL_DATABASE = \"003\";\n\n    public static final String PACKAGE_TECHNICAL_HTTP = \"004\";\n\n    public static final String PACKAGE_TECHNICAL_MQ = \"005\";\n\n    public static final String PACKAGE_TECHNICAL_JAVA = \"006\";\n\n    public static final String PACKAGE_TECHNICAL_MAIL = \"007\";\n\n    public static final String PACKAGE_TECHNICAL_SOCKET = \"008\";\n\n    public static final String PACKAGE_TECHNICAL_MISC = \"009\";\n\n    public static final String PACKAGE_TECHNICAL_FTP = \"010\";\n\n    public static final String PACKAGE_TECHNICAL_LDAP = \"011\";\n\n    // XException - Protocol Package\n    public static final String PACKAGE_PROTOCOL_PROTOCOL = \"000\";\n\n    public static final String PACKAGE_PROTOCOL_AS400 = \"001\";\n\n    public static final String PACKAGE_PROTOCOL_BYTEARRAYLIST = \"002\";\n\n    public static final String PACKAGE_PROTOCOL_RECORDS = \"003\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLEOBJECT = \"004\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLETEXT = \"005\";\n\n    public static final String PACKAGE_PROTOCOL_SOAP = \"006\";\n\n    public static final String PACKAGE_PROTOCOL_XML = \"007\";\n\n    public static final String PACKAGE_PROTOCOL_SIMPLE = \"008\";\n\n    public static final String PACKAGE_PROTOCOL_CSV = \"009\";\n\n    // XException - Application Package\n    public static final String PACKAGE_APPLICATION_ROUTER = \"001\";\n\n    public static final String PACKAGE_APPLICATION_ADAPTER = \"002\";\n\n    public static final String PACKAGE_APPLICATION_APPLICATIONFACTORY = \"003\";\n\n    // XException - Base Package\n    public static final String PACKAGE_BASE_NOTIFYERROR = \"001\";\n\n    public static final String PACKAGE_BASE_JOURNAL = \"002\";\n\n    public static final String PACKAGE_BASE_XBUSSYSTEM = \"003\";\n\n    public static final String PACKAGE_BASE_DELETEDMESSAGESTORE = \"004\";\n\n    // XException - Admin Package\n    public static final String PACKAGE_ADMIN_ADMIN = \"000\";\n\n    public static final String PACKAGE_ADMIN_JMX = \"001\";\n\n    public static final String PACKAGE_ADMIN_HTML = \"002\";\n\n    public static final String PACKAGE_ADMIN_SOAP = \"003\";\n\n    // XException - Core Base Package\n    public static final String PACKAGE_COREBASE_COREBASE = \"000\";\n\n    public static final String PACKAGE_COREBASE_CONFIG = \"001\";\n\n    public static final String PACKAGE_COREBASE_TRACE = \"002\";\n\n    public static final String PACKAGE_COREBASE_TIMEOUTCALL = \"003\";\n\n    public static final String PACKAGE_COREBASE_XML = \"004\";\n\n    public static final String PACKAGE_COREBASE_STRINGS = \"005\";\n\n    public static final String PACKAGE_COREBASE_ARITHMETIC = \"006\";\n\n    public static final String PACKAGE_COREBASE_REFLECTION = \"007\";\n\n    public static final String PACKAGE_COREBASE_BYTEARRAYS = \"008\";\n\n    // XException - Bootstrap Package\n    public static final String PACKAGE_BOOTSTRAP_BOOTSTRAP = \"000\";\n\n    // XException for Examples\n    public static final String LAYER_SAMPLE = \"99\";\n\n    public static final String PACKAGE_SAMPLE_SAMPLE = \"888\";\n\n    // XException for TestDriver\n    public static final String LAYER_TESTDRIVER = \"99\";\n\n    public static final String PACKAGE_TESTDRIVER_TESTDRIVER = \"999\";\n\n    public static final String POSTPROCESSING_PERSYSTEM = \"perSystem\";\n\n    public static final String POSTPROCESSING_FINAL = \"final\";\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/ConstantsTest4.java",
		"test_prompt": "// ConstantsTest4.java\npackage net.sf.xbus.base.core;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Constants}.\n* It contains ten unit test cases for the {@link Constants#getAS400DateFormat()} method.\n*/\nclass ConstantsTest4 {"
	},
	{
		"original_code": "// ReflectionSupport.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>ReflectionSupport</code> provides methods to create objects and call\n * methods with the reflection API more easy.\n */\npublic class ReflectionSupport {\n\n    /**\n     * Create an object of the class with the given name. The class must have a\n     * constructor without parameters.\n     *\n     * @param classname fully qualified name of the class\n     * @return an object of the class with the given name\n     * @throws XException if the object cannot be created\n     */\n    static public Object createObject(String classname) throws XException {\n        Class classDefinition = classForName(classname);\n        Object retObject = null;\n        try {\n            retObject = classDefinition.newInstance();\n        } catch (InstantiationException e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(classDefinition.getName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(classDefinition.getName());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n            }\n        } catch (IllegalAccessException e) {\n            List params = new Vector();\n            params.add(classDefinition.getName());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"2\", e, params);\n        }\n        return retObject;\n    }\n\n    /**\n     * Creates an object of the class with the given name.\n     *\n     * @param classname fully qualified name of the class\n     * @param conArgsClass the parameter types for the constructor\n     * @param conArgs array of objects to be passed as arguments to the\n     *            constructor call\n     * @return a new object created by calling the constructor this object\n     *         represents\n     * @throws XException if the object cannot be created\n     */\n    static public Object createObject(String classname, Class[] conArgsClass, Object[] conArgs) throws XException {\n        Object retObject = null;\n        try {\n            Class classDefinition = classForName(classname);\n            Constructor objectConstructor = classDefinition.getConstructor(conArgsClass);\n            retObject = objectConstructor.newInstance(conArgs);\n        } catch (Exception e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(classname);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(classname);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n            }\n        }\n        return retObject;\n    }\n\n    /**\n     * Returns the <code>Class</code> object associated with the class or\n     * interface with the given string name.\n     *\n     * @param className the fully qualified name of the desired class\n     * @return the <code>Class</code> object for the class with the specified\n     *         name\n     * @throws XException if the class cannot be found\n     */\n    static public Class classForName(String className) throws XException {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        try {\n            if ((cl == null) || !(cl instanceof XBUSClassLoader)) {\n                return Class.forName(className, true, XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n            } else {\n                return Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n            }\n        } catch (ClassNotFoundException e) {\n            List params = new Vector();\n            params.add(className);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"3\", e, params);\n        }\n    }\n\n    /**\n     * Calls a method with the help of the reflection API.\n     *\n     * @param methodname the name of the method to be called\n     * @param inObject the object for which the method shall be called\n     * @param parameterTypes an array containing the classes of the parameters\n     * @param arguments an array with the parameters\n     * @return the result of the method call\n     * @throws XException if the method cannot be called\n     */\n    static public Object callMethod(String methodname, Object inObject, Class[] parameterTypes, Object[] arguments) throws XException {\n        Object retObject = null;\n        try {\n            Method method = inObject.getClass().getMethod(methodname, parameterTypes);\n            retObject = method.invoke(inObject, arguments);\n        } catch (NoSuchMethodException e) {\n            List params = new Vector();\n            params.add(inObject.getClass().getName());\n            params.add(methodname);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"4\", e, params);\n        } catch (IllegalAccessException e) {\n            List params = new Vector();\n            params.add(inObject.getClass().getName());\n            params.add(methodname);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"5\", e, params);\n        } catch (InvocationTargetException e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(inObject.getClass().getName());\n                    params.add(methodname);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"6\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(inObject.getClass().getName());\n                params.add(methodname);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"6\", e, params);\n            }\n        }\n        return retObject;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/reflection/ReflectionSupportTest0.java",
		"test_prompt": "// ReflectionSupportTest0.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReflectionSupport}.\n* It contains ten unit test cases for the {@link ReflectionSupport#createObject(String)} method.\n*/\nclass ReflectionSupportTest0 {"
	},
	{
		"original_code": "// ReflectionSupport.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>ReflectionSupport</code> provides methods to create objects and call\n * methods with the reflection API more easy.\n */\npublic class ReflectionSupport {\n\n    /**\n     * Create an object of the class with the given name. The class must have a\n     * constructor without parameters.\n     *\n     * @param classname fully qualified name of the class\n     * @return an object of the class with the given name\n     * @throws XException if the object cannot be created\n     */\n    static public Object createObject(String classname) throws XException {\n        Class classDefinition = classForName(classname);\n        Object retObject = null;\n        try {\n            retObject = classDefinition.newInstance();\n        } catch (InstantiationException e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(classDefinition.getName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(classDefinition.getName());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n            }\n        } catch (IllegalAccessException e) {\n            List params = new Vector();\n            params.add(classDefinition.getName());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"2\", e, params);\n        }\n        return retObject;\n    }\n\n    /**\n     * Creates an object of the class with the given name.\n     *\n     * @param classname fully qualified name of the class\n     * @param conArgsClass the parameter types for the constructor\n     * @param conArgs array of objects to be passed as arguments to the\n     *            constructor call\n     * @return a new object created by calling the constructor this object\n     *         represents\n     * @throws XException if the object cannot be created\n     */\n    static public Object createObject(String classname, Class[] conArgsClass, Object[] conArgs) throws XException {\n        Object retObject = null;\n        try {\n            Class classDefinition = classForName(classname);\n            Constructor objectConstructor = classDefinition.getConstructor(conArgsClass);\n            retObject = objectConstructor.newInstance(conArgs);\n        } catch (Exception e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(classname);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(classname);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n            }\n        }\n        return retObject;\n    }\n\n    /**\n     * Returns the <code>Class</code> object associated with the class or\n     * interface with the given string name.\n     *\n     * @param className the fully qualified name of the desired class\n     * @return the <code>Class</code> object for the class with the specified\n     *         name\n     * @throws XException if the class cannot be found\n     */\n    static public Class classForName(String className) throws XException {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        try {\n            if ((cl == null) || !(cl instanceof XBUSClassLoader)) {\n                return Class.forName(className, true, XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n            } else {\n                return Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n            }\n        } catch (ClassNotFoundException e) {\n            List params = new Vector();\n            params.add(className);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"3\", e, params);\n        }\n    }\n\n    /**\n     * Calls a method with the help of the reflection API.\n     *\n     * @param methodname the name of the method to be called\n     * @param inObject the object for which the method shall be called\n     * @param parameterTypes an array containing the classes of the parameters\n     * @param arguments an array with the parameters\n     * @return the result of the method call\n     * @throws XException if the method cannot be called\n     */\n    static public Object callMethod(String methodname, Object inObject, Class[] parameterTypes, Object[] arguments) throws XException {\n        Object retObject = null;\n        try {\n            Method method = inObject.getClass().getMethod(methodname, parameterTypes);\n            retObject = method.invoke(inObject, arguments);\n        } catch (NoSuchMethodException e) {\n            List params = new Vector();\n            params.add(inObject.getClass().getName());\n            params.add(methodname);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"4\", e, params);\n        } catch (IllegalAccessException e) {\n            List params = new Vector();\n            params.add(inObject.getClass().getName());\n            params.add(methodname);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"5\", e, params);\n        } catch (InvocationTargetException e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(inObject.getClass().getName());\n                    params.add(methodname);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"6\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(inObject.getClass().getName());\n                params.add(methodname);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"6\", e, params);\n            }\n        }\n        return retObject;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/reflection/ReflectionSupportTest1.java",
		"test_prompt": "// ReflectionSupportTest1.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReflectionSupport}.\n* It contains ten unit test cases for the {@link ReflectionSupport#createObject(String, Class[], Object[])} method.\n*/\nclass ReflectionSupportTest1 {"
	},
	{
		"original_code": "// ReflectionSupport.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>ReflectionSupport</code> provides methods to create objects and call\n * methods with the reflection API more easy.\n */\npublic class ReflectionSupport {\n\n    /**\n     * Create an object of the class with the given name. The class must have a\n     * constructor without parameters.\n     *\n     * @param classname fully qualified name of the class\n     * @return an object of the class with the given name\n     * @throws XException if the object cannot be created\n     */\n    static public Object createObject(String classname) throws XException {\n        Class classDefinition = classForName(classname);\n        Object retObject = null;\n        try {\n            retObject = classDefinition.newInstance();\n        } catch (InstantiationException e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(classDefinition.getName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(classDefinition.getName());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n            }\n        } catch (IllegalAccessException e) {\n            List params = new Vector();\n            params.add(classDefinition.getName());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"2\", e, params);\n        }\n        return retObject;\n    }\n\n    /**\n     * Creates an object of the class with the given name.\n     *\n     * @param classname fully qualified name of the class\n     * @param conArgsClass the parameter types for the constructor\n     * @param conArgs array of objects to be passed as arguments to the\n     *            constructor call\n     * @return a new object created by calling the constructor this object\n     *         represents\n     * @throws XException if the object cannot be created\n     */\n    static public Object createObject(String classname, Class[] conArgsClass, Object[] conArgs) throws XException {\n        Object retObject = null;\n        try {\n            Class classDefinition = classForName(classname);\n            Constructor objectConstructor = classDefinition.getConstructor(conArgsClass);\n            retObject = objectConstructor.newInstance(conArgs);\n        } catch (Exception e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(classname);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(classname);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n            }\n        }\n        return retObject;\n    }\n\n    /**\n     * Returns the <code>Class</code> object associated with the class or\n     * interface with the given string name.\n     *\n     * @param className the fully qualified name of the desired class\n     * @return the <code>Class</code> object for the class with the specified\n     *         name\n     * @throws XException if the class cannot be found\n     */\n    static public Class classForName(String className) throws XException {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        try {\n            if ((cl == null) || !(cl instanceof XBUSClassLoader)) {\n                return Class.forName(className, true, XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n            } else {\n                return Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n            }\n        } catch (ClassNotFoundException e) {\n            List params = new Vector();\n            params.add(className);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"3\", e, params);\n        }\n    }\n\n    /**\n     * Calls a method with the help of the reflection API.\n     *\n     * @param methodname the name of the method to be called\n     * @param inObject the object for which the method shall be called\n     * @param parameterTypes an array containing the classes of the parameters\n     * @param arguments an array with the parameters\n     * @return the result of the method call\n     * @throws XException if the method cannot be called\n     */\n    static public Object callMethod(String methodname, Object inObject, Class[] parameterTypes, Object[] arguments) throws XException {\n        Object retObject = null;\n        try {\n            Method method = inObject.getClass().getMethod(methodname, parameterTypes);\n            retObject = method.invoke(inObject, arguments);\n        } catch (NoSuchMethodException e) {\n            List params = new Vector();\n            params.add(inObject.getClass().getName());\n            params.add(methodname);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"4\", e, params);\n        } catch (IllegalAccessException e) {\n            List params = new Vector();\n            params.add(inObject.getClass().getName());\n            params.add(methodname);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"5\", e, params);\n        } catch (InvocationTargetException e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(inObject.getClass().getName());\n                    params.add(methodname);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"6\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(inObject.getClass().getName());\n                params.add(methodname);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"6\", e, params);\n            }\n        }\n        return retObject;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/reflection/ReflectionSupportTest2.java",
		"test_prompt": "// ReflectionSupportTest2.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReflectionSupport}.\n* It contains ten unit test cases for the {@link ReflectionSupport#classForName(String)} method.\n*/\nclass ReflectionSupportTest2 {"
	},
	{
		"original_code": "// ReflectionSupport.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\n\n/**\n * <code>ReflectionSupport</code> provides methods to create objects and call\n * methods with the reflection API more easy.\n */\npublic class ReflectionSupport {\n\n    /**\n     * Create an object of the class with the given name. The class must have a\n     * constructor without parameters.\n     *\n     * @param classname fully qualified name of the class\n     * @return an object of the class with the given name\n     * @throws XException if the object cannot be created\n     */\n    static public Object createObject(String classname) throws XException {\n        Class classDefinition = classForName(classname);\n        Object retObject = null;\n        try {\n            retObject = classDefinition.newInstance();\n        } catch (InstantiationException e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(classDefinition.getName());\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(classDefinition.getName());\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n            }\n        } catch (IllegalAccessException e) {\n            List params = new Vector();\n            params.add(classDefinition.getName());\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"2\", e, params);\n        }\n        return retObject;\n    }\n\n    /**\n     * Creates an object of the class with the given name.\n     *\n     * @param classname fully qualified name of the class\n     * @param conArgsClass the parameter types for the constructor\n     * @param conArgs array of objects to be passed as arguments to the\n     *            constructor call\n     * @return a new object created by calling the constructor this object\n     *         represents\n     * @throws XException if the object cannot be created\n     */\n    static public Object createObject(String classname, Class[] conArgsClass, Object[] conArgs) throws XException {\n        Object retObject = null;\n        try {\n            Class classDefinition = classForName(classname);\n            Constructor objectConstructor = classDefinition.getConstructor(conArgsClass);\n            retObject = objectConstructor.newInstance(conArgs);\n        } catch (Exception e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(classname);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(classname);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"1\", e, params);\n            }\n        }\n        return retObject;\n    }\n\n    /**\n     * Returns the <code>Class</code> object associated with the class or\n     * interface with the given string name.\n     *\n     * @param className the fully qualified name of the desired class\n     * @return the <code>Class</code> object for the class with the specified\n     *         name\n     * @throws XException if the class cannot be found\n     */\n    static public Class classForName(String className) throws XException {\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n        try {\n            if ((cl == null) || !(cl instanceof XBUSClassLoader)) {\n                return Class.forName(className, true, XBUSClassLoader.getInstance(Thread.currentThread().getContextClassLoader()));\n            } else {\n                return Class.forName(className, true, Thread.currentThread().getContextClassLoader());\n            }\n        } catch (ClassNotFoundException e) {\n            List params = new Vector();\n            params.add(className);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"3\", e, params);\n        }\n    }\n\n    /**\n     * Calls a method with the help of the reflection API.\n     *\n     * @param methodname the name of the method to be called\n     * @param inObject the object for which the method shall be called\n     * @param parameterTypes an array containing the classes of the parameters\n     * @param arguments an array with the parameters\n     * @return the result of the method call\n     * @throws XException if the method cannot be called\n     */\n    static public Object callMethod(String methodname, Object inObject, Class[] parameterTypes, Object[] arguments) throws XException {\n        Object retObject = null;\n        try {\n            Method method = inObject.getClass().getMethod(methodname, parameterTypes);\n            retObject = method.invoke(inObject, arguments);\n        } catch (NoSuchMethodException e) {\n            List params = new Vector();\n            params.add(inObject.getClass().getName());\n            params.add(methodname);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"4\", e, params);\n        } catch (IllegalAccessException e) {\n            List params = new Vector();\n            params.add(inObject.getClass().getName());\n            params.add(methodname);\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"5\", e, params);\n        } catch (InvocationTargetException e) {\n            if ((e.getCause() != null) && (e.getCause() instanceof XException)) {\n                /*\n\t\t\t\t * If this is an XException it has already been traced, there is\n\t\t\t\t * no need to create another XException.\n\t\t\t\t */\n                try {\n                    throw (XException) e.getCause();\n                } catch (ClassCastException e1) {\n                    /*\n\t\t\t\t\t * Sometimes it doesn't work, then we throw a XException\n\t\t\t\t\t * explicitly\n\t\t\t\t\t */\n                    List params = new Vector();\n                    params.add(inObject.getClass().getName());\n                    params.add(methodname);\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"6\", e, params);\n                }\n            } else {\n                List params = new Vector();\n                params.add(inObject.getClass().getName());\n                params.add(methodname);\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_REFLECTION, \"6\", e, params);\n            }\n        }\n        return retObject;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/reflection/ReflectionSupportTest3.java",
		"test_prompt": "// ReflectionSupportTest3.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ReflectionSupport}.\n* It contains ten unit test cases for the {@link ReflectionSupport#callMethod(String, Object, Class[], Object[])} method.\n*/\nclass ReflectionSupportTest3 {"
	},
	{
		"original_code": "// XBUSClassLoader.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.trace.Trace;\n\n/**\n * <code>XBUSClassLoader</code> manages an <code>URLClassLoader</code>, that\n * loads all jar-files under <code>XBUS_HOME/lib</code>,\n * <code>XBUS_HOME/lib/runtime</code> and <code>XBUS_HOME/plugin/lib</code>. All\n * *Bootstrap classes use this <code>URLClassLoader</code> to start the\n * functionality of the xBus. For this reason, only the library\n * <code>xbus-bootstrap.jar</code> must be in the <code>CLASSPATH</code> when\n * starting the xBus.\n */\npublic class XBUSClassLoader extends URLClassLoader {\n\n    static private XBUSClassLoader mClassLoader = null;\n\n    private static final Object classLock = XBUSClassLoader.class;\n\n    private XBUSClassLoader(URL[] urlArray, ClassLoader parent) {\n        super(urlArray, parent);\n    }\n\n    /**\n     * Returns an instance of the <code>URLClassLoader</code>, that loads all\n     * jar files under <code>XBUS_HOME/lib</code>,\n     * <code>XBUS_HOME/lib/runtime</code> and <code>XBUS_HOME/plugin/lib</code>.\n     * The first call will initialize the <code>URLClassLoader</code>.\n     *\n     * @param parent\n     *            the parent <code>ClassLoader</code>\n     * @return an <code>URLClassLoader</code> suitable for the xBus\n     */\n    static public XBUSClassLoader getInstance(ClassLoader parent) {\n        return createClassLoader(parent);\n    }\n\n    static private XBUSClassLoader createClassLoader(ClassLoader parent) {\n        synchronized (classLock) {\n            if (mClassLoader == null) {\n                /*\n\t\t\t\t * Check if XBUS_HOME is set. This is done here, because loading\n\t\t\t\t * the configuration will be the first point, where XBUS_HOME is\n\t\t\t\t * used.\n\t\t\t\t */\n                if (Constants.XBUS_HOME == null) {\n                    Trace.error(\"XBUS_HOME has not been set!\");\n                    System.exit(1);\n                }\n                Vector urls = new Vector();\n                addUrls(urls, Constants.XBUS_HOME + \"/lib\");\n                addUrls(urls, Constants.XBUS_HOME + \"/lib/runtime\");\n                addUrls(urls, Constants.XBUS_HOME + \"/plugin/lib\");\n                addUrls(urls, Constants.XBUS_HOME + \"/test/lib\");\n                URL[] urlArray = new URL[urls.size()];\n                for (int i = 0; i < urls.size(); i++) {\n                    urlArray[i] = (URL) (urls.elementAt(i));\n                }\n                mClassLoader = new XBUSClassLoader(urlArray, parent);\n            }\n        }\n        return mClassLoader;\n    }\n\n    private static void addUrls(Vector urls, String dirName) {\n        File libPath = new File(dirName);\n        File[] jars = libPath.listFiles();\n        for (int i = 0; (jars != null) && (i < jars.length); i++) {\n            if ((jars[i].isFile()) && ((jars[i].getName().endsWith(\"jar\")) || (jars[i].getName().endsWith(\"zip\")))) {\n                try {\n                    urls.add(jars[i].toURL());\n                } catch (MalformedURLException e) {\n                    Trace.error(e);\n                    System.exit(1);\n                }\n            }\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/core/reflection/XBUSClassLoaderTest.java",
		"test_prompt": "// XBUSClassLoaderTest.java\npackage net.sf.xbus.base.core.reflection;\n\nimport java.io.File;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.trace.Trace;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XBUSClassLoader}.\n* It contains ten unit test cases for the {@link XBUSClassLoader#getInstance(ClassLoader)} method.\n*/\nclass XBUSClassLoaderTest {"
	},
	{
		"original_code": "// DeletedMessageStore.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>DeletedMessageStore</code> manages the saving of messages before they\n * are deleted in case of an error.\n * <p>\n * It implements a <b>Singleton </b> pattern, where there is one instance per\n * thread.\n */\npublic class DeletedMessageStore {\n\n    private static final String SECTION = \"DeletedMessageStore\";\n\n    private static Hashtable mDeletedMessageStores = new Hashtable();\n\n    private static final Object classLock = DeletedMessageStore.class;\n\n    private Object mMessage = null;\n\n    private XBUSSystem mSystem = null;\n\n    private DeletedMessageStore() {\n        mDeletedMessageStores.put(Thread.currentThread().getName(), this);\n    }\n\n    /**\n     * Returns an instance of the <code>DeletedMessageStore</code>. A new\n     * instance will be created if there is none existing for this thread.\n     *\n     * @return an instance of the <code>DeletedMessageStore</code>\n     */\n    public static DeletedMessageStore getInstance() {\n        synchronized (classLock) {\n            DeletedMessageStore dmStore = (DeletedMessageStore) mDeletedMessageStores.get(Thread.currentThread().getName());\n            if (dmStore == null) {\n                dmStore = new DeletedMessageStore();\n            }\n            return dmStore;\n        }\n    }\n\n    /**\n     * Set the message that shall be saved. The XML file will contain the\n     * <code>String</code> representation of this object.\n     *\n     * @param message\n     *            the message to be saved\n     */\n    public void setMessage(Object message) {\n        mMessage = message;\n    }\n\n    /**\n     * Sets the system that has received the message.\n     *\n     * @param system\n     *            the receiving message\n     */\n    public void setSystem(XBUSSystem system) {\n        mSystem = system;\n    }\n\n    /**\n     * Writes the name of the system, its additional addresses and the message\n     * into a XML file. The name of the directory is read out of the\n     * configuration. The filename is\n     * <code><i>system.getCompleteName()</i>.xml.<i>timestamp</i></code>.\n     *\n     * @return true if the writing has been successful, false if there has been\n     *         a problem\n     */\n    public boolean writeMessage() {\n        try {\n            if (getEnabled(mSystem)) {\n                writeFile(buildXML(mMessage, mSystem), mSystem, getDirectory());\n            }\n            return true;\n        } catch (XException e) {\n            Trace.error(\"Problem while writing to DeletedMessageStore\");\n            return false;\n        }\n    }\n\n    /**\n     * Reads the name of all files containing deleted messages.\n     *\n     * @return an array with the name of all files containing deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String[] getDeletedMessageFilenames() throws XException {\n        File[] files = new File(getDirectory()).listFiles();\n        String[] retArray = new String[files.length];\n        for (int i = 0; i < retArray.length; i++) {\n            retArray[i] = files[i].getName();\n        }\n        return retArray;\n    }\n\n    /**\n     * Reads a deleted message and makes a new attempt to send it to its\n     * destinations.\n     *\n     * @param filename\n     *            the name of a file containing a deleted message\n     * @return a message of success or failure\n     */\n    public static String resendDeletedMessage(String filename) {\n        StringBuffer retString = new StringBuffer();\n        TAManager taManager = null;\n        Trace.info(\"Resending message from \" + filename);\n        /*\n\t\t * Reading and parsing the deleted message\n\t\t */\n        try {\n            Document messageDom = XMLHelper.parseXML(readFile(getDirectory() + Constants.FILE_SEPERATOR + filename), null, null);\n            XBUSSystem source = new XBUSSystem(messageDom.getFirstChild().getNodeName());\n            NodeList addresses = messageDom.getElementsByTagName(\"Address\");\n            Node address = null;\n            String attrName = null;\n            String addressValue = null;\n            for (int i = 0; i < addresses.getLength(); i++) {\n                address = addresses.item(i);\n                if ((attrName = XMLHelper.getAttribute(address, \"name\")) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"1\");\n                }\n                if ((addressValue = XMLHelper.getNodeText(address)) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"2\");\n                }\n                source.setAddress(attrName, addressValue);\n            }\n            NodeList data = messageDom.getElementsByTagName(\"Data\");\n            String request = null;\n            if (data.getLength() > 0) {\n                Node messageNode = messageDom.getElementsByTagName(\"Data\").item(0);\n                Node dataNode = null;\n                if ((dataNode = messageNode.getFirstChild()) != null) {\n                    request = dataNode.getNodeValue();\n                }\n            }\n            if (request == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"3\");\n            }\n            /*\n\t\t\t * Resending the message\n\t\t\t */\n            taManager = TAManager.getInstance();\n            taManager.clearManager();\n            taManager.begin();\n            Adapter adapter = new Adapter();\n            adapter.callApplication(source, request, Constants.TYPE_TEXT);\n            Object responseObject = adapter.getResponse();\n            if (Constants.RC_OK.equals(adapter.getReturncode())) {\n                taManager.commit();\n                PostProcessor.start(source, responseObject, Constants.POSTPROCESSING_PERSYSTEM);\n                Trace.info(\"End resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Message from \").append(source.getCompleteName()).append(\" successfully resent!\");\n                File messageFile = new File(getDirectory() + Constants.FILE_SEPERATOR + filename);\n                if (messageFile.delete()) {\n                    retString.append(\"<br>\");\n                    retString.append(\"File \").append(filename).append(\" has been deleted.\");\n                } else {\n                    retString.append(\"<br />\");\n                    retString.append(\"File \").append(filename).append(\" cannot be deleted.\");\n                }\n            } else {\n                taManager.rollback();\n                Trace.info(\"Error while resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Error while resending \").append(source.getCompleteName()).append(\"<br>\").append(\"Reason: \").append(adapter.getErrormessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n            }\n        } catch (Exception t) {\n            Trace.info(\"Error while resending \" + filename);\n            Trace.info(\"-----------------------------\");\n            retString.append(\"Error while resending \").append(filename).append(\"<br>\").append(\"Reason: \").append(t.getMessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n        } finally {\n            if (taManager != null) {\n                taManager.close();\n            }\n        }\n        return retString.toString();\n    }\n\n    private static boolean getEnabled(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        return config.getValueAsBooleanOptional(Constants.CHAPTER_BASE, SECTION, \"Enabled\") || config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"UseDeletedMessageStore\");\n    }\n\n    /**\n     * Reads the name of the directory of the deleted messages out of the\n     * configuration.\n     *\n     * @return the name of the directory containing the deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String getDirectory() throws XException {\n        return Configuration.getInstance().getValue(Constants.CHAPTER_BASE, SECTION, \"Directory\");\n    }\n\n    private void writeFile(String message, XBUSSystem system, String directory) throws XException {\n        String fileName = new StringBuffer(directory).append(Constants.FILE_SEPERATOR).append(system.getCompleteName()).append(Constants.getDateAsString()).append(\".xml\").toString();\n        BufferedWriter buffOut = null;\n        try {\n            buffOut = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), Constants.getXMLEncoding()));\n            buffOut.write(message);\n            buffOut.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffOut != null) {\n                try {\n                    buffOut.close();\n                } catch (IOException e1) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e1);\n                }\n            }\n        }\n    }\n\n    private String buildXML(Object message, XBUSSystem system) throws XException {\n        Document doc = XMLHelper.getDocumentBuilder(\"Default\", null).newDocument();\n        Element root = doc.createElement(XDomSupport.makeTagNameValid(system.getName()));\n        doc.appendChild(root);\n        Hashtable addresses = system.getAddresses();\n        if (!addresses.isEmpty()) {\n            Element addressesNode = doc.createElement(\"Addresses\");\n            String address = null;\n            Element addressNode = null;\n            for (Enumeration keys = addresses.keys(); keys.hasMoreElements(); ) {\n                address = (String) keys.nextElement();\n                addressNode = doc.createElement(\"Address\");\n                addressNode.setAttribute(\"name\", address);\n                addressNode.appendChild(doc.createTextNode((String) addresses.get(address)));\n                addressesNode.appendChild(addressNode);\n            }\n            root.appendChild(addressesNode);\n        }\n        Element data = doc.createElement(\"Data\");\n        data.appendChild(doc.createCDATASection(message.toString()));\n        root.appendChild(data);\n        return XMLHelper.serializeXML(doc, null);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename\n     *            the name of the file including the directory\n     * @return the content of the file\n     */\n    static private String readFile(String filename) throws XException {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        BufferedReader buffReader = null;\n        try {\n            buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffReader != null) {\n                try {\n                    buffReader.close();\n                } catch (IOException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/deletedMessageStore/DeletedMessageStoreTest0.java",
		"test_prompt": "// DeletedMessageStoreTest0.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeletedMessageStore}.\n* It contains ten unit test cases for the {@link DeletedMessageStore#getInstance()} method.\n*/\nclass DeletedMessageStoreTest0 {"
	},
	{
		"original_code": "// DeletedMessageStore.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>DeletedMessageStore</code> manages the saving of messages before they\n * are deleted in case of an error.\n * <p>\n * It implements a <b>Singleton </b> pattern, where there is one instance per\n * thread.\n */\npublic class DeletedMessageStore {\n\n    private static final String SECTION = \"DeletedMessageStore\";\n\n    private static Hashtable mDeletedMessageStores = new Hashtable();\n\n    private static final Object classLock = DeletedMessageStore.class;\n\n    private Object mMessage = null;\n\n    private XBUSSystem mSystem = null;\n\n    private DeletedMessageStore() {\n        mDeletedMessageStores.put(Thread.currentThread().getName(), this);\n    }\n\n    /**\n     * Returns an instance of the <code>DeletedMessageStore</code>. A new\n     * instance will be created if there is none existing for this thread.\n     *\n     * @return an instance of the <code>DeletedMessageStore</code>\n     */\n    public static DeletedMessageStore getInstance() {\n        synchronized (classLock) {\n            DeletedMessageStore dmStore = (DeletedMessageStore) mDeletedMessageStores.get(Thread.currentThread().getName());\n            if (dmStore == null) {\n                dmStore = new DeletedMessageStore();\n            }\n            return dmStore;\n        }\n    }\n\n    /**\n     * Set the message that shall be saved. The XML file will contain the\n     * <code>String</code> representation of this object.\n     *\n     * @param message\n     *            the message to be saved\n     */\n    public void setMessage(Object message) {\n        mMessage = message;\n    }\n\n    /**\n     * Sets the system that has received the message.\n     *\n     * @param system\n     *            the receiving message\n     */\n    public void setSystem(XBUSSystem system) {\n        mSystem = system;\n    }\n\n    /**\n     * Writes the name of the system, its additional addresses and the message\n     * into a XML file. The name of the directory is read out of the\n     * configuration. The filename is\n     * <code><i>system.getCompleteName()</i>.xml.<i>timestamp</i></code>.\n     *\n     * @return true if the writing has been successful, false if there has been\n     *         a problem\n     */\n    public boolean writeMessage() {\n        try {\n            if (getEnabled(mSystem)) {\n                writeFile(buildXML(mMessage, mSystem), mSystem, getDirectory());\n            }\n            return true;\n        } catch (XException e) {\n            Trace.error(\"Problem while writing to DeletedMessageStore\");\n            return false;\n        }\n    }\n\n    /**\n     * Reads the name of all files containing deleted messages.\n     *\n     * @return an array with the name of all files containing deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String[] getDeletedMessageFilenames() throws XException {\n        File[] files = new File(getDirectory()).listFiles();\n        String[] retArray = new String[files.length];\n        for (int i = 0; i < retArray.length; i++) {\n            retArray[i] = files[i].getName();\n        }\n        return retArray;\n    }\n\n    /**\n     * Reads a deleted message and makes a new attempt to send it to its\n     * destinations.\n     *\n     * @param filename\n     *            the name of a file containing a deleted message\n     * @return a message of success or failure\n     */\n    public static String resendDeletedMessage(String filename) {\n        StringBuffer retString = new StringBuffer();\n        TAManager taManager = null;\n        Trace.info(\"Resending message from \" + filename);\n        /*\n\t\t * Reading and parsing the deleted message\n\t\t */\n        try {\n            Document messageDom = XMLHelper.parseXML(readFile(getDirectory() + Constants.FILE_SEPERATOR + filename), null, null);\n            XBUSSystem source = new XBUSSystem(messageDom.getFirstChild().getNodeName());\n            NodeList addresses = messageDom.getElementsByTagName(\"Address\");\n            Node address = null;\n            String attrName = null;\n            String addressValue = null;\n            for (int i = 0; i < addresses.getLength(); i++) {\n                address = addresses.item(i);\n                if ((attrName = XMLHelper.getAttribute(address, \"name\")) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"1\");\n                }\n                if ((addressValue = XMLHelper.getNodeText(address)) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"2\");\n                }\n                source.setAddress(attrName, addressValue);\n            }\n            NodeList data = messageDom.getElementsByTagName(\"Data\");\n            String request = null;\n            if (data.getLength() > 0) {\n                Node messageNode = messageDom.getElementsByTagName(\"Data\").item(0);\n                Node dataNode = null;\n                if ((dataNode = messageNode.getFirstChild()) != null) {\n                    request = dataNode.getNodeValue();\n                }\n            }\n            if (request == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"3\");\n            }\n            /*\n\t\t\t * Resending the message\n\t\t\t */\n            taManager = TAManager.getInstance();\n            taManager.clearManager();\n            taManager.begin();\n            Adapter adapter = new Adapter();\n            adapter.callApplication(source, request, Constants.TYPE_TEXT);\n            Object responseObject = adapter.getResponse();\n            if (Constants.RC_OK.equals(adapter.getReturncode())) {\n                taManager.commit();\n                PostProcessor.start(source, responseObject, Constants.POSTPROCESSING_PERSYSTEM);\n                Trace.info(\"End resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Message from \").append(source.getCompleteName()).append(\" successfully resent!\");\n                File messageFile = new File(getDirectory() + Constants.FILE_SEPERATOR + filename);\n                if (messageFile.delete()) {\n                    retString.append(\"<br>\");\n                    retString.append(\"File \").append(filename).append(\" has been deleted.\");\n                } else {\n                    retString.append(\"<br />\");\n                    retString.append(\"File \").append(filename).append(\" cannot be deleted.\");\n                }\n            } else {\n                taManager.rollback();\n                Trace.info(\"Error while resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Error while resending \").append(source.getCompleteName()).append(\"<br>\").append(\"Reason: \").append(adapter.getErrormessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n            }\n        } catch (Exception t) {\n            Trace.info(\"Error while resending \" + filename);\n            Trace.info(\"-----------------------------\");\n            retString.append(\"Error while resending \").append(filename).append(\"<br>\").append(\"Reason: \").append(t.getMessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n        } finally {\n            if (taManager != null) {\n                taManager.close();\n            }\n        }\n        return retString.toString();\n    }\n\n    private static boolean getEnabled(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        return config.getValueAsBooleanOptional(Constants.CHAPTER_BASE, SECTION, \"Enabled\") || config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"UseDeletedMessageStore\");\n    }\n\n    /**\n     * Reads the name of the directory of the deleted messages out of the\n     * configuration.\n     *\n     * @return the name of the directory containing the deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String getDirectory() throws XException {\n        return Configuration.getInstance().getValue(Constants.CHAPTER_BASE, SECTION, \"Directory\");\n    }\n\n    private void writeFile(String message, XBUSSystem system, String directory) throws XException {\n        String fileName = new StringBuffer(directory).append(Constants.FILE_SEPERATOR).append(system.getCompleteName()).append(Constants.getDateAsString()).append(\".xml\").toString();\n        BufferedWriter buffOut = null;\n        try {\n            buffOut = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), Constants.getXMLEncoding()));\n            buffOut.write(message);\n            buffOut.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffOut != null) {\n                try {\n                    buffOut.close();\n                } catch (IOException e1) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e1);\n                }\n            }\n        }\n    }\n\n    private String buildXML(Object message, XBUSSystem system) throws XException {\n        Document doc = XMLHelper.getDocumentBuilder(\"Default\", null).newDocument();\n        Element root = doc.createElement(XDomSupport.makeTagNameValid(system.getName()));\n        doc.appendChild(root);\n        Hashtable addresses = system.getAddresses();\n        if (!addresses.isEmpty()) {\n            Element addressesNode = doc.createElement(\"Addresses\");\n            String address = null;\n            Element addressNode = null;\n            for (Enumeration keys = addresses.keys(); keys.hasMoreElements(); ) {\n                address = (String) keys.nextElement();\n                addressNode = doc.createElement(\"Address\");\n                addressNode.setAttribute(\"name\", address);\n                addressNode.appendChild(doc.createTextNode((String) addresses.get(address)));\n                addressesNode.appendChild(addressNode);\n            }\n            root.appendChild(addressesNode);\n        }\n        Element data = doc.createElement(\"Data\");\n        data.appendChild(doc.createCDATASection(message.toString()));\n        root.appendChild(data);\n        return XMLHelper.serializeXML(doc, null);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename\n     *            the name of the file including the directory\n     * @return the content of the file\n     */\n    static private String readFile(String filename) throws XException {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        BufferedReader buffReader = null;\n        try {\n            buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffReader != null) {\n                try {\n                    buffReader.close();\n                } catch (IOException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/deletedMessageStore/DeletedMessageStoreTest1.java",
		"test_prompt": "// DeletedMessageStoreTest1.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeletedMessageStore}.\n* It contains ten unit test cases for the {@link DeletedMessageStore#writeMessage()} method.\n*/\nclass DeletedMessageStoreTest1 {"
	},
	{
		"original_code": "// DeletedMessageStore.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>DeletedMessageStore</code> manages the saving of messages before they\n * are deleted in case of an error.\n * <p>\n * It implements a <b>Singleton </b> pattern, where there is one instance per\n * thread.\n */\npublic class DeletedMessageStore {\n\n    private static final String SECTION = \"DeletedMessageStore\";\n\n    private static Hashtable mDeletedMessageStores = new Hashtable();\n\n    private static final Object classLock = DeletedMessageStore.class;\n\n    private Object mMessage = null;\n\n    private XBUSSystem mSystem = null;\n\n    private DeletedMessageStore() {\n        mDeletedMessageStores.put(Thread.currentThread().getName(), this);\n    }\n\n    /**\n     * Returns an instance of the <code>DeletedMessageStore</code>. A new\n     * instance will be created if there is none existing for this thread.\n     *\n     * @return an instance of the <code>DeletedMessageStore</code>\n     */\n    public static DeletedMessageStore getInstance() {\n        synchronized (classLock) {\n            DeletedMessageStore dmStore = (DeletedMessageStore) mDeletedMessageStores.get(Thread.currentThread().getName());\n            if (dmStore == null) {\n                dmStore = new DeletedMessageStore();\n            }\n            return dmStore;\n        }\n    }\n\n    /**\n     * Set the message that shall be saved. The XML file will contain the\n     * <code>String</code> representation of this object.\n     *\n     * @param message\n     *            the message to be saved\n     */\n    public void setMessage(Object message) {\n        mMessage = message;\n    }\n\n    /**\n     * Sets the system that has received the message.\n     *\n     * @param system\n     *            the receiving message\n     */\n    public void setSystem(XBUSSystem system) {\n        mSystem = system;\n    }\n\n    /**\n     * Writes the name of the system, its additional addresses and the message\n     * into a XML file. The name of the directory is read out of the\n     * configuration. The filename is\n     * <code><i>system.getCompleteName()</i>.xml.<i>timestamp</i></code>.\n     *\n     * @return true if the writing has been successful, false if there has been\n     *         a problem\n     */\n    public boolean writeMessage() {\n        try {\n            if (getEnabled(mSystem)) {\n                writeFile(buildXML(mMessage, mSystem), mSystem, getDirectory());\n            }\n            return true;\n        } catch (XException e) {\n            Trace.error(\"Problem while writing to DeletedMessageStore\");\n            return false;\n        }\n    }\n\n    /**\n     * Reads the name of all files containing deleted messages.\n     *\n     * @return an array with the name of all files containing deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String[] getDeletedMessageFilenames() throws XException {\n        File[] files = new File(getDirectory()).listFiles();\n        String[] retArray = new String[files.length];\n        for (int i = 0; i < retArray.length; i++) {\n            retArray[i] = files[i].getName();\n        }\n        return retArray;\n    }\n\n    /**\n     * Reads a deleted message and makes a new attempt to send it to its\n     * destinations.\n     *\n     * @param filename\n     *            the name of a file containing a deleted message\n     * @return a message of success or failure\n     */\n    public static String resendDeletedMessage(String filename) {\n        StringBuffer retString = new StringBuffer();\n        TAManager taManager = null;\n        Trace.info(\"Resending message from \" + filename);\n        /*\n\t\t * Reading and parsing the deleted message\n\t\t */\n        try {\n            Document messageDom = XMLHelper.parseXML(readFile(getDirectory() + Constants.FILE_SEPERATOR + filename), null, null);\n            XBUSSystem source = new XBUSSystem(messageDom.getFirstChild().getNodeName());\n            NodeList addresses = messageDom.getElementsByTagName(\"Address\");\n            Node address = null;\n            String attrName = null;\n            String addressValue = null;\n            for (int i = 0; i < addresses.getLength(); i++) {\n                address = addresses.item(i);\n                if ((attrName = XMLHelper.getAttribute(address, \"name\")) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"1\");\n                }\n                if ((addressValue = XMLHelper.getNodeText(address)) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"2\");\n                }\n                source.setAddress(attrName, addressValue);\n            }\n            NodeList data = messageDom.getElementsByTagName(\"Data\");\n            String request = null;\n            if (data.getLength() > 0) {\n                Node messageNode = messageDom.getElementsByTagName(\"Data\").item(0);\n                Node dataNode = null;\n                if ((dataNode = messageNode.getFirstChild()) != null) {\n                    request = dataNode.getNodeValue();\n                }\n            }\n            if (request == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"3\");\n            }\n            /*\n\t\t\t * Resending the message\n\t\t\t */\n            taManager = TAManager.getInstance();\n            taManager.clearManager();\n            taManager.begin();\n            Adapter adapter = new Adapter();\n            adapter.callApplication(source, request, Constants.TYPE_TEXT);\n            Object responseObject = adapter.getResponse();\n            if (Constants.RC_OK.equals(adapter.getReturncode())) {\n                taManager.commit();\n                PostProcessor.start(source, responseObject, Constants.POSTPROCESSING_PERSYSTEM);\n                Trace.info(\"End resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Message from \").append(source.getCompleteName()).append(\" successfully resent!\");\n                File messageFile = new File(getDirectory() + Constants.FILE_SEPERATOR + filename);\n                if (messageFile.delete()) {\n                    retString.append(\"<br>\");\n                    retString.append(\"File \").append(filename).append(\" has been deleted.\");\n                } else {\n                    retString.append(\"<br />\");\n                    retString.append(\"File \").append(filename).append(\" cannot be deleted.\");\n                }\n            } else {\n                taManager.rollback();\n                Trace.info(\"Error while resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Error while resending \").append(source.getCompleteName()).append(\"<br>\").append(\"Reason: \").append(adapter.getErrormessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n            }\n        } catch (Exception t) {\n            Trace.info(\"Error while resending \" + filename);\n            Trace.info(\"-----------------------------\");\n            retString.append(\"Error while resending \").append(filename).append(\"<br>\").append(\"Reason: \").append(t.getMessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n        } finally {\n            if (taManager != null) {\n                taManager.close();\n            }\n        }\n        return retString.toString();\n    }\n\n    private static boolean getEnabled(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        return config.getValueAsBooleanOptional(Constants.CHAPTER_BASE, SECTION, \"Enabled\") || config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"UseDeletedMessageStore\");\n    }\n\n    /**\n     * Reads the name of the directory of the deleted messages out of the\n     * configuration.\n     *\n     * @return the name of the directory containing the deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String getDirectory() throws XException {\n        return Configuration.getInstance().getValue(Constants.CHAPTER_BASE, SECTION, \"Directory\");\n    }\n\n    private void writeFile(String message, XBUSSystem system, String directory) throws XException {\n        String fileName = new StringBuffer(directory).append(Constants.FILE_SEPERATOR).append(system.getCompleteName()).append(Constants.getDateAsString()).append(\".xml\").toString();\n        BufferedWriter buffOut = null;\n        try {\n            buffOut = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), Constants.getXMLEncoding()));\n            buffOut.write(message);\n            buffOut.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffOut != null) {\n                try {\n                    buffOut.close();\n                } catch (IOException e1) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e1);\n                }\n            }\n        }\n    }\n\n    private String buildXML(Object message, XBUSSystem system) throws XException {\n        Document doc = XMLHelper.getDocumentBuilder(\"Default\", null).newDocument();\n        Element root = doc.createElement(XDomSupport.makeTagNameValid(system.getName()));\n        doc.appendChild(root);\n        Hashtable addresses = system.getAddresses();\n        if (!addresses.isEmpty()) {\n            Element addressesNode = doc.createElement(\"Addresses\");\n            String address = null;\n            Element addressNode = null;\n            for (Enumeration keys = addresses.keys(); keys.hasMoreElements(); ) {\n                address = (String) keys.nextElement();\n                addressNode = doc.createElement(\"Address\");\n                addressNode.setAttribute(\"name\", address);\n                addressNode.appendChild(doc.createTextNode((String) addresses.get(address)));\n                addressesNode.appendChild(addressNode);\n            }\n            root.appendChild(addressesNode);\n        }\n        Element data = doc.createElement(\"Data\");\n        data.appendChild(doc.createCDATASection(message.toString()));\n        root.appendChild(data);\n        return XMLHelper.serializeXML(doc, null);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename\n     *            the name of the file including the directory\n     * @return the content of the file\n     */\n    static private String readFile(String filename) throws XException {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        BufferedReader buffReader = null;\n        try {\n            buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffReader != null) {\n                try {\n                    buffReader.close();\n                } catch (IOException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/deletedMessageStore/DeletedMessageStoreTest2.java",
		"test_prompt": "// DeletedMessageStoreTest2.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeletedMessageStore}.\n* It contains ten unit test cases for the {@link DeletedMessageStore#getDeletedMessageFilenames()} method.\n*/\nclass DeletedMessageStoreTest2 {"
	},
	{
		"original_code": "// DeletedMessageStore.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>DeletedMessageStore</code> manages the saving of messages before they\n * are deleted in case of an error.\n * <p>\n * It implements a <b>Singleton </b> pattern, where there is one instance per\n * thread.\n */\npublic class DeletedMessageStore {\n\n    private static final String SECTION = \"DeletedMessageStore\";\n\n    private static Hashtable mDeletedMessageStores = new Hashtable();\n\n    private static final Object classLock = DeletedMessageStore.class;\n\n    private Object mMessage = null;\n\n    private XBUSSystem mSystem = null;\n\n    private DeletedMessageStore() {\n        mDeletedMessageStores.put(Thread.currentThread().getName(), this);\n    }\n\n    /**\n     * Returns an instance of the <code>DeletedMessageStore</code>. A new\n     * instance will be created if there is none existing for this thread.\n     *\n     * @return an instance of the <code>DeletedMessageStore</code>\n     */\n    public static DeletedMessageStore getInstance() {\n        synchronized (classLock) {\n            DeletedMessageStore dmStore = (DeletedMessageStore) mDeletedMessageStores.get(Thread.currentThread().getName());\n            if (dmStore == null) {\n                dmStore = new DeletedMessageStore();\n            }\n            return dmStore;\n        }\n    }\n\n    /**\n     * Set the message that shall be saved. The XML file will contain the\n     * <code>String</code> representation of this object.\n     *\n     * @param message\n     *            the message to be saved\n     */\n    public void setMessage(Object message) {\n        mMessage = message;\n    }\n\n    /**\n     * Sets the system that has received the message.\n     *\n     * @param system\n     *            the receiving message\n     */\n    public void setSystem(XBUSSystem system) {\n        mSystem = system;\n    }\n\n    /**\n     * Writes the name of the system, its additional addresses and the message\n     * into a XML file. The name of the directory is read out of the\n     * configuration. The filename is\n     * <code><i>system.getCompleteName()</i>.xml.<i>timestamp</i></code>.\n     *\n     * @return true if the writing has been successful, false if there has been\n     *         a problem\n     */\n    public boolean writeMessage() {\n        try {\n            if (getEnabled(mSystem)) {\n                writeFile(buildXML(mMessage, mSystem), mSystem, getDirectory());\n            }\n            return true;\n        } catch (XException e) {\n            Trace.error(\"Problem while writing to DeletedMessageStore\");\n            return false;\n        }\n    }\n\n    /**\n     * Reads the name of all files containing deleted messages.\n     *\n     * @return an array with the name of all files containing deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String[] getDeletedMessageFilenames() throws XException {\n        File[] files = new File(getDirectory()).listFiles();\n        String[] retArray = new String[files.length];\n        for (int i = 0; i < retArray.length; i++) {\n            retArray[i] = files[i].getName();\n        }\n        return retArray;\n    }\n\n    /**\n     * Reads a deleted message and makes a new attempt to send it to its\n     * destinations.\n     *\n     * @param filename\n     *            the name of a file containing a deleted message\n     * @return a message of success or failure\n     */\n    public static String resendDeletedMessage(String filename) {\n        StringBuffer retString = new StringBuffer();\n        TAManager taManager = null;\n        Trace.info(\"Resending message from \" + filename);\n        /*\n\t\t * Reading and parsing the deleted message\n\t\t */\n        try {\n            Document messageDom = XMLHelper.parseXML(readFile(getDirectory() + Constants.FILE_SEPERATOR + filename), null, null);\n            XBUSSystem source = new XBUSSystem(messageDom.getFirstChild().getNodeName());\n            NodeList addresses = messageDom.getElementsByTagName(\"Address\");\n            Node address = null;\n            String attrName = null;\n            String addressValue = null;\n            for (int i = 0; i < addresses.getLength(); i++) {\n                address = addresses.item(i);\n                if ((attrName = XMLHelper.getAttribute(address, \"name\")) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"1\");\n                }\n                if ((addressValue = XMLHelper.getNodeText(address)) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"2\");\n                }\n                source.setAddress(attrName, addressValue);\n            }\n            NodeList data = messageDom.getElementsByTagName(\"Data\");\n            String request = null;\n            if (data.getLength() > 0) {\n                Node messageNode = messageDom.getElementsByTagName(\"Data\").item(0);\n                Node dataNode = null;\n                if ((dataNode = messageNode.getFirstChild()) != null) {\n                    request = dataNode.getNodeValue();\n                }\n            }\n            if (request == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"3\");\n            }\n            /*\n\t\t\t * Resending the message\n\t\t\t */\n            taManager = TAManager.getInstance();\n            taManager.clearManager();\n            taManager.begin();\n            Adapter adapter = new Adapter();\n            adapter.callApplication(source, request, Constants.TYPE_TEXT);\n            Object responseObject = adapter.getResponse();\n            if (Constants.RC_OK.equals(adapter.getReturncode())) {\n                taManager.commit();\n                PostProcessor.start(source, responseObject, Constants.POSTPROCESSING_PERSYSTEM);\n                Trace.info(\"End resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Message from \").append(source.getCompleteName()).append(\" successfully resent!\");\n                File messageFile = new File(getDirectory() + Constants.FILE_SEPERATOR + filename);\n                if (messageFile.delete()) {\n                    retString.append(\"<br>\");\n                    retString.append(\"File \").append(filename).append(\" has been deleted.\");\n                } else {\n                    retString.append(\"<br />\");\n                    retString.append(\"File \").append(filename).append(\" cannot be deleted.\");\n                }\n            } else {\n                taManager.rollback();\n                Trace.info(\"Error while resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Error while resending \").append(source.getCompleteName()).append(\"<br>\").append(\"Reason: \").append(adapter.getErrormessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n            }\n        } catch (Exception t) {\n            Trace.info(\"Error while resending \" + filename);\n            Trace.info(\"-----------------------------\");\n            retString.append(\"Error while resending \").append(filename).append(\"<br>\").append(\"Reason: \").append(t.getMessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n        } finally {\n            if (taManager != null) {\n                taManager.close();\n            }\n        }\n        return retString.toString();\n    }\n\n    private static boolean getEnabled(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        return config.getValueAsBooleanOptional(Constants.CHAPTER_BASE, SECTION, \"Enabled\") || config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"UseDeletedMessageStore\");\n    }\n\n    /**\n     * Reads the name of the directory of the deleted messages out of the\n     * configuration.\n     *\n     * @return the name of the directory containing the deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String getDirectory() throws XException {\n        return Configuration.getInstance().getValue(Constants.CHAPTER_BASE, SECTION, \"Directory\");\n    }\n\n    private void writeFile(String message, XBUSSystem system, String directory) throws XException {\n        String fileName = new StringBuffer(directory).append(Constants.FILE_SEPERATOR).append(system.getCompleteName()).append(Constants.getDateAsString()).append(\".xml\").toString();\n        BufferedWriter buffOut = null;\n        try {\n            buffOut = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), Constants.getXMLEncoding()));\n            buffOut.write(message);\n            buffOut.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffOut != null) {\n                try {\n                    buffOut.close();\n                } catch (IOException e1) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e1);\n                }\n            }\n        }\n    }\n\n    private String buildXML(Object message, XBUSSystem system) throws XException {\n        Document doc = XMLHelper.getDocumentBuilder(\"Default\", null).newDocument();\n        Element root = doc.createElement(XDomSupport.makeTagNameValid(system.getName()));\n        doc.appendChild(root);\n        Hashtable addresses = system.getAddresses();\n        if (!addresses.isEmpty()) {\n            Element addressesNode = doc.createElement(\"Addresses\");\n            String address = null;\n            Element addressNode = null;\n            for (Enumeration keys = addresses.keys(); keys.hasMoreElements(); ) {\n                address = (String) keys.nextElement();\n                addressNode = doc.createElement(\"Address\");\n                addressNode.setAttribute(\"name\", address);\n                addressNode.appendChild(doc.createTextNode((String) addresses.get(address)));\n                addressesNode.appendChild(addressNode);\n            }\n            root.appendChild(addressesNode);\n        }\n        Element data = doc.createElement(\"Data\");\n        data.appendChild(doc.createCDATASection(message.toString()));\n        root.appendChild(data);\n        return XMLHelper.serializeXML(doc, null);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename\n     *            the name of the file including the directory\n     * @return the content of the file\n     */\n    static private String readFile(String filename) throws XException {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        BufferedReader buffReader = null;\n        try {\n            buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffReader != null) {\n                try {\n                    buffReader.close();\n                } catch (IOException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/deletedMessageStore/DeletedMessageStoreTest3.java",
		"test_prompt": "// DeletedMessageStoreTest3.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeletedMessageStore}.\n* It contains ten unit test cases for the {@link DeletedMessageStore#resendDeletedMessage(String)} method.\n*/\nclass DeletedMessageStoreTest3 {"
	},
	{
		"original_code": "// DeletedMessageStore.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>DeletedMessageStore</code> manages the saving of messages before they\n * are deleted in case of an error.\n * <p>\n * It implements a <b>Singleton </b> pattern, where there is one instance per\n * thread.\n */\npublic class DeletedMessageStore {\n\n    private static final String SECTION = \"DeletedMessageStore\";\n\n    private static Hashtable mDeletedMessageStores = new Hashtable();\n\n    private static final Object classLock = DeletedMessageStore.class;\n\n    private Object mMessage = null;\n\n    private XBUSSystem mSystem = null;\n\n    private DeletedMessageStore() {\n        mDeletedMessageStores.put(Thread.currentThread().getName(), this);\n    }\n\n    /**\n     * Returns an instance of the <code>DeletedMessageStore</code>. A new\n     * instance will be created if there is none existing for this thread.\n     *\n     * @return an instance of the <code>DeletedMessageStore</code>\n     */\n    public static DeletedMessageStore getInstance() {\n        synchronized (classLock) {\n            DeletedMessageStore dmStore = (DeletedMessageStore) mDeletedMessageStores.get(Thread.currentThread().getName());\n            if (dmStore == null) {\n                dmStore = new DeletedMessageStore();\n            }\n            return dmStore;\n        }\n    }\n\n    /**\n     * Set the message that shall be saved. The XML file will contain the\n     * <code>String</code> representation of this object.\n     *\n     * @param message\n     *            the message to be saved\n     */\n    public void setMessage(Object message) {\n        mMessage = message;\n    }\n\n    /**\n     * Sets the system that has received the message.\n     *\n     * @param system\n     *            the receiving message\n     */\n    public void setSystem(XBUSSystem system) {\n        mSystem = system;\n    }\n\n    /**\n     * Writes the name of the system, its additional addresses and the message\n     * into a XML file. The name of the directory is read out of the\n     * configuration. The filename is\n     * <code><i>system.getCompleteName()</i>.xml.<i>timestamp</i></code>.\n     *\n     * @return true if the writing has been successful, false if there has been\n     *         a problem\n     */\n    public boolean writeMessage() {\n        try {\n            if (getEnabled(mSystem)) {\n                writeFile(buildXML(mMessage, mSystem), mSystem, getDirectory());\n            }\n            return true;\n        } catch (XException e) {\n            Trace.error(\"Problem while writing to DeletedMessageStore\");\n            return false;\n        }\n    }\n\n    /**\n     * Reads the name of all files containing deleted messages.\n     *\n     * @return an array with the name of all files containing deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String[] getDeletedMessageFilenames() throws XException {\n        File[] files = new File(getDirectory()).listFiles();\n        String[] retArray = new String[files.length];\n        for (int i = 0; i < retArray.length; i++) {\n            retArray[i] = files[i].getName();\n        }\n        return retArray;\n    }\n\n    /**\n     * Reads a deleted message and makes a new attempt to send it to its\n     * destinations.\n     *\n     * @param filename\n     *            the name of a file containing a deleted message\n     * @return a message of success or failure\n     */\n    public static String resendDeletedMessage(String filename) {\n        StringBuffer retString = new StringBuffer();\n        TAManager taManager = null;\n        Trace.info(\"Resending message from \" + filename);\n        /*\n\t\t * Reading and parsing the deleted message\n\t\t */\n        try {\n            Document messageDom = XMLHelper.parseXML(readFile(getDirectory() + Constants.FILE_SEPERATOR + filename), null, null);\n            XBUSSystem source = new XBUSSystem(messageDom.getFirstChild().getNodeName());\n            NodeList addresses = messageDom.getElementsByTagName(\"Address\");\n            Node address = null;\n            String attrName = null;\n            String addressValue = null;\n            for (int i = 0; i < addresses.getLength(); i++) {\n                address = addresses.item(i);\n                if ((attrName = XMLHelper.getAttribute(address, \"name\")) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"1\");\n                }\n                if ((addressValue = XMLHelper.getNodeText(address)) == null) {\n                    throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"2\");\n                }\n                source.setAddress(attrName, addressValue);\n            }\n            NodeList data = messageDom.getElementsByTagName(\"Data\");\n            String request = null;\n            if (data.getLength() > 0) {\n                Node messageNode = messageDom.getElementsByTagName(\"Data\").item(0);\n                Node dataNode = null;\n                if ((dataNode = messageNode.getFirstChild()) != null) {\n                    request = dataNode.getNodeValue();\n                }\n            }\n            if (request == null) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"3\");\n            }\n            /*\n\t\t\t * Resending the message\n\t\t\t */\n            taManager = TAManager.getInstance();\n            taManager.clearManager();\n            taManager.begin();\n            Adapter adapter = new Adapter();\n            adapter.callApplication(source, request, Constants.TYPE_TEXT);\n            Object responseObject = adapter.getResponse();\n            if (Constants.RC_OK.equals(adapter.getReturncode())) {\n                taManager.commit();\n                PostProcessor.start(source, responseObject, Constants.POSTPROCESSING_PERSYSTEM);\n                Trace.info(\"End resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Message from \").append(source.getCompleteName()).append(\" successfully resent!\");\n                File messageFile = new File(getDirectory() + Constants.FILE_SEPERATOR + filename);\n                if (messageFile.delete()) {\n                    retString.append(\"<br>\");\n                    retString.append(\"File \").append(filename).append(\" has been deleted.\");\n                } else {\n                    retString.append(\"<br />\");\n                    retString.append(\"File \").append(filename).append(\" cannot be deleted.\");\n                }\n            } else {\n                taManager.rollback();\n                Trace.info(\"Error while resending \" + source.getCompleteName());\n                Trace.info(\"-----------------------------\");\n                retString.append(\"Error while resending \").append(source.getCompleteName()).append(\"<br>\").append(\"Reason: \").append(adapter.getErrormessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n            }\n        } catch (Exception t) {\n            Trace.info(\"Error while resending \" + filename);\n            Trace.info(\"-----------------------------\");\n            retString.append(\"Error while resending \").append(filename).append(\"<br>\").append(\"Reason: \").append(t.getMessage()).append(\"<br>\").append(\"File \").append(filename).append(\" has not been deleted.\");\n        } finally {\n            if (taManager != null) {\n                taManager.close();\n            }\n        }\n        return retString.toString();\n    }\n\n    private static boolean getEnabled(XBUSSystem system) throws XException {\n        Configuration config = Configuration.getInstance();\n        return config.getValueAsBooleanOptional(Constants.CHAPTER_BASE, SECTION, \"Enabled\") || config.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system.getName(), \"UseDeletedMessageStore\");\n    }\n\n    /**\n     * Reads the name of the directory of the deleted messages out of the\n     * configuration.\n     *\n     * @return the name of the directory containing the deleted messages\n     * @throws XException\n     *             if any error occures\n     */\n    public static String getDirectory() throws XException {\n        return Configuration.getInstance().getValue(Constants.CHAPTER_BASE, SECTION, \"Directory\");\n    }\n\n    private void writeFile(String message, XBUSSystem system, String directory) throws XException {\n        String fileName = new StringBuffer(directory).append(Constants.FILE_SEPERATOR).append(system.getCompleteName()).append(Constants.getDateAsString()).append(\".xml\").toString();\n        BufferedWriter buffOut = null;\n        try {\n            buffOut = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(fileName), Constants.getXMLEncoding()));\n            buffOut.write(message);\n            buffOut.close();\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffOut != null) {\n                try {\n                    buffOut.close();\n                } catch (IOException e1) {\n                    throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e1);\n                }\n            }\n        }\n    }\n\n    private String buildXML(Object message, XBUSSystem system) throws XException {\n        Document doc = XMLHelper.getDocumentBuilder(\"Default\", null).newDocument();\n        Element root = doc.createElement(XDomSupport.makeTagNameValid(system.getName()));\n        doc.appendChild(root);\n        Hashtable addresses = system.getAddresses();\n        if (!addresses.isEmpty()) {\n            Element addressesNode = doc.createElement(\"Addresses\");\n            String address = null;\n            Element addressNode = null;\n            for (Enumeration keys = addresses.keys(); keys.hasMoreElements(); ) {\n                address = (String) keys.nextElement();\n                addressNode = doc.createElement(\"Address\");\n                addressNode.setAttribute(\"name\", address);\n                addressNode.appendChild(doc.createTextNode((String) addresses.get(address)));\n                addressesNode.appendChild(addressNode);\n            }\n            root.appendChild(addressesNode);\n        }\n        Element data = doc.createElement(\"Data\");\n        data.appendChild(doc.createCDATASection(message.toString()));\n        root.appendChild(data);\n        return XMLHelper.serializeXML(doc, null);\n    }\n\n    /**\n     * Reads a file.\n     *\n     * @param filename\n     *            the name of the file including the directory\n     * @return the content of the file\n     */\n    static private String readFile(String filename) throws XException {\n        StringBuffer retBuffer = new StringBuffer();\n        File sourceFile = new File(filename);\n        String zeile;\n        BufferedReader buffReader = null;\n        try {\n            buffReader = new BufferedReader(new InputStreamReader(new FileInputStream(sourceFile)));\n            if ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(zeile);\n            }\n            // if((zeile = buffReader.readLine()) != null)\n            while ((zeile = buffReader.readLine()) != null) {\n                retBuffer.append(Constants.LINE_SEPERATOR);\n                retBuffer.append(zeile);\n            }\n            // while ((zeile = buffReader.readLine()) != null)\n        } catch (IOException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_BASE, Constants.PACKAGE_BASE_DELETEDMESSAGESTORE, \"0\", e);\n        } finally {\n            if (buffReader != null) {\n                try {\n                    buffReader.close();\n                } catch (IOException e1) {\n                    // do nothing\n                }\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/deletedMessageStore/DeletedMessageStoreTest4.java",
		"test_prompt": "// DeletedMessageStoreTest4.java\npackage net.sf.xbus.base.deletedMessageStore;\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport net.sf.xbus.application.Adapter;\nimport net.sf.xbus.application.PostProcessor;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.TAManager;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.base.core.trace.Trace;\nimport net.sf.xbus.base.xbussystem.XBUSSystem;\nimport net.sf.xbus.base.xml.XDomSupport;\nimport net.sf.xbus.base.xml.XMLHelper;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DeletedMessageStore}.\n* It contains ten unit test cases for the {@link DeletedMessageStore#getDirectory()} method.\n*/\nclass DeletedMessageStoreTest4 {"
	},
	{
		"original_code": "// XDomSupport.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>XDomSupport</code> is a collection of operations on DOM trees. It\n * extends the possibilities offered in the <code>org.w3c.dom</code> package.\n *\n * @author Stephan D�wel\n */\npublic abstract class XDomSupport {\n\n    /**\n     * <code>getChildNodesByAttrValue</code> retrieves child nodes selected by\n     * a certain value of a certain attribute. Child nodes without the specified\n     * attribute are not selected.\n     *\n     * @param parent the node for which children are searched\n     * @param attrName the attribute to check\n     * @param attrValue the attribute's value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code>,\n     *             <code>attrName</code> or <code>attrValue</code> are\n     *             <code>null</code> or <code>attrName</code> is empty\n     */\n    public static List getChildNodesByAttrValue(Node parent, String attrName, String attrValue, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (attrName == null || attrName.length() == 0)\n            throw new IllegalArgumentException(\"Attribute name may not be empty\");\n        if (attrValue == null)\n            throw new IllegalArgumentException(\"Attribute value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && ((Element) child).getAttribute(attrName).equals(attrValue))\n                if (nodeTag != null && nodeTag.length() > 0)\n                    // Tag name must be checked\n                    if (child.getNodeName().equals(nodeTag))\n                        result.add(child);\n                    else\n                        result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildNodesByAttrValue (Node parent, String attrName, String\n    // attrValue, String nodeTag)\n    public static String getNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getNodeText(Node node)\n    /**\n     * <code>getTrimedNodeText</code> retrieves the value for a node\n     * representing the corresponding xml tag.\n     *\n     * @param node the node representing the xml tag\n     * @return the value stored within the xml tag, the string is trimed for\n     *         leading and ending white space\n     */\n    public static String getTrimedNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n                foundValue = foundValue.trim();\n                // trim in between\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getTrimedNodeText(Node node)\n    /**\n     * <code>getChildElementsByValue</code> retrieves child nodes of type\n     * element selected by a certain for the value stored with them.\n     *\n     * @param parent the node for which children are searched\n     * @param value the value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code> or\n     *             <code>value</code> are <code>null</code>\n     */\n    public static List getChildElementsByValue(Node parent, String value, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (value == null)\n            throw new IllegalArgumentException(\"Value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && (nodeTag == null || nodeTag.length() == 0 || child.getNodeName().equals(nodeTag)) && value.equals(getTrimedNodeText(child)))\n                result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildElementsByValue (Node parent, String value, String nodeTag)\n    /**\n     * <code>getNextNodeIndexIgnoringFormatingText</code> retrieves the\n     * position of the next node after the position <code>startPos</code>\n     * within the list <code>nodes</code> which is not a text node only\n     * containing whitespace.\n     *\n     * @param nodes the node list\n     * @param startPos the position to start from\n     * @return the position; -1 if no node was found\n     */\n    public static int getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos) {\n        int pos;\n        boolean nodeNotFound = true;\n        for (pos = startPos; pos < nodes.getLength() && nodeNotFound; pos++) {\n            // Search all nodes afetr position <startpos>\n            Node node = nodes.item(pos);\n            if (node != null && (node.getNodeType() != Node.TEXT_NODE || node.getNodeValue().trim().length() > 0))\n                nodeNotFound = false;\n        }\n        if (nodeNotFound)\n            pos = -1;\n        else\n            // <pos> incremented once in for loop after finding the node\n            pos--;\n        return pos;\n    }\n\n    // getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos)\n    /**\n     * <code>deleteWhitespaceTextInElementNodes</code> deletes all text nodes\n     * containing only whitespace within xml tags. This operation is useful to\n     * get rid of formatting information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodes(Document doc) throws XException {\n        IteratedWhitespaceInElementDeletion itop = new IteratedWhitespaceInElementDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodes(Document doc)\n    /**\n     * <code>deleteWhitespaceTextInElementNodesAndComments</code> deletes all\n     * text nodes containing only whitespace within xml tags and all comment\n     * nodes. This operation is useful to get rid of formatting and editor\n     * information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodesAndComments(Document doc) throws XException {\n        IteratedWhitespaceInElementAndCommentDeletion itop = new IteratedWhitespaceInElementAndCommentDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodesAndComments(Document doc)\n    /**\n     * <code>traversePreOrder</code> traverses a DOM tree in pre-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePreOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePreOrder(root, itop);\n    }\n\n    // traversePreOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePreOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It executes the specified operation on the specified\n     * node and proceeds to its children. The traversal may treat dynamically\n     * deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    private static void recursivePreOrder(Node node, IteratedNodeOperation itop) throws XException {\n        itop.iteratedProcedure(node);\n        // Process the actual node ...\n        if (node.hasChildNodes()) {\n            // ... and then all its children\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePreOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n    }\n\n    // recursivePreOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>traversePostOrder</code> traverses a DOM tree in post-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePostOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePostOrder(root, itop);\n    }\n\n    // traversePostOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePostOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It proceeds on all children of the specified node\n     * and then executes the specified operation on the node itself. The\n     * traversal may treat dynamically deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void recursivePostOrder(Node node, IteratedNodeOperation itop) throws XException {\n        if (node.hasChildNodes()) {\n            // Process all children of the actual node ...\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePostOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n        itop.iteratedProcedure(node);\n        // ... and then the actual node itself\n    }\n\n    // recursivePostOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>isValidTagName</code> checks if a string conforms to the\n     * conventions for xml tag names.\n     *\n     * @param name the string to check\n     * @return <code>true</code> if the string is a well-formed tag name,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isValidTagName(String name) {\n        boolean result = (name.length() > 0 && (Character.isLetter(name.charAt(0)) || name.charAt(0) == '_'));\n        for (int i = 1; i < name.length() && result; i++) result = (Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_');\n        return result;\n    }\n\n    // isValidTagName(String name)\n    /**\n     * Removes invalid characters from tag names.\n     *\n     * @param name the name of the tag\n     * @return the name of the tag without invalid characters\n     */\n    public static String makeTagNameValid(String name) {\n        StringBuffer retBuffer = new StringBuffer();\n        for (int i = 0; i < name.length(); i++) {\n            if ((Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_')) {\n                retBuffer.append(name.charAt(i));\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n// XDomSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XDomSupportTest0.java",
		"test_prompt": "// XDomSupportTest0.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XDomSupport}.\n* It contains ten unit test cases for the {@link XDomSupport#getChildNodesByAttrValue(Node, String, String, String)} method.\n*/\nclass XDomSupportTest0 {"
	},
	{
		"original_code": "// XDomSupport.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>XDomSupport</code> is a collection of operations on DOM trees. It\n * extends the possibilities offered in the <code>org.w3c.dom</code> package.\n *\n * @author Stephan D�wel\n */\npublic abstract class XDomSupport {\n\n    /**\n     * <code>getChildNodesByAttrValue</code> retrieves child nodes selected by\n     * a certain value of a certain attribute. Child nodes without the specified\n     * attribute are not selected.\n     *\n     * @param parent the node for which children are searched\n     * @param attrName the attribute to check\n     * @param attrValue the attribute's value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code>,\n     *             <code>attrName</code> or <code>attrValue</code> are\n     *             <code>null</code> or <code>attrName</code> is empty\n     */\n    public static List getChildNodesByAttrValue(Node parent, String attrName, String attrValue, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (attrName == null || attrName.length() == 0)\n            throw new IllegalArgumentException(\"Attribute name may not be empty\");\n        if (attrValue == null)\n            throw new IllegalArgumentException(\"Attribute value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && ((Element) child).getAttribute(attrName).equals(attrValue))\n                if (nodeTag != null && nodeTag.length() > 0)\n                    // Tag name must be checked\n                    if (child.getNodeName().equals(nodeTag))\n                        result.add(child);\n                    else\n                        result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildNodesByAttrValue (Node parent, String attrName, String\n    // attrValue, String nodeTag)\n    public static String getNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getNodeText(Node node)\n    /**\n     * <code>getTrimedNodeText</code> retrieves the value for a node\n     * representing the corresponding xml tag.\n     *\n     * @param node the node representing the xml tag\n     * @return the value stored within the xml tag, the string is trimed for\n     *         leading and ending white space\n     */\n    public static String getTrimedNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n                foundValue = foundValue.trim();\n                // trim in between\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getTrimedNodeText(Node node)\n    /**\n     * <code>getChildElementsByValue</code> retrieves child nodes of type\n     * element selected by a certain for the value stored with them.\n     *\n     * @param parent the node for which children are searched\n     * @param value the value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code> or\n     *             <code>value</code> are <code>null</code>\n     */\n    public static List getChildElementsByValue(Node parent, String value, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (value == null)\n            throw new IllegalArgumentException(\"Value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && (nodeTag == null || nodeTag.length() == 0 || child.getNodeName().equals(nodeTag)) && value.equals(getTrimedNodeText(child)))\n                result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildElementsByValue (Node parent, String value, String nodeTag)\n    /**\n     * <code>getNextNodeIndexIgnoringFormatingText</code> retrieves the\n     * position of the next node after the position <code>startPos</code>\n     * within the list <code>nodes</code> which is not a text node only\n     * containing whitespace.\n     *\n     * @param nodes the node list\n     * @param startPos the position to start from\n     * @return the position; -1 if no node was found\n     */\n    public static int getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos) {\n        int pos;\n        boolean nodeNotFound = true;\n        for (pos = startPos; pos < nodes.getLength() && nodeNotFound; pos++) {\n            // Search all nodes afetr position <startpos>\n            Node node = nodes.item(pos);\n            if (node != null && (node.getNodeType() != Node.TEXT_NODE || node.getNodeValue().trim().length() > 0))\n                nodeNotFound = false;\n        }\n        if (nodeNotFound)\n            pos = -1;\n        else\n            // <pos> incremented once in for loop after finding the node\n            pos--;\n        return pos;\n    }\n\n    // getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos)\n    /**\n     * <code>deleteWhitespaceTextInElementNodes</code> deletes all text nodes\n     * containing only whitespace within xml tags. This operation is useful to\n     * get rid of formatting information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodes(Document doc) throws XException {\n        IteratedWhitespaceInElementDeletion itop = new IteratedWhitespaceInElementDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodes(Document doc)\n    /**\n     * <code>deleteWhitespaceTextInElementNodesAndComments</code> deletes all\n     * text nodes containing only whitespace within xml tags and all comment\n     * nodes. This operation is useful to get rid of formatting and editor\n     * information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodesAndComments(Document doc) throws XException {\n        IteratedWhitespaceInElementAndCommentDeletion itop = new IteratedWhitespaceInElementAndCommentDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodesAndComments(Document doc)\n    /**\n     * <code>traversePreOrder</code> traverses a DOM tree in pre-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePreOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePreOrder(root, itop);\n    }\n\n    // traversePreOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePreOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It executes the specified operation on the specified\n     * node and proceeds to its children. The traversal may treat dynamically\n     * deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    private static void recursivePreOrder(Node node, IteratedNodeOperation itop) throws XException {\n        itop.iteratedProcedure(node);\n        // Process the actual node ...\n        if (node.hasChildNodes()) {\n            // ... and then all its children\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePreOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n    }\n\n    // recursivePreOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>traversePostOrder</code> traverses a DOM tree in post-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePostOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePostOrder(root, itop);\n    }\n\n    // traversePostOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePostOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It proceeds on all children of the specified node\n     * and then executes the specified operation on the node itself. The\n     * traversal may treat dynamically deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void recursivePostOrder(Node node, IteratedNodeOperation itop) throws XException {\n        if (node.hasChildNodes()) {\n            // Process all children of the actual node ...\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePostOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n        itop.iteratedProcedure(node);\n        // ... and then the actual node itself\n    }\n\n    // recursivePostOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>isValidTagName</code> checks if a string conforms to the\n     * conventions for xml tag names.\n     *\n     * @param name the string to check\n     * @return <code>true</code> if the string is a well-formed tag name,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isValidTagName(String name) {\n        boolean result = (name.length() > 0 && (Character.isLetter(name.charAt(0)) || name.charAt(0) == '_'));\n        for (int i = 1; i < name.length() && result; i++) result = (Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_');\n        return result;\n    }\n\n    // isValidTagName(String name)\n    /**\n     * Removes invalid characters from tag names.\n     *\n     * @param name the name of the tag\n     * @return the name of the tag without invalid characters\n     */\n    public static String makeTagNameValid(String name) {\n        StringBuffer retBuffer = new StringBuffer();\n        for (int i = 0; i < name.length(); i++) {\n            if ((Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_')) {\n                retBuffer.append(name.charAt(i));\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n// XDomSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XDomSupportTest1.java",
		"test_prompt": "// XDomSupportTest1.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XDomSupport}.\n* It contains ten unit test cases for the {@link XDomSupport#getNodeText(Node)} method.\n*/\nclass XDomSupportTest1 {"
	},
	{
		"original_code": "// XDomSupport.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>XDomSupport</code> is a collection of operations on DOM trees. It\n * extends the possibilities offered in the <code>org.w3c.dom</code> package.\n *\n * @author Stephan D�wel\n */\npublic abstract class XDomSupport {\n\n    /**\n     * <code>getChildNodesByAttrValue</code> retrieves child nodes selected by\n     * a certain value of a certain attribute. Child nodes without the specified\n     * attribute are not selected.\n     *\n     * @param parent the node for which children are searched\n     * @param attrName the attribute to check\n     * @param attrValue the attribute's value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code>,\n     *             <code>attrName</code> or <code>attrValue</code> are\n     *             <code>null</code> or <code>attrName</code> is empty\n     */\n    public static List getChildNodesByAttrValue(Node parent, String attrName, String attrValue, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (attrName == null || attrName.length() == 0)\n            throw new IllegalArgumentException(\"Attribute name may not be empty\");\n        if (attrValue == null)\n            throw new IllegalArgumentException(\"Attribute value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && ((Element) child).getAttribute(attrName).equals(attrValue))\n                if (nodeTag != null && nodeTag.length() > 0)\n                    // Tag name must be checked\n                    if (child.getNodeName().equals(nodeTag))\n                        result.add(child);\n                    else\n                        result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildNodesByAttrValue (Node parent, String attrName, String\n    // attrValue, String nodeTag)\n    public static String getNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getNodeText(Node node)\n    /**\n     * <code>getTrimedNodeText</code> retrieves the value for a node\n     * representing the corresponding xml tag.\n     *\n     * @param node the node representing the xml tag\n     * @return the value stored within the xml tag, the string is trimed for\n     *         leading and ending white space\n     */\n    public static String getTrimedNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n                foundValue = foundValue.trim();\n                // trim in between\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getTrimedNodeText(Node node)\n    /**\n     * <code>getChildElementsByValue</code> retrieves child nodes of type\n     * element selected by a certain for the value stored with them.\n     *\n     * @param parent the node for which children are searched\n     * @param value the value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code> or\n     *             <code>value</code> are <code>null</code>\n     */\n    public static List getChildElementsByValue(Node parent, String value, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (value == null)\n            throw new IllegalArgumentException(\"Value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && (nodeTag == null || nodeTag.length() == 0 || child.getNodeName().equals(nodeTag)) && value.equals(getTrimedNodeText(child)))\n                result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildElementsByValue (Node parent, String value, String nodeTag)\n    /**\n     * <code>getNextNodeIndexIgnoringFormatingText</code> retrieves the\n     * position of the next node after the position <code>startPos</code>\n     * within the list <code>nodes</code> which is not a text node only\n     * containing whitespace.\n     *\n     * @param nodes the node list\n     * @param startPos the position to start from\n     * @return the position; -1 if no node was found\n     */\n    public static int getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos) {\n        int pos;\n        boolean nodeNotFound = true;\n        for (pos = startPos; pos < nodes.getLength() && nodeNotFound; pos++) {\n            // Search all nodes afetr position <startpos>\n            Node node = nodes.item(pos);\n            if (node != null && (node.getNodeType() != Node.TEXT_NODE || node.getNodeValue().trim().length() > 0))\n                nodeNotFound = false;\n        }\n        if (nodeNotFound)\n            pos = -1;\n        else\n            // <pos> incremented once in for loop after finding the node\n            pos--;\n        return pos;\n    }\n\n    // getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos)\n    /**\n     * <code>deleteWhitespaceTextInElementNodes</code> deletes all text nodes\n     * containing only whitespace within xml tags. This operation is useful to\n     * get rid of formatting information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodes(Document doc) throws XException {\n        IteratedWhitespaceInElementDeletion itop = new IteratedWhitespaceInElementDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodes(Document doc)\n    /**\n     * <code>deleteWhitespaceTextInElementNodesAndComments</code> deletes all\n     * text nodes containing only whitespace within xml tags and all comment\n     * nodes. This operation is useful to get rid of formatting and editor\n     * information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodesAndComments(Document doc) throws XException {\n        IteratedWhitespaceInElementAndCommentDeletion itop = new IteratedWhitespaceInElementAndCommentDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodesAndComments(Document doc)\n    /**\n     * <code>traversePreOrder</code> traverses a DOM tree in pre-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePreOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePreOrder(root, itop);\n    }\n\n    // traversePreOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePreOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It executes the specified operation on the specified\n     * node and proceeds to its children. The traversal may treat dynamically\n     * deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    private static void recursivePreOrder(Node node, IteratedNodeOperation itop) throws XException {\n        itop.iteratedProcedure(node);\n        // Process the actual node ...\n        if (node.hasChildNodes()) {\n            // ... and then all its children\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePreOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n    }\n\n    // recursivePreOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>traversePostOrder</code> traverses a DOM tree in post-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePostOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePostOrder(root, itop);\n    }\n\n    // traversePostOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePostOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It proceeds on all children of the specified node\n     * and then executes the specified operation on the node itself. The\n     * traversal may treat dynamically deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void recursivePostOrder(Node node, IteratedNodeOperation itop) throws XException {\n        if (node.hasChildNodes()) {\n            // Process all children of the actual node ...\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePostOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n        itop.iteratedProcedure(node);\n        // ... and then the actual node itself\n    }\n\n    // recursivePostOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>isValidTagName</code> checks if a string conforms to the\n     * conventions for xml tag names.\n     *\n     * @param name the string to check\n     * @return <code>true</code> if the string is a well-formed tag name,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isValidTagName(String name) {\n        boolean result = (name.length() > 0 && (Character.isLetter(name.charAt(0)) || name.charAt(0) == '_'));\n        for (int i = 1; i < name.length() && result; i++) result = (Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_');\n        return result;\n    }\n\n    // isValidTagName(String name)\n    /**\n     * Removes invalid characters from tag names.\n     *\n     * @param name the name of the tag\n     * @return the name of the tag without invalid characters\n     */\n    public static String makeTagNameValid(String name) {\n        StringBuffer retBuffer = new StringBuffer();\n        for (int i = 0; i < name.length(); i++) {\n            if ((Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_')) {\n                retBuffer.append(name.charAt(i));\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n// XDomSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XDomSupportTest2.java",
		"test_prompt": "// XDomSupportTest2.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XDomSupport}.\n* It contains ten unit test cases for the {@link XDomSupport#getTrimedNodeText(Node)} method.\n*/\nclass XDomSupportTest2 {"
	},
	{
		"original_code": "// XDomSupport.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>XDomSupport</code> is a collection of operations on DOM trees. It\n * extends the possibilities offered in the <code>org.w3c.dom</code> package.\n *\n * @author Stephan D�wel\n */\npublic abstract class XDomSupport {\n\n    /**\n     * <code>getChildNodesByAttrValue</code> retrieves child nodes selected by\n     * a certain value of a certain attribute. Child nodes without the specified\n     * attribute are not selected.\n     *\n     * @param parent the node for which children are searched\n     * @param attrName the attribute to check\n     * @param attrValue the attribute's value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code>,\n     *             <code>attrName</code> or <code>attrValue</code> are\n     *             <code>null</code> or <code>attrName</code> is empty\n     */\n    public static List getChildNodesByAttrValue(Node parent, String attrName, String attrValue, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (attrName == null || attrName.length() == 0)\n            throw new IllegalArgumentException(\"Attribute name may not be empty\");\n        if (attrValue == null)\n            throw new IllegalArgumentException(\"Attribute value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && ((Element) child).getAttribute(attrName).equals(attrValue))\n                if (nodeTag != null && nodeTag.length() > 0)\n                    // Tag name must be checked\n                    if (child.getNodeName().equals(nodeTag))\n                        result.add(child);\n                    else\n                        result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildNodesByAttrValue (Node parent, String attrName, String\n    // attrValue, String nodeTag)\n    public static String getNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getNodeText(Node node)\n    /**\n     * <code>getTrimedNodeText</code> retrieves the value for a node\n     * representing the corresponding xml tag.\n     *\n     * @param node the node representing the xml tag\n     * @return the value stored within the xml tag, the string is trimed for\n     *         leading and ending white space\n     */\n    public static String getTrimedNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n                foundValue = foundValue.trim();\n                // trim in between\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getTrimedNodeText(Node node)\n    /**\n     * <code>getChildElementsByValue</code> retrieves child nodes of type\n     * element selected by a certain for the value stored with them.\n     *\n     * @param parent the node for which children are searched\n     * @param value the value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code> or\n     *             <code>value</code> are <code>null</code>\n     */\n    public static List getChildElementsByValue(Node parent, String value, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (value == null)\n            throw new IllegalArgumentException(\"Value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && (nodeTag == null || nodeTag.length() == 0 || child.getNodeName().equals(nodeTag)) && value.equals(getTrimedNodeText(child)))\n                result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildElementsByValue (Node parent, String value, String nodeTag)\n    /**\n     * <code>getNextNodeIndexIgnoringFormatingText</code> retrieves the\n     * position of the next node after the position <code>startPos</code>\n     * within the list <code>nodes</code> which is not a text node only\n     * containing whitespace.\n     *\n     * @param nodes the node list\n     * @param startPos the position to start from\n     * @return the position; -1 if no node was found\n     */\n    public static int getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos) {\n        int pos;\n        boolean nodeNotFound = true;\n        for (pos = startPos; pos < nodes.getLength() && nodeNotFound; pos++) {\n            // Search all nodes afetr position <startpos>\n            Node node = nodes.item(pos);\n            if (node != null && (node.getNodeType() != Node.TEXT_NODE || node.getNodeValue().trim().length() > 0))\n                nodeNotFound = false;\n        }\n        if (nodeNotFound)\n            pos = -1;\n        else\n            // <pos> incremented once in for loop after finding the node\n            pos--;\n        return pos;\n    }\n\n    // getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos)\n    /**\n     * <code>deleteWhitespaceTextInElementNodes</code> deletes all text nodes\n     * containing only whitespace within xml tags. This operation is useful to\n     * get rid of formatting information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodes(Document doc) throws XException {\n        IteratedWhitespaceInElementDeletion itop = new IteratedWhitespaceInElementDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodes(Document doc)\n    /**\n     * <code>deleteWhitespaceTextInElementNodesAndComments</code> deletes all\n     * text nodes containing only whitespace within xml tags and all comment\n     * nodes. This operation is useful to get rid of formatting and editor\n     * information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodesAndComments(Document doc) throws XException {\n        IteratedWhitespaceInElementAndCommentDeletion itop = new IteratedWhitespaceInElementAndCommentDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodesAndComments(Document doc)\n    /**\n     * <code>traversePreOrder</code> traverses a DOM tree in pre-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePreOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePreOrder(root, itop);\n    }\n\n    // traversePreOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePreOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It executes the specified operation on the specified\n     * node and proceeds to its children. The traversal may treat dynamically\n     * deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    private static void recursivePreOrder(Node node, IteratedNodeOperation itop) throws XException {\n        itop.iteratedProcedure(node);\n        // Process the actual node ...\n        if (node.hasChildNodes()) {\n            // ... and then all its children\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePreOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n    }\n\n    // recursivePreOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>traversePostOrder</code> traverses a DOM tree in post-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePostOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePostOrder(root, itop);\n    }\n\n    // traversePostOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePostOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It proceeds on all children of the specified node\n     * and then executes the specified operation on the node itself. The\n     * traversal may treat dynamically deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void recursivePostOrder(Node node, IteratedNodeOperation itop) throws XException {\n        if (node.hasChildNodes()) {\n            // Process all children of the actual node ...\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePostOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n        itop.iteratedProcedure(node);\n        // ... and then the actual node itself\n    }\n\n    // recursivePostOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>isValidTagName</code> checks if a string conforms to the\n     * conventions for xml tag names.\n     *\n     * @param name the string to check\n     * @return <code>true</code> if the string is a well-formed tag name,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isValidTagName(String name) {\n        boolean result = (name.length() > 0 && (Character.isLetter(name.charAt(0)) || name.charAt(0) == '_'));\n        for (int i = 1; i < name.length() && result; i++) result = (Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_');\n        return result;\n    }\n\n    // isValidTagName(String name)\n    /**\n     * Removes invalid characters from tag names.\n     *\n     * @param name the name of the tag\n     * @return the name of the tag without invalid characters\n     */\n    public static String makeTagNameValid(String name) {\n        StringBuffer retBuffer = new StringBuffer();\n        for (int i = 0; i < name.length(); i++) {\n            if ((Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_')) {\n                retBuffer.append(name.charAt(i));\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n// XDomSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XDomSupportTest3.java",
		"test_prompt": "// XDomSupportTest3.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XDomSupport}.\n* It contains ten unit test cases for the {@link XDomSupport#getChildElementsByValue(Node, String, String)} method.\n*/\nclass XDomSupportTest3 {"
	},
	{
		"original_code": "// XDomSupport.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>XDomSupport</code> is a collection of operations on DOM trees. It\n * extends the possibilities offered in the <code>org.w3c.dom</code> package.\n *\n * @author Stephan D�wel\n */\npublic abstract class XDomSupport {\n\n    /**\n     * <code>getChildNodesByAttrValue</code> retrieves child nodes selected by\n     * a certain value of a certain attribute. Child nodes without the specified\n     * attribute are not selected.\n     *\n     * @param parent the node for which children are searched\n     * @param attrName the attribute to check\n     * @param attrValue the attribute's value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code>,\n     *             <code>attrName</code> or <code>attrValue</code> are\n     *             <code>null</code> or <code>attrName</code> is empty\n     */\n    public static List getChildNodesByAttrValue(Node parent, String attrName, String attrValue, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (attrName == null || attrName.length() == 0)\n            throw new IllegalArgumentException(\"Attribute name may not be empty\");\n        if (attrValue == null)\n            throw new IllegalArgumentException(\"Attribute value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && ((Element) child).getAttribute(attrName).equals(attrValue))\n                if (nodeTag != null && nodeTag.length() > 0)\n                    // Tag name must be checked\n                    if (child.getNodeName().equals(nodeTag))\n                        result.add(child);\n                    else\n                        result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildNodesByAttrValue (Node parent, String attrName, String\n    // attrValue, String nodeTag)\n    public static String getNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getNodeText(Node node)\n    /**\n     * <code>getTrimedNodeText</code> retrieves the value for a node\n     * representing the corresponding xml tag.\n     *\n     * @param node the node representing the xml tag\n     * @return the value stored within the xml tag, the string is trimed for\n     *         leading and ending white space\n     */\n    public static String getTrimedNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n                foundValue = foundValue.trim();\n                // trim in between\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getTrimedNodeText(Node node)\n    /**\n     * <code>getChildElementsByValue</code> retrieves child nodes of type\n     * element selected by a certain for the value stored with them.\n     *\n     * @param parent the node for which children are searched\n     * @param value the value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code> or\n     *             <code>value</code> are <code>null</code>\n     */\n    public static List getChildElementsByValue(Node parent, String value, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (value == null)\n            throw new IllegalArgumentException(\"Value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && (nodeTag == null || nodeTag.length() == 0 || child.getNodeName().equals(nodeTag)) && value.equals(getTrimedNodeText(child)))\n                result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildElementsByValue (Node parent, String value, String nodeTag)\n    /**\n     * <code>getNextNodeIndexIgnoringFormatingText</code> retrieves the\n     * position of the next node after the position <code>startPos</code>\n     * within the list <code>nodes</code> which is not a text node only\n     * containing whitespace.\n     *\n     * @param nodes the node list\n     * @param startPos the position to start from\n     * @return the position; -1 if no node was found\n     */\n    public static int getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos) {\n        int pos;\n        boolean nodeNotFound = true;\n        for (pos = startPos; pos < nodes.getLength() && nodeNotFound; pos++) {\n            // Search all nodes afetr position <startpos>\n            Node node = nodes.item(pos);\n            if (node != null && (node.getNodeType() != Node.TEXT_NODE || node.getNodeValue().trim().length() > 0))\n                nodeNotFound = false;\n        }\n        if (nodeNotFound)\n            pos = -1;\n        else\n            // <pos> incremented once in for loop after finding the node\n            pos--;\n        return pos;\n    }\n\n    // getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos)\n    /**\n     * <code>deleteWhitespaceTextInElementNodes</code> deletes all text nodes\n     * containing only whitespace within xml tags. This operation is useful to\n     * get rid of formatting information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodes(Document doc) throws XException {\n        IteratedWhitespaceInElementDeletion itop = new IteratedWhitespaceInElementDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodes(Document doc)\n    /**\n     * <code>deleteWhitespaceTextInElementNodesAndComments</code> deletes all\n     * text nodes containing only whitespace within xml tags and all comment\n     * nodes. This operation is useful to get rid of formatting and editor\n     * information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodesAndComments(Document doc) throws XException {\n        IteratedWhitespaceInElementAndCommentDeletion itop = new IteratedWhitespaceInElementAndCommentDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodesAndComments(Document doc)\n    /**\n     * <code>traversePreOrder</code> traverses a DOM tree in pre-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePreOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePreOrder(root, itop);\n    }\n\n    // traversePreOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePreOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It executes the specified operation on the specified\n     * node and proceeds to its children. The traversal may treat dynamically\n     * deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    private static void recursivePreOrder(Node node, IteratedNodeOperation itop) throws XException {\n        itop.iteratedProcedure(node);\n        // Process the actual node ...\n        if (node.hasChildNodes()) {\n            // ... and then all its children\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePreOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n    }\n\n    // recursivePreOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>traversePostOrder</code> traverses a DOM tree in post-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePostOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePostOrder(root, itop);\n    }\n\n    // traversePostOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePostOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It proceeds on all children of the specified node\n     * and then executes the specified operation on the node itself. The\n     * traversal may treat dynamically deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void recursivePostOrder(Node node, IteratedNodeOperation itop) throws XException {\n        if (node.hasChildNodes()) {\n            // Process all children of the actual node ...\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePostOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n        itop.iteratedProcedure(node);\n        // ... and then the actual node itself\n    }\n\n    // recursivePostOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>isValidTagName</code> checks if a string conforms to the\n     * conventions for xml tag names.\n     *\n     * @param name the string to check\n     * @return <code>true</code> if the string is a well-formed tag name,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isValidTagName(String name) {\n        boolean result = (name.length() > 0 && (Character.isLetter(name.charAt(0)) || name.charAt(0) == '_'));\n        for (int i = 1; i < name.length() && result; i++) result = (Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_');\n        return result;\n    }\n\n    // isValidTagName(String name)\n    /**\n     * Removes invalid characters from tag names.\n     *\n     * @param name the name of the tag\n     * @return the name of the tag without invalid characters\n     */\n    public static String makeTagNameValid(String name) {\n        StringBuffer retBuffer = new StringBuffer();\n        for (int i = 0; i < name.length(); i++) {\n            if ((Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_')) {\n                retBuffer.append(name.charAt(i));\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n// XDomSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XDomSupportTest4.java",
		"test_prompt": "// XDomSupportTest4.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XDomSupport}.\n* It contains ten unit test cases for the {@link XDomSupport#getNextNodeIndexIgnoringFormatingText(NodeList, int)} method.\n*/\nclass XDomSupportTest4 {"
	},
	{
		"original_code": "// XDomSupport.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>XDomSupport</code> is a collection of operations on DOM trees. It\n * extends the possibilities offered in the <code>org.w3c.dom</code> package.\n *\n * @author Stephan D�wel\n */\npublic abstract class XDomSupport {\n\n    /**\n     * <code>getChildNodesByAttrValue</code> retrieves child nodes selected by\n     * a certain value of a certain attribute. Child nodes without the specified\n     * attribute are not selected.\n     *\n     * @param parent the node for which children are searched\n     * @param attrName the attribute to check\n     * @param attrValue the attribute's value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code>,\n     *             <code>attrName</code> or <code>attrValue</code> are\n     *             <code>null</code> or <code>attrName</code> is empty\n     */\n    public static List getChildNodesByAttrValue(Node parent, String attrName, String attrValue, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (attrName == null || attrName.length() == 0)\n            throw new IllegalArgumentException(\"Attribute name may not be empty\");\n        if (attrValue == null)\n            throw new IllegalArgumentException(\"Attribute value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && ((Element) child).getAttribute(attrName).equals(attrValue))\n                if (nodeTag != null && nodeTag.length() > 0)\n                    // Tag name must be checked\n                    if (child.getNodeName().equals(nodeTag))\n                        result.add(child);\n                    else\n                        result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildNodesByAttrValue (Node parent, String attrName, String\n    // attrValue, String nodeTag)\n    public static String getNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getNodeText(Node node)\n    /**\n     * <code>getTrimedNodeText</code> retrieves the value for a node\n     * representing the corresponding xml tag.\n     *\n     * @param node the node representing the xml tag\n     * @return the value stored within the xml tag, the string is trimed for\n     *         leading and ending white space\n     */\n    public static String getTrimedNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n                foundValue = foundValue.trim();\n                // trim in between\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getTrimedNodeText(Node node)\n    /**\n     * <code>getChildElementsByValue</code> retrieves child nodes of type\n     * element selected by a certain for the value stored with them.\n     *\n     * @param parent the node for which children are searched\n     * @param value the value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code> or\n     *             <code>value</code> are <code>null</code>\n     */\n    public static List getChildElementsByValue(Node parent, String value, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (value == null)\n            throw new IllegalArgumentException(\"Value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && (nodeTag == null || nodeTag.length() == 0 || child.getNodeName().equals(nodeTag)) && value.equals(getTrimedNodeText(child)))\n                result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildElementsByValue (Node parent, String value, String nodeTag)\n    /**\n     * <code>getNextNodeIndexIgnoringFormatingText</code> retrieves the\n     * position of the next node after the position <code>startPos</code>\n     * within the list <code>nodes</code> which is not a text node only\n     * containing whitespace.\n     *\n     * @param nodes the node list\n     * @param startPos the position to start from\n     * @return the position; -1 if no node was found\n     */\n    public static int getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos) {\n        int pos;\n        boolean nodeNotFound = true;\n        for (pos = startPos; pos < nodes.getLength() && nodeNotFound; pos++) {\n            // Search all nodes afetr position <startpos>\n            Node node = nodes.item(pos);\n            if (node != null && (node.getNodeType() != Node.TEXT_NODE || node.getNodeValue().trim().length() > 0))\n                nodeNotFound = false;\n        }\n        if (nodeNotFound)\n            pos = -1;\n        else\n            // <pos> incremented once in for loop after finding the node\n            pos--;\n        return pos;\n    }\n\n    // getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos)\n    /**\n     * <code>deleteWhitespaceTextInElementNodes</code> deletes all text nodes\n     * containing only whitespace within xml tags. This operation is useful to\n     * get rid of formatting information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodes(Document doc) throws XException {\n        IteratedWhitespaceInElementDeletion itop = new IteratedWhitespaceInElementDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodes(Document doc)\n    /**\n     * <code>deleteWhitespaceTextInElementNodesAndComments</code> deletes all\n     * text nodes containing only whitespace within xml tags and all comment\n     * nodes. This operation is useful to get rid of formatting and editor\n     * information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodesAndComments(Document doc) throws XException {\n        IteratedWhitespaceInElementAndCommentDeletion itop = new IteratedWhitespaceInElementAndCommentDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodesAndComments(Document doc)\n    /**\n     * <code>traversePreOrder</code> traverses a DOM tree in pre-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePreOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePreOrder(root, itop);\n    }\n\n    // traversePreOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePreOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It executes the specified operation on the specified\n     * node and proceeds to its children. The traversal may treat dynamically\n     * deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    private static void recursivePreOrder(Node node, IteratedNodeOperation itop) throws XException {\n        itop.iteratedProcedure(node);\n        // Process the actual node ...\n        if (node.hasChildNodes()) {\n            // ... and then all its children\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePreOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n    }\n\n    // recursivePreOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>traversePostOrder</code> traverses a DOM tree in post-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePostOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePostOrder(root, itop);\n    }\n\n    // traversePostOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePostOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It proceeds on all children of the specified node\n     * and then executes the specified operation on the node itself. The\n     * traversal may treat dynamically deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void recursivePostOrder(Node node, IteratedNodeOperation itop) throws XException {\n        if (node.hasChildNodes()) {\n            // Process all children of the actual node ...\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePostOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n        itop.iteratedProcedure(node);\n        // ... and then the actual node itself\n    }\n\n    // recursivePostOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>isValidTagName</code> checks if a string conforms to the\n     * conventions for xml tag names.\n     *\n     * @param name the string to check\n     * @return <code>true</code> if the string is a well-formed tag name,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isValidTagName(String name) {\n        boolean result = (name.length() > 0 && (Character.isLetter(name.charAt(0)) || name.charAt(0) == '_'));\n        for (int i = 1; i < name.length() && result; i++) result = (Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_');\n        return result;\n    }\n\n    // isValidTagName(String name)\n    /**\n     * Removes invalid characters from tag names.\n     *\n     * @param name the name of the tag\n     * @return the name of the tag without invalid characters\n     */\n    public static String makeTagNameValid(String name) {\n        StringBuffer retBuffer = new StringBuffer();\n        for (int i = 0; i < name.length(); i++) {\n            if ((Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_')) {\n                retBuffer.append(name.charAt(i));\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n// XDomSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XDomSupportTest5.java",
		"test_prompt": "// XDomSupportTest5.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XDomSupport}.\n* It contains ten unit test cases for the {@link XDomSupport#isValidTagName(String)} method.\n*/\nclass XDomSupportTest5 {"
	},
	{
		"original_code": "// XDomSupport.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\n/**\n * <code>XDomSupport</code> is a collection of operations on DOM trees. It\n * extends the possibilities offered in the <code>org.w3c.dom</code> package.\n *\n * @author Stephan D�wel\n */\npublic abstract class XDomSupport {\n\n    /**\n     * <code>getChildNodesByAttrValue</code> retrieves child nodes selected by\n     * a certain value of a certain attribute. Child nodes without the specified\n     * attribute are not selected.\n     *\n     * @param parent the node for which children are searched\n     * @param attrName the attribute to check\n     * @param attrValue the attribute's value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code>,\n     *             <code>attrName</code> or <code>attrValue</code> are\n     *             <code>null</code> or <code>attrName</code> is empty\n     */\n    public static List getChildNodesByAttrValue(Node parent, String attrName, String attrValue, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (attrName == null || attrName.length() == 0)\n            throw new IllegalArgumentException(\"Attribute name may not be empty\");\n        if (attrValue == null)\n            throw new IllegalArgumentException(\"Attribute value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && ((Element) child).getAttribute(attrName).equals(attrValue))\n                if (nodeTag != null && nodeTag.length() > 0)\n                    // Tag name must be checked\n                    if (child.getNodeName().equals(nodeTag))\n                        result.add(child);\n                    else\n                        result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildNodesByAttrValue (Node parent, String attrName, String\n    // attrValue, String nodeTag)\n    public static String getNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getNodeText(Node node)\n    /**\n     * <code>getTrimedNodeText</code> retrieves the value for a node\n     * representing the corresponding xml tag.\n     *\n     * @param node the node representing the xml tag\n     * @return the value stored within the xml tag, the string is trimed for\n     *         leading and ending white space\n     */\n    public static String getTrimedNodeText(Node node) {\n        // The value is stored in child nodes of type Text\n        NodeList children = node.getChildNodes();\n        String foundValue = \"\";\n        for (int j = 0; j < children.getLength(); j++) {\n            // Check all children\n            Node child = children.item(j);\n            if (child.getNodeType() == Node.TEXT_NODE) {\n                // Concatenate all text node contents\n                foundValue = foundValue.concat(child.getNodeValue());\n                foundValue = foundValue.trim();\n                // trim in between\n            }\n            // if (child.getNodeType()==Node.TEXT_NODE)\n        }\n        // for (int j=0; j<children.getLength(); j++)\n        return foundValue;\n    }\n\n    // getTrimedNodeText(Node node)\n    /**\n     * <code>getChildElementsByValue</code> retrieves child nodes of type\n     * element selected by a certain for the value stored with them.\n     *\n     * @param parent the node for which children are searched\n     * @param value the value to search for\n     * @param nodeTag the tag name for the searched child nodes, if\n     *            <code>null</code> or empty string the tag name is not used\n     *            for the selection\n     * @return the list of selected child nodes\n     * @throws IllegalArgumentException in case that <code>parent</code> or\n     *             <code>value</code> are <code>null</code>\n     */\n    public static List getChildElementsByValue(Node parent, String value, String nodeTag) throws IllegalArgumentException {\n        if (parent == null)\n            throw new IllegalArgumentException(\"Parent node may not be null\");\n        if (value == null)\n            throw new IllegalArgumentException(\"Value may not be null\");\n        LinkedList result = new LinkedList();\n        NodeList children = parent.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            // Check all children\n            Node child = children.item(i);\n            if (child.getNodeType() == Node.ELEMENT_NODE && (nodeTag == null || nodeTag.length() == 0 || child.getNodeName().equals(nodeTag)) && value.equals(getTrimedNodeText(child)))\n                result.add(child);\n        }\n        // for (int i=0; i<children.getLength(); i++)\n        return result;\n    }\n\n    // getChildElementsByValue (Node parent, String value, String nodeTag)\n    /**\n     * <code>getNextNodeIndexIgnoringFormatingText</code> retrieves the\n     * position of the next node after the position <code>startPos</code>\n     * within the list <code>nodes</code> which is not a text node only\n     * containing whitespace.\n     *\n     * @param nodes the node list\n     * @param startPos the position to start from\n     * @return the position; -1 if no node was found\n     */\n    public static int getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos) {\n        int pos;\n        boolean nodeNotFound = true;\n        for (pos = startPos; pos < nodes.getLength() && nodeNotFound; pos++) {\n            // Search all nodes afetr position <startpos>\n            Node node = nodes.item(pos);\n            if (node != null && (node.getNodeType() != Node.TEXT_NODE || node.getNodeValue().trim().length() > 0))\n                nodeNotFound = false;\n        }\n        if (nodeNotFound)\n            pos = -1;\n        else\n            // <pos> incremented once in for loop after finding the node\n            pos--;\n        return pos;\n    }\n\n    // getNextNodeIndexIgnoringFormatingText(NodeList nodes, int startPos)\n    /**\n     * <code>deleteWhitespaceTextInElementNodes</code> deletes all text nodes\n     * containing only whitespace within xml tags. This operation is useful to\n     * get rid of formatting information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodes(Document doc) throws XException {\n        IteratedWhitespaceInElementDeletion itop = new IteratedWhitespaceInElementDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodes(Document doc)\n    /**\n     * <code>deleteWhitespaceTextInElementNodesAndComments</code> deletes all\n     * text nodes containing only whitespace within xml tags and all comment\n     * nodes. This operation is useful to get rid of formatting and editor\n     * information in a parsed xml file.\n     *\n     * @param doc the DOM tree to clean\n     * @throws XException only for syntactical reasons (use of a generic\n     *             traversal method)\n     */\n    public static void deleteWhitespaceTextInElementNodesAndComments(Document doc) throws XException {\n        IteratedWhitespaceInElementAndCommentDeletion itop = new IteratedWhitespaceInElementAndCommentDeletion();\n        traversePreOrder(doc, itop);\n    }\n\n    // deleteWhitespaceTextInElementNodesAndComments(Document doc)\n    /**\n     * <code>traversePreOrder</code> traverses a DOM tree in pre-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePreOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePreOrder(root, itop);\n    }\n\n    // traversePreOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePreOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It executes the specified operation on the specified\n     * node and proceeds to its children. The traversal may treat dynamically\n     * deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    private static void recursivePreOrder(Node node, IteratedNodeOperation itop) throws XException {\n        itop.iteratedProcedure(node);\n        // Process the actual node ...\n        if (node.hasChildNodes()) {\n            // ... and then all its children\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePreOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n    }\n\n    // recursivePreOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>traversePostOrder</code> traverses a DOM tree in post-order and\n     * executes the specified operation on each node. The traversal may treat\n     * dynamically deleted nodes but no extensions.\n     *\n     * @param doc the DOM tree to traverse\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void traversePostOrder(Document doc, IteratedNodeOperation itop) throws XException {\n        // Start at root\n        Element root = null;\n        root = doc.getDocumentElement();\n        if (root != null)\n            // Continue recursively.\n            recursivePostOrder(root, itop);\n    }\n\n    // traversePostOrder(Document doc, IteratedNodeOperation itop)\n    /**\n     * <code>recursivePostOrder</code> is the recursive heart of DOM tree\n     * pre-order traversal. It proceeds on all children of the specified node\n     * and then executes the specified operation on the node itself. The\n     * traversal may treat dynamically deleted nodes but no extensions.\n     *\n     * @param node the actual node\n     * @param itop the operation to execute\n     * @throws XException in case that <code>itop</code> throws one\n     */\n    public static void recursivePostOrder(Node node, IteratedNodeOperation itop) throws XException {\n        if (node.hasChildNodes()) {\n            // Process all children of the actual node ...\n            NodeList children = node.getChildNodes();\n            int childCount = children.getLength();\n            // Save it for the case of node deletion.\n            for (int i = 0; i < childCount; i++) recursivePostOrder(children.item(i - childCount + children.getLength()), itop);\n            // with correction for node deletion\n        }\n        // if (node.hasChildNodes())\n        itop.iteratedProcedure(node);\n        // ... and then the actual node itself\n    }\n\n    // recursivePostOrder(Node node, IteratedNodeOperation itop)\n    /**\n     * <code>isValidTagName</code> checks if a string conforms to the\n     * conventions for xml tag names.\n     *\n     * @param name the string to check\n     * @return <code>true</code> if the string is a well-formed tag name,\n     *         otherwise <code>false</code>\n     */\n    public static boolean isValidTagName(String name) {\n        boolean result = (name.length() > 0 && (Character.isLetter(name.charAt(0)) || name.charAt(0) == '_'));\n        for (int i = 1; i < name.length() && result; i++) result = (Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_');\n        return result;\n    }\n\n    // isValidTagName(String name)\n    /**\n     * Removes invalid characters from tag names.\n     *\n     * @param name the name of the tag\n     * @return the name of the tag without invalid characters\n     */\n    public static String makeTagNameValid(String name) {\n        StringBuffer retBuffer = new StringBuffer();\n        for (int i = 0; i < name.length(); i++) {\n            if ((Character.isLetter(name.charAt(i)) || Character.isDigit(name.charAt(i)) || name.charAt(i) == '_')) {\n                retBuffer.append(name.charAt(i));\n            }\n        }\n        return retBuffer.toString();\n    }\n}\n// XDomSupport\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XDomSupportTest6.java",
		"test_prompt": "// XDomSupportTest6.java\npackage net.sf.xbus.base.xml;\n\nimport java.util.LinkedList;\nimport java.util.List;\nimport net.sf.xbus.base.core.XException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XDomSupport}.\n* It contains ten unit test cases for the {@link XDomSupport#makeTagNameValid(String)} method.\n*/\nclass XDomSupportTest6 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest0.java",
		"test_prompt": "// XMLHelperTest0.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#getTagAttribute(Document, String, String)} method.\n*/\nclass XMLHelperTest0 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest1.java",
		"test_prompt": "// XMLHelperTest1.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#getAttribute(Node, String)} method.\n*/\nclass XMLHelperTest1 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest2.java",
		"test_prompt": "// XMLHelperTest2.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#getTagCDATA(Document, String)} method.\n*/\nclass XMLHelperTest2 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest3.java",
		"test_prompt": "// XMLHelperTest3.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#getTagText(Document, String)} method.\n*/\nclass XMLHelperTest3 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest4.java",
		"test_prompt": "// XMLHelperTest4.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#getNodeText(Node)} method.\n*/\nclass XMLHelperTest4 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest5.java",
		"test_prompt": "// XMLHelperTest5.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#getTagTextList(Document, String)} method.\n*/\nclass XMLHelperTest5 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest6.java",
		"test_prompt": "// XMLHelperTest6.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#parseXML(String, String, String)} method.\n*/\nclass XMLHelperTest6 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest7.java",
		"test_prompt": "// XMLHelperTest7.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#getDocumentBuilder(String, String)} method.\n*/\nclass XMLHelperTest7 {"
	},
	{
		"original_code": "// XMLHelper.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\n/**\n * <code>XMLHelper</code> offers some support for treating XML structures.\n *\n * @author Stefan Fleckenstein\n */\npublic class XMLHelper {\n\n    private static final String DOUBLELINEFEED = \"\\n\\n\";\n\n    private static final String DOUBLELINESEPARATOR = Constants.LINE_SEPERATOR + Constants.LINE_SEPERATOR;\n\n    /**\n     * <code>getTagAttribute</code> gets the text of the attribute named\n     * <code>attr</code> in the first occurence of the <code>tag</code> in\n     * the given <code>org.w3c.dom.Document</code>.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain the attribute <code>attr</code>.\n     */\n    static public String getTagAttribute(Document doc, String tag, String attr) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            retText = getAttribute(currentTag, attr);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagAttribute(Document doc, String tag, String attr)\n    /**\n     * Returns the value of the attribute.\n     *\n     * @param node\n     *            the node which shall contain the attribute\n     * @param attr\n     *            the attribute name to search for\n     * @return the attribute value or <code>null</code> if the node does not\n     *         contain the attribute <code>attr</code>.\n     */\n    public static String getAttribute(Node node, String attr) {\n        String retText = null;\n        NamedNodeMap attributes = node.getAttributes();\n        // its attributes\n        boolean textFound = false;\n        // for terminating search loop\n        for (int j = 0; (!textFound) && (j < attributes.getLength()); j++) {\n            // loop over attributes\n            if (attributes.item(j).getNodeName().equals(attr)) {\n                // searched attribute found\n                retText = attributes.item(j).getNodeValue();\n                // return its value\n                textFound = true;\n            }\n            // if (attributes.item(j).getNodeName().equals(attr))\n        }\n        // for (int j = 0;(!textFound) && (j < attributes.getLength()); j++)\n        return retText;\n    }\n\n    /**\n     * <code>getTagCDATA</code> gets the content of the first CDATA section in\n     * the first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the CDATA section value or <code>null</code> if the no\n     *         <code>tag</code> node exists or if the first <code>tag</code>\n     *         node does not contain a CDATA section labelled with\n     *         <code>tag</code> exists.\n     */\n    static public String getTagCDATA(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node currentTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            currentTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = currentTag.getChildNodes();\n            // its child nodes\n            boolean textFound = false;\n            // for terminating search loop\n            for (int j = 0; (!textFound) && j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                if (grandchildren.item(j).getNodeType() == Node.CDATA_SECTION_NODE) {\n                    // CDATA section found\n                    retText = grandchildren.item(j).getNodeValue();\n                    // return its value\n                    textFound = true;\n                }\n                // if\n                // (grandchildren.item(j).getNodeType()==Node.CDATA_SECTION_NODE)\n            }\n            // for (int j = 0;(!textFound) && j < grandchildren.getLength();\n            // j++)\n        }\n        // if (children.getLength() > 0)\n        /*\n\t\t * Workaround, since the Serializer disturbs the linefeeds of the CDATA\n\t\t */\n        if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED)) {\n            retText = retText.replaceAll(DOUBLELINEFEED, Constants.LINE_SEPERATOR);\n        }\n        // if (!DOUBLELINESEPARATOR.equals(DOUBLELINEFEED))\n        return retText;\n    }\n\n    // getTagCDATA(Document doc, String tag)\n    /**\n     * Gets the text of the first occurence of the <code>tag</code> in the\n     * given <code>org.w3c.dom.Document</code>. Exactly spoken, it retrieves\n     * the value of the first text node of that occurence.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     */\n    static public String getTagText(Document doc, String tag) {\n        String retText = null;\n        // for the result\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            retText = getNodeText(foundTag);\n        }\n        // if (children.getLength() > 0)\n        return retText;\n    }\n\n    // getTagText(Document doc, String tag)\n    public static String getNodeText(Node tag) {\n        String retText = null;\n        NodeList children = tag.getChildNodes();\n        boolean textFound = false;\n        for (int j = 0; (!textFound) && j < children.getLength(); j++) {\n            if (children.item(j).getNodeType() == Node.TEXT_NODE) {\n                retText = children.item(j).getNodeValue();\n                textFound = true;\n            }\n        }\n        return retText;\n    }\n\n    /**\n     * Gets the name/value list composed by the child element nodes of the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. The mentioned name is the tag of\n     * the child node and the value in the name/value pair just the node value.\n     * Child nodes other than element nodes are ignored. The value is extracted\n     * from the first child node of the element node - if this one is a text\n     * node. All other child nodes are ignored.\n     *\n     * @param doc\n     *            the document in which to search\n     * @param tag\n     *            the tag to serch for\n     * @return the text value or <code>null</code> if no <code>tag</code>\n     *         node exists of if the first one does nor contain text.\n     * @throws XException\n     *             if one of the examined element nodes for a name/value pair\n     *             has no child or another node than a text node as first child\n     */\n    static public Hashtable getTagTextList(Document doc, String tag) throws XException {\n        Hashtable retTable = null;\n        // for return object\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            retTable = new Hashtable();\n            foundTag = children.item(0);\n            // first occurence of searched tag\n            NodeList grandchildren = foundTag.getChildNodes();\n            // its child nodes\n            for (int j = 0; j < grandchildren.getLength(); j++) {\n                // loop over child nodes\n                Node grand = grandchildren.item(j);\n                if (grand.getNodeType() == Node.ELEMENT_NODE) {\n                    // element node found\n                    Node grand2 = grandchildren.item(j).getFirstChild();\n                    if ((grand2 != null) && (grand2.getNodeType() == Node.TEXT_NODE)) {\n                        // text node found to read the value\n                        String nodeName = grandchildren.item(j).getNodeName();\n                        String nodeValue = grand2.getNodeValue();\n                        retTable.put(nodeName, nodeValue);\n                    } else // then ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                    {\n                        // no child or one of wrong node type\n                        throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"1\");\n                    }\n                    // else ((grand2 != null) && (grand2.getNodeType() ==\n                    // Node.TEXT_NODE))\n                }\n                // if (grand.getNodeType() == Node.ELEMENT_NODE)\n            }\n            // for (int j = 0; j < grandchildren.getLength(); j++)\n        }\n        // if (children.getLength() > 0)\n        return retTable;\n    }\n\n    // getTagTextList(Document doc, String tag)\n    /**\n     * <code>setTagTextList</code> stotes a list of name/value pairs in the\n     * first occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. Each pair makes up an element node\n     * with the given name as tag and the given value as node value (in a text\n     * node). If the <code>tag</code> doesn't exist, nothing happens. If\n     * <code>tag</code> exists, its previous content is replaced by the list\n     * of text nodes.\n     *\n     * @param doc\n     *            the <code>org.w3c.dom.Document</code> containing the tag\n     * @param tag\n     *            name of the tag that should be replaced\n     * @param entries\n     *            contains the data for the list of text nodes. Both keys and\n     *            elements must be of type <code>String</code>. The keys are\n     *            treated as tag names, the elements are treated as values for\n     *            the text nodes.\n     */\n    static public void setTagTextList(Document doc, String tag, Hashtable entries) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            for (Enumeration e = entries.keys(); e.hasMoreElements(); ) {\n                // loop over name/value pairs\n                String key = (String) e.nextElement();\n                Element child = doc.createElement(key);\n                // the element node from the name ...\n                child.appendChild(doc.createTextNode((String) entries.get(key)));\n                // ... plus the text node for the value\n                newElement.appendChild(child);\n                // to the tag node\n            }\n            // for (Enumeration enum = entries.keys();\n            // enum.hasMoreElements();)\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node containg the name/value pairs\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagTextList(Document doc, String tag, Hashtable entries)\n    /**\n     * <code>setTagText</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>. If the <code>tag</code> doesn't\n     * exist, nothing happens, otherwise the corresponding node is completely\n     * replaced.\n     */\n    static public void setTagText(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createTextNode(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagText(Document doc, String tag, String text)\n    /**\n     * <code>setTagCDATA</code> sets the <code>text</code> in the first\n     * occurence of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code> as CDATA section. If the\n     * <code>tag</code> doesn't exist, nothing happens, otherwise the\n     * corresponding node is completely replaced.\n     */\n    static public void setTagCDATA(Document doc, String tag, String text) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        if (children.getLength() > 0) {\n            // some nodes with searched tag found\n            Element newElement = doc.createElement(tag);\n            // The old tag node will just be replaced.\n            newElement.appendChild(doc.createCDATASection(text));\n            // the value to store\n            Node oldTag = children.item(0);\n            // Replace the first tag occurence ...\n            Node father = oldTag.getParentNode();\n            // ... in its parent node ...\n            father.replaceChild(newElement, oldTag);\n            // by the newly constructed node\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // setTagCDATA(Document doc, String tag, String text)\n    /**\n     * Deletes the first occurance of the <code>tag</code> in the given\n     * <code>org.w3c.dom.Document</code>.\n     * <p>\n     * Does nothing if the <code>tag</code> doesn't exist.\n     */\n    static public void deleteTag(Document doc, String tag) {\n        NodeList children = doc.getElementsByTagName(tag);\n        // all nodes with the specified tag\n        Node foundTag;\n        if (children.getLength() > 0) {\n            foundTag = children.item(0);\n            // the first tag occurence ...\n            Node father = foundTag.getParentNode();\n            // its parent node\n            father.removeChild(foundTag);\n        }\n        // if (children.getLength() > 0)\n    }\n\n    // deleteTag(Document doc, String tag)\n    /**\n     * Parses the given XML string.\n     */\n    static public Document parseXML(String xml, String messageName, String system) throws XException {\n        Document retDocument = null;\n        if (messageName == null) {\n            messageName = \"Default\";\n        }\n        if ((xml != null) && (xml.length() > 0)) {\n            try {\n                ByteArrayInputStream xmlStream = new ByteArrayInputStream(xml.getBytes(Constants.getXMLEncoding()));\n                InputSource inputSource = new InputSource(xmlStream);\n                String systemString = new StringBuffer().append(Constants.XBUS_ETC).append(\"dtd\").append(Constants.FILE_SEPERATOR).toString();\n                String systemId = new File(systemString).toURL().toString();\n                inputSource.setSystemId(systemId);\n                DOMParser parser = new DOMParser();\n                parser.setFeature(\"http://xml.org/sax/features/validation\", getValidating(messageName, system));\n                parser.setFeature(\"http://xml.org/sax/features/namespaces\", getNamespaceAware(messageName, system));\n                String schema = getXMLSchema(messageName, system);\n                if (schema != null) {\n                    parser.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n                    parser.setFeature(\"http://xml.org/sax/features/validation\", true);\n                    parser.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n                    parser.setProperty(\"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation\", new StringBuffer().append(Constants.XBUS_ETC).append(\"Schema\").append(Constants.FILE_SEPERATOR).append(schema).toString());\n                }\n                parser.setErrorHandler(new XParserErrorHandler());\n                parser.parse(inputSource);\n                retDocument = parser.getDocument();\n            } catch (Exception e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return retDocument;\n    }\n\n    /**\n     * Returns a <code>DocumentBuilder</code> needed for parsing. For better\n     * performance, <code>DocumentBuilders</code> are cached per thread. Due\n     * to the message type the parser may be instructed\n     * <ul>\n     * <li>to ignore whitespace in elements,</li>\n     * <li>to ignore comments,</li>\n     * <li>to validate the xml document against its DTD.</li>\n     * </ul>\n     * Configuration keys control these options.\n     *\n     * @return a {@link javax.xml.parsers.DocumentBuilder DocumentBuilder}\n     *         object for xml parsing\n     * @throws XException\n     *             in case that any problem with instantiating the\n     *             <code>DocumentBuilder</code> object arises\n     */\n    static public DocumentBuilder getDocumentBuilder(String messageName, String system) throws XException {\n        DocumentBuilder docBuilder;\n        if (messageName == null) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"2\");\n        }\n        try // to cast to XException\n        {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setIgnoringComments(getIgnoringComments(messageName, system));\n            factory.setIgnoringElementContentWhitespace(getIgnoringElementContentWhitespace(messageName, system));\n            factory.setValidating(getValidating(messageName, system));\n            factory.setNamespaceAware(getNamespaceAware(messageName, system));\n            docBuilder = factory.newDocumentBuilder();\n            docBuilder.setErrorHandler(new XParserErrorHandler());\n        }// try\n         catch (ParserConfigurationException e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        // catch\n        return docBuilder;\n    }\n\n    // getDocumentBuilder()\n    private static boolean getIgnoringComments(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringComments = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringComments\");\n        if (system != null) {\n            setIgnoringComments = setIgnoringComments || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringComments\");\n        }\n        return setIgnoringComments;\n    }\n\n    private static boolean getIgnoringElementContentWhitespace(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setIgnoringElementContentWhitespace = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"IgnoringElementContentWhitespace\");\n        if (system != null) {\n            setIgnoringElementContentWhitespace = setIgnoringElementContentWhitespace || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"IgnoringElementContentWhitespace\");\n        }\n        return setIgnoringElementContentWhitespace;\n    }\n\n    private static boolean getValidating(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setValidating = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"XMLValidating\");\n        if (system != null) {\n            setValidating = setValidating || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"XMLValidating\");\n        }\n        return setValidating;\n    }\n\n    private static String getXMLSchema(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        String schema = null;\n        if (system != null) {\n            schema = standConf.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"XMLSchema\");\n        }\n        if (schema == null) {\n            schema = xbusConf.getValueOptional(\"ParserSettings\", messageName, \"XMLSchema\");\n        }\n        return schema;\n    }\n\n    private static boolean getNamespaceAware(String messageName, String system) throws XException {\n        Configuration standConf = Configuration.getInstance();\n        Configuration xbusConf = Configuration.getInstance(\"xbus\");\n        boolean setNamespaceAware = xbusConf.getValueAsBoolean(\"ParserSettings\", messageName, \"NamespaceAware\");\n        if (system != null) {\n            setNamespaceAware = setNamespaceAware || standConf.getValueAsBooleanOptional(Constants.CHAPTER_SYSTEM, system, \"NamespaceAware\");\n        }\n        return setNamespaceAware;\n    }\n\n    /**\n     * Serializes a XML document.\n     *\n     * @param doc\n     *            the given <code>org.w3c.dom.Document</code> to be serialized\n     * @param systemID\n     *            reference to the DTD of the XML document\n     * @return the content of the XML document in its string representation\n     */\n    static public String serializeXML(Document doc, String systemID) throws XException {\n        String xmlData = null;\n        if (doc != null) {\n            Transformer serializer = getSerializer(systemID);\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            try {\n                serializer.transform(new DOMSource(doc), new StreamResult(outStream));\n                xmlData = outStream.toString(Constants.getXMLEncoding());\n                outStream.close();\n                // The serializer contains a bug and replaces DOS line breaks\n                // \"\\r\\n\" by \"\\r\\r\\n\" within any element text.\n                // This is corrected in the follwing instruction.\n                xmlData = xmlData.replaceAll(\"\\r\\r\\n\", \"\\r\\n\");\n            } catch (TransformerException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            } catch (IOException e) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n            }\n        }\n        return xmlData;\n    }\n\n    /**\n     * Returns a <code>Serializer</code> needed for serializing XML documents.\n     */\n    static private Transformer getSerializer(String systemID) throws XException {\n        setTransformerProperties();\n        Transformer serializer;\n        TransformerFactory tfactory = TransformerFactory.newInstance();\n        // This creates a transformer that does a simple identity transform,\n        // and thus can be used for all intents and purposes as a serializer.\n        try {\n            serializer = tfactory.newTransformer();\n            serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            serializer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n            serializer.setOutputProperty(OutputKeys.ENCODING, Constants.getXMLEncoding());\n            if ((systemID != null) && (systemID.length() > 0)) {\n                serializer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, systemID);\n            }\n        } catch (Throwable e) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_COREBASE, Constants.PACKAGE_COREBASE_XML, \"0\", e);\n        }\n        return serializer;\n    }\n\n    /**\n     */\n    public static void setTransformerProperties() throws XException {\n        if (System.getProperty(\"java.version\").startsWith(\"1.5\")) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", \"com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl\");\n        }\n        String transformerProperty = Configuration.getInstance().getValueOptional(Constants.CHAPTER_BASE, \"XML\", \"TransformerFactory\");\n        if (transformerProperty != null) {\n            System.setProperty(\"javax.xml.transform.TransformerFactory\", transformerProperty);\n        }\n    }\n}\n// XMLHelper\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/xml/XMLHelperTest8.java",
		"test_prompt": "// XMLHelperTest8.java\npackage net.sf.xbus.base.xml;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.apache.xerces.parsers.DOMParser;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link XMLHelper}.\n* It contains ten unit test cases for the {@link XMLHelper#serializeXML(Document, String)} method.\n*/\nclass XMLHelperTest8 {"
	},
	{
		"original_code": "// ByteArrayConverterFile.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.technical.file.FileBase;\n\n/**\n * @author Fleckenstein\n *\n * To change this generated comment edit the template variable \"typecomment\":\n * Window>Preferences>Java>Templates. To enable and disable the creation of type\n * comments go to Window>Preferences>Java>Code Generation.\n */\npublic class ByteArrayConverterFile implements ByteArrayConverter {\n\n    private String mEncoding;\n\n    private byte mSpace;\n\n    public ByteArrayConverterFile(String system) throws XException {\n        String encoding = FileBase.getEncoding(system);\n        byte[] spaceArray = null;\n        try {\n            spaceArray = \" \".getBytes(encoding);\n            if (spaceArray.length != 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"2\");\n            }\n            mSpace = spaceArray[0];\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        mEncoding = encoding;\n    }\n\n    /**\n     * @see net.sf.xbus.base.bytearraylist.ByteArrayConverter#byteArrayToString(byte[])\n     */\n    public String byteArrayToString(byte[] array) throws XException {\n        try {\n            return new String(array, mEncoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n    }\n\n    /**\n     */\n    public byte[] stringToByteArray(String string, int length) throws XException {\n        byte[] stringArray = null;\n        try {\n            boolean end = false;\n            while (!end) {\n                stringArray = string.getBytes(mEncoding);\n                if (stringArray.length <= length) {\n                    end = true;\n                } else {\n                    string = string.substring(0, string.length() - 1);\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        if (stringArray.length == length) {\n            return stringArray;\n        } else {\n            byte[] retArray = new byte[length];\n            for (int i = 0; i < length; i++) {\n                if (i < stringArray.length) {\n                    retArray[i] = stringArray[i];\n                } else {\n                    retArray[i] = mSpace;\n                }\n            }\n            return retArray;\n        }\n    }\n\n    public byte[] stringToByteArray(String string) throws XException {\n        try {\n            return string.getBytes(mEncoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayConverterFileTest0.java",
		"test_prompt": "// ByteArrayConverterFileTest0.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.technical.file.FileBase;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayConverterFile}.\n* It contains ten unit test cases for the {@link ByteArrayConverterFile#byteArrayToString(byte[])} method.\n*/\nclass ByteArrayConverterFileTest0 {"
	},
	{
		"original_code": "// ByteArrayConverterFile.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.technical.file.FileBase;\n\n/**\n * @author Fleckenstein\n *\n * To change this generated comment edit the template variable \"typecomment\":\n * Window>Preferences>Java>Templates. To enable and disable the creation of type\n * comments go to Window>Preferences>Java>Code Generation.\n */\npublic class ByteArrayConverterFile implements ByteArrayConverter {\n\n    private String mEncoding;\n\n    private byte mSpace;\n\n    public ByteArrayConverterFile(String system) throws XException {\n        String encoding = FileBase.getEncoding(system);\n        byte[] spaceArray = null;\n        try {\n            spaceArray = \" \".getBytes(encoding);\n            if (spaceArray.length != 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"2\");\n            }\n            mSpace = spaceArray[0];\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        mEncoding = encoding;\n    }\n\n    /**\n     * @see net.sf.xbus.base.bytearraylist.ByteArrayConverter#byteArrayToString(byte[])\n     */\n    public String byteArrayToString(byte[] array) throws XException {\n        try {\n            return new String(array, mEncoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n    }\n\n    /**\n     */\n    public byte[] stringToByteArray(String string, int length) throws XException {\n        byte[] stringArray = null;\n        try {\n            boolean end = false;\n            while (!end) {\n                stringArray = string.getBytes(mEncoding);\n                if (stringArray.length <= length) {\n                    end = true;\n                } else {\n                    string = string.substring(0, string.length() - 1);\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        if (stringArray.length == length) {\n            return stringArray;\n        } else {\n            byte[] retArray = new byte[length];\n            for (int i = 0; i < length; i++) {\n                if (i < stringArray.length) {\n                    retArray[i] = stringArray[i];\n                } else {\n                    retArray[i] = mSpace;\n                }\n            }\n            return retArray;\n        }\n    }\n\n    public byte[] stringToByteArray(String string) throws XException {\n        try {\n            return string.getBytes(mEncoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayConverterFileTest1.java",
		"test_prompt": "// ByteArrayConverterFileTest1.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.technical.file.FileBase;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayConverterFile}.\n* It contains ten unit test cases for the {@link ByteArrayConverterFile#stringToByteArray(String, int)} method.\n*/\nclass ByteArrayConverterFileTest1 {"
	},
	{
		"original_code": "// ByteArrayConverterFile.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.technical.file.FileBase;\n\n/**\n * @author Fleckenstein\n *\n * To change this generated comment edit the template variable \"typecomment\":\n * Window>Preferences>Java>Templates. To enable and disable the creation of type\n * comments go to Window>Preferences>Java>Code Generation.\n */\npublic class ByteArrayConverterFile implements ByteArrayConverter {\n\n    private String mEncoding;\n\n    private byte mSpace;\n\n    public ByteArrayConverterFile(String system) throws XException {\n        String encoding = FileBase.getEncoding(system);\n        byte[] spaceArray = null;\n        try {\n            spaceArray = \" \".getBytes(encoding);\n            if (spaceArray.length != 1) {\n                throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"2\");\n            }\n            mSpace = spaceArray[0];\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        mEncoding = encoding;\n    }\n\n    /**\n     * @see net.sf.xbus.base.bytearraylist.ByteArrayConverter#byteArrayToString(byte[])\n     */\n    public String byteArrayToString(byte[] array) throws XException {\n        try {\n            return new String(array, mEncoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n    }\n\n    /**\n     */\n    public byte[] stringToByteArray(String string, int length) throws XException {\n        byte[] stringArray = null;\n        try {\n            boolean end = false;\n            while (!end) {\n                stringArray = string.getBytes(mEncoding);\n                if (stringArray.length <= length) {\n                    end = true;\n                } else {\n                    string = string.substring(0, string.length() - 1);\n                }\n            }\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        if (stringArray.length == length) {\n            return stringArray;\n        } else {\n            byte[] retArray = new byte[length];\n            for (int i = 0; i < length; i++) {\n                if (i < stringArray.length) {\n                    retArray[i] = stringArray[i];\n                } else {\n                    retArray[i] = mSpace;\n                }\n            }\n            return retArray;\n        }\n    }\n\n    public byte[] stringToByteArray(String string) throws XException {\n        try {\n            return string.getBytes(mEncoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayConverterFileTest2.java",
		"test_prompt": "// ByteArrayConverterFileTest2.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.technical.file.FileBase;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayConverterFile}.\n* It contains ten unit test cases for the {@link ByteArrayConverterFile#stringToByteArray(String)} method.\n*/\nclass ByteArrayConverterFileTest2 {"
	},
	{
		"original_code": "// ByteArrayConverterFactory.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * @author Fleckenstein\n *\n * To change this generated comment edit the template variable \"typecomment\":\n * Window>Preferences>Java>Templates. To enable and disable the creation of type\n * comments go to Window>Preferences>Java>Code Generation.\n */\npublic class ByteArrayConverterFactory {\n\n    static public ByteArrayConverter getConverter(String system) throws XException {\n        Configuration config = Configuration.getInstance();\n        String as400name = config.getValueOptional(Constants.CHAPTER_SYSTEM, system, \"AS400\");\n        if (as400name != null) {\n            return new ByteArrayConverterAS400(system);\n        } else {\n            return new ByteArrayConverterFile(system);\n        }\n    }\n\n    /**\n     * Acts as a container for the information of one\n     */\n    class Field {\n\n        public String name = null;\n\n        public String value = null;\n\n        public int length = 0;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayConverterFactoryTest.java",
		"test_prompt": "// ByteArrayConverterFactoryTest.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayConverterFactory}.\n* It contains ten unit test cases for the {@link ByteArrayConverterFactory#getConverter(String)} method.\n*/\nclass ByteArrayConverterFactoryTest {"
	},
	{
		"original_code": "// ByteArrayConverterAS400.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.as400.AS400FileBase;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\n\n/**\n * @author Fleckenstein\n *\n * To change this generated comment edit the template variable \"typecomment\":\n * Window>Preferences>Java>Templates. To enable and disable the creation of type\n * comments go to Window>Preferences>Java>Code Generation.\n */\npublic class ByteArrayConverterAS400 implements ByteArrayConverter {\n\n    private CharConverter conv = null;\n\n    private byte mSpace;\n\n    public ByteArrayConverterAS400(String system) throws XException {\n        String as400name = Configuration.getInstance().getValue(Constants.CHAPTER_SYSTEM, system, \"AS400\");\n        AS400 as400 = AS400Connection.getInstance(as400name).getSystem();\n        String encoding = AS400FileBase.getEncoding(as400, system);\n        try {\n            conv = new CharConverter(encoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        byte[] spaceArray = null;\n        spaceArray = conv.stringToByteArray(\" \");\n        if (spaceArray.length != 1) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"2\");\n        }\n        mSpace = spaceArray[0];\n    }\n\n    /**\n     * @see net.sf.xbus.base.bytearraylist.ByteArrayConverter#byteArrayToString(byte[])\n     */\n    public String byteArrayToString(byte[] array) {\n        return conv.byteArrayToString(array);\n    }\n\n    /**\n     */\n    public byte[] stringToByteArray(String string, int length) {\n        byte[] stringArray = null;\n        boolean end = false;\n        while (!end) {\n            stringArray = conv.stringToByteArray(string);\n            if (stringArray.length <= length) {\n                end = true;\n            } else {\n                string = string.substring(0, string.length() - 1);\n            }\n        }\n        if (stringArray.length == length) {\n            return stringArray;\n        } else {\n            byte[] retArray = new byte[length];\n            for (int i = 0; i < length; i++) {\n                if (i < stringArray.length) {\n                    retArray[i] = stringArray[i];\n                } else {\n                    retArray[i] = mSpace;\n                }\n            }\n            return retArray;\n        }\n    }\n\n    public byte[] stringToByteArray(String string) {\n        return conv.stringToByteArray(string);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayConverterAS400Test0.java",
		"test_prompt": "// ByteArrayConverterAS400Test0.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.as400.AS400FileBase;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayConverterAS400}.\n* It contains ten unit test cases for the {@link ByteArrayConverterAS400#byteArrayToString(byte[])} method.\n*/\nclass ByteArrayConverterAS400Test0 {"
	},
	{
		"original_code": "// ByteArrayConverterAS400.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.as400.AS400FileBase;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\n\n/**\n * @author Fleckenstein\n *\n * To change this generated comment edit the template variable \"typecomment\":\n * Window>Preferences>Java>Templates. To enable and disable the creation of type\n * comments go to Window>Preferences>Java>Code Generation.\n */\npublic class ByteArrayConverterAS400 implements ByteArrayConverter {\n\n    private CharConverter conv = null;\n\n    private byte mSpace;\n\n    public ByteArrayConverterAS400(String system) throws XException {\n        String as400name = Configuration.getInstance().getValue(Constants.CHAPTER_SYSTEM, system, \"AS400\");\n        AS400 as400 = AS400Connection.getInstance(as400name).getSystem();\n        String encoding = AS400FileBase.getEncoding(as400, system);\n        try {\n            conv = new CharConverter(encoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        byte[] spaceArray = null;\n        spaceArray = conv.stringToByteArray(\" \");\n        if (spaceArray.length != 1) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"2\");\n        }\n        mSpace = spaceArray[0];\n    }\n\n    /**\n     * @see net.sf.xbus.base.bytearraylist.ByteArrayConverter#byteArrayToString(byte[])\n     */\n    public String byteArrayToString(byte[] array) {\n        return conv.byteArrayToString(array);\n    }\n\n    /**\n     */\n    public byte[] stringToByteArray(String string, int length) {\n        byte[] stringArray = null;\n        boolean end = false;\n        while (!end) {\n            stringArray = conv.stringToByteArray(string);\n            if (stringArray.length <= length) {\n                end = true;\n            } else {\n                string = string.substring(0, string.length() - 1);\n            }\n        }\n        if (stringArray.length == length) {\n            return stringArray;\n        } else {\n            byte[] retArray = new byte[length];\n            for (int i = 0; i < length; i++) {\n                if (i < stringArray.length) {\n                    retArray[i] = stringArray[i];\n                } else {\n                    retArray[i] = mSpace;\n                }\n            }\n            return retArray;\n        }\n    }\n\n    public byte[] stringToByteArray(String string) {\n        return conv.stringToByteArray(string);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayConverterAS400Test1.java",
		"test_prompt": "// ByteArrayConverterAS400Test1.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.as400.AS400FileBase;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayConverterAS400}.\n* It contains ten unit test cases for the {@link ByteArrayConverterAS400#stringToByteArray(String, int)} method.\n*/\nclass ByteArrayConverterAS400Test1 {"
	},
	{
		"original_code": "// ByteArrayConverterAS400.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.as400.AS400FileBase;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\n\n/**\n * @author Fleckenstein\n *\n * To change this generated comment edit the template variable \"typecomment\":\n * Window>Preferences>Java>Templates. To enable and disable the creation of type\n * comments go to Window>Preferences>Java>Code Generation.\n */\npublic class ByteArrayConverterAS400 implements ByteArrayConverter {\n\n    private CharConverter conv = null;\n\n    private byte mSpace;\n\n    public ByteArrayConverterAS400(String system) throws XException {\n        String as400name = Configuration.getInstance().getValue(Constants.CHAPTER_SYSTEM, system, \"AS400\");\n        AS400 as400 = AS400Connection.getInstance(as400name).getSystem();\n        String encoding = AS400FileBase.getEncoding(as400, system);\n        try {\n            conv = new CharConverter(encoding);\n        } catch (UnsupportedEncodingException e) {\n            throw new XException(Constants.LOCATION_EXTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"0\", e);\n        }\n        byte[] spaceArray = null;\n        spaceArray = conv.stringToByteArray(\" \");\n        if (spaceArray.length != 1) {\n            throw new XException(Constants.LOCATION_INTERN, Constants.LAYER_PROTOCOL, Constants.PACKAGE_PROTOCOL_BYTEARRAYLIST, \"2\");\n        }\n        mSpace = spaceArray[0];\n    }\n\n    /**\n     * @see net.sf.xbus.base.bytearraylist.ByteArrayConverter#byteArrayToString(byte[])\n     */\n    public String byteArrayToString(byte[] array) {\n        return conv.byteArrayToString(array);\n    }\n\n    /**\n     */\n    public byte[] stringToByteArray(String string, int length) {\n        byte[] stringArray = null;\n        boolean end = false;\n        while (!end) {\n            stringArray = conv.stringToByteArray(string);\n            if (stringArray.length <= length) {\n                end = true;\n            } else {\n                string = string.substring(0, string.length() - 1);\n            }\n        }\n        if (stringArray.length == length) {\n            return stringArray;\n        } else {\n            byte[] retArray = new byte[length];\n            for (int i = 0; i < length; i++) {\n                if (i < stringArray.length) {\n                    retArray[i] = stringArray[i];\n                } else {\n                    retArray[i] = mSpace;\n                }\n            }\n            return retArray;\n        }\n    }\n\n    public byte[] stringToByteArray(String string) {\n        return conv.stringToByteArray(string);\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayConverterAS400Test2.java",
		"test_prompt": "// ByteArrayConverterAS400Test2.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.io.UnsupportedEncodingException;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.config.Configuration;\nimport net.sf.xbus.technical.as400.AS400Connection;\nimport net.sf.xbus.technical.as400.AS400FileBase;\nimport com.ibm.as400.access.AS400;\nimport com.ibm.as400.access.CharConverter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayConverterAS400}.\n* It contains ten unit test cases for the {@link ByteArrayConverterAS400#stringToByteArray(String)} method.\n*/\nclass ByteArrayConverterAS400Test2 {"
	},
	{
		"original_code": "// ByteArrayList.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Manages a list of byte arrays.\n */\npublic class ByteArrayList {\n\n    private List mByteArrays;\n\n    private int mLength;\n\n    public ByteArrayList() {\n        mByteArrays = new Vector();\n        mLength = 0;\n    }\n\n    /**\n     * <code>getContentAsString</code> returns the content of the\n     * <code>ByteArrayList</code> as string. Each single byte array builds up\n     * one line in the string.\n     *\n     * @param system used to determine the ByteArrayConverter and linebreaks\n     * @return A string containing the byte arrays in lines.\n     * @throws XException in case that the conversion cannot be performed\n     */\n    public String getContentAsString(String system) throws XException {\n        /*\n\t\t * Create converter and linebreak\n\t\t */\n        ByteArrayConverter byteArrayConverter = ByteArrayConverterFactory.getConverter(system);\n        String platform = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Platform\");\n        String lineBreak = Constants.LINE_SEPERATOR;\n        if (platform != null) {\n            lineBreak = Constants.getLineSeperator(platform);\n        }\n        // for the result\n        StringBuffer buffer = new StringBuffer(mLength + mByteArrays.size() * lineBreak.length());\n        // how many characters alreday stored into the string buffer?\n        int charsRead = 0;\n        // A single line\n        String line = null;\n        if (mByteArrays.size() > 0) {\n            // There are some lines in the byte array, here process the first\n            // one.\n            line = byteArrayConverter.byteArrayToString((byte[]) mByteArrays.get(0));\n            buffer.append(line);\n            charsRead += line.length();\n        }\n        // if (mByteArrays.size()>0)\n        for (int i = 1; i < mByteArrays.size(); i++) {\n            // for the following lines\n            // first finish the previous line with a line break\n            buffer.append(lineBreak);\n            charsRead += lineBreak.length();\n            // now the current line\n            line = byteArrayConverter.byteArrayToString((byte[]) mByteArrays.get(i));\n            buffer.append(line);\n            charsRead += line.length();\n        }\n        // for (int i=1; i<mByteArrays.size(); i++)\n        return buffer.substring(0, charsRead);\n    }\n\n    // getContentAsString(ByteArrayConverter byteArrayConverter, String\n    // lineBreak)\n    /**\n     * @see java.lang.Object#toString()\n     */\n    public String toString() {\n        int outputLength = Integer.MAX_VALUE;\n        if (mLength * 3 < outputLength)\n            outputLength = mLength * 3;\n        StringBuffer buffer = new StringBuffer(outputLength);\n        Iterator it = mByteArrays.iterator();\n        int charCount = 0;\n        String byteHex = null;\n        while (it.hasNext() && charCount + 2 < outputLength) {\n            byte[] line = (byte[]) it.next();\n            for (int i = 0; i < line.length && charCount + 2 < outputLength; i++) {\n                if (line[i] < 0)\n                    byteHex = Integer.toHexString(line[i] + 256).toUpperCase();\n                else\n                    byteHex = Integer.toHexString(line[i]).toUpperCase();\n                if (byteHex.length() == 1)\n                    buffer.append('0');\n                buffer.append(byteHex);\n                buffer.append(' ');\n                charCount += 3;\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Appends the specified byte array to the end of this list.\n     *\n     * @param byteArray byte array to be appended to this list\n     */\n    public void add(byte[] byteArray) {\n        mByteArrays.add(byteArray);\n        mLength += byteArray.length;\n    }\n\n    /**\n     * Returns an iterator over the elements in this list in proper sequence.\n     *\n     * @return an iterator over the elements in this list in proper sequence\n     */\n    public Iterator iterator() {\n        return mByteArrays.iterator();\n    }\n\n    /**\n     * Method length.\n     *\n     * @return int\n     */\n    public int length() {\n        return mLength;\n    }\n\n    public byte[] get(int index) {\n        return (byte[]) mByteArrays.get(index);\n    }\n\n    public void addAll(ByteArrayList list) {\n        if (list != null) {\n            Iterator it = list.iterator();\n            while (it.hasNext()) add((byte[]) it.next());\n        }\n    }\n\n    /**\n     * @return the content of the ByteArrayList as an array of bytes with system\n     *         specific line breaks.\n     */\n    public byte[] toByteArray() {\n        byte[] retArray = null;\n        byte[] lineBreak = Constants.LINE_SEPERATOR.getBytes();\n        for (Iterator it = iterator(); it.hasNext(); ) {\n            byte[] line = (byte[]) it.next();\n            retArray = concatenate(retArray, line);\n            retArray = concatenate(retArray, lineBreak);\n        }\n        return retArray;\n    }\n\n    /**\n     * Concatenates two byte arrays\n     *\n     * @param b1 the byte array at the beginning\n     * @param b2 the byte array at the end\n     * @return the concatenated byte array\n     */\n    private byte[] concatenate(byte[] b1, byte[] b2) {\n        if (b1 == null) {\n            return b2;\n        }\n        if (b2 == null) {\n            return b1;\n        }\n        byte[] retArray = new byte[b1.length + b2.length];\n        System.arraycopy(b1, 0, retArray, 0, b1.length);\n        System.arraycopy(b2, 0, retArray, b1.length, b2.length);\n        return retArray;\n    }\n\n    static public ByteArrayList createByteArrayList(byte[] byteBuffer, int lineLength) throws XException {\n        ByteArrayList retArray = new ByteArrayList();\n        if (lineLength > 0) {\n            byte[] byteArray;\n            int i = 0;\n            while (i + lineLength <= byteBuffer.length) {\n                byteArray = XByteArraySupport.subArray(byteBuffer, i, lineLength);\n                retArray.add(byteArray);\n                i += lineLength;\n                while (i < byteBuffer.length && (byteBuffer[i] == Constants.NEWLINE || byteBuffer[i] == Constants.CARRIAGE_RETURN)) {\n                    i++;\n                }\n            }\n        } else {\n            byte[] byteArray;\n            int i = 0;\n            int lastPos = 0;\n            while (i < byteBuffer.length) {\n                if ((byteBuffer[i] == Constants.NEWLINE) || (byteBuffer[i] == Constants.CARRIAGE_RETURN)) {\n                    byteArray = XByteArraySupport.subArray(byteBuffer, lastPos, i - lastPos);\n                    retArray.add(byteArray);\n                    do {\n                        i++;\n                    } while ((i < byteBuffer.length) && ((byteBuffer[i] == Constants.NEWLINE) || (byteBuffer[i] == Constants.CARRIAGE_RETURN)));\n                    lastPos = i;\n                } else {\n                    i++;\n                }\n            }\n            if (lastPos < i) {\n                byteArray = XByteArraySupport.subArray(byteBuffer, lastPos, i - lastPos);\n                retArray.add(byteArray);\n            }\n        }\n        return retArray;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayListTest0.java",
		"test_prompt": "// ByteArrayListTest0.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayList}.\n* It contains ten unit test cases for the {@link ByteArrayList#iterator()} method.\n*/\nclass ByteArrayListTest0 {"
	},
	{
		"original_code": "// ByteArrayList.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Manages a list of byte arrays.\n */\npublic class ByteArrayList {\n\n    private List mByteArrays;\n\n    private int mLength;\n\n    public ByteArrayList() {\n        mByteArrays = new Vector();\n        mLength = 0;\n    }\n\n    /**\n     * <code>getContentAsString</code> returns the content of the\n     * <code>ByteArrayList</code> as string. Each single byte array builds up\n     * one line in the string.\n     *\n     * @param system used to determine the ByteArrayConverter and linebreaks\n     * @return A string containing the byte arrays in lines.\n     * @throws XException in case that the conversion cannot be performed\n     */\n    public String getContentAsString(String system) throws XException {\n        /*\n\t\t * Create converter and linebreak\n\t\t */\n        ByteArrayConverter byteArrayConverter = ByteArrayConverterFactory.getConverter(system);\n        String platform = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Platform\");\n        String lineBreak = Constants.LINE_SEPERATOR;\n        if (platform != null) {\n            lineBreak = Constants.getLineSeperator(platform);\n        }\n        // for the result\n        StringBuffer buffer = new StringBuffer(mLength + mByteArrays.size() * lineBreak.length());\n        // how many characters alreday stored into the string buffer?\n        int charsRead = 0;\n        // A single line\n        String line = null;\n        if (mByteArrays.size() > 0) {\n            // There are some lines in the byte array, here process the first\n            // one.\n            line = byteArrayConverter.byteArrayToString((byte[]) mByteArrays.get(0));\n            buffer.append(line);\n            charsRead += line.length();\n        }\n        // if (mByteArrays.size()>0)\n        for (int i = 1; i < mByteArrays.size(); i++) {\n            // for the following lines\n            // first finish the previous line with a line break\n            buffer.append(lineBreak);\n            charsRead += lineBreak.length();\n            // now the current line\n            line = byteArrayConverter.byteArrayToString((byte[]) mByteArrays.get(i));\n            buffer.append(line);\n            charsRead += line.length();\n        }\n        // for (int i=1; i<mByteArrays.size(); i++)\n        return buffer.substring(0, charsRead);\n    }\n\n    // getContentAsString(ByteArrayConverter byteArrayConverter, String\n    // lineBreak)\n    /**\n     * @see java.lang.Object#toString()\n     */\n    public String toString() {\n        int outputLength = Integer.MAX_VALUE;\n        if (mLength * 3 < outputLength)\n            outputLength = mLength * 3;\n        StringBuffer buffer = new StringBuffer(outputLength);\n        Iterator it = mByteArrays.iterator();\n        int charCount = 0;\n        String byteHex = null;\n        while (it.hasNext() && charCount + 2 < outputLength) {\n            byte[] line = (byte[]) it.next();\n            for (int i = 0; i < line.length && charCount + 2 < outputLength; i++) {\n                if (line[i] < 0)\n                    byteHex = Integer.toHexString(line[i] + 256).toUpperCase();\n                else\n                    byteHex = Integer.toHexString(line[i]).toUpperCase();\n                if (byteHex.length() == 1)\n                    buffer.append('0');\n                buffer.append(byteHex);\n                buffer.append(' ');\n                charCount += 3;\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Appends the specified byte array to the end of this list.\n     *\n     * @param byteArray byte array to be appended to this list\n     */\n    public void add(byte[] byteArray) {\n        mByteArrays.add(byteArray);\n        mLength += byteArray.length;\n    }\n\n    /**\n     * Returns an iterator over the elements in this list in proper sequence.\n     *\n     * @return an iterator over the elements in this list in proper sequence\n     */\n    public Iterator iterator() {\n        return mByteArrays.iterator();\n    }\n\n    /**\n     * Method length.\n     *\n     * @return int\n     */\n    public int length() {\n        return mLength;\n    }\n\n    public byte[] get(int index) {\n        return (byte[]) mByteArrays.get(index);\n    }\n\n    public void addAll(ByteArrayList list) {\n        if (list != null) {\n            Iterator it = list.iterator();\n            while (it.hasNext()) add((byte[]) it.next());\n        }\n    }\n\n    /**\n     * @return the content of the ByteArrayList as an array of bytes with system\n     *         specific line breaks.\n     */\n    public byte[] toByteArray() {\n        byte[] retArray = null;\n        byte[] lineBreak = Constants.LINE_SEPERATOR.getBytes();\n        for (Iterator it = iterator(); it.hasNext(); ) {\n            byte[] line = (byte[]) it.next();\n            retArray = concatenate(retArray, line);\n            retArray = concatenate(retArray, lineBreak);\n        }\n        return retArray;\n    }\n\n    /**\n     * Concatenates two byte arrays\n     *\n     * @param b1 the byte array at the beginning\n     * @param b2 the byte array at the end\n     * @return the concatenated byte array\n     */\n    private byte[] concatenate(byte[] b1, byte[] b2) {\n        if (b1 == null) {\n            return b2;\n        }\n        if (b2 == null) {\n            return b1;\n        }\n        byte[] retArray = new byte[b1.length + b2.length];\n        System.arraycopy(b1, 0, retArray, 0, b1.length);\n        System.arraycopy(b2, 0, retArray, b1.length, b2.length);\n        return retArray;\n    }\n\n    static public ByteArrayList createByteArrayList(byte[] byteBuffer, int lineLength) throws XException {\n        ByteArrayList retArray = new ByteArrayList();\n        if (lineLength > 0) {\n            byte[] byteArray;\n            int i = 0;\n            while (i + lineLength <= byteBuffer.length) {\n                byteArray = XByteArraySupport.subArray(byteBuffer, i, lineLength);\n                retArray.add(byteArray);\n                i += lineLength;\n                while (i < byteBuffer.length && (byteBuffer[i] == Constants.NEWLINE || byteBuffer[i] == Constants.CARRIAGE_RETURN)) {\n                    i++;\n                }\n            }\n        } else {\n            byte[] byteArray;\n            int i = 0;\n            int lastPos = 0;\n            while (i < byteBuffer.length) {\n                if ((byteBuffer[i] == Constants.NEWLINE) || (byteBuffer[i] == Constants.CARRIAGE_RETURN)) {\n                    byteArray = XByteArraySupport.subArray(byteBuffer, lastPos, i - lastPos);\n                    retArray.add(byteArray);\n                    do {\n                        i++;\n                    } while ((i < byteBuffer.length) && ((byteBuffer[i] == Constants.NEWLINE) || (byteBuffer[i] == Constants.CARRIAGE_RETURN)));\n                    lastPos = i;\n                } else {\n                    i++;\n                }\n            }\n            if (lastPos < i) {\n                byteArray = XByteArraySupport.subArray(byteBuffer, lastPos, i - lastPos);\n                retArray.add(byteArray);\n            }\n        }\n        return retArray;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayListTest1.java",
		"test_prompt": "// ByteArrayListTest1.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayList}.\n* It contains ten unit test cases for the {@link ByteArrayList#length()} method.\n*/\nclass ByteArrayListTest1 {"
	},
	{
		"original_code": "// ByteArrayList.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Manages a list of byte arrays.\n */\npublic class ByteArrayList {\n\n    private List mByteArrays;\n\n    private int mLength;\n\n    public ByteArrayList() {\n        mByteArrays = new Vector();\n        mLength = 0;\n    }\n\n    /**\n     * <code>getContentAsString</code> returns the content of the\n     * <code>ByteArrayList</code> as string. Each single byte array builds up\n     * one line in the string.\n     *\n     * @param system used to determine the ByteArrayConverter and linebreaks\n     * @return A string containing the byte arrays in lines.\n     * @throws XException in case that the conversion cannot be performed\n     */\n    public String getContentAsString(String system) throws XException {\n        /*\n\t\t * Create converter and linebreak\n\t\t */\n        ByteArrayConverter byteArrayConverter = ByteArrayConverterFactory.getConverter(system);\n        String platform = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Platform\");\n        String lineBreak = Constants.LINE_SEPERATOR;\n        if (platform != null) {\n            lineBreak = Constants.getLineSeperator(platform);\n        }\n        // for the result\n        StringBuffer buffer = new StringBuffer(mLength + mByteArrays.size() * lineBreak.length());\n        // how many characters alreday stored into the string buffer?\n        int charsRead = 0;\n        // A single line\n        String line = null;\n        if (mByteArrays.size() > 0) {\n            // There are some lines in the byte array, here process the first\n            // one.\n            line = byteArrayConverter.byteArrayToString((byte[]) mByteArrays.get(0));\n            buffer.append(line);\n            charsRead += line.length();\n        }\n        // if (mByteArrays.size()>0)\n        for (int i = 1; i < mByteArrays.size(); i++) {\n            // for the following lines\n            // first finish the previous line with a line break\n            buffer.append(lineBreak);\n            charsRead += lineBreak.length();\n            // now the current line\n            line = byteArrayConverter.byteArrayToString((byte[]) mByteArrays.get(i));\n            buffer.append(line);\n            charsRead += line.length();\n        }\n        // for (int i=1; i<mByteArrays.size(); i++)\n        return buffer.substring(0, charsRead);\n    }\n\n    // getContentAsString(ByteArrayConverter byteArrayConverter, String\n    // lineBreak)\n    /**\n     * @see java.lang.Object#toString()\n     */\n    public String toString() {\n        int outputLength = Integer.MAX_VALUE;\n        if (mLength * 3 < outputLength)\n            outputLength = mLength * 3;\n        StringBuffer buffer = new StringBuffer(outputLength);\n        Iterator it = mByteArrays.iterator();\n        int charCount = 0;\n        String byteHex = null;\n        while (it.hasNext() && charCount + 2 < outputLength) {\n            byte[] line = (byte[]) it.next();\n            for (int i = 0; i < line.length && charCount + 2 < outputLength; i++) {\n                if (line[i] < 0)\n                    byteHex = Integer.toHexString(line[i] + 256).toUpperCase();\n                else\n                    byteHex = Integer.toHexString(line[i]).toUpperCase();\n                if (byteHex.length() == 1)\n                    buffer.append('0');\n                buffer.append(byteHex);\n                buffer.append(' ');\n                charCount += 3;\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Appends the specified byte array to the end of this list.\n     *\n     * @param byteArray byte array to be appended to this list\n     */\n    public void add(byte[] byteArray) {\n        mByteArrays.add(byteArray);\n        mLength += byteArray.length;\n    }\n\n    /**\n     * Returns an iterator over the elements in this list in proper sequence.\n     *\n     * @return an iterator over the elements in this list in proper sequence\n     */\n    public Iterator iterator() {\n        return mByteArrays.iterator();\n    }\n\n    /**\n     * Method length.\n     *\n     * @return int\n     */\n    public int length() {\n        return mLength;\n    }\n\n    public byte[] get(int index) {\n        return (byte[]) mByteArrays.get(index);\n    }\n\n    public void addAll(ByteArrayList list) {\n        if (list != null) {\n            Iterator it = list.iterator();\n            while (it.hasNext()) add((byte[]) it.next());\n        }\n    }\n\n    /**\n     * @return the content of the ByteArrayList as an array of bytes with system\n     *         specific line breaks.\n     */\n    public byte[] toByteArray() {\n        byte[] retArray = null;\n        byte[] lineBreak = Constants.LINE_SEPERATOR.getBytes();\n        for (Iterator it = iterator(); it.hasNext(); ) {\n            byte[] line = (byte[]) it.next();\n            retArray = concatenate(retArray, line);\n            retArray = concatenate(retArray, lineBreak);\n        }\n        return retArray;\n    }\n\n    /**\n     * Concatenates two byte arrays\n     *\n     * @param b1 the byte array at the beginning\n     * @param b2 the byte array at the end\n     * @return the concatenated byte array\n     */\n    private byte[] concatenate(byte[] b1, byte[] b2) {\n        if (b1 == null) {\n            return b2;\n        }\n        if (b2 == null) {\n            return b1;\n        }\n        byte[] retArray = new byte[b1.length + b2.length];\n        System.arraycopy(b1, 0, retArray, 0, b1.length);\n        System.arraycopy(b2, 0, retArray, b1.length, b2.length);\n        return retArray;\n    }\n\n    static public ByteArrayList createByteArrayList(byte[] byteBuffer, int lineLength) throws XException {\n        ByteArrayList retArray = new ByteArrayList();\n        if (lineLength > 0) {\n            byte[] byteArray;\n            int i = 0;\n            while (i + lineLength <= byteBuffer.length) {\n                byteArray = XByteArraySupport.subArray(byteBuffer, i, lineLength);\n                retArray.add(byteArray);\n                i += lineLength;\n                while (i < byteBuffer.length && (byteBuffer[i] == Constants.NEWLINE || byteBuffer[i] == Constants.CARRIAGE_RETURN)) {\n                    i++;\n                }\n            }\n        } else {\n            byte[] byteArray;\n            int i = 0;\n            int lastPos = 0;\n            while (i < byteBuffer.length) {\n                if ((byteBuffer[i] == Constants.NEWLINE) || (byteBuffer[i] == Constants.CARRIAGE_RETURN)) {\n                    byteArray = XByteArraySupport.subArray(byteBuffer, lastPos, i - lastPos);\n                    retArray.add(byteArray);\n                    do {\n                        i++;\n                    } while ((i < byteBuffer.length) && ((byteBuffer[i] == Constants.NEWLINE) || (byteBuffer[i] == Constants.CARRIAGE_RETURN)));\n                    lastPos = i;\n                } else {\n                    i++;\n                }\n            }\n            if (lastPos < i) {\n                byteArray = XByteArraySupport.subArray(byteBuffer, lastPos, i - lastPos);\n                retArray.add(byteArray);\n            }\n        }\n        return retArray;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayListTest2.java",
		"test_prompt": "// ByteArrayListTest2.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayList}.\n* It contains ten unit test cases for the {@link ByteArrayList#toByteArray()} method.\n*/\nclass ByteArrayListTest2 {"
	},
	{
		"original_code": "// ByteArrayList.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\n\n/**\n * Manages a list of byte arrays.\n */\npublic class ByteArrayList {\n\n    private List mByteArrays;\n\n    private int mLength;\n\n    public ByteArrayList() {\n        mByteArrays = new Vector();\n        mLength = 0;\n    }\n\n    /**\n     * <code>getContentAsString</code> returns the content of the\n     * <code>ByteArrayList</code> as string. Each single byte array builds up\n     * one line in the string.\n     *\n     * @param system used to determine the ByteArrayConverter and linebreaks\n     * @return A string containing the byte arrays in lines.\n     * @throws XException in case that the conversion cannot be performed\n     */\n    public String getContentAsString(String system) throws XException {\n        /*\n\t\t * Create converter and linebreak\n\t\t */\n        ByteArrayConverter byteArrayConverter = ByteArrayConverterFactory.getConverter(system);\n        String platform = Configuration.getInstance().getValueOptional(Constants.CHAPTER_SYSTEM, system, \"Platform\");\n        String lineBreak = Constants.LINE_SEPERATOR;\n        if (platform != null) {\n            lineBreak = Constants.getLineSeperator(platform);\n        }\n        // for the result\n        StringBuffer buffer = new StringBuffer(mLength + mByteArrays.size() * lineBreak.length());\n        // how many characters alreday stored into the string buffer?\n        int charsRead = 0;\n        // A single line\n        String line = null;\n        if (mByteArrays.size() > 0) {\n            // There are some lines in the byte array, here process the first\n            // one.\n            line = byteArrayConverter.byteArrayToString((byte[]) mByteArrays.get(0));\n            buffer.append(line);\n            charsRead += line.length();\n        }\n        // if (mByteArrays.size()>0)\n        for (int i = 1; i < mByteArrays.size(); i++) {\n            // for the following lines\n            // first finish the previous line with a line break\n            buffer.append(lineBreak);\n            charsRead += lineBreak.length();\n            // now the current line\n            line = byteArrayConverter.byteArrayToString((byte[]) mByteArrays.get(i));\n            buffer.append(line);\n            charsRead += line.length();\n        }\n        // for (int i=1; i<mByteArrays.size(); i++)\n        return buffer.substring(0, charsRead);\n    }\n\n    // getContentAsString(ByteArrayConverter byteArrayConverter, String\n    // lineBreak)\n    /**\n     * @see java.lang.Object#toString()\n     */\n    public String toString() {\n        int outputLength = Integer.MAX_VALUE;\n        if (mLength * 3 < outputLength)\n            outputLength = mLength * 3;\n        StringBuffer buffer = new StringBuffer(outputLength);\n        Iterator it = mByteArrays.iterator();\n        int charCount = 0;\n        String byteHex = null;\n        while (it.hasNext() && charCount + 2 < outputLength) {\n            byte[] line = (byte[]) it.next();\n            for (int i = 0; i < line.length && charCount + 2 < outputLength; i++) {\n                if (line[i] < 0)\n                    byteHex = Integer.toHexString(line[i] + 256).toUpperCase();\n                else\n                    byteHex = Integer.toHexString(line[i]).toUpperCase();\n                if (byteHex.length() == 1)\n                    buffer.append('0');\n                buffer.append(byteHex);\n                buffer.append(' ');\n                charCount += 3;\n            }\n        }\n        return buffer.toString();\n    }\n\n    /**\n     * Appends the specified byte array to the end of this list.\n     *\n     * @param byteArray byte array to be appended to this list\n     */\n    public void add(byte[] byteArray) {\n        mByteArrays.add(byteArray);\n        mLength += byteArray.length;\n    }\n\n    /**\n     * Returns an iterator over the elements in this list in proper sequence.\n     *\n     * @return an iterator over the elements in this list in proper sequence\n     */\n    public Iterator iterator() {\n        return mByteArrays.iterator();\n    }\n\n    /**\n     * Method length.\n     *\n     * @return int\n     */\n    public int length() {\n        return mLength;\n    }\n\n    public byte[] get(int index) {\n        return (byte[]) mByteArrays.get(index);\n    }\n\n    public void addAll(ByteArrayList list) {\n        if (list != null) {\n            Iterator it = list.iterator();\n            while (it.hasNext()) add((byte[]) it.next());\n        }\n    }\n\n    /**\n     * @return the content of the ByteArrayList as an array of bytes with system\n     *         specific line breaks.\n     */\n    public byte[] toByteArray() {\n        byte[] retArray = null;\n        byte[] lineBreak = Constants.LINE_SEPERATOR.getBytes();\n        for (Iterator it = iterator(); it.hasNext(); ) {\n            byte[] line = (byte[]) it.next();\n            retArray = concatenate(retArray, line);\n            retArray = concatenate(retArray, lineBreak);\n        }\n        return retArray;\n    }\n\n    /**\n     * Concatenates two byte arrays\n     *\n     * @param b1 the byte array at the beginning\n     * @param b2 the byte array at the end\n     * @return the concatenated byte array\n     */\n    private byte[] concatenate(byte[] b1, byte[] b2) {\n        if (b1 == null) {\n            return b2;\n        }\n        if (b2 == null) {\n            return b1;\n        }\n        byte[] retArray = new byte[b1.length + b2.length];\n        System.arraycopy(b1, 0, retArray, 0, b1.length);\n        System.arraycopy(b2, 0, retArray, b1.length, b2.length);\n        return retArray;\n    }\n\n    static public ByteArrayList createByteArrayList(byte[] byteBuffer, int lineLength) throws XException {\n        ByteArrayList retArray = new ByteArrayList();\n        if (lineLength > 0) {\n            byte[] byteArray;\n            int i = 0;\n            while (i + lineLength <= byteBuffer.length) {\n                byteArray = XByteArraySupport.subArray(byteBuffer, i, lineLength);\n                retArray.add(byteArray);\n                i += lineLength;\n                while (i < byteBuffer.length && (byteBuffer[i] == Constants.NEWLINE || byteBuffer[i] == Constants.CARRIAGE_RETURN)) {\n                    i++;\n                }\n            }\n        } else {\n            byte[] byteArray;\n            int i = 0;\n            int lastPos = 0;\n            while (i < byteBuffer.length) {\n                if ((byteBuffer[i] == Constants.NEWLINE) || (byteBuffer[i] == Constants.CARRIAGE_RETURN)) {\n                    byteArray = XByteArraySupport.subArray(byteBuffer, lastPos, i - lastPos);\n                    retArray.add(byteArray);\n                    do {\n                        i++;\n                    } while ((i < byteBuffer.length) && ((byteBuffer[i] == Constants.NEWLINE) || (byteBuffer[i] == Constants.CARRIAGE_RETURN)));\n                    lastPos = i;\n                } else {\n                    i++;\n                }\n            }\n            if (lastPos < i) {\n                byteArray = XByteArraySupport.subArray(byteBuffer, lastPos, i - lastPos);\n                retArray.add(byteArray);\n            }\n        }\n        return retArray;\n    }\n}\n",
		"id": "EvoSuiteBenchmark/83_xbus/src/main/java/net/sf/xbus/base/bytearraylist/ByteArrayListTest3.java",
		"test_prompt": "// ByteArrayListTest3.java\npackage net.sf.xbus.base.bytearraylist;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Vector;\nimport net.sf.xbus.base.core.Constants;\nimport net.sf.xbus.base.core.XException;\nimport net.sf.xbus.base.core.bytearrays.XByteArraySupport;\nimport net.sf.xbus.base.core.config.Configuration;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ByteArrayList}.\n* It contains ten unit test cases for the {@link ByteArrayList#createByteArrayList(byte[], int)} method.\n*/\nclass ByteArrayListTest3 {"
	}
]