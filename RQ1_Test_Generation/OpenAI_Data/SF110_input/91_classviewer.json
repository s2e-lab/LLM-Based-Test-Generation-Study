[
	{
		"original_code": "// StringList.java\n/* \r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * String holding and manipulation class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class StringList {\r\n\r\n    private ArrayList<String> tempList;\r\n\r\n    private Object[] tempArray = null;\r\n\r\n    private int length;\r\n\r\n    public StringList() {\r\n        tempList = new ArrayList<String>();\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return tempList.isEmpty();\r\n    }\r\n\r\n    public boolean contains(String obj) {\r\n        return tempList.contains(obj);\r\n    }\r\n\r\n    public void add(String obj) {\r\n        tempList.add(obj);\r\n    }\r\n\r\n    public String get(int index) {\r\n        return tempList.get(index);\r\n    }\r\n\r\n    public int size() {\r\n        return tempList.size();\r\n    }\r\n\r\n    public String[] toArray() {\r\n        tempArray = tempList.toArray();\r\n        String[] tempString = new String[tempArray.length];\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString[i] = (String) tempArray[i];\r\n        }\r\n        return tempString;\r\n    }\r\n\r\n    public StringList clone() {\r\n        tempArray = tempList.toArray();\r\n        StringList tempString = new StringList();\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString.add((String) tempArray[i]);\r\n        }\r\n        return tempString;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringListTest0.java",
		"test_prompt": "// StringListTest0.java\n//5-31-04  Added size() method.  ___JSH\n//11-18-07 Changed version.  ___JSH\npackage com.jstevh.tools;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringList}.\n* It contains ten unit test cases for the {@link StringList#isEmpty()} method.\n*/\nclass StringListTest0 {"
	},
	{
		"original_code": "// StringList.java\n/* \r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * String holding and manipulation class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class StringList {\r\n\r\n    private ArrayList<String> tempList;\r\n\r\n    private Object[] tempArray = null;\r\n\r\n    private int length;\r\n\r\n    public StringList() {\r\n        tempList = new ArrayList<String>();\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return tempList.isEmpty();\r\n    }\r\n\r\n    public boolean contains(String obj) {\r\n        return tempList.contains(obj);\r\n    }\r\n\r\n    public void add(String obj) {\r\n        tempList.add(obj);\r\n    }\r\n\r\n    public String get(int index) {\r\n        return tempList.get(index);\r\n    }\r\n\r\n    public int size() {\r\n        return tempList.size();\r\n    }\r\n\r\n    public String[] toArray() {\r\n        tempArray = tempList.toArray();\r\n        String[] tempString = new String[tempArray.length];\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString[i] = (String) tempArray[i];\r\n        }\r\n        return tempString;\r\n    }\r\n\r\n    public StringList clone() {\r\n        tempArray = tempList.toArray();\r\n        StringList tempString = new StringList();\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString.add((String) tempArray[i]);\r\n        }\r\n        return tempString;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringListTest1.java",
		"test_prompt": "// StringListTest1.java\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringList}.\n* It contains ten unit test cases for the {@link StringList#contains(String)} method.\n*/\nclass StringListTest1 {"
	},
	{
		"original_code": "// StringList.java\n/* \r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * String holding and manipulation class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class StringList {\r\n\r\n    private ArrayList<String> tempList;\r\n\r\n    private Object[] tempArray = null;\r\n\r\n    private int length;\r\n\r\n    public StringList() {\r\n        tempList = new ArrayList<String>();\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return tempList.isEmpty();\r\n    }\r\n\r\n    public boolean contains(String obj) {\r\n        return tempList.contains(obj);\r\n    }\r\n\r\n    public void add(String obj) {\r\n        tempList.add(obj);\r\n    }\r\n\r\n    public String get(int index) {\r\n        return tempList.get(index);\r\n    }\r\n\r\n    public int size() {\r\n        return tempList.size();\r\n    }\r\n\r\n    public String[] toArray() {\r\n        tempArray = tempList.toArray();\r\n        String[] tempString = new String[tempArray.length];\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString[i] = (String) tempArray[i];\r\n        }\r\n        return tempString;\r\n    }\r\n\r\n    public StringList clone() {\r\n        tempArray = tempList.toArray();\r\n        StringList tempString = new StringList();\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString.add((String) tempArray[i]);\r\n        }\r\n        return tempString;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringListTest2.java",
		"test_prompt": "// StringListTest2.java\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringList}.\n* It contains ten unit test cases for the {@link StringList#size()} method.\n*/\nclass StringListTest2 {"
	},
	{
		"original_code": "// StringList.java\n/* \r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * String holding and manipulation class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class StringList {\r\n\r\n    private ArrayList<String> tempList;\r\n\r\n    private Object[] tempArray = null;\r\n\r\n    private int length;\r\n\r\n    public StringList() {\r\n        tempList = new ArrayList<String>();\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return tempList.isEmpty();\r\n    }\r\n\r\n    public boolean contains(String obj) {\r\n        return tempList.contains(obj);\r\n    }\r\n\r\n    public void add(String obj) {\r\n        tempList.add(obj);\r\n    }\r\n\r\n    public String get(int index) {\r\n        return tempList.get(index);\r\n    }\r\n\r\n    public int size() {\r\n        return tempList.size();\r\n    }\r\n\r\n    public String[] toArray() {\r\n        tempArray = tempList.toArray();\r\n        String[] tempString = new String[tempArray.length];\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString[i] = (String) tempArray[i];\r\n        }\r\n        return tempString;\r\n    }\r\n\r\n    public StringList clone() {\r\n        tempArray = tempList.toArray();\r\n        StringList tempString = new StringList();\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString.add((String) tempArray[i]);\r\n        }\r\n        return tempString;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringListTest3.java",
		"test_prompt": "// StringListTest3.java\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringList}.\n* It contains ten unit test cases for the {@link StringList#toArray()} method.\n*/\nclass StringListTest3 {"
	},
	{
		"original_code": "// StringList.java\n/* \r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * String holding and manipulation class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class StringList {\r\n\r\n    private ArrayList<String> tempList;\r\n\r\n    private Object[] tempArray = null;\r\n\r\n    private int length;\r\n\r\n    public StringList() {\r\n        tempList = new ArrayList<String>();\r\n    }\r\n\r\n    public boolean isEmpty() {\r\n        return tempList.isEmpty();\r\n    }\r\n\r\n    public boolean contains(String obj) {\r\n        return tempList.contains(obj);\r\n    }\r\n\r\n    public void add(String obj) {\r\n        tempList.add(obj);\r\n    }\r\n\r\n    public String get(int index) {\r\n        return tempList.get(index);\r\n    }\r\n\r\n    public int size() {\r\n        return tempList.size();\r\n    }\r\n\r\n    public String[] toArray() {\r\n        tempArray = tempList.toArray();\r\n        String[] tempString = new String[tempArray.length];\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString[i] = (String) tempArray[i];\r\n        }\r\n        return tempString;\r\n    }\r\n\r\n    public StringList clone() {\r\n        tempArray = tempList.toArray();\r\n        StringList tempString = new StringList();\r\n        for (int i = 0; i < tempArray.length; i++) {\r\n            tempString.add((String) tempArray[i]);\r\n        }\r\n        return tempString;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringListTest4.java",
		"test_prompt": "// StringListTest4.java\n//5-31-04  Added size() method.  ___JSH\r\n//11-18-07 Changed version.  ___JSH\r\npackage com.jstevh.tools;\n\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringList}.\n* It contains ten unit test cases for the {@link StringList#clone()} method.\n*/\nclass StringListTest4 {"
	},
	{
		"original_code": "// StringTools.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.tools;\r\n\r\n/**\r\n * Some static tools for string manipulation\r\n *\r\n * @author   James Harris\r\n * @version  1.1\r\n */\r\npublic class StringTools {\r\n\r\n    private static int count, length;\r\n\r\n    /**\r\n     * Searches through given string array for a given string\r\n     * fragment and returns an array of the strings that have\r\n     * fragment in them.\r\n     *\r\n     * @param    strings    string array that is searched through\r\n     *           fragment   string fragment with which to search\r\n     *\r\n     * @return   string array of found strings\r\n     */\r\n    public static String[] searchStrings(String[] strings, String fragment) {\r\n        String[] tempArray = null;\r\n        if (strings != null && fragment != null) {\r\n            String tempStr, tempStr2;\r\n            StringList hold = new StringList();\r\n            for (int i = 0; i < strings.length; i++) {\r\n                tempStr2 = strings[i].toLowerCase();\r\n                tempStr = fragment.toLowerCase();\r\n                if (tempStr2.indexOf(tempStr) != -1) {\r\n                    hold.add(strings[i]);\r\n                }\r\n            }\r\n            if (!hold.isEmpty())\r\n                tempArray = hold.toArray();\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Searches through given index string array for a given string\r\n     * fragment and returns an array of the strings from given base\r\n     * array.\r\n     *\r\n     * @param    strings    string array that values are pulled from\r\n     *           index      string array that is searched through\r\n     *           fragment   string fragment with which to search\r\n     *\r\n     * @return   string array of found strings\r\n     */\r\n    public static String[] searchStrings(String[] strings, String[] index, String fragment) {\r\n        String[] tempArray = null;\r\n        if (strings != null && index != null && fragment != null && index.length <= strings.length) {\r\n            String tempStr, tempStr2;\r\n            StringList hold = new StringList();\r\n            for (int i = 0; i < index.length; i++) {\r\n                tempStr2 = index[i].toLowerCase();\r\n                tempStr = fragment.toLowerCase();\r\n                if (tempStr2.indexOf(tempStr) != -1) {\r\n                    hold.add(strings[i]);\r\n                }\r\n            }\r\n            if (!hold.isEmpty())\r\n                tempArray = hold.toArray();\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (array == null)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Searches through given string array for a given string\r\n     * fragment and deletes fragment from strings that have\r\n     * fragment in them.\r\n     *\r\n     * @param    in        string fragment to be deleted out\r\n     *           strings   array with strings to delete fragment from\r\n     *\r\n     * @return   toString() on string buffer used, for debugging\r\n     */\r\n    public static String removeStrings(String in, String[] strings) {\r\n        if (in == null || strings == null)\r\n            return null;\r\n        StringBuffer buff = new StringBuffer(in.trim());\r\n        int pos1, length;\r\n        for (int i = 0; i < strings.length; i++) {\r\n            pos1 = buff.toString().indexOf(strings[i]);\r\n            length = strings[i].length();\r\n            while (pos1 != -1) {\r\n                buff.delete(pos1, pos1 + length);\r\n                pos1 = buff.toString().indexOf(strings[i]);\r\n            }\r\n        }\r\n        String tempStr = buff.toString();\r\n        return tempStr;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringToolsTest0.java",
		"test_prompt": "// StringToolsTest0.java\npackage com.jstevh.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringTools}.\n* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String)} method.\n*/\nclass StringToolsTest0 {"
	},
	{
		"original_code": "// StringTools.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.tools;\r\n\r\n/**\r\n * Some static tools for string manipulation\r\n *\r\n * @author   James Harris\r\n * @version  1.1\r\n */\r\npublic class StringTools {\r\n\r\n    private static int count, length;\r\n\r\n    /**\r\n     * Searches through given string array for a given string\r\n     * fragment and returns an array of the strings that have\r\n     * fragment in them.\r\n     *\r\n     * @param    strings    string array that is searched through\r\n     *           fragment   string fragment with which to search\r\n     *\r\n     * @return   string array of found strings\r\n     */\r\n    public static String[] searchStrings(String[] strings, String fragment) {\r\n        String[] tempArray = null;\r\n        if (strings != null && fragment != null) {\r\n            String tempStr, tempStr2;\r\n            StringList hold = new StringList();\r\n            for (int i = 0; i < strings.length; i++) {\r\n                tempStr2 = strings[i].toLowerCase();\r\n                tempStr = fragment.toLowerCase();\r\n                if (tempStr2.indexOf(tempStr) != -1) {\r\n                    hold.add(strings[i]);\r\n                }\r\n            }\r\n            if (!hold.isEmpty())\r\n                tempArray = hold.toArray();\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Searches through given index string array for a given string\r\n     * fragment and returns an array of the strings from given base\r\n     * array.\r\n     *\r\n     * @param    strings    string array that values are pulled from\r\n     *           index      string array that is searched through\r\n     *           fragment   string fragment with which to search\r\n     *\r\n     * @return   string array of found strings\r\n     */\r\n    public static String[] searchStrings(String[] strings, String[] index, String fragment) {\r\n        String[] tempArray = null;\r\n        if (strings != null && index != null && fragment != null && index.length <= strings.length) {\r\n            String tempStr, tempStr2;\r\n            StringList hold = new StringList();\r\n            for (int i = 0; i < index.length; i++) {\r\n                tempStr2 = index[i].toLowerCase();\r\n                tempStr = fragment.toLowerCase();\r\n                if (tempStr2.indexOf(tempStr) != -1) {\r\n                    hold.add(strings[i]);\r\n                }\r\n            }\r\n            if (!hold.isEmpty())\r\n                tempArray = hold.toArray();\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (array == null)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Searches through given string array for a given string\r\n     * fragment and deletes fragment from strings that have\r\n     * fragment in them.\r\n     *\r\n     * @param    in        string fragment to be deleted out\r\n     *           strings   array with strings to delete fragment from\r\n     *\r\n     * @return   toString() on string buffer used, for debugging\r\n     */\r\n    public static String removeStrings(String in, String[] strings) {\r\n        if (in == null || strings == null)\r\n            return null;\r\n        StringBuffer buff = new StringBuffer(in.trim());\r\n        int pos1, length;\r\n        for (int i = 0; i < strings.length; i++) {\r\n            pos1 = buff.toString().indexOf(strings[i]);\r\n            length = strings[i].length();\r\n            while (pos1 != -1) {\r\n                buff.delete(pos1, pos1 + length);\r\n                pos1 = buff.toString().indexOf(strings[i]);\r\n            }\r\n        }\r\n        String tempStr = buff.toString();\r\n        return tempStr;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringToolsTest1.java",
		"test_prompt": "// StringToolsTest1.java\npackage com.jstevh.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringTools}.\n* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String[], String)} method.\n*/\nclass StringToolsTest1 {"
	},
	{
		"original_code": "// StringTools.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.tools;\r\n\r\n/**\r\n * Some static tools for string manipulation\r\n *\r\n * @author   James Harris\r\n * @version  1.1\r\n */\r\npublic class StringTools {\r\n\r\n    private static int count, length;\r\n\r\n    /**\r\n     * Searches through given string array for a given string\r\n     * fragment and returns an array of the strings that have\r\n     * fragment in them.\r\n     *\r\n     * @param    strings    string array that is searched through\r\n     *           fragment   string fragment with which to search\r\n     *\r\n     * @return   string array of found strings\r\n     */\r\n    public static String[] searchStrings(String[] strings, String fragment) {\r\n        String[] tempArray = null;\r\n        if (strings != null && fragment != null) {\r\n            String tempStr, tempStr2;\r\n            StringList hold = new StringList();\r\n            for (int i = 0; i < strings.length; i++) {\r\n                tempStr2 = strings[i].toLowerCase();\r\n                tempStr = fragment.toLowerCase();\r\n                if (tempStr2.indexOf(tempStr) != -1) {\r\n                    hold.add(strings[i]);\r\n                }\r\n            }\r\n            if (!hold.isEmpty())\r\n                tempArray = hold.toArray();\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Searches through given index string array for a given string\r\n     * fragment and returns an array of the strings from given base\r\n     * array.\r\n     *\r\n     * @param    strings    string array that values are pulled from\r\n     *           index      string array that is searched through\r\n     *           fragment   string fragment with which to search\r\n     *\r\n     * @return   string array of found strings\r\n     */\r\n    public static String[] searchStrings(String[] strings, String[] index, String fragment) {\r\n        String[] tempArray = null;\r\n        if (strings != null && index != null && fragment != null && index.length <= strings.length) {\r\n            String tempStr, tempStr2;\r\n            StringList hold = new StringList();\r\n            for (int i = 0; i < index.length; i++) {\r\n                tempStr2 = index[i].toLowerCase();\r\n                tempStr = fragment.toLowerCase();\r\n                if (tempStr2.indexOf(tempStr) != -1) {\r\n                    hold.add(strings[i]);\r\n                }\r\n            }\r\n            if (!hold.isEmpty())\r\n                tempArray = hold.toArray();\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (array == null)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Searches through given string array for a given string\r\n     * fragment and deletes fragment from strings that have\r\n     * fragment in them.\r\n     *\r\n     * @param    in        string fragment to be deleted out\r\n     *           strings   array with strings to delete fragment from\r\n     *\r\n     * @return   toString() on string buffer used, for debugging\r\n     */\r\n    public static String removeStrings(String in, String[] strings) {\r\n        if (in == null || strings == null)\r\n            return null;\r\n        StringBuffer buff = new StringBuffer(in.trim());\r\n        int pos1, length;\r\n        for (int i = 0; i < strings.length; i++) {\r\n            pos1 = buff.toString().indexOf(strings[i]);\r\n            length = strings[i].length();\r\n            while (pos1 != -1) {\r\n                buff.delete(pos1, pos1 + length);\r\n                pos1 = buff.toString().indexOf(strings[i]);\r\n            }\r\n        }\r\n        String tempStr = buff.toString();\r\n        return tempStr;\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringToolsTest2.java",
		"test_prompt": "// StringToolsTest2.java\npackage com.jstevh.tools;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StringTools}.\n* It contains ten unit test cases for the {@link StringTools#removeStrings(String, String[])} method.\n*/\nclass StringToolsTest2 {"
	},
	{
		"original_code": "// SAXDirParser.java\n/* \r\n * SAXDirParser - program for viewing public class information\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser class that pulls preference information\r\n * from preference.xml\r\n *\r\n * @author   James Harris\r\n * @version  5.0.2 beta\r\n */\r\npublic class SAXDirParser extends DefaultHandler {\r\n\r\n    public String webData = \"\";\r\n\r\n    public String getWebData() {\r\n        return webData;\r\n    }\r\n\r\n    private static HashMap<String, String> directory = new HashMap<String, String>();\r\n\r\n    private static StringList localPackages = new StringList();\r\n\r\n    private static String localBrowser = \"\";\r\n\r\n    private static String file_editor = \"\";\r\n\r\n    private static boolean lineNumAccepted = false;\r\n\r\n    private static String lineNumParam = \"\";\r\n\r\n    private boolean check;\r\n\r\n    private boolean local;\r\n\r\n    private int level;\r\n\r\n    private String location;\r\n\r\n    public SAXDirParser() throws Exception {\r\n    }\r\n\r\n    public void startElement(String namespace, String local, String qname, Attributes atts) throws SAXException {\r\n        if (qname.compareTo(\"BrowserLoc\") == 0) {\r\n            check = true;\r\n            level = 0;\r\n        }\r\n        if (qname.compareTo(\"Editor\") == 0) {\r\n            check = true;\r\n            level = 10;\r\n        }\r\n        if (qname.compareTo(\"acceptsLineNumber\") == 0) {\r\n            check = true;\r\n            level = 11;\r\n        }\r\n        if (qname.compareTo(\"parameter\") == 0) {\r\n            check = true;\r\n            level = 12;\r\n        }\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            level = 2;\r\n            check = false;\r\n        }\r\n        if (qname.compareTo(\"Web\") == 0) {\r\n            check = true;\r\n            level = 30;\r\n        }\r\n        if (qname.compareTo(\"Local\") == 0) {\r\n            check = true;\r\n            level = 31;\r\n        }\r\n        if (qname.compareTo(\"Names\") == 0) {\r\n            check = true;\r\n            ;\r\n        }\r\n        if (qname.compareTo(\"pkg\") == 0) {\r\n            level = 4;\r\n        }\r\n    }\r\n\r\n    public void characters(char[] charArray, int start, int length) {\r\n        if (check && level >= 0) {\r\n            String tempStr = \"\";\r\n            for (int i = start; i < start + length; i++) {\r\n                tempStr += charArray[i];\r\n            }\r\n            if (level == 0) {\r\n                localBrowser = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 10) {\r\n                file_editor = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 11) {\r\n                if (tempStr.compareToIgnoreCase(\"Yes\") == 0) {\r\n                    lineNumAccepted = true;\r\n                } else\r\n                    lineNumAccepted = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 12) {\r\n                lineNumParam = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 30) {\r\n                location = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 31) {\r\n                if (tempStr.compareToIgnoreCase(\"No\") != 0) {\r\n                    local = true;\r\n                } else\r\n                    local = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 4) {\r\n                if (tempStr.trim().compareTo(\"\") != 0) {\r\n                    if (tempStr.endsWith(\".\"))\r\n                        tempStr = tempStr.substring(0, tempStr.length() - 1);\r\n                    directory.put(tempStr, location);\r\n                    if (local)\r\n                        localPackages.add(tempStr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void endElement(String namespace, String local, String qname) throws SAXException {\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            check = false;\r\n        }\r\n    }\r\n\r\n    public static HashMap getDirectory() {\r\n        return (HashMap) directory.clone();\r\n    }\r\n\r\n    public static StringList getLocalPackages() {\r\n        if (localPackages.isEmpty())\r\n            return null;\r\n        return localPackages.clone();\r\n    }\r\n\r\n    public static String getLocalBrowser() {\r\n        return localBrowser;\r\n    }\r\n\r\n    public static String getEditor() {\r\n        return file_editor;\r\n    }\r\n\r\n    public static boolean acceptsLineNumber() {\r\n        return lineNumAccepted;\r\n    }\r\n\r\n    public static String lineNumberParameter() {\r\n        return lineNumParam;\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n        SAXParser myParser = saxFactory.newSAXParser();\r\n        XMLReader myReader = myParser.getXMLReader();\r\n        myReader.setContentHandler(new SAXDirParser());\r\n        myReader.parse(\"packagedirectory.xml\");\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"java.lang\"));\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"javax.swing.border\"));\r\n        System.out.println(\"test local browser, test gives \" + localBrowser);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/SAXDirParserTest0.java",
		"test_prompt": "// SAXDirParserTest0.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SAXDirParser}.\n* It contains ten unit test cases for the {@link SAXDirParser#getDirectory()} method.\n*/\nclass SAXDirParserTest0 {"
	},
	{
		"original_code": "// SAXDirParser.java\n/* \r\n * SAXDirParser - program for viewing public class information\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser class that pulls preference information\r\n * from preference.xml\r\n *\r\n * @author   James Harris\r\n * @version  5.0.2 beta\r\n */\r\npublic class SAXDirParser extends DefaultHandler {\r\n\r\n    public String webData = \"\";\r\n\r\n    public String getWebData() {\r\n        return webData;\r\n    }\r\n\r\n    private static HashMap<String, String> directory = new HashMap<String, String>();\r\n\r\n    private static StringList localPackages = new StringList();\r\n\r\n    private static String localBrowser = \"\";\r\n\r\n    private static String file_editor = \"\";\r\n\r\n    private static boolean lineNumAccepted = false;\r\n\r\n    private static String lineNumParam = \"\";\r\n\r\n    private boolean check;\r\n\r\n    private boolean local;\r\n\r\n    private int level;\r\n\r\n    private String location;\r\n\r\n    public SAXDirParser() throws Exception {\r\n    }\r\n\r\n    public void startElement(String namespace, String local, String qname, Attributes atts) throws SAXException {\r\n        if (qname.compareTo(\"BrowserLoc\") == 0) {\r\n            check = true;\r\n            level = 0;\r\n        }\r\n        if (qname.compareTo(\"Editor\") == 0) {\r\n            check = true;\r\n            level = 10;\r\n        }\r\n        if (qname.compareTo(\"acceptsLineNumber\") == 0) {\r\n            check = true;\r\n            level = 11;\r\n        }\r\n        if (qname.compareTo(\"parameter\") == 0) {\r\n            check = true;\r\n            level = 12;\r\n        }\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            level = 2;\r\n            check = false;\r\n        }\r\n        if (qname.compareTo(\"Web\") == 0) {\r\n            check = true;\r\n            level = 30;\r\n        }\r\n        if (qname.compareTo(\"Local\") == 0) {\r\n            check = true;\r\n            level = 31;\r\n        }\r\n        if (qname.compareTo(\"Names\") == 0) {\r\n            check = true;\r\n            ;\r\n        }\r\n        if (qname.compareTo(\"pkg\") == 0) {\r\n            level = 4;\r\n        }\r\n    }\r\n\r\n    public void characters(char[] charArray, int start, int length) {\r\n        if (check && level >= 0) {\r\n            String tempStr = \"\";\r\n            for (int i = start; i < start + length; i++) {\r\n                tempStr += charArray[i];\r\n            }\r\n            if (level == 0) {\r\n                localBrowser = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 10) {\r\n                file_editor = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 11) {\r\n                if (tempStr.compareToIgnoreCase(\"Yes\") == 0) {\r\n                    lineNumAccepted = true;\r\n                } else\r\n                    lineNumAccepted = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 12) {\r\n                lineNumParam = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 30) {\r\n                location = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 31) {\r\n                if (tempStr.compareToIgnoreCase(\"No\") != 0) {\r\n                    local = true;\r\n                } else\r\n                    local = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 4) {\r\n                if (tempStr.trim().compareTo(\"\") != 0) {\r\n                    if (tempStr.endsWith(\".\"))\r\n                        tempStr = tempStr.substring(0, tempStr.length() - 1);\r\n                    directory.put(tempStr, location);\r\n                    if (local)\r\n                        localPackages.add(tempStr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void endElement(String namespace, String local, String qname) throws SAXException {\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            check = false;\r\n        }\r\n    }\r\n\r\n    public static HashMap getDirectory() {\r\n        return (HashMap) directory.clone();\r\n    }\r\n\r\n    public static StringList getLocalPackages() {\r\n        if (localPackages.isEmpty())\r\n            return null;\r\n        return localPackages.clone();\r\n    }\r\n\r\n    public static String getLocalBrowser() {\r\n        return localBrowser;\r\n    }\r\n\r\n    public static String getEditor() {\r\n        return file_editor;\r\n    }\r\n\r\n    public static boolean acceptsLineNumber() {\r\n        return lineNumAccepted;\r\n    }\r\n\r\n    public static String lineNumberParameter() {\r\n        return lineNumParam;\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n        SAXParser myParser = saxFactory.newSAXParser();\r\n        XMLReader myReader = myParser.getXMLReader();\r\n        myReader.setContentHandler(new SAXDirParser());\r\n        myReader.parse(\"packagedirectory.xml\");\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"java.lang\"));\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"javax.swing.border\"));\r\n        System.out.println(\"test local browser, test gives \" + localBrowser);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/SAXDirParserTest1.java",
		"test_prompt": "// SAXDirParserTest1.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SAXDirParser}.\n* It contains ten unit test cases for the {@link SAXDirParser#getLocalPackages()} method.\n*/\nclass SAXDirParserTest1 {"
	},
	{
		"original_code": "// SAXDirParser.java\n/* \r\n * SAXDirParser - program for viewing public class information\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser class that pulls preference information\r\n * from preference.xml\r\n *\r\n * @author   James Harris\r\n * @version  5.0.2 beta\r\n */\r\npublic class SAXDirParser extends DefaultHandler {\r\n\r\n    public String webData = \"\";\r\n\r\n    public String getWebData() {\r\n        return webData;\r\n    }\r\n\r\n    private static HashMap<String, String> directory = new HashMap<String, String>();\r\n\r\n    private static StringList localPackages = new StringList();\r\n\r\n    private static String localBrowser = \"\";\r\n\r\n    private static String file_editor = \"\";\r\n\r\n    private static boolean lineNumAccepted = false;\r\n\r\n    private static String lineNumParam = \"\";\r\n\r\n    private boolean check;\r\n\r\n    private boolean local;\r\n\r\n    private int level;\r\n\r\n    private String location;\r\n\r\n    public SAXDirParser() throws Exception {\r\n    }\r\n\r\n    public void startElement(String namespace, String local, String qname, Attributes atts) throws SAXException {\r\n        if (qname.compareTo(\"BrowserLoc\") == 0) {\r\n            check = true;\r\n            level = 0;\r\n        }\r\n        if (qname.compareTo(\"Editor\") == 0) {\r\n            check = true;\r\n            level = 10;\r\n        }\r\n        if (qname.compareTo(\"acceptsLineNumber\") == 0) {\r\n            check = true;\r\n            level = 11;\r\n        }\r\n        if (qname.compareTo(\"parameter\") == 0) {\r\n            check = true;\r\n            level = 12;\r\n        }\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            level = 2;\r\n            check = false;\r\n        }\r\n        if (qname.compareTo(\"Web\") == 0) {\r\n            check = true;\r\n            level = 30;\r\n        }\r\n        if (qname.compareTo(\"Local\") == 0) {\r\n            check = true;\r\n            level = 31;\r\n        }\r\n        if (qname.compareTo(\"Names\") == 0) {\r\n            check = true;\r\n            ;\r\n        }\r\n        if (qname.compareTo(\"pkg\") == 0) {\r\n            level = 4;\r\n        }\r\n    }\r\n\r\n    public void characters(char[] charArray, int start, int length) {\r\n        if (check && level >= 0) {\r\n            String tempStr = \"\";\r\n            for (int i = start; i < start + length; i++) {\r\n                tempStr += charArray[i];\r\n            }\r\n            if (level == 0) {\r\n                localBrowser = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 10) {\r\n                file_editor = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 11) {\r\n                if (tempStr.compareToIgnoreCase(\"Yes\") == 0) {\r\n                    lineNumAccepted = true;\r\n                } else\r\n                    lineNumAccepted = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 12) {\r\n                lineNumParam = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 30) {\r\n                location = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 31) {\r\n                if (tempStr.compareToIgnoreCase(\"No\") != 0) {\r\n                    local = true;\r\n                } else\r\n                    local = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 4) {\r\n                if (tempStr.trim().compareTo(\"\") != 0) {\r\n                    if (tempStr.endsWith(\".\"))\r\n                        tempStr = tempStr.substring(0, tempStr.length() - 1);\r\n                    directory.put(tempStr, location);\r\n                    if (local)\r\n                        localPackages.add(tempStr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void endElement(String namespace, String local, String qname) throws SAXException {\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            check = false;\r\n        }\r\n    }\r\n\r\n    public static HashMap getDirectory() {\r\n        return (HashMap) directory.clone();\r\n    }\r\n\r\n    public static StringList getLocalPackages() {\r\n        if (localPackages.isEmpty())\r\n            return null;\r\n        return localPackages.clone();\r\n    }\r\n\r\n    public static String getLocalBrowser() {\r\n        return localBrowser;\r\n    }\r\n\r\n    public static String getEditor() {\r\n        return file_editor;\r\n    }\r\n\r\n    public static boolean acceptsLineNumber() {\r\n        return lineNumAccepted;\r\n    }\r\n\r\n    public static String lineNumberParameter() {\r\n        return lineNumParam;\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n        SAXParser myParser = saxFactory.newSAXParser();\r\n        XMLReader myReader = myParser.getXMLReader();\r\n        myReader.setContentHandler(new SAXDirParser());\r\n        myReader.parse(\"packagedirectory.xml\");\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"java.lang\"));\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"javax.swing.border\"));\r\n        System.out.println(\"test local browser, test gives \" + localBrowser);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/SAXDirParserTest2.java",
		"test_prompt": "// SAXDirParserTest2.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SAXDirParser}.\n* It contains ten unit test cases for the {@link SAXDirParser#getLocalBrowser()} method.\n*/\nclass SAXDirParserTest2 {"
	},
	{
		"original_code": "// SAXDirParser.java\n/* \r\n * SAXDirParser - program for viewing public class information\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser class that pulls preference information\r\n * from preference.xml\r\n *\r\n * @author   James Harris\r\n * @version  5.0.2 beta\r\n */\r\npublic class SAXDirParser extends DefaultHandler {\r\n\r\n    public String webData = \"\";\r\n\r\n    public String getWebData() {\r\n        return webData;\r\n    }\r\n\r\n    private static HashMap<String, String> directory = new HashMap<String, String>();\r\n\r\n    private static StringList localPackages = new StringList();\r\n\r\n    private static String localBrowser = \"\";\r\n\r\n    private static String file_editor = \"\";\r\n\r\n    private static boolean lineNumAccepted = false;\r\n\r\n    private static String lineNumParam = \"\";\r\n\r\n    private boolean check;\r\n\r\n    private boolean local;\r\n\r\n    private int level;\r\n\r\n    private String location;\r\n\r\n    public SAXDirParser() throws Exception {\r\n    }\r\n\r\n    public void startElement(String namespace, String local, String qname, Attributes atts) throws SAXException {\r\n        if (qname.compareTo(\"BrowserLoc\") == 0) {\r\n            check = true;\r\n            level = 0;\r\n        }\r\n        if (qname.compareTo(\"Editor\") == 0) {\r\n            check = true;\r\n            level = 10;\r\n        }\r\n        if (qname.compareTo(\"acceptsLineNumber\") == 0) {\r\n            check = true;\r\n            level = 11;\r\n        }\r\n        if (qname.compareTo(\"parameter\") == 0) {\r\n            check = true;\r\n            level = 12;\r\n        }\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            level = 2;\r\n            check = false;\r\n        }\r\n        if (qname.compareTo(\"Web\") == 0) {\r\n            check = true;\r\n            level = 30;\r\n        }\r\n        if (qname.compareTo(\"Local\") == 0) {\r\n            check = true;\r\n            level = 31;\r\n        }\r\n        if (qname.compareTo(\"Names\") == 0) {\r\n            check = true;\r\n            ;\r\n        }\r\n        if (qname.compareTo(\"pkg\") == 0) {\r\n            level = 4;\r\n        }\r\n    }\r\n\r\n    public void characters(char[] charArray, int start, int length) {\r\n        if (check && level >= 0) {\r\n            String tempStr = \"\";\r\n            for (int i = start; i < start + length; i++) {\r\n                tempStr += charArray[i];\r\n            }\r\n            if (level == 0) {\r\n                localBrowser = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 10) {\r\n                file_editor = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 11) {\r\n                if (tempStr.compareToIgnoreCase(\"Yes\") == 0) {\r\n                    lineNumAccepted = true;\r\n                } else\r\n                    lineNumAccepted = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 12) {\r\n                lineNumParam = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 30) {\r\n                location = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 31) {\r\n                if (tempStr.compareToIgnoreCase(\"No\") != 0) {\r\n                    local = true;\r\n                } else\r\n                    local = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 4) {\r\n                if (tempStr.trim().compareTo(\"\") != 0) {\r\n                    if (tempStr.endsWith(\".\"))\r\n                        tempStr = tempStr.substring(0, tempStr.length() - 1);\r\n                    directory.put(tempStr, location);\r\n                    if (local)\r\n                        localPackages.add(tempStr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void endElement(String namespace, String local, String qname) throws SAXException {\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            check = false;\r\n        }\r\n    }\r\n\r\n    public static HashMap getDirectory() {\r\n        return (HashMap) directory.clone();\r\n    }\r\n\r\n    public static StringList getLocalPackages() {\r\n        if (localPackages.isEmpty())\r\n            return null;\r\n        return localPackages.clone();\r\n    }\r\n\r\n    public static String getLocalBrowser() {\r\n        return localBrowser;\r\n    }\r\n\r\n    public static String getEditor() {\r\n        return file_editor;\r\n    }\r\n\r\n    public static boolean acceptsLineNumber() {\r\n        return lineNumAccepted;\r\n    }\r\n\r\n    public static String lineNumberParameter() {\r\n        return lineNumParam;\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n        SAXParser myParser = saxFactory.newSAXParser();\r\n        XMLReader myReader = myParser.getXMLReader();\r\n        myReader.setContentHandler(new SAXDirParser());\r\n        myReader.parse(\"packagedirectory.xml\");\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"java.lang\"));\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"javax.swing.border\"));\r\n        System.out.println(\"test local browser, test gives \" + localBrowser);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/SAXDirParserTest3.java",
		"test_prompt": "// SAXDirParserTest3.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SAXDirParser}.\n* It contains ten unit test cases for the {@link SAXDirParser#getEditor()} method.\n*/\nclass SAXDirParserTest3 {"
	},
	{
		"original_code": "// SAXDirParser.java\n/* \r\n * SAXDirParser - program for viewing public class information\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser class that pulls preference information\r\n * from preference.xml\r\n *\r\n * @author   James Harris\r\n * @version  5.0.2 beta\r\n */\r\npublic class SAXDirParser extends DefaultHandler {\r\n\r\n    public String webData = \"\";\r\n\r\n    public String getWebData() {\r\n        return webData;\r\n    }\r\n\r\n    private static HashMap<String, String> directory = new HashMap<String, String>();\r\n\r\n    private static StringList localPackages = new StringList();\r\n\r\n    private static String localBrowser = \"\";\r\n\r\n    private static String file_editor = \"\";\r\n\r\n    private static boolean lineNumAccepted = false;\r\n\r\n    private static String lineNumParam = \"\";\r\n\r\n    private boolean check;\r\n\r\n    private boolean local;\r\n\r\n    private int level;\r\n\r\n    private String location;\r\n\r\n    public SAXDirParser() throws Exception {\r\n    }\r\n\r\n    public void startElement(String namespace, String local, String qname, Attributes atts) throws SAXException {\r\n        if (qname.compareTo(\"BrowserLoc\") == 0) {\r\n            check = true;\r\n            level = 0;\r\n        }\r\n        if (qname.compareTo(\"Editor\") == 0) {\r\n            check = true;\r\n            level = 10;\r\n        }\r\n        if (qname.compareTo(\"acceptsLineNumber\") == 0) {\r\n            check = true;\r\n            level = 11;\r\n        }\r\n        if (qname.compareTo(\"parameter\") == 0) {\r\n            check = true;\r\n            level = 12;\r\n        }\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            level = 2;\r\n            check = false;\r\n        }\r\n        if (qname.compareTo(\"Web\") == 0) {\r\n            check = true;\r\n            level = 30;\r\n        }\r\n        if (qname.compareTo(\"Local\") == 0) {\r\n            check = true;\r\n            level = 31;\r\n        }\r\n        if (qname.compareTo(\"Names\") == 0) {\r\n            check = true;\r\n            ;\r\n        }\r\n        if (qname.compareTo(\"pkg\") == 0) {\r\n            level = 4;\r\n        }\r\n    }\r\n\r\n    public void characters(char[] charArray, int start, int length) {\r\n        if (check && level >= 0) {\r\n            String tempStr = \"\";\r\n            for (int i = start; i < start + length; i++) {\r\n                tempStr += charArray[i];\r\n            }\r\n            if (level == 0) {\r\n                localBrowser = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 10) {\r\n                file_editor = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 11) {\r\n                if (tempStr.compareToIgnoreCase(\"Yes\") == 0) {\r\n                    lineNumAccepted = true;\r\n                } else\r\n                    lineNumAccepted = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 12) {\r\n                lineNumParam = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 30) {\r\n                location = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 31) {\r\n                if (tempStr.compareToIgnoreCase(\"No\") != 0) {\r\n                    local = true;\r\n                } else\r\n                    local = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 4) {\r\n                if (tempStr.trim().compareTo(\"\") != 0) {\r\n                    if (tempStr.endsWith(\".\"))\r\n                        tempStr = tempStr.substring(0, tempStr.length() - 1);\r\n                    directory.put(tempStr, location);\r\n                    if (local)\r\n                        localPackages.add(tempStr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void endElement(String namespace, String local, String qname) throws SAXException {\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            check = false;\r\n        }\r\n    }\r\n\r\n    public static HashMap getDirectory() {\r\n        return (HashMap) directory.clone();\r\n    }\r\n\r\n    public static StringList getLocalPackages() {\r\n        if (localPackages.isEmpty())\r\n            return null;\r\n        return localPackages.clone();\r\n    }\r\n\r\n    public static String getLocalBrowser() {\r\n        return localBrowser;\r\n    }\r\n\r\n    public static String getEditor() {\r\n        return file_editor;\r\n    }\r\n\r\n    public static boolean acceptsLineNumber() {\r\n        return lineNumAccepted;\r\n    }\r\n\r\n    public static String lineNumberParameter() {\r\n        return lineNumParam;\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n        SAXParser myParser = saxFactory.newSAXParser();\r\n        XMLReader myReader = myParser.getXMLReader();\r\n        myReader.setContentHandler(new SAXDirParser());\r\n        myReader.parse(\"packagedirectory.xml\");\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"java.lang\"));\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"javax.swing.border\"));\r\n        System.out.println(\"test local browser, test gives \" + localBrowser);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/SAXDirParserTest4.java",
		"test_prompt": "// SAXDirParserTest4.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SAXDirParser}.\n* It contains ten unit test cases for the {@link SAXDirParser#acceptsLineNumber()} method.\n*/\nclass SAXDirParserTest4 {"
	},
	{
		"original_code": "// SAXDirParser.java\n/* \r\n * SAXDirParser - program for viewing public class information\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser class that pulls preference information\r\n * from preference.xml\r\n *\r\n * @author   James Harris\r\n * @version  5.0.2 beta\r\n */\r\npublic class SAXDirParser extends DefaultHandler {\r\n\r\n    public String webData = \"\";\r\n\r\n    public String getWebData() {\r\n        return webData;\r\n    }\r\n\r\n    private static HashMap<String, String> directory = new HashMap<String, String>();\r\n\r\n    private static StringList localPackages = new StringList();\r\n\r\n    private static String localBrowser = \"\";\r\n\r\n    private static String file_editor = \"\";\r\n\r\n    private static boolean lineNumAccepted = false;\r\n\r\n    private static String lineNumParam = \"\";\r\n\r\n    private boolean check;\r\n\r\n    private boolean local;\r\n\r\n    private int level;\r\n\r\n    private String location;\r\n\r\n    public SAXDirParser() throws Exception {\r\n    }\r\n\r\n    public void startElement(String namespace, String local, String qname, Attributes atts) throws SAXException {\r\n        if (qname.compareTo(\"BrowserLoc\") == 0) {\r\n            check = true;\r\n            level = 0;\r\n        }\r\n        if (qname.compareTo(\"Editor\") == 0) {\r\n            check = true;\r\n            level = 10;\r\n        }\r\n        if (qname.compareTo(\"acceptsLineNumber\") == 0) {\r\n            check = true;\r\n            level = 11;\r\n        }\r\n        if (qname.compareTo(\"parameter\") == 0) {\r\n            check = true;\r\n            level = 12;\r\n        }\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            level = 2;\r\n            check = false;\r\n        }\r\n        if (qname.compareTo(\"Web\") == 0) {\r\n            check = true;\r\n            level = 30;\r\n        }\r\n        if (qname.compareTo(\"Local\") == 0) {\r\n            check = true;\r\n            level = 31;\r\n        }\r\n        if (qname.compareTo(\"Names\") == 0) {\r\n            check = true;\r\n            ;\r\n        }\r\n        if (qname.compareTo(\"pkg\") == 0) {\r\n            level = 4;\r\n        }\r\n    }\r\n\r\n    public void characters(char[] charArray, int start, int length) {\r\n        if (check && level >= 0) {\r\n            String tempStr = \"\";\r\n            for (int i = start; i < start + length; i++) {\r\n                tempStr += charArray[i];\r\n            }\r\n            if (level == 0) {\r\n                localBrowser = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 10) {\r\n                file_editor = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 11) {\r\n                if (tempStr.compareToIgnoreCase(\"Yes\") == 0) {\r\n                    lineNumAccepted = true;\r\n                } else\r\n                    lineNumAccepted = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 12) {\r\n                lineNumParam = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 30) {\r\n                location = tempStr;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 31) {\r\n                if (tempStr.compareToIgnoreCase(\"No\") != 0) {\r\n                    local = true;\r\n                } else\r\n                    local = false;\r\n                check = false;\r\n                level = -1;\r\n            }\r\n            if (level == 4) {\r\n                if (tempStr.trim().compareTo(\"\") != 0) {\r\n                    if (tempStr.endsWith(\".\"))\r\n                        tempStr = tempStr.substring(0, tempStr.length() - 1);\r\n                    directory.put(tempStr, location);\r\n                    if (local)\r\n                        localPackages.add(tempStr);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void endElement(String namespace, String local, String qname) throws SAXException {\r\n        if (qname.compareTo(\"Group\") == 0) {\r\n            check = false;\r\n        }\r\n    }\r\n\r\n    public static HashMap getDirectory() {\r\n        return (HashMap) directory.clone();\r\n    }\r\n\r\n    public static StringList getLocalPackages() {\r\n        if (localPackages.isEmpty())\r\n            return null;\r\n        return localPackages.clone();\r\n    }\r\n\r\n    public static String getLocalBrowser() {\r\n        return localBrowser;\r\n    }\r\n\r\n    public static String getEditor() {\r\n        return file_editor;\r\n    }\r\n\r\n    public static boolean acceptsLineNumber() {\r\n        return lineNumAccepted;\r\n    }\r\n\r\n    public static String lineNumberParameter() {\r\n        return lineNumParam;\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n        SAXParser myParser = saxFactory.newSAXParser();\r\n        XMLReader myReader = myParser.getXMLReader();\r\n        myReader.setContentHandler(new SAXDirParser());\r\n        myReader.parse(\"packagedirectory.xml\");\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"java.lang\"));\r\n        System.out.println(\"test directory, test gives \" + directory.get(\"javax.swing.border\"));\r\n        System.out.println(\"test local browser, test gives \" + localBrowser);\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/SAXDirParserTest5.java",
		"test_prompt": "// SAXDirParserTest5.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link SAXDirParser}.\n* It contains ten unit test cases for the {@link SAXDirParser#lineNumberParameter()} method.\n*/\nclass SAXDirParserTest5 {"
	},
	{
		"original_code": "// ClassViewer.java\n/* \n * Class Viewer - program for viewing public class information\n *\n * Copyright (C) 2004-2010  James Harris \n *\n * This program is free software; you can redistribute it \n *\n * and/or modify it under the terms of the GNU General Public\n *\n * License as published by the Free Software Foundation;\n *\n * either version 2 of the License, or (at your option) any \n *\n * later version.\n *\n *\n * This program is distributed in the hope that it will be \n *\n * useful, but WITHOUT ANY WARRANTY; without even the implied \n *\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \n *\n * PURPOSE. See the GNU General Public License for more details.\n *\n *\n * You should have received a copy of the GNU General Public \n *\n * License along with this program; if not, write to the Free \n *\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \n *\n * Boston, MA 02111-1307 USA\n *\n */\npackage com.jstevh.viewer;\n\nimport javax.swing.*;\nimport javax.swing.WindowConstants;\nimport javax.swing.border.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.datatransfer.*;\nimport java.io.*;\nimport java.net.*;\nimport java.applet.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\n\n/**\n * Viewing class that runs as an application or applet whichs\n * is paired with an internal ClassInfo which is the data class.\n * <p>\n * This class is for viewing data and managing.\n *\n * @author   James Harris\n * @version  5.0.3\n */\npublic class ClassViewer extends JApplet {\n\n    static final long serialVersionUID = -8097082256025613859L;\n\n    private static String noWarrantyStr = \"\";\n\n    {\n        noWarrantyStr += \"Class Viewer version \" + VERSION + \", Copyright (C) \" + YEAR + \" by James Harris\";\n        noWarrantyStr += \"\\ncomes with ABSOLUTELY NO WARRANTY; for details\";\n        noWarrantyStr += \"\\nsee http://www.opensource.org/licenses/gpl-license.php\\n\";\n        noWarrantyStr += \"\\nThis is free software, and you are welcome\\n\";\n        noWarrantyStr += \"to redistribute it under certain conditions;\";\n        noWarrantyStr += \"\\ncheck at http://www.opensource.org/licenses/gpl-license.php\";\n        noWarrantyStr += \"\\nfor details.\";\n    }\n\n    JButton b1 = new JButton(\"Documents\");\n\n    JTextArea txtArea, resWin, fldArea, cstrArea, infoArea;\n\n    JComboBox txt = new JComboBox();\n\n    JTextField txtTextField;\n\n    JTextField txt2 = new JTextField(10);\n\n    JPopupMenu popup = new JPopupMenu();\n\n    JMenuItem copy = new JMenuItem(\"Copy\");\n\n    JMenuItem search = new JMenuItem(\"Search\");\n\n    JMenuItem goJavaDoc = new JMenuItem(\"Documents\");\n\n    JMenu[] menus = { new JMenu(\"Help\"), new JMenu(\"Weblinks\"), new JMenu(\"Command\") };\n\n    JMenuBar menuBar = new JMenuBar();\n\n    JMenuItem instructions = new JMenuItem(\"Instructions\");\n\n    JMenuItem about = new JMenuItem(\"About\");\n\n    JMenuItem link1 = new JMenuItem(\"Class Viewer Home\");\n\n    JMenuItem link2 = new JMenuItem(\"Basic Use Instructions\");\n\n    JMenuItem link3 = new JMenuItem(\"Beyond Mundane Blog\");\n\n    JMenuItem link4 = new JMenuItem(\"Java.net--Tools\");\n\n    JMenuItem command1 = new JMenuItem(\"Set classpath\");\n\n    JMenuItem command2 = new JMenuItem(\"Edit file\");\n\n    JTabbedPane panes = new JTabbedPane();\n\n    static final int RESWIN = 0, CSTRWIN = 1, FLDWIN = 2;\n\n    public static boolean mainRun = false;\n\n    public static String classPath;\n\n    public static String currentDir;\n\n    public static String operating_system;\n\n    public static String file_separator;\n\n    public static String file_editor;\n\n    public static final String VERSION = \"5.0.3\";\n\n    public static final int YEAR = 2011;\n\n    private ClassInfo myClassInfo;\n\n    private String startClass;\n\n    private DirManager locManager;\n\n    private HashMap location;\n\n    private StringList localPackages;\n\n    private boolean isLocalFile = false;\n\n    private String[] strMethods;\n\n    private String[] displayMethods;\n\n    private Dimension scrSize;\n\n    private boolean autoSearch = false;\n\n    private String[] resWinData;\n\n    private int resWinLine;\n\n    public ClassViewer() {\n        // try{\n        //UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n        // }\n        // catch (Exception e){e.printStackTrace();}\n        txt.requestFocus();\n    }\n\n    public ClassViewer(String name) {\n        //try{\n        //  UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n        //}\n        //catch (Exception e){e.printStackTrace();}\n        startClass = name;\n        txt.requestFocus();\n    }\n\n    public void init() {\n        if (mainRun) {\n            try {\n                classPath = System.getProperty(\"java.class.path\");\n                currentDir = System.getProperty(\"user.dir\");\n                operating_system = System.getProperty(\"os.name\");\n                file_separator = System.getProperty(\"file.separator\");\n            } catch (java.security.AccessControlException access) {\n                access.printStackTrace();\n                System.out.println(\"Should never go in here\");\n                mainRun = false;\n            }\n        }\n        //getToolkit().getScreenSize();\n        scrSize = getSize();\n        double ratio = scrSize.getWidth() / 1024;\n        txtArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        txtArea.setLineWrap(true);\n        fldArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        resWin = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        cstrArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        infoArea = new JTextArea((int) (5 * ratio), (int) (20 * ratio));\n        //Adding in menus, first one is the help\n        //need to switch to fields with names\n        menus[0].add(instructions);\n        menus[0].add(about);\n        menus[1].add(link1);\n        menus[1].add(link2);\n        menus[1].add(link3);\n        menus[1].add(link4);\n        menus[2].add(command1);\n        menus[2].add(command2);\n        command2.setEnabled(false);\n        for (int i = 0; i < (menus.length); i++) {\n            menuBar.add(menus[i]);\n        }\n        setJMenuBar(menuBar);\n        if (mainRun)\n            popup.add(copy);\n        popup.add(search);\n        popup.add(goJavaDoc);\n        instructions.addActionListener(showInstructions);\n        about.addActionListener(showInfo);\n        link1.addActionListener(goHome);\n        link2.addActionListener(goBUO);\n        link3.addActionListener(goBeyond);\n        link4.addActionListener(goJN);\n        command1.addActionListener(setClasspath);\n        command2.addActionListener(editFile);\n        //menu items for pop-up menu getting ActionListeners\n        copy.addActionListener(copyToClipBoard);\n        search.addActionListener(srchMethods);\n        goJavaDoc.addActionListener(srchThenDocuments);\n        b1.addActionListener(getDocuments);\n        txt.setEditable(true);\n        txt.setMaximumRowCount(5);\n        txt.addActionListener(inMeth);\n        //Found this value by trying but put in a backup\n        Object checkComponent = txt.getComponent(2);\n        try {\n            txtTextField = (JTextField) checkComponent;\n        } catch (ClassCastException e) {\n            txtTextField = findTextField(txt);\n        }\n        txt2.addActionListener(srchMethods2);\n        txtArea.setEditable(false);\n        txtArea.addMouseListener(new ml());\n        resWin.addMouseListener(new ml());\n        fldArea.setEditable(false);\n        infoArea.setEditable(false);\n        Container cp = getContentPane();\n        JPanel bottomPanel = new JPanel();\n        JPanel bigWindows = new JPanel(), smallWindow = new JPanel(), classNameInput = new JPanel(), searchWindow = new JPanel();\n        if (!mainRun) {\n            TitledBorder mode = new TitledBorder(\"Running in applet mode\");\n            mode.setTitleColor(Color.BLUE);\n            mode.setTitleJustification(TitledBorder.CENTER);\n            bottomPanel.setBorder(mode);\n        }\n        bigWindows.setBorder(new TitledBorder(\"Public Methods\"));\n        smallWindow.setBorder(new TitledBorder(\"General Class Information\"));\n        classNameInput.setBorder(new TitledBorder(\"Class Name\"));\n        searchWindow.setBorder(new TitledBorder(\"Search String\"));\n        //cp.setLayout( new BoxLayout(cp, BoxLayout.Y_AXIS ));\n        bigWindows.add(new JScrollPane(txtArea));\n        bigWindows.add(panes);\n        panes.addTab(\"Results Window\", new JScrollPane(resWin));\n        panes.addTab(\"Constructors\", new JScrollPane(cstrArea));\n        panes.addTab(\"Fields\", new JScrollPane(fldArea));\n        smallWindow.add(infoArea);\n        classNameInput.add(txt);\n        searchWindow.add(txt2);\n        bottomPanel.add(bigWindows);\n        bottomPanel.add(smallWindow, BorderLayout.PAGE_START);\n        bottomPanel.add(classNameInput);\n        bottomPanel.add(b1);\n        bottomPanel.add(searchWindow);\n        cp.add(bottomPanel);\n        //Dimension d = getPreferredSize();\n        //d = getSize();\n        txt.requestFocus();\n        locManager = new DirManager(mainRun);\n        if (!locManager.loaded()) {\n            System.out.println(locManager.fileNotFoundError());\n            if (locManager.fileNotFoundError()) {\n                String errorStr = \"File packagedirectory.xml not found.\";\n                errorStr += \"\\n\\nLooking in directory--\\n\" + locManager.currentDir + locManager.fileSeparator;\n                errorStr += \"\\n\\nPlease put that file in the same folder as the main\";\n                errorStr += \"\\nClass Viewer program and restart program.\\n\\n\";\n                resWin.setText(errorStr);\n                errorStr += noWarrantyStr;\n                txtArea.setText(errorStr);\n            }\n        } else {\n            if (mainRun)\n                txtArea.setText(\"classpath=\" + classPath + \"\\n\\n\" + noWarrantyStr);\n            else\n                txtArea.setText(noWarrantyStr);\n        }\n        location = locManager.getDirectory();\n        if (startClass != null && startClass.compareTo(\"\") != 0) {\n            txt.addItem(startClass);\n            System.out.println(\"adding \" + startClass);\n        }\n        localPackages = locManager.getLocalPackages();\n        file_editor = locManager.getEditor();\n    }\n\n    /**\n     * Returns the JTextField that should contain user input\n     * <p>\n     *\n     * @param  in JComboBox to search within\n     *\n     * @return      a JTextField component\n     */\n    private JTextField findTextField(Container in) {\n        System.out.println(\"Looking for a JTextField inside of JComboBox\");\n        Component[] allComponents = in.getComponents();\n        JTextField retValue;\n        for (int i = 0; i < allComponents.length; i++) {\n            try {\n                retValue = (JTextField) allComponents[i];\n            } catch (ClassCastException e) {\n                continue;\n            }\n            return retValue;\n        }\n        System.out.println(\"Couldn't find JTextField inside of JComboBox\");\n        return null;\n    }\n\n    /**\n     * Returns information about the projects creator\n     * <p>\n     * This class is called when the user clicks Help and then About\n     *\n     * @return      string with author information\n     */\n    public String getAppletInfo() {\n        return \"ClassViewer for Java\" + '\\n' + \"Author: James Harris\" + '\\n' + \"Version: \" + VERSION;\n    }\n\n    /**\n     * Primary ActionListener that creates ClassInfo and populates\n     * data on screen\n     * <p>\n     * This class is called when a class name is entered.\n     */\n    ActionListener inMeth = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            if (e.getActionCommand().equals(\"comboBoxChanged\")) {\n                String tempStr = (String) txt.getSelectedItem();\n                if (tempStr == null || tempStr.trim().equals(\"\"))\n                    return;\n                try {\n                    myClassInfo = new ClassInfo(tempStr, locManager);\n                    txtArea.setText(\"\");\n                    if (txtArea.getLineWrap())\n                        txtArea.setLineWrap(false);\n                    if (resWin.getLineWrap())\n                        resWin.setLineWrap(false);\n                    resWin.setText(\"\");\n                    fldArea.setText(\"\");\n                    cstrArea.setText(\"\");\n                    int pos = txt.getSelectedIndex();\n                    if (pos != -1)\n                        txt.removeItemAt(pos);\n                    txt.insertItemAt(myClassInfo.getClassName(), 0);\n                    if (txt.getItemCount() > 4)\n                        txt.removeItemAt(4);\n                    txt.setSelectedIndex(0);\n                    txtTextField.setText(\"\");\n                    if (!myClassInfo.isInterface()) {\n                        if (myClassInfo.isAbstract())\n                            infoArea.setText(\"Abstract class \");\n                        else\n                            infoArea.setText(\"Class \");\n                    } else\n                        infoArea.setText(\"Interface \");\n                    infoArea.append(myClassInfo.getClassName() + '\\n');\n                    tempStr = myClassInfo.getSuperClassName();\n                    if (tempStr != null)\n                        infoArea.append(\"Superclass is \" + tempStr + '\\n');\n                    addInterfaces(infoArea);\n                    strMethods = myClassInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);\n                    if (strMethods != null) {\n                        displayMethods = new String[strMethods.length];\n                        for (int i = 0; i < strMethods.length; i++) {\n                            tempStr = removePackages(removeDeclarations(strMethods[i]));\n                            displayMethods[i] = tempStr;\n                            txtArea.append(tempStr + '\\n');\n                        }\n                        txtArea.setCaretPosition(0);\n                    } else\n                        txtArea.append(\"No public methods.\");\n                    addConstructors(cstrArea);\n                    panes.setSelectedIndex(CSTRWIN);\n                    addFields(fldArea);\n                    txtTextField.setText(\"\");\n                    if (localPackages.contains(myClassInfo.getClassPackage()))\n                        isLocalFile = true;\n                    if (isLocalFile)\n                        command2.setEnabled(true);\n                    else\n                        command2.setEnabled(false);\n                } catch (ClassNotFoundException j) {\n                    txtArea.setText(\"Class '\" + tempStr + \"' not found.  Case matters and for unknown\\n packages, the full class name is required.\");\n                }\n            }\n        }\n    };\n\n    /**\n     * MouseAdapter class that generates pop up when you right click\n     * on selected text.  It also does the search.\n     */\n    class ml extends MouseAdapter {\n\n        public void mouseReleased(MouseEvent e) {\n            if (myClassInfo != null) {\n                if (resWin.isFocusOwner() && e.getClickCount() < 2) {\n                    try {\n                        resWinLine = resWin.getLineOfOffset(resWin.getSelectionStart());\n                    } catch (javax.swing.text.BadLocationException k) {\n                        //if there's this exception, for now, do nothing, and move on\n                    }\n                }\n            }\n        }\n\n        public void mouseClicked(MouseEvent e) {\n            int event = e.getModifiers();\n            if (myClassInfo != null && event == InputEvent.BUTTON1_MASK && e.getClickCount() == 2) {\n                if (txtArea.isFocusOwner()) {\n                    resWin.setText(\"\");\n                    String[] result = myClassInfo.srchMethods(txtArea.getSelectedText(), displayMethods);\n                    if (result == null)\n                        resWin.append(\"No methods found.\");\n                    else {\n                        addStrings(resWin, result, resWinData);\n                        resWin.setCaretPosition(0);\n                    }\n                    resWinLine = 0;\n                    panes.setSelectedIndex(RESWIN);\n                } else if (resWin.isFocusOwner()) {\n                    int lineStart, lineEnd;\n                    try {\n                        resWinLine = resWin.getLineOfOffset(resWin.getSelectionStart());\n                        lineStart = resWin.getLineStartOffset(resWinLine);\n                        lineEnd = resWin.getLineEndOffset(resWinLine);\n                        resWin.setCaretPosition(lineStart);\n                        resWin.moveCaretPosition(lineEnd);\n                        doDocuments(resWinLine);\n                    } catch (Exception j) {\n                        j.printStackTrace();\n                    }\n                }\n            }\n            if (myClassInfo != null && event == InputEvent.BUTTON3_MASK) {\n                popup.setVisible(true);\n                popup.show(txtArea, e.getX(), e.getY());\n            }\n        }\n    }\n\n    /**\n     * ActionListener that does search when \"Search\" chosen from pop-up\n     * menu.\n     */\n    ActionListener srchMethods = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txtArea.getSelectedText();\n            resWin.setText(\"\");\n            if (myClassInfo != null) {\n                String[] result = myClassInfo.srchMethods(tempStr, displayMethods);\n                if (result == null)\n                    resWin.append(\"No methods found.\");\n                else {\n                    addStrings(resWin, result, resWinData);\n                    resWin.setCaretPosition(0);\n                }\n                panes.setSelectedIndex(RESWIN);\n            }\n        }\n    };\n\n    /**\n     * ActionListener that does search when text is entered\n     * in input field.\n     */\n    ActionListener srchMethods2 = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txt2.getText().trim();\n            resWin.setText(\"\");\n            if (myClassInfo != null) {\n                String[] result;\n                if (tempStr.indexOf(\" \") != -1) {\n                    int pos = tempStr.indexOf(\" \");\n                    StringList hold = new StringList();\n                    String segment;\n                    int count = 0;\n                    while (pos != -1 && count < 10) {\n                        segment = tempStr.substring(0, pos);\n                        tempStr = tempStr.substring(pos).trim();\n                        hold.add(segment);\n                        pos = tempStr.indexOf(\" \");\n                        count++;\n                    }\n                    hold.add(tempStr);\n                    String[] tempResults;\n                    result = myClassInfo.srchMethods(hold.get(0));\n                    for (int i = 0; i < hold.size(); i++) {\n                        result = StringTools.searchStrings(result, hold.get(i));\n                    }\n                } else\n                    result = myClassInfo.srchMethods(tempStr);\n                if (result == null)\n                    resWin.append(\"No methods found.\");\n                else {\n                    addStrings(resWin, result);\n                    resWin.setCaretPosition(0);\n                }\n                panes.setSelectedIndex(RESWIN);\n            }\n        }\n    };\n\n    /**\n     * ActionListener calls srchMethods and getDocuments when \"Documents\"\n     * is selected from pop-up menu.\n     */\n    ActionListener srchThenDocuments = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            srchMethods.actionPerformed(e);\n            getDocuments.actionPerformed(e);\n        }\n    };\n\n    /**\n     * ActionListener shows About information, selected from main menu.\n     */\n    ActionListener showInfo = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            JOptionPane.showMessageDialog(null, getAppletInfo(), \"About ClassViewer\", JOptionPane.INFORMATION_MESSAGE);\n        }\n    };\n\n    /**\n     * ActionListener go to Class Viewer Home webpage\n     */\n    ActionListener goHome = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://classviewer.sourceforge.net\");\n        }\n    };\n\n    /**\n     * ActionListener go to Basic Use Overview webpage\n     */\n    ActionListener goBUO = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://classviewer.sourceforge.net/useoverview.html\");\n        }\n    };\n\n    /**\n     * ActionListener go to Java Tools page at Java.net\n     */\n    ActionListener goJN = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://community.java.net/javatools/\");\n        }\n    };\n\n    ActionListener goBeyond = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://beyondmund.blogspot.com/\");\n        }\n    };\n\n    ActionListener setClasspath = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String newPath = JOptionPane.showInputDialog(\"Set Classpath\", classPath);\n            if (newPath != null) {\n                try {\n                    System.setProperty(\"java.class.path\", newPath);\n                    classPath = System.getProperty(\"java.class.path\");\n                } catch (java.security.AccessControlException access) {\n                    access.printStackTrace();\n                    System.out.print(\"Crashed trying to set classpath\");\n                }\n            }\n        }\n    };\n\n    ActionListener editFile = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            doCommand(\"editFile\", \"\");\n        }\n    };\n\n    /**\n     * ActionListener shows Instructions, selected from main menu.\n     */\n    ActionListener showInstructions = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String instrStr = \"\";\n            instrStr += \"Please input a full class name in the window below then\";\n            instrStr += \"\\npress <Enter>\\n\";\n            instrStr += \"\\nCase matters but known package names like\";\n            instrStr += \"\\njava.lang can be left off.\\n\";\n            instrStr += \"\\nSee packagedirectory.xml file for list of known packages\";\n            instrStr += \"\\nand add packages as needed.\\n\\n\";\n            instrStr += \"After the methods load you can select a search string in the \";\n            instrStr += \"\\nleft panel by highlighting some segment then right click.\\n\";\n            instrStr += \"\\nOr you can double-click on some string segment.\\n\";\n            instrStr += \"\\nOr you can enter a search string in the search field.  Searches\\n\";\n            instrStr += \"in that field are space delimited and case insensitive.\\n\";\n            instrStr += \"\\nClick <Documents> button after a class is entered or after\";\n            instrStr += \"\\nsearching for methods to get documents to a particular method.\\n\";\n            instrStr += \"\\nRecommended Java version is Java 1.5.0 or higher\";\n            resWin.setText(instrStr);\n            resWin.setCaretPosition(0);\n        }\n    };\n\n    /**\n     * ActionListener copies to System clipboard, selected from pop-up menu.\n     */\n    ActionListener copyToClipBoard = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txtArea.getSelectedText();\n            if (tempStr != null) {\n                StringSelection selString = new StringSelection(tempStr);\n                getToolkit().getSystemClipboard().setContents(selString, selString);\n            }\n        }\n    };\n\n    /**\n     * ActionListener gets Documents\n     */\n    ActionListener getDocuments = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            actionPerformed(e, resWinLine);\n            resWin.requestFocus();\n            int lineStart, lineEnd;\n            try {\n                lineStart = resWin.getLineStartOffset(resWinLine);\n                lineEnd = resWin.getLineEndOffset(resWinLine);\n                resWin.setCaretPosition(lineStart);\n                resWin.moveCaretPosition(lineEnd);\n            } catch (javax.swing.text.BadLocationException k) {\n                //if there's this exception, for now, do nothing, and move on\n            }\n        }\n\n        public void actionPerformed(ActionEvent e, int line) {\n            doDocuments(line);\n        }\n    };\n\n    private boolean doDocuments(int line) {\n        String className, packageName, tempStr = null;\n        if (myClassInfo != null) {\n            boolean check = false;\n            boolean found = false;\n            String[] tempArray;\n            MethodData mData = myClassInfo.getFoundMethod(line);\n            if (mData != null) {\n                packageName = mData.getMethPackage();\n                className = mData.getMethClass();\n            } else {\n                packageName = myClassInfo.getClassPackage();\n                className = myClassInfo.getClassName();\n            }\n            if (locManager == null) {\n                locManager = new DirManager(mainRun);\n                location = locManager.getDirectory();\n            }\n            String locString = (String) location.get(packageName);\n            if ((locString != null && locString.trim().compareTo(\"\") != 0) || packageName.indexOf(\"java.\") != -1 || packageName.indexOf(\"javax.\") != -1) {\n                String runString = \"\";\n                String localBrowser = \"\";\n                if (locString != null)\n                    runString = locString;\n                else if (packageName.indexOf(\"java.\") != -1)\n                    runString = (String) location.get(\"java.lang\");\n                else if (packageName.indexOf(\"javax.\") != -1)\n                    runString = (String) location.get(\"javax.swing.border\");\n                tempStr = className.replace('.', '/');\n                try {\n                    if (tempStr != null) {\n                        tempStr += \".html\";\n                        if (mData != null) {\n                            String tempStr2 = mData.getMethName();\n                            if (tempStr2.indexOf(\",\") != -1) {\n                                StringBuffer buff = new StringBuffer(tempStr2);\n                                int pos = 0;\n                                do {\n                                    pos = buff.toString().indexOf(\",\", pos);\n                                    //buff.insert(++pos, ' ');\n                                    buff.insert(++pos, '%');\n                                    buff.insert(++pos, '2');\n                                    buff.insert(++pos, '0');\n                                } while (buff.toString().indexOf(\",\", pos) != -1);\n                                tempStr2 = buff.toString();\n                            }\n                            tempStr += \"#\" + tempStr2;\n                        }\n                        runString += tempStr;\n                    }\n                    callBrowser(runString);\n                    return true;\n                } catch (NullPointerException j) {\n                    System.out.println(\"Null pointer exception\");\n                    j.printStackTrace();\n                    return false;\n                }\n            } else if (isLocalFile) {\n                if (doCommand(\"editMethod\", mData.getMethName()))\n                    return true;\n                else\n                    return false;\n            } else\n                resWin.setText(\"Unknown package.  Unable to lookup Documents.\\n  Please add package to packagedirectory.xml file.\");\n            return false;\n        }\n        return false;\n    }\n\n    public boolean callBrowser(String runString) {\n        String tempStr = \"\";\n        if (locManager == null)\n            locManager = new DirManager(mainRun);\n        if (!mainRun) {\n            try {\n                AppletContext appC = getAppletContext();\n                URL ur = new URL(runString);\n                appC.showDocument(ur, \"_blank\");\n            } catch (MalformedURLException l) {\n                l.printStackTrace();\n                return false;\n            }\n        } else {\n            try {\n                Runtime r = Runtime.getRuntime();\n                tempStr = locManager.getLocalBrowser() + \" \";\n                tempStr += runString;\n                r.exec(tempStr);\n            } catch (Exception m) {\n                m.printStackTrace();\n                JOptionPane.showMessageDialog(null, \"Run call: \" + tempStr, \"Error calling browser\", JOptionPane.ERROR_MESSAGE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean doCommand(String comm, String infoString) {\n        String tempStr = \"\";\n        if (locManager == null)\n            locManager = new DirManager(mainRun);\n        if (mainRun) {\n            if (comm.compareTo(\"editFile\") == 0) {\n                tempStr = findFile();\n                if (tempStr == null) {\n                    JOptionPane.showMessageDialog(null, \"File not found.  Please check your classpath.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                } else\n                    tempStr = file_editor + \" \" + tempStr;\n            } else if (comm.compareTo(\"editMethod\") == 0) {\n                int lineNum = 0;\n                tempStr = findFile();\n                if (tempStr == null) {\n                    JOptionPane.showMessageDialog(null, \"File not found.  Please check your classpath.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                }\n                lineNum = getMethodLineNum(tempStr, infoString);\n                if (lineNum != -1) {\n                    if (locManager.acceptsLineNumber())\n                        tempStr = file_editor + \" \" + tempStr + \" \" + locManager.lineNumberParameter() + lineNum;\n                    else {\n                        tempStr = file_editor + \" \" + tempStr;\n                        JOptionPane.showMessageDialog(null, \"Not all text editors will accept the line number as an argument so giving it to you here.\\nClick ok and your text editor will run.  Method is at line# \" + lineNum, \"Line Number Information\", JOptionPane.INFORMATION_MESSAGE);\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(null, \"Error reading file at: \" + tempStr, \"File read error\", JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            if (tempStr != null) {\n                System.out.println(\"tempStr=\" + tempStr);\n                try {\n                    Runtime r = Runtime.getRuntime();\n                    r.exec(tempStr);\n                } catch (Exception m) {\n                    m.printStackTrace();\n                    JOptionPane.showMessageDialog(null, \"Run call: \" + tempStr, \"Runtime error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String findFile() {\n        String packageInfo = myClassInfo.getClassName();\n        String primary_path = \"\";\n        primary_path = packageInfo.replace('.', file_separator.charAt(0));\n        primary_path += \".java\";\n        String full_path = null;\n        String[] bases;\n        StringList partials = new StringList();\n        String buildString = \"\";\n        char addChar;\n        for (int i = 0; i < classPath.length(); i++) {\n            addChar = classPath.charAt(i);\n            if (addChar != ';')\n                buildString += addChar;\n            else {\n                partials.add(buildString);\n                buildString = \"\";\n            }\n        }\n        if (buildString.length() != 0)\n            partials.add(buildString);\n        bases = partials.toArray();\n        File test_path;\n        String tempPath;\n        for (int i = 0; i < bases.length; i++) {\n            tempPath = bases[i];\n            if (tempPath.charAt(tempPath.length() - 1) != file_separator.charAt(0))\n                tempPath += file_separator;\n            test_path = new File(tempPath + primary_path);\n            if (test_path.exists()) {\n                full_path = tempPath + primary_path;\n            }\n        }\n        return full_path;\n    }\n\n    private int getMethodLineNum(String file_path, String methodName) {\n        StringList fullMethod = new StringList();\n        String buildStr = \"\";\n        char addChar;\n        fullMethod.add(\"public\");\n        int pos;\n        pos = methodName.indexOf(\"(\");\n        fullMethod.add(methodName.substring(0, pos));\n        for (int i = pos + 1; i < methodName.length(); i++) {\n            addChar = methodName.charAt(i);\n            if (addChar == ')') {\n                fullMethod.add(removePackages(buildStr));\n                break;\n            }\n            if (addChar != ',')\n                buildStr += addChar;\n            if (addChar == ' ' || addChar == ',') {\n                fullMethod.add(removePackages(buildStr));\n                buildStr = \"\";\n            }\n        }\n        int count = -1;\n        try {\n            File temp_file = new File(file_path);\n            FileReader fileReader = new FileReader(temp_file);\n            BufferedReader reader = new BufferedReader(fileReader);\n            String tempLine;\n            count = 0;\n            String[] method_array = fullMethod.toArray();\n            boolean testArgs = false;\n            int i = 0;\n            while ((tempLine = reader.readLine()) != null) {\n                pos = 0;\n                count++;\n                pos = tempLine.indexOf(method_array[0]);\n                if (pos != -1) {\n                    testArgs = true;\n                    i = 1;\n                    while (i < method_array.length && testArgs) {\n                        pos = tempLine.indexOf(method_array[i]);\n                        if (pos == -1)\n                            testArgs = false;\n                        else\n                            tempLine = tempLine.substring(pos);\n                        i++;\n                    }\n                }\n                if (testArgs)\n                    break;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return -1;\n        }\n        return count;\n    }\n\n    public String removeDeclarations(String in) {\n        String tempStr = null;\n        tempStr = myClassInfo.getClassName() + '.';\n        String[] known = { \"public \", tempStr };\n        return StringTools.removeStrings(in, known);\n    }\n\n    public String removePackages(String in) {\n        String[] known = myClassInfo.knownPackages;\n        return StringTools.removeStrings(in, known);\n    }\n\n    private void addStrings(JTextArea textArea, String[] strings) {\n        if (strings != null) {\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        }\n    }\n\n    private void addStrings(JTextArea textArea, String[] strings, String[] output) {\n        if (strings != null) {\n            output = new String[strings.length];\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n                output[i] = tempStr;\n            }\n        }\n    }\n\n    private void addInterfaces(JTextArea textArea) {\n        String[] strings = myClassInfo.printInterfaces();\n        if (strings != null) {\n            textArea.append(\"Interfaces:\" + '\\n');\n            for (int i = 0; i < strings.length; i++) {\n                textArea.append(strings[i] + '\\n');\n            }\n        } else\n            textArea.append(\"No interfaces.\");\n    }\n\n    private void addConstructors(JTextArea textArea) {\n        String[] strings = myClassInfo.printConstructors();\n        if (strings != null) {\n            textArea.append(\"Constructors:\" + '\\n');\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        } else if (!myClassInfo.isInterface())\n            textArea.setText(\"No public constructors.\");\n        else\n            textArea.append(\"It's an interface.\");\n    }\n\n    private void addFields(JTextArea textArea) {\n        String[] strings = myClassInfo.printFields();\n        if (strings != null) {\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        } else\n            textArea.setText(\"No public fields.\");\n    }\n\n    public void trySettingFocus() {\n        //method call for setting focus to input field\n        txt.requestFocus();\n    }\n\n    public static void main(String[] args) throws Exception {\n        mainRun = true;\n        JApplet viewer;\n        if (args.length == 1) {\n            viewer = new ClassViewer(args[0].trim());\n        } else\n            viewer = new ClassViewer();\n        JFrame frame = new JFrame(\"ClassViewer\");\n        frame.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        frame.getContentPane().add(viewer);\n        int width, height;\n        double width_adjust, height_adjust;\n        Dimension dim = frame.getToolkit().getScreenSize();\n        //using screen resolution of my laptop where I'm currently developing\n        width_adjust = 1280 / dim.getWidth();\n        height_adjust = 800 / dim.getHeight();\n        width = (int) (width_adjust * 0.85 * dim.getWidth());\n        height = (int) (height_adjust * 0.85 * dim.getHeight());\n        frame.setSize(width, height);\n        viewer.setSize(width, height);\n        viewer.init();\n        frame.setVisible(true);\n        //sets focus after start of app\n        ((ClassViewer) viewer).trySettingFocus();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassViewerTest0.java",
		"test_prompt": "// ClassViewerTest0.java\npackage com.jstevh.viewer;\n\nimport javax.swing.*;\nimport javax.swing.WindowConstants;\nimport javax.swing.border.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.datatransfer.*;\nimport java.io.*;\nimport java.net.*;\nimport java.applet.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassViewer}.\n* It contains ten unit test cases for the {@link ClassViewer#callBrowser(String)} method.\n*/\nclass ClassViewerTest0 {"
	},
	{
		"original_code": "// ClassViewer.java\n/* \n * Class Viewer - program for viewing public class information\n *\n * Copyright (C) 2004-2010  James Harris \n *\n * This program is free software; you can redistribute it \n *\n * and/or modify it under the terms of the GNU General Public\n *\n * License as published by the Free Software Foundation;\n *\n * either version 2 of the License, or (at your option) any \n *\n * later version.\n *\n *\n * This program is distributed in the hope that it will be \n *\n * useful, but WITHOUT ANY WARRANTY; without even the implied \n *\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \n *\n * PURPOSE. See the GNU General Public License for more details.\n *\n *\n * You should have received a copy of the GNU General Public \n *\n * License along with this program; if not, write to the Free \n *\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \n *\n * Boston, MA 02111-1307 USA\n *\n */\npackage com.jstevh.viewer;\n\nimport javax.swing.*;\nimport javax.swing.WindowConstants;\nimport javax.swing.border.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.datatransfer.*;\nimport java.io.*;\nimport java.net.*;\nimport java.applet.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\n\n/**\n * Viewing class that runs as an application or applet whichs\n * is paired with an internal ClassInfo which is the data class.\n * <p>\n * This class is for viewing data and managing.\n *\n * @author   James Harris\n * @version  5.0.3\n */\npublic class ClassViewer extends JApplet {\n\n    static final long serialVersionUID = -8097082256025613859L;\n\n    private static String noWarrantyStr = \"\";\n\n    {\n        noWarrantyStr += \"Class Viewer version \" + VERSION + \", Copyright (C) \" + YEAR + \" by James Harris\";\n        noWarrantyStr += \"\\ncomes with ABSOLUTELY NO WARRANTY; for details\";\n        noWarrantyStr += \"\\nsee http://www.opensource.org/licenses/gpl-license.php\\n\";\n        noWarrantyStr += \"\\nThis is free software, and you are welcome\\n\";\n        noWarrantyStr += \"to redistribute it under certain conditions;\";\n        noWarrantyStr += \"\\ncheck at http://www.opensource.org/licenses/gpl-license.php\";\n        noWarrantyStr += \"\\nfor details.\";\n    }\n\n    JButton b1 = new JButton(\"Documents\");\n\n    JTextArea txtArea, resWin, fldArea, cstrArea, infoArea;\n\n    JComboBox txt = new JComboBox();\n\n    JTextField txtTextField;\n\n    JTextField txt2 = new JTextField(10);\n\n    JPopupMenu popup = new JPopupMenu();\n\n    JMenuItem copy = new JMenuItem(\"Copy\");\n\n    JMenuItem search = new JMenuItem(\"Search\");\n\n    JMenuItem goJavaDoc = new JMenuItem(\"Documents\");\n\n    JMenu[] menus = { new JMenu(\"Help\"), new JMenu(\"Weblinks\"), new JMenu(\"Command\") };\n\n    JMenuBar menuBar = new JMenuBar();\n\n    JMenuItem instructions = new JMenuItem(\"Instructions\");\n\n    JMenuItem about = new JMenuItem(\"About\");\n\n    JMenuItem link1 = new JMenuItem(\"Class Viewer Home\");\n\n    JMenuItem link2 = new JMenuItem(\"Basic Use Instructions\");\n\n    JMenuItem link3 = new JMenuItem(\"Beyond Mundane Blog\");\n\n    JMenuItem link4 = new JMenuItem(\"Java.net--Tools\");\n\n    JMenuItem command1 = new JMenuItem(\"Set classpath\");\n\n    JMenuItem command2 = new JMenuItem(\"Edit file\");\n\n    JTabbedPane panes = new JTabbedPane();\n\n    static final int RESWIN = 0, CSTRWIN = 1, FLDWIN = 2;\n\n    public static boolean mainRun = false;\n\n    public static String classPath;\n\n    public static String currentDir;\n\n    public static String operating_system;\n\n    public static String file_separator;\n\n    public static String file_editor;\n\n    public static final String VERSION = \"5.0.3\";\n\n    public static final int YEAR = 2011;\n\n    private ClassInfo myClassInfo;\n\n    private String startClass;\n\n    private DirManager locManager;\n\n    private HashMap location;\n\n    private StringList localPackages;\n\n    private boolean isLocalFile = false;\n\n    private String[] strMethods;\n\n    private String[] displayMethods;\n\n    private Dimension scrSize;\n\n    private boolean autoSearch = false;\n\n    private String[] resWinData;\n\n    private int resWinLine;\n\n    public ClassViewer() {\n        // try{\n        //UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n        // }\n        // catch (Exception e){e.printStackTrace();}\n        txt.requestFocus();\n    }\n\n    public ClassViewer(String name) {\n        //try{\n        //  UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n        //}\n        //catch (Exception e){e.printStackTrace();}\n        startClass = name;\n        txt.requestFocus();\n    }\n\n    public void init() {\n        if (mainRun) {\n            try {\n                classPath = System.getProperty(\"java.class.path\");\n                currentDir = System.getProperty(\"user.dir\");\n                operating_system = System.getProperty(\"os.name\");\n                file_separator = System.getProperty(\"file.separator\");\n            } catch (java.security.AccessControlException access) {\n                access.printStackTrace();\n                System.out.println(\"Should never go in here\");\n                mainRun = false;\n            }\n        }\n        //getToolkit().getScreenSize();\n        scrSize = getSize();\n        double ratio = scrSize.getWidth() / 1024;\n        txtArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        txtArea.setLineWrap(true);\n        fldArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        resWin = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        cstrArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        infoArea = new JTextArea((int) (5 * ratio), (int) (20 * ratio));\n        //Adding in menus, first one is the help\n        //need to switch to fields with names\n        menus[0].add(instructions);\n        menus[0].add(about);\n        menus[1].add(link1);\n        menus[1].add(link2);\n        menus[1].add(link3);\n        menus[1].add(link4);\n        menus[2].add(command1);\n        menus[2].add(command2);\n        command2.setEnabled(false);\n        for (int i = 0; i < (menus.length); i++) {\n            menuBar.add(menus[i]);\n        }\n        setJMenuBar(menuBar);\n        if (mainRun)\n            popup.add(copy);\n        popup.add(search);\n        popup.add(goJavaDoc);\n        instructions.addActionListener(showInstructions);\n        about.addActionListener(showInfo);\n        link1.addActionListener(goHome);\n        link2.addActionListener(goBUO);\n        link3.addActionListener(goBeyond);\n        link4.addActionListener(goJN);\n        command1.addActionListener(setClasspath);\n        command2.addActionListener(editFile);\n        //menu items for pop-up menu getting ActionListeners\n        copy.addActionListener(copyToClipBoard);\n        search.addActionListener(srchMethods);\n        goJavaDoc.addActionListener(srchThenDocuments);\n        b1.addActionListener(getDocuments);\n        txt.setEditable(true);\n        txt.setMaximumRowCount(5);\n        txt.addActionListener(inMeth);\n        //Found this value by trying but put in a backup\n        Object checkComponent = txt.getComponent(2);\n        try {\n            txtTextField = (JTextField) checkComponent;\n        } catch (ClassCastException e) {\n            txtTextField = findTextField(txt);\n        }\n        txt2.addActionListener(srchMethods2);\n        txtArea.setEditable(false);\n        txtArea.addMouseListener(new ml());\n        resWin.addMouseListener(new ml());\n        fldArea.setEditable(false);\n        infoArea.setEditable(false);\n        Container cp = getContentPane();\n        JPanel bottomPanel = new JPanel();\n        JPanel bigWindows = new JPanel(), smallWindow = new JPanel(), classNameInput = new JPanel(), searchWindow = new JPanel();\n        if (!mainRun) {\n            TitledBorder mode = new TitledBorder(\"Running in applet mode\");\n            mode.setTitleColor(Color.BLUE);\n            mode.setTitleJustification(TitledBorder.CENTER);\n            bottomPanel.setBorder(mode);\n        }\n        bigWindows.setBorder(new TitledBorder(\"Public Methods\"));\n        smallWindow.setBorder(new TitledBorder(\"General Class Information\"));\n        classNameInput.setBorder(new TitledBorder(\"Class Name\"));\n        searchWindow.setBorder(new TitledBorder(\"Search String\"));\n        //cp.setLayout( new BoxLayout(cp, BoxLayout.Y_AXIS ));\n        bigWindows.add(new JScrollPane(txtArea));\n        bigWindows.add(panes);\n        panes.addTab(\"Results Window\", new JScrollPane(resWin));\n        panes.addTab(\"Constructors\", new JScrollPane(cstrArea));\n        panes.addTab(\"Fields\", new JScrollPane(fldArea));\n        smallWindow.add(infoArea);\n        classNameInput.add(txt);\n        searchWindow.add(txt2);\n        bottomPanel.add(bigWindows);\n        bottomPanel.add(smallWindow, BorderLayout.PAGE_START);\n        bottomPanel.add(classNameInput);\n        bottomPanel.add(b1);\n        bottomPanel.add(searchWindow);\n        cp.add(bottomPanel);\n        //Dimension d = getPreferredSize();\n        //d = getSize();\n        txt.requestFocus();\n        locManager = new DirManager(mainRun);\n        if (!locManager.loaded()) {\n            System.out.println(locManager.fileNotFoundError());\n            if (locManager.fileNotFoundError()) {\n                String errorStr = \"File packagedirectory.xml not found.\";\n                errorStr += \"\\n\\nLooking in directory--\\n\" + locManager.currentDir + locManager.fileSeparator;\n                errorStr += \"\\n\\nPlease put that file in the same folder as the main\";\n                errorStr += \"\\nClass Viewer program and restart program.\\n\\n\";\n                resWin.setText(errorStr);\n                errorStr += noWarrantyStr;\n                txtArea.setText(errorStr);\n            }\n        } else {\n            if (mainRun)\n                txtArea.setText(\"classpath=\" + classPath + \"\\n\\n\" + noWarrantyStr);\n            else\n                txtArea.setText(noWarrantyStr);\n        }\n        location = locManager.getDirectory();\n        if (startClass != null && startClass.compareTo(\"\") != 0) {\n            txt.addItem(startClass);\n            System.out.println(\"adding \" + startClass);\n        }\n        localPackages = locManager.getLocalPackages();\n        file_editor = locManager.getEditor();\n    }\n\n    /**\n     * Returns the JTextField that should contain user input\n     * <p>\n     *\n     * @param  in JComboBox to search within\n     *\n     * @return      a JTextField component\n     */\n    private JTextField findTextField(Container in) {\n        System.out.println(\"Looking for a JTextField inside of JComboBox\");\n        Component[] allComponents = in.getComponents();\n        JTextField retValue;\n        for (int i = 0; i < allComponents.length; i++) {\n            try {\n                retValue = (JTextField) allComponents[i];\n            } catch (ClassCastException e) {\n                continue;\n            }\n            return retValue;\n        }\n        System.out.println(\"Couldn't find JTextField inside of JComboBox\");\n        return null;\n    }\n\n    /**\n     * Returns information about the projects creator\n     * <p>\n     * This class is called when the user clicks Help and then About\n     *\n     * @return      string with author information\n     */\n    public String getAppletInfo() {\n        return \"ClassViewer for Java\" + '\\n' + \"Author: James Harris\" + '\\n' + \"Version: \" + VERSION;\n    }\n\n    /**\n     * Primary ActionListener that creates ClassInfo and populates\n     * data on screen\n     * <p>\n     * This class is called when a class name is entered.\n     */\n    ActionListener inMeth = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            if (e.getActionCommand().equals(\"comboBoxChanged\")) {\n                String tempStr = (String) txt.getSelectedItem();\n                if (tempStr == null || tempStr.trim().equals(\"\"))\n                    return;\n                try {\n                    myClassInfo = new ClassInfo(tempStr, locManager);\n                    txtArea.setText(\"\");\n                    if (txtArea.getLineWrap())\n                        txtArea.setLineWrap(false);\n                    if (resWin.getLineWrap())\n                        resWin.setLineWrap(false);\n                    resWin.setText(\"\");\n                    fldArea.setText(\"\");\n                    cstrArea.setText(\"\");\n                    int pos = txt.getSelectedIndex();\n                    if (pos != -1)\n                        txt.removeItemAt(pos);\n                    txt.insertItemAt(myClassInfo.getClassName(), 0);\n                    if (txt.getItemCount() > 4)\n                        txt.removeItemAt(4);\n                    txt.setSelectedIndex(0);\n                    txtTextField.setText(\"\");\n                    if (!myClassInfo.isInterface()) {\n                        if (myClassInfo.isAbstract())\n                            infoArea.setText(\"Abstract class \");\n                        else\n                            infoArea.setText(\"Class \");\n                    } else\n                        infoArea.setText(\"Interface \");\n                    infoArea.append(myClassInfo.getClassName() + '\\n');\n                    tempStr = myClassInfo.getSuperClassName();\n                    if (tempStr != null)\n                        infoArea.append(\"Superclass is \" + tempStr + '\\n');\n                    addInterfaces(infoArea);\n                    strMethods = myClassInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);\n                    if (strMethods != null) {\n                        displayMethods = new String[strMethods.length];\n                        for (int i = 0; i < strMethods.length; i++) {\n                            tempStr = removePackages(removeDeclarations(strMethods[i]));\n                            displayMethods[i] = tempStr;\n                            txtArea.append(tempStr + '\\n');\n                        }\n                        txtArea.setCaretPosition(0);\n                    } else\n                        txtArea.append(\"No public methods.\");\n                    addConstructors(cstrArea);\n                    panes.setSelectedIndex(CSTRWIN);\n                    addFields(fldArea);\n                    txtTextField.setText(\"\");\n                    if (localPackages.contains(myClassInfo.getClassPackage()))\n                        isLocalFile = true;\n                    if (isLocalFile)\n                        command2.setEnabled(true);\n                    else\n                        command2.setEnabled(false);\n                } catch (ClassNotFoundException j) {\n                    txtArea.setText(\"Class '\" + tempStr + \"' not found.  Case matters and for unknown\\n packages, the full class name is required.\");\n                }\n            }\n        }\n    };\n\n    /**\n     * MouseAdapter class that generates pop up when you right click\n     * on selected text.  It also does the search.\n     */\n    class ml extends MouseAdapter {\n\n        public void mouseReleased(MouseEvent e) {\n            if (myClassInfo != null) {\n                if (resWin.isFocusOwner() && e.getClickCount() < 2) {\n                    try {\n                        resWinLine = resWin.getLineOfOffset(resWin.getSelectionStart());\n                    } catch (javax.swing.text.BadLocationException k) {\n                        //if there's this exception, for now, do nothing, and move on\n                    }\n                }\n            }\n        }\n\n        public void mouseClicked(MouseEvent e) {\n            int event = e.getModifiers();\n            if (myClassInfo != null && event == InputEvent.BUTTON1_MASK && e.getClickCount() == 2) {\n                if (txtArea.isFocusOwner()) {\n                    resWin.setText(\"\");\n                    String[] result = myClassInfo.srchMethods(txtArea.getSelectedText(), displayMethods);\n                    if (result == null)\n                        resWin.append(\"No methods found.\");\n                    else {\n                        addStrings(resWin, result, resWinData);\n                        resWin.setCaretPosition(0);\n                    }\n                    resWinLine = 0;\n                    panes.setSelectedIndex(RESWIN);\n                } else if (resWin.isFocusOwner()) {\n                    int lineStart, lineEnd;\n                    try {\n                        resWinLine = resWin.getLineOfOffset(resWin.getSelectionStart());\n                        lineStart = resWin.getLineStartOffset(resWinLine);\n                        lineEnd = resWin.getLineEndOffset(resWinLine);\n                        resWin.setCaretPosition(lineStart);\n                        resWin.moveCaretPosition(lineEnd);\n                        doDocuments(resWinLine);\n                    } catch (Exception j) {\n                        j.printStackTrace();\n                    }\n                }\n            }\n            if (myClassInfo != null && event == InputEvent.BUTTON3_MASK) {\n                popup.setVisible(true);\n                popup.show(txtArea, e.getX(), e.getY());\n            }\n        }\n    }\n\n    /**\n     * ActionListener that does search when \"Search\" chosen from pop-up\n     * menu.\n     */\n    ActionListener srchMethods = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txtArea.getSelectedText();\n            resWin.setText(\"\");\n            if (myClassInfo != null) {\n                String[] result = myClassInfo.srchMethods(tempStr, displayMethods);\n                if (result == null)\n                    resWin.append(\"No methods found.\");\n                else {\n                    addStrings(resWin, result, resWinData);\n                    resWin.setCaretPosition(0);\n                }\n                panes.setSelectedIndex(RESWIN);\n            }\n        }\n    };\n\n    /**\n     * ActionListener that does search when text is entered\n     * in input field.\n     */\n    ActionListener srchMethods2 = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txt2.getText().trim();\n            resWin.setText(\"\");\n            if (myClassInfo != null) {\n                String[] result;\n                if (tempStr.indexOf(\" \") != -1) {\n                    int pos = tempStr.indexOf(\" \");\n                    StringList hold = new StringList();\n                    String segment;\n                    int count = 0;\n                    while (pos != -1 && count < 10) {\n                        segment = tempStr.substring(0, pos);\n                        tempStr = tempStr.substring(pos).trim();\n                        hold.add(segment);\n                        pos = tempStr.indexOf(\" \");\n                        count++;\n                    }\n                    hold.add(tempStr);\n                    String[] tempResults;\n                    result = myClassInfo.srchMethods(hold.get(0));\n                    for (int i = 0; i < hold.size(); i++) {\n                        result = StringTools.searchStrings(result, hold.get(i));\n                    }\n                } else\n                    result = myClassInfo.srchMethods(tempStr);\n                if (result == null)\n                    resWin.append(\"No methods found.\");\n                else {\n                    addStrings(resWin, result);\n                    resWin.setCaretPosition(0);\n                }\n                panes.setSelectedIndex(RESWIN);\n            }\n        }\n    };\n\n    /**\n     * ActionListener calls srchMethods and getDocuments when \"Documents\"\n     * is selected from pop-up menu.\n     */\n    ActionListener srchThenDocuments = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            srchMethods.actionPerformed(e);\n            getDocuments.actionPerformed(e);\n        }\n    };\n\n    /**\n     * ActionListener shows About information, selected from main menu.\n     */\n    ActionListener showInfo = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            JOptionPane.showMessageDialog(null, getAppletInfo(), \"About ClassViewer\", JOptionPane.INFORMATION_MESSAGE);\n        }\n    };\n\n    /**\n     * ActionListener go to Class Viewer Home webpage\n     */\n    ActionListener goHome = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://classviewer.sourceforge.net\");\n        }\n    };\n\n    /**\n     * ActionListener go to Basic Use Overview webpage\n     */\n    ActionListener goBUO = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://classviewer.sourceforge.net/useoverview.html\");\n        }\n    };\n\n    /**\n     * ActionListener go to Java Tools page at Java.net\n     */\n    ActionListener goJN = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://community.java.net/javatools/\");\n        }\n    };\n\n    ActionListener goBeyond = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://beyondmund.blogspot.com/\");\n        }\n    };\n\n    ActionListener setClasspath = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String newPath = JOptionPane.showInputDialog(\"Set Classpath\", classPath);\n            if (newPath != null) {\n                try {\n                    System.setProperty(\"java.class.path\", newPath);\n                    classPath = System.getProperty(\"java.class.path\");\n                } catch (java.security.AccessControlException access) {\n                    access.printStackTrace();\n                    System.out.print(\"Crashed trying to set classpath\");\n                }\n            }\n        }\n    };\n\n    ActionListener editFile = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            doCommand(\"editFile\", \"\");\n        }\n    };\n\n    /**\n     * ActionListener shows Instructions, selected from main menu.\n     */\n    ActionListener showInstructions = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String instrStr = \"\";\n            instrStr += \"Please input a full class name in the window below then\";\n            instrStr += \"\\npress <Enter>\\n\";\n            instrStr += \"\\nCase matters but known package names like\";\n            instrStr += \"\\njava.lang can be left off.\\n\";\n            instrStr += \"\\nSee packagedirectory.xml file for list of known packages\";\n            instrStr += \"\\nand add packages as needed.\\n\\n\";\n            instrStr += \"After the methods load you can select a search string in the \";\n            instrStr += \"\\nleft panel by highlighting some segment then right click.\\n\";\n            instrStr += \"\\nOr you can double-click on some string segment.\\n\";\n            instrStr += \"\\nOr you can enter a search string in the search field.  Searches\\n\";\n            instrStr += \"in that field are space delimited and case insensitive.\\n\";\n            instrStr += \"\\nClick <Documents> button after a class is entered or after\";\n            instrStr += \"\\nsearching for methods to get documents to a particular method.\\n\";\n            instrStr += \"\\nRecommended Java version is Java 1.5.0 or higher\";\n            resWin.setText(instrStr);\n            resWin.setCaretPosition(0);\n        }\n    };\n\n    /**\n     * ActionListener copies to System clipboard, selected from pop-up menu.\n     */\n    ActionListener copyToClipBoard = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txtArea.getSelectedText();\n            if (tempStr != null) {\n                StringSelection selString = new StringSelection(tempStr);\n                getToolkit().getSystemClipboard().setContents(selString, selString);\n            }\n        }\n    };\n\n    /**\n     * ActionListener gets Documents\n     */\n    ActionListener getDocuments = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            actionPerformed(e, resWinLine);\n            resWin.requestFocus();\n            int lineStart, lineEnd;\n            try {\n                lineStart = resWin.getLineStartOffset(resWinLine);\n                lineEnd = resWin.getLineEndOffset(resWinLine);\n                resWin.setCaretPosition(lineStart);\n                resWin.moveCaretPosition(lineEnd);\n            } catch (javax.swing.text.BadLocationException k) {\n                //if there's this exception, for now, do nothing, and move on\n            }\n        }\n\n        public void actionPerformed(ActionEvent e, int line) {\n            doDocuments(line);\n        }\n    };\n\n    private boolean doDocuments(int line) {\n        String className, packageName, tempStr = null;\n        if (myClassInfo != null) {\n            boolean check = false;\n            boolean found = false;\n            String[] tempArray;\n            MethodData mData = myClassInfo.getFoundMethod(line);\n            if (mData != null) {\n                packageName = mData.getMethPackage();\n                className = mData.getMethClass();\n            } else {\n                packageName = myClassInfo.getClassPackage();\n                className = myClassInfo.getClassName();\n            }\n            if (locManager == null) {\n                locManager = new DirManager(mainRun);\n                location = locManager.getDirectory();\n            }\n            String locString = (String) location.get(packageName);\n            if ((locString != null && locString.trim().compareTo(\"\") != 0) || packageName.indexOf(\"java.\") != -1 || packageName.indexOf(\"javax.\") != -1) {\n                String runString = \"\";\n                String localBrowser = \"\";\n                if (locString != null)\n                    runString = locString;\n                else if (packageName.indexOf(\"java.\") != -1)\n                    runString = (String) location.get(\"java.lang\");\n                else if (packageName.indexOf(\"javax.\") != -1)\n                    runString = (String) location.get(\"javax.swing.border\");\n                tempStr = className.replace('.', '/');\n                try {\n                    if (tempStr != null) {\n                        tempStr += \".html\";\n                        if (mData != null) {\n                            String tempStr2 = mData.getMethName();\n                            if (tempStr2.indexOf(\",\") != -1) {\n                                StringBuffer buff = new StringBuffer(tempStr2);\n                                int pos = 0;\n                                do {\n                                    pos = buff.toString().indexOf(\",\", pos);\n                                    //buff.insert(++pos, ' ');\n                                    buff.insert(++pos, '%');\n                                    buff.insert(++pos, '2');\n                                    buff.insert(++pos, '0');\n                                } while (buff.toString().indexOf(\",\", pos) != -1);\n                                tempStr2 = buff.toString();\n                            }\n                            tempStr += \"#\" + tempStr2;\n                        }\n                        runString += tempStr;\n                    }\n                    callBrowser(runString);\n                    return true;\n                } catch (NullPointerException j) {\n                    System.out.println(\"Null pointer exception\");\n                    j.printStackTrace();\n                    return false;\n                }\n            } else if (isLocalFile) {\n                if (doCommand(\"editMethod\", mData.getMethName()))\n                    return true;\n                else\n                    return false;\n            } else\n                resWin.setText(\"Unknown package.  Unable to lookup Documents.\\n  Please add package to packagedirectory.xml file.\");\n            return false;\n        }\n        return false;\n    }\n\n    public boolean callBrowser(String runString) {\n        String tempStr = \"\";\n        if (locManager == null)\n            locManager = new DirManager(mainRun);\n        if (!mainRun) {\n            try {\n                AppletContext appC = getAppletContext();\n                URL ur = new URL(runString);\n                appC.showDocument(ur, \"_blank\");\n            } catch (MalformedURLException l) {\n                l.printStackTrace();\n                return false;\n            }\n        } else {\n            try {\n                Runtime r = Runtime.getRuntime();\n                tempStr = locManager.getLocalBrowser() + \" \";\n                tempStr += runString;\n                r.exec(tempStr);\n            } catch (Exception m) {\n                m.printStackTrace();\n                JOptionPane.showMessageDialog(null, \"Run call: \" + tempStr, \"Error calling browser\", JOptionPane.ERROR_MESSAGE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean doCommand(String comm, String infoString) {\n        String tempStr = \"\";\n        if (locManager == null)\n            locManager = new DirManager(mainRun);\n        if (mainRun) {\n            if (comm.compareTo(\"editFile\") == 0) {\n                tempStr = findFile();\n                if (tempStr == null) {\n                    JOptionPane.showMessageDialog(null, \"File not found.  Please check your classpath.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                } else\n                    tempStr = file_editor + \" \" + tempStr;\n            } else if (comm.compareTo(\"editMethod\") == 0) {\n                int lineNum = 0;\n                tempStr = findFile();\n                if (tempStr == null) {\n                    JOptionPane.showMessageDialog(null, \"File not found.  Please check your classpath.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                }\n                lineNum = getMethodLineNum(tempStr, infoString);\n                if (lineNum != -1) {\n                    if (locManager.acceptsLineNumber())\n                        tempStr = file_editor + \" \" + tempStr + \" \" + locManager.lineNumberParameter() + lineNum;\n                    else {\n                        tempStr = file_editor + \" \" + tempStr;\n                        JOptionPane.showMessageDialog(null, \"Not all text editors will accept the line number as an argument so giving it to you here.\\nClick ok and your text editor will run.  Method is at line# \" + lineNum, \"Line Number Information\", JOptionPane.INFORMATION_MESSAGE);\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(null, \"Error reading file at: \" + tempStr, \"File read error\", JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            if (tempStr != null) {\n                System.out.println(\"tempStr=\" + tempStr);\n                try {\n                    Runtime r = Runtime.getRuntime();\n                    r.exec(tempStr);\n                } catch (Exception m) {\n                    m.printStackTrace();\n                    JOptionPane.showMessageDialog(null, \"Run call: \" + tempStr, \"Runtime error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String findFile() {\n        String packageInfo = myClassInfo.getClassName();\n        String primary_path = \"\";\n        primary_path = packageInfo.replace('.', file_separator.charAt(0));\n        primary_path += \".java\";\n        String full_path = null;\n        String[] bases;\n        StringList partials = new StringList();\n        String buildString = \"\";\n        char addChar;\n        for (int i = 0; i < classPath.length(); i++) {\n            addChar = classPath.charAt(i);\n            if (addChar != ';')\n                buildString += addChar;\n            else {\n                partials.add(buildString);\n                buildString = \"\";\n            }\n        }\n        if (buildString.length() != 0)\n            partials.add(buildString);\n        bases = partials.toArray();\n        File test_path;\n        String tempPath;\n        for (int i = 0; i < bases.length; i++) {\n            tempPath = bases[i];\n            if (tempPath.charAt(tempPath.length() - 1) != file_separator.charAt(0))\n                tempPath += file_separator;\n            test_path = new File(tempPath + primary_path);\n            if (test_path.exists()) {\n                full_path = tempPath + primary_path;\n            }\n        }\n        return full_path;\n    }\n\n    private int getMethodLineNum(String file_path, String methodName) {\n        StringList fullMethod = new StringList();\n        String buildStr = \"\";\n        char addChar;\n        fullMethod.add(\"public\");\n        int pos;\n        pos = methodName.indexOf(\"(\");\n        fullMethod.add(methodName.substring(0, pos));\n        for (int i = pos + 1; i < methodName.length(); i++) {\n            addChar = methodName.charAt(i);\n            if (addChar == ')') {\n                fullMethod.add(removePackages(buildStr));\n                break;\n            }\n            if (addChar != ',')\n                buildStr += addChar;\n            if (addChar == ' ' || addChar == ',') {\n                fullMethod.add(removePackages(buildStr));\n                buildStr = \"\";\n            }\n        }\n        int count = -1;\n        try {\n            File temp_file = new File(file_path);\n            FileReader fileReader = new FileReader(temp_file);\n            BufferedReader reader = new BufferedReader(fileReader);\n            String tempLine;\n            count = 0;\n            String[] method_array = fullMethod.toArray();\n            boolean testArgs = false;\n            int i = 0;\n            while ((tempLine = reader.readLine()) != null) {\n                pos = 0;\n                count++;\n                pos = tempLine.indexOf(method_array[0]);\n                if (pos != -1) {\n                    testArgs = true;\n                    i = 1;\n                    while (i < method_array.length && testArgs) {\n                        pos = tempLine.indexOf(method_array[i]);\n                        if (pos == -1)\n                            testArgs = false;\n                        else\n                            tempLine = tempLine.substring(pos);\n                        i++;\n                    }\n                }\n                if (testArgs)\n                    break;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return -1;\n        }\n        return count;\n    }\n\n    public String removeDeclarations(String in) {\n        String tempStr = null;\n        tempStr = myClassInfo.getClassName() + '.';\n        String[] known = { \"public \", tempStr };\n        return StringTools.removeStrings(in, known);\n    }\n\n    public String removePackages(String in) {\n        String[] known = myClassInfo.knownPackages;\n        return StringTools.removeStrings(in, known);\n    }\n\n    private void addStrings(JTextArea textArea, String[] strings) {\n        if (strings != null) {\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        }\n    }\n\n    private void addStrings(JTextArea textArea, String[] strings, String[] output) {\n        if (strings != null) {\n            output = new String[strings.length];\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n                output[i] = tempStr;\n            }\n        }\n    }\n\n    private void addInterfaces(JTextArea textArea) {\n        String[] strings = myClassInfo.printInterfaces();\n        if (strings != null) {\n            textArea.append(\"Interfaces:\" + '\\n');\n            for (int i = 0; i < strings.length; i++) {\n                textArea.append(strings[i] + '\\n');\n            }\n        } else\n            textArea.append(\"No interfaces.\");\n    }\n\n    private void addConstructors(JTextArea textArea) {\n        String[] strings = myClassInfo.printConstructors();\n        if (strings != null) {\n            textArea.append(\"Constructors:\" + '\\n');\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        } else if (!myClassInfo.isInterface())\n            textArea.setText(\"No public constructors.\");\n        else\n            textArea.append(\"It's an interface.\");\n    }\n\n    private void addFields(JTextArea textArea) {\n        String[] strings = myClassInfo.printFields();\n        if (strings != null) {\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        } else\n            textArea.setText(\"No public fields.\");\n    }\n\n    public void trySettingFocus() {\n        //method call for setting focus to input field\n        txt.requestFocus();\n    }\n\n    public static void main(String[] args) throws Exception {\n        mainRun = true;\n        JApplet viewer;\n        if (args.length == 1) {\n            viewer = new ClassViewer(args[0].trim());\n        } else\n            viewer = new ClassViewer();\n        JFrame frame = new JFrame(\"ClassViewer\");\n        frame.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        frame.getContentPane().add(viewer);\n        int width, height;\n        double width_adjust, height_adjust;\n        Dimension dim = frame.getToolkit().getScreenSize();\n        //using screen resolution of my laptop where I'm currently developing\n        width_adjust = 1280 / dim.getWidth();\n        height_adjust = 800 / dim.getHeight();\n        width = (int) (width_adjust * 0.85 * dim.getWidth());\n        height = (int) (height_adjust * 0.85 * dim.getHeight());\n        frame.setSize(width, height);\n        viewer.setSize(width, height);\n        viewer.init();\n        frame.setVisible(true);\n        //sets focus after start of app\n        ((ClassViewer) viewer).trySettingFocus();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassViewerTest1.java",
		"test_prompt": "// ClassViewerTest1.java\npackage com.jstevh.viewer;\n\nimport javax.swing.*;\nimport javax.swing.WindowConstants;\nimport javax.swing.border.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.datatransfer.*;\nimport java.io.*;\nimport java.net.*;\nimport java.applet.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassViewer}.\n* It contains ten unit test cases for the {@link ClassViewer#removeDeclarations(String)} method.\n*/\nclass ClassViewerTest1 {"
	},
	{
		"original_code": "// ClassViewer.java\n/* \n * Class Viewer - program for viewing public class information\n *\n * Copyright (C) 2004-2010  James Harris \n *\n * This program is free software; you can redistribute it \n *\n * and/or modify it under the terms of the GNU General Public\n *\n * License as published by the Free Software Foundation;\n *\n * either version 2 of the License, or (at your option) any \n *\n * later version.\n *\n *\n * This program is distributed in the hope that it will be \n *\n * useful, but WITHOUT ANY WARRANTY; without even the implied \n *\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \n *\n * PURPOSE. See the GNU General Public License for more details.\n *\n *\n * You should have received a copy of the GNU General Public \n *\n * License along with this program; if not, write to the Free \n *\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \n *\n * Boston, MA 02111-1307 USA\n *\n */\npackage com.jstevh.viewer;\n\nimport javax.swing.*;\nimport javax.swing.WindowConstants;\nimport javax.swing.border.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.datatransfer.*;\nimport java.io.*;\nimport java.net.*;\nimport java.applet.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\n\n/**\n * Viewing class that runs as an application or applet whichs\n * is paired with an internal ClassInfo which is the data class.\n * <p>\n * This class is for viewing data and managing.\n *\n * @author   James Harris\n * @version  5.0.3\n */\npublic class ClassViewer extends JApplet {\n\n    static final long serialVersionUID = -8097082256025613859L;\n\n    private static String noWarrantyStr = \"\";\n\n    {\n        noWarrantyStr += \"Class Viewer version \" + VERSION + \", Copyright (C) \" + YEAR + \" by James Harris\";\n        noWarrantyStr += \"\\ncomes with ABSOLUTELY NO WARRANTY; for details\";\n        noWarrantyStr += \"\\nsee http://www.opensource.org/licenses/gpl-license.php\\n\";\n        noWarrantyStr += \"\\nThis is free software, and you are welcome\\n\";\n        noWarrantyStr += \"to redistribute it under certain conditions;\";\n        noWarrantyStr += \"\\ncheck at http://www.opensource.org/licenses/gpl-license.php\";\n        noWarrantyStr += \"\\nfor details.\";\n    }\n\n    JButton b1 = new JButton(\"Documents\");\n\n    JTextArea txtArea, resWin, fldArea, cstrArea, infoArea;\n\n    JComboBox txt = new JComboBox();\n\n    JTextField txtTextField;\n\n    JTextField txt2 = new JTextField(10);\n\n    JPopupMenu popup = new JPopupMenu();\n\n    JMenuItem copy = new JMenuItem(\"Copy\");\n\n    JMenuItem search = new JMenuItem(\"Search\");\n\n    JMenuItem goJavaDoc = new JMenuItem(\"Documents\");\n\n    JMenu[] menus = { new JMenu(\"Help\"), new JMenu(\"Weblinks\"), new JMenu(\"Command\") };\n\n    JMenuBar menuBar = new JMenuBar();\n\n    JMenuItem instructions = new JMenuItem(\"Instructions\");\n\n    JMenuItem about = new JMenuItem(\"About\");\n\n    JMenuItem link1 = new JMenuItem(\"Class Viewer Home\");\n\n    JMenuItem link2 = new JMenuItem(\"Basic Use Instructions\");\n\n    JMenuItem link3 = new JMenuItem(\"Beyond Mundane Blog\");\n\n    JMenuItem link4 = new JMenuItem(\"Java.net--Tools\");\n\n    JMenuItem command1 = new JMenuItem(\"Set classpath\");\n\n    JMenuItem command2 = new JMenuItem(\"Edit file\");\n\n    JTabbedPane panes = new JTabbedPane();\n\n    static final int RESWIN = 0, CSTRWIN = 1, FLDWIN = 2;\n\n    public static boolean mainRun = false;\n\n    public static String classPath;\n\n    public static String currentDir;\n\n    public static String operating_system;\n\n    public static String file_separator;\n\n    public static String file_editor;\n\n    public static final String VERSION = \"5.0.3\";\n\n    public static final int YEAR = 2011;\n\n    private ClassInfo myClassInfo;\n\n    private String startClass;\n\n    private DirManager locManager;\n\n    private HashMap location;\n\n    private StringList localPackages;\n\n    private boolean isLocalFile = false;\n\n    private String[] strMethods;\n\n    private String[] displayMethods;\n\n    private Dimension scrSize;\n\n    private boolean autoSearch = false;\n\n    private String[] resWinData;\n\n    private int resWinLine;\n\n    public ClassViewer() {\n        // try{\n        //UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n        // }\n        // catch (Exception e){e.printStackTrace();}\n        txt.requestFocus();\n    }\n\n    public ClassViewer(String name) {\n        //try{\n        //  UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n        //}\n        //catch (Exception e){e.printStackTrace();}\n        startClass = name;\n        txt.requestFocus();\n    }\n\n    public void init() {\n        if (mainRun) {\n            try {\n                classPath = System.getProperty(\"java.class.path\");\n                currentDir = System.getProperty(\"user.dir\");\n                operating_system = System.getProperty(\"os.name\");\n                file_separator = System.getProperty(\"file.separator\");\n            } catch (java.security.AccessControlException access) {\n                access.printStackTrace();\n                System.out.println(\"Should never go in here\");\n                mainRun = false;\n            }\n        }\n        //getToolkit().getScreenSize();\n        scrSize = getSize();\n        double ratio = scrSize.getWidth() / 1024;\n        txtArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        txtArea.setLineWrap(true);\n        fldArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        resWin = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        cstrArea = new JTextArea((int) (20 * ratio), (int) (40 * ratio));\n        infoArea = new JTextArea((int) (5 * ratio), (int) (20 * ratio));\n        //Adding in menus, first one is the help\n        //need to switch to fields with names\n        menus[0].add(instructions);\n        menus[0].add(about);\n        menus[1].add(link1);\n        menus[1].add(link2);\n        menus[1].add(link3);\n        menus[1].add(link4);\n        menus[2].add(command1);\n        menus[2].add(command2);\n        command2.setEnabled(false);\n        for (int i = 0; i < (menus.length); i++) {\n            menuBar.add(menus[i]);\n        }\n        setJMenuBar(menuBar);\n        if (mainRun)\n            popup.add(copy);\n        popup.add(search);\n        popup.add(goJavaDoc);\n        instructions.addActionListener(showInstructions);\n        about.addActionListener(showInfo);\n        link1.addActionListener(goHome);\n        link2.addActionListener(goBUO);\n        link3.addActionListener(goBeyond);\n        link4.addActionListener(goJN);\n        command1.addActionListener(setClasspath);\n        command2.addActionListener(editFile);\n        //menu items for pop-up menu getting ActionListeners\n        copy.addActionListener(copyToClipBoard);\n        search.addActionListener(srchMethods);\n        goJavaDoc.addActionListener(srchThenDocuments);\n        b1.addActionListener(getDocuments);\n        txt.setEditable(true);\n        txt.setMaximumRowCount(5);\n        txt.addActionListener(inMeth);\n        //Found this value by trying but put in a backup\n        Object checkComponent = txt.getComponent(2);\n        try {\n            txtTextField = (JTextField) checkComponent;\n        } catch (ClassCastException e) {\n            txtTextField = findTextField(txt);\n        }\n        txt2.addActionListener(srchMethods2);\n        txtArea.setEditable(false);\n        txtArea.addMouseListener(new ml());\n        resWin.addMouseListener(new ml());\n        fldArea.setEditable(false);\n        infoArea.setEditable(false);\n        Container cp = getContentPane();\n        JPanel bottomPanel = new JPanel();\n        JPanel bigWindows = new JPanel(), smallWindow = new JPanel(), classNameInput = new JPanel(), searchWindow = new JPanel();\n        if (!mainRun) {\n            TitledBorder mode = new TitledBorder(\"Running in applet mode\");\n            mode.setTitleColor(Color.BLUE);\n            mode.setTitleJustification(TitledBorder.CENTER);\n            bottomPanel.setBorder(mode);\n        }\n        bigWindows.setBorder(new TitledBorder(\"Public Methods\"));\n        smallWindow.setBorder(new TitledBorder(\"General Class Information\"));\n        classNameInput.setBorder(new TitledBorder(\"Class Name\"));\n        searchWindow.setBorder(new TitledBorder(\"Search String\"));\n        //cp.setLayout( new BoxLayout(cp, BoxLayout.Y_AXIS ));\n        bigWindows.add(new JScrollPane(txtArea));\n        bigWindows.add(panes);\n        panes.addTab(\"Results Window\", new JScrollPane(resWin));\n        panes.addTab(\"Constructors\", new JScrollPane(cstrArea));\n        panes.addTab(\"Fields\", new JScrollPane(fldArea));\n        smallWindow.add(infoArea);\n        classNameInput.add(txt);\n        searchWindow.add(txt2);\n        bottomPanel.add(bigWindows);\n        bottomPanel.add(smallWindow, BorderLayout.PAGE_START);\n        bottomPanel.add(classNameInput);\n        bottomPanel.add(b1);\n        bottomPanel.add(searchWindow);\n        cp.add(bottomPanel);\n        //Dimension d = getPreferredSize();\n        //d = getSize();\n        txt.requestFocus();\n        locManager = new DirManager(mainRun);\n        if (!locManager.loaded()) {\n            System.out.println(locManager.fileNotFoundError());\n            if (locManager.fileNotFoundError()) {\n                String errorStr = \"File packagedirectory.xml not found.\";\n                errorStr += \"\\n\\nLooking in directory--\\n\" + locManager.currentDir + locManager.fileSeparator;\n                errorStr += \"\\n\\nPlease put that file in the same folder as the main\";\n                errorStr += \"\\nClass Viewer program and restart program.\\n\\n\";\n                resWin.setText(errorStr);\n                errorStr += noWarrantyStr;\n                txtArea.setText(errorStr);\n            }\n        } else {\n            if (mainRun)\n                txtArea.setText(\"classpath=\" + classPath + \"\\n\\n\" + noWarrantyStr);\n            else\n                txtArea.setText(noWarrantyStr);\n        }\n        location = locManager.getDirectory();\n        if (startClass != null && startClass.compareTo(\"\") != 0) {\n            txt.addItem(startClass);\n            System.out.println(\"adding \" + startClass);\n        }\n        localPackages = locManager.getLocalPackages();\n        file_editor = locManager.getEditor();\n    }\n\n    /**\n     * Returns the JTextField that should contain user input\n     * <p>\n     *\n     * @param  in JComboBox to search within\n     *\n     * @return      a JTextField component\n     */\n    private JTextField findTextField(Container in) {\n        System.out.println(\"Looking for a JTextField inside of JComboBox\");\n        Component[] allComponents = in.getComponents();\n        JTextField retValue;\n        for (int i = 0; i < allComponents.length; i++) {\n            try {\n                retValue = (JTextField) allComponents[i];\n            } catch (ClassCastException e) {\n                continue;\n            }\n            return retValue;\n        }\n        System.out.println(\"Couldn't find JTextField inside of JComboBox\");\n        return null;\n    }\n\n    /**\n     * Returns information about the projects creator\n     * <p>\n     * This class is called when the user clicks Help and then About\n     *\n     * @return      string with author information\n     */\n    public String getAppletInfo() {\n        return \"ClassViewer for Java\" + '\\n' + \"Author: James Harris\" + '\\n' + \"Version: \" + VERSION;\n    }\n\n    /**\n     * Primary ActionListener that creates ClassInfo and populates\n     * data on screen\n     * <p>\n     * This class is called when a class name is entered.\n     */\n    ActionListener inMeth = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            if (e.getActionCommand().equals(\"comboBoxChanged\")) {\n                String tempStr = (String) txt.getSelectedItem();\n                if (tempStr == null || tempStr.trim().equals(\"\"))\n                    return;\n                try {\n                    myClassInfo = new ClassInfo(tempStr, locManager);\n                    txtArea.setText(\"\");\n                    if (txtArea.getLineWrap())\n                        txtArea.setLineWrap(false);\n                    if (resWin.getLineWrap())\n                        resWin.setLineWrap(false);\n                    resWin.setText(\"\");\n                    fldArea.setText(\"\");\n                    cstrArea.setText(\"\");\n                    int pos = txt.getSelectedIndex();\n                    if (pos != -1)\n                        txt.removeItemAt(pos);\n                    txt.insertItemAt(myClassInfo.getClassName(), 0);\n                    if (txt.getItemCount() > 4)\n                        txt.removeItemAt(4);\n                    txt.setSelectedIndex(0);\n                    txtTextField.setText(\"\");\n                    if (!myClassInfo.isInterface()) {\n                        if (myClassInfo.isAbstract())\n                            infoArea.setText(\"Abstract class \");\n                        else\n                            infoArea.setText(\"Class \");\n                    } else\n                        infoArea.setText(\"Interface \");\n                    infoArea.append(myClassInfo.getClassName() + '\\n');\n                    tempStr = myClassInfo.getSuperClassName();\n                    if (tempStr != null)\n                        infoArea.append(\"Superclass is \" + tempStr + '\\n');\n                    addInterfaces(infoArea);\n                    strMethods = myClassInfo.printMethods(ClassInfo.NO_INHERITED_METHODS);\n                    if (strMethods != null) {\n                        displayMethods = new String[strMethods.length];\n                        for (int i = 0; i < strMethods.length; i++) {\n                            tempStr = removePackages(removeDeclarations(strMethods[i]));\n                            displayMethods[i] = tempStr;\n                            txtArea.append(tempStr + '\\n');\n                        }\n                        txtArea.setCaretPosition(0);\n                    } else\n                        txtArea.append(\"No public methods.\");\n                    addConstructors(cstrArea);\n                    panes.setSelectedIndex(CSTRWIN);\n                    addFields(fldArea);\n                    txtTextField.setText(\"\");\n                    if (localPackages.contains(myClassInfo.getClassPackage()))\n                        isLocalFile = true;\n                    if (isLocalFile)\n                        command2.setEnabled(true);\n                    else\n                        command2.setEnabled(false);\n                } catch (ClassNotFoundException j) {\n                    txtArea.setText(\"Class '\" + tempStr + \"' not found.  Case matters and for unknown\\n packages, the full class name is required.\");\n                }\n            }\n        }\n    };\n\n    /**\n     * MouseAdapter class that generates pop up when you right click\n     * on selected text.  It also does the search.\n     */\n    class ml extends MouseAdapter {\n\n        public void mouseReleased(MouseEvent e) {\n            if (myClassInfo != null) {\n                if (resWin.isFocusOwner() && e.getClickCount() < 2) {\n                    try {\n                        resWinLine = resWin.getLineOfOffset(resWin.getSelectionStart());\n                    } catch (javax.swing.text.BadLocationException k) {\n                        //if there's this exception, for now, do nothing, and move on\n                    }\n                }\n            }\n        }\n\n        public void mouseClicked(MouseEvent e) {\n            int event = e.getModifiers();\n            if (myClassInfo != null && event == InputEvent.BUTTON1_MASK && e.getClickCount() == 2) {\n                if (txtArea.isFocusOwner()) {\n                    resWin.setText(\"\");\n                    String[] result = myClassInfo.srchMethods(txtArea.getSelectedText(), displayMethods);\n                    if (result == null)\n                        resWin.append(\"No methods found.\");\n                    else {\n                        addStrings(resWin, result, resWinData);\n                        resWin.setCaretPosition(0);\n                    }\n                    resWinLine = 0;\n                    panes.setSelectedIndex(RESWIN);\n                } else if (resWin.isFocusOwner()) {\n                    int lineStart, lineEnd;\n                    try {\n                        resWinLine = resWin.getLineOfOffset(resWin.getSelectionStart());\n                        lineStart = resWin.getLineStartOffset(resWinLine);\n                        lineEnd = resWin.getLineEndOffset(resWinLine);\n                        resWin.setCaretPosition(lineStart);\n                        resWin.moveCaretPosition(lineEnd);\n                        doDocuments(resWinLine);\n                    } catch (Exception j) {\n                        j.printStackTrace();\n                    }\n                }\n            }\n            if (myClassInfo != null && event == InputEvent.BUTTON3_MASK) {\n                popup.setVisible(true);\n                popup.show(txtArea, e.getX(), e.getY());\n            }\n        }\n    }\n\n    /**\n     * ActionListener that does search when \"Search\" chosen from pop-up\n     * menu.\n     */\n    ActionListener srchMethods = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txtArea.getSelectedText();\n            resWin.setText(\"\");\n            if (myClassInfo != null) {\n                String[] result = myClassInfo.srchMethods(tempStr, displayMethods);\n                if (result == null)\n                    resWin.append(\"No methods found.\");\n                else {\n                    addStrings(resWin, result, resWinData);\n                    resWin.setCaretPosition(0);\n                }\n                panes.setSelectedIndex(RESWIN);\n            }\n        }\n    };\n\n    /**\n     * ActionListener that does search when text is entered\n     * in input field.\n     */\n    ActionListener srchMethods2 = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txt2.getText().trim();\n            resWin.setText(\"\");\n            if (myClassInfo != null) {\n                String[] result;\n                if (tempStr.indexOf(\" \") != -1) {\n                    int pos = tempStr.indexOf(\" \");\n                    StringList hold = new StringList();\n                    String segment;\n                    int count = 0;\n                    while (pos != -1 && count < 10) {\n                        segment = tempStr.substring(0, pos);\n                        tempStr = tempStr.substring(pos).trim();\n                        hold.add(segment);\n                        pos = tempStr.indexOf(\" \");\n                        count++;\n                    }\n                    hold.add(tempStr);\n                    String[] tempResults;\n                    result = myClassInfo.srchMethods(hold.get(0));\n                    for (int i = 0; i < hold.size(); i++) {\n                        result = StringTools.searchStrings(result, hold.get(i));\n                    }\n                } else\n                    result = myClassInfo.srchMethods(tempStr);\n                if (result == null)\n                    resWin.append(\"No methods found.\");\n                else {\n                    addStrings(resWin, result);\n                    resWin.setCaretPosition(0);\n                }\n                panes.setSelectedIndex(RESWIN);\n            }\n        }\n    };\n\n    /**\n     * ActionListener calls srchMethods and getDocuments when \"Documents\"\n     * is selected from pop-up menu.\n     */\n    ActionListener srchThenDocuments = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            srchMethods.actionPerformed(e);\n            getDocuments.actionPerformed(e);\n        }\n    };\n\n    /**\n     * ActionListener shows About information, selected from main menu.\n     */\n    ActionListener showInfo = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            JOptionPane.showMessageDialog(null, getAppletInfo(), \"About ClassViewer\", JOptionPane.INFORMATION_MESSAGE);\n        }\n    };\n\n    /**\n     * ActionListener go to Class Viewer Home webpage\n     */\n    ActionListener goHome = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://classviewer.sourceforge.net\");\n        }\n    };\n\n    /**\n     * ActionListener go to Basic Use Overview webpage\n     */\n    ActionListener goBUO = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://classviewer.sourceforge.net/useoverview.html\");\n        }\n    };\n\n    /**\n     * ActionListener go to Java Tools page at Java.net\n     */\n    ActionListener goJN = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://community.java.net/javatools/\");\n        }\n    };\n\n    ActionListener goBeyond = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            callBrowser(\"http://beyondmund.blogspot.com/\");\n        }\n    };\n\n    ActionListener setClasspath = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String newPath = JOptionPane.showInputDialog(\"Set Classpath\", classPath);\n            if (newPath != null) {\n                try {\n                    System.setProperty(\"java.class.path\", newPath);\n                    classPath = System.getProperty(\"java.class.path\");\n                } catch (java.security.AccessControlException access) {\n                    access.printStackTrace();\n                    System.out.print(\"Crashed trying to set classpath\");\n                }\n            }\n        }\n    };\n\n    ActionListener editFile = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            doCommand(\"editFile\", \"\");\n        }\n    };\n\n    /**\n     * ActionListener shows Instructions, selected from main menu.\n     */\n    ActionListener showInstructions = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String instrStr = \"\";\n            instrStr += \"Please input a full class name in the window below then\";\n            instrStr += \"\\npress <Enter>\\n\";\n            instrStr += \"\\nCase matters but known package names like\";\n            instrStr += \"\\njava.lang can be left off.\\n\";\n            instrStr += \"\\nSee packagedirectory.xml file for list of known packages\";\n            instrStr += \"\\nand add packages as needed.\\n\\n\";\n            instrStr += \"After the methods load you can select a search string in the \";\n            instrStr += \"\\nleft panel by highlighting some segment then right click.\\n\";\n            instrStr += \"\\nOr you can double-click on some string segment.\\n\";\n            instrStr += \"\\nOr you can enter a search string in the search field.  Searches\\n\";\n            instrStr += \"in that field are space delimited and case insensitive.\\n\";\n            instrStr += \"\\nClick <Documents> button after a class is entered or after\";\n            instrStr += \"\\nsearching for methods to get documents to a particular method.\\n\";\n            instrStr += \"\\nRecommended Java version is Java 1.5.0 or higher\";\n            resWin.setText(instrStr);\n            resWin.setCaretPosition(0);\n        }\n    };\n\n    /**\n     * ActionListener copies to System clipboard, selected from pop-up menu.\n     */\n    ActionListener copyToClipBoard = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            String tempStr = txtArea.getSelectedText();\n            if (tempStr != null) {\n                StringSelection selString = new StringSelection(tempStr);\n                getToolkit().getSystemClipboard().setContents(selString, selString);\n            }\n        }\n    };\n\n    /**\n     * ActionListener gets Documents\n     */\n    ActionListener getDocuments = new ActionListener() {\n\n        public void actionPerformed(ActionEvent e) {\n            actionPerformed(e, resWinLine);\n            resWin.requestFocus();\n            int lineStart, lineEnd;\n            try {\n                lineStart = resWin.getLineStartOffset(resWinLine);\n                lineEnd = resWin.getLineEndOffset(resWinLine);\n                resWin.setCaretPosition(lineStart);\n                resWin.moveCaretPosition(lineEnd);\n            } catch (javax.swing.text.BadLocationException k) {\n                //if there's this exception, for now, do nothing, and move on\n            }\n        }\n\n        public void actionPerformed(ActionEvent e, int line) {\n            doDocuments(line);\n        }\n    };\n\n    private boolean doDocuments(int line) {\n        String className, packageName, tempStr = null;\n        if (myClassInfo != null) {\n            boolean check = false;\n            boolean found = false;\n            String[] tempArray;\n            MethodData mData = myClassInfo.getFoundMethod(line);\n            if (mData != null) {\n                packageName = mData.getMethPackage();\n                className = mData.getMethClass();\n            } else {\n                packageName = myClassInfo.getClassPackage();\n                className = myClassInfo.getClassName();\n            }\n            if (locManager == null) {\n                locManager = new DirManager(mainRun);\n                location = locManager.getDirectory();\n            }\n            String locString = (String) location.get(packageName);\n            if ((locString != null && locString.trim().compareTo(\"\") != 0) || packageName.indexOf(\"java.\") != -1 || packageName.indexOf(\"javax.\") != -1) {\n                String runString = \"\";\n                String localBrowser = \"\";\n                if (locString != null)\n                    runString = locString;\n                else if (packageName.indexOf(\"java.\") != -1)\n                    runString = (String) location.get(\"java.lang\");\n                else if (packageName.indexOf(\"javax.\") != -1)\n                    runString = (String) location.get(\"javax.swing.border\");\n                tempStr = className.replace('.', '/');\n                try {\n                    if (tempStr != null) {\n                        tempStr += \".html\";\n                        if (mData != null) {\n                            String tempStr2 = mData.getMethName();\n                            if (tempStr2.indexOf(\",\") != -1) {\n                                StringBuffer buff = new StringBuffer(tempStr2);\n                                int pos = 0;\n                                do {\n                                    pos = buff.toString().indexOf(\",\", pos);\n                                    //buff.insert(++pos, ' ');\n                                    buff.insert(++pos, '%');\n                                    buff.insert(++pos, '2');\n                                    buff.insert(++pos, '0');\n                                } while (buff.toString().indexOf(\",\", pos) != -1);\n                                tempStr2 = buff.toString();\n                            }\n                            tempStr += \"#\" + tempStr2;\n                        }\n                        runString += tempStr;\n                    }\n                    callBrowser(runString);\n                    return true;\n                } catch (NullPointerException j) {\n                    System.out.println(\"Null pointer exception\");\n                    j.printStackTrace();\n                    return false;\n                }\n            } else if (isLocalFile) {\n                if (doCommand(\"editMethod\", mData.getMethName()))\n                    return true;\n                else\n                    return false;\n            } else\n                resWin.setText(\"Unknown package.  Unable to lookup Documents.\\n  Please add package to packagedirectory.xml file.\");\n            return false;\n        }\n        return false;\n    }\n\n    public boolean callBrowser(String runString) {\n        String tempStr = \"\";\n        if (locManager == null)\n            locManager = new DirManager(mainRun);\n        if (!mainRun) {\n            try {\n                AppletContext appC = getAppletContext();\n                URL ur = new URL(runString);\n                appC.showDocument(ur, \"_blank\");\n            } catch (MalformedURLException l) {\n                l.printStackTrace();\n                return false;\n            }\n        } else {\n            try {\n                Runtime r = Runtime.getRuntime();\n                tempStr = locManager.getLocalBrowser() + \" \";\n                tempStr += runString;\n                r.exec(tempStr);\n            } catch (Exception m) {\n                m.printStackTrace();\n                JOptionPane.showMessageDialog(null, \"Run call: \" + tempStr, \"Error calling browser\", JOptionPane.ERROR_MESSAGE);\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean doCommand(String comm, String infoString) {\n        String tempStr = \"\";\n        if (locManager == null)\n            locManager = new DirManager(mainRun);\n        if (mainRun) {\n            if (comm.compareTo(\"editFile\") == 0) {\n                tempStr = findFile();\n                if (tempStr == null) {\n                    JOptionPane.showMessageDialog(null, \"File not found.  Please check your classpath.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                } else\n                    tempStr = file_editor + \" \" + tempStr;\n            } else if (comm.compareTo(\"editMethod\") == 0) {\n                int lineNum = 0;\n                tempStr = findFile();\n                if (tempStr == null) {\n                    JOptionPane.showMessageDialog(null, \"File not found.  Please check your classpath.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                }\n                lineNum = getMethodLineNum(tempStr, infoString);\n                if (lineNum != -1) {\n                    if (locManager.acceptsLineNumber())\n                        tempStr = file_editor + \" \" + tempStr + \" \" + locManager.lineNumberParameter() + lineNum;\n                    else {\n                        tempStr = file_editor + \" \" + tempStr;\n                        JOptionPane.showMessageDialog(null, \"Not all text editors will accept the line number as an argument so giving it to you here.\\nClick ok and your text editor will run.  Method is at line# \" + lineNum, \"Line Number Information\", JOptionPane.INFORMATION_MESSAGE);\n                    }\n                } else {\n                    JOptionPane.showMessageDialog(null, \"Error reading file at: \" + tempStr, \"File read error\", JOptionPane.ERROR_MESSAGE);\n                }\n            }\n            if (tempStr != null) {\n                System.out.println(\"tempStr=\" + tempStr);\n                try {\n                    Runtime r = Runtime.getRuntime();\n                    r.exec(tempStr);\n                } catch (Exception m) {\n                    m.printStackTrace();\n                    JOptionPane.showMessageDialog(null, \"Run call: \" + tempStr, \"Runtime error\", JOptionPane.ERROR_MESSAGE);\n                    return false;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private String findFile() {\n        String packageInfo = myClassInfo.getClassName();\n        String primary_path = \"\";\n        primary_path = packageInfo.replace('.', file_separator.charAt(0));\n        primary_path += \".java\";\n        String full_path = null;\n        String[] bases;\n        StringList partials = new StringList();\n        String buildString = \"\";\n        char addChar;\n        for (int i = 0; i < classPath.length(); i++) {\n            addChar = classPath.charAt(i);\n            if (addChar != ';')\n                buildString += addChar;\n            else {\n                partials.add(buildString);\n                buildString = \"\";\n            }\n        }\n        if (buildString.length() != 0)\n            partials.add(buildString);\n        bases = partials.toArray();\n        File test_path;\n        String tempPath;\n        for (int i = 0; i < bases.length; i++) {\n            tempPath = bases[i];\n            if (tempPath.charAt(tempPath.length() - 1) != file_separator.charAt(0))\n                tempPath += file_separator;\n            test_path = new File(tempPath + primary_path);\n            if (test_path.exists()) {\n                full_path = tempPath + primary_path;\n            }\n        }\n        return full_path;\n    }\n\n    private int getMethodLineNum(String file_path, String methodName) {\n        StringList fullMethod = new StringList();\n        String buildStr = \"\";\n        char addChar;\n        fullMethod.add(\"public\");\n        int pos;\n        pos = methodName.indexOf(\"(\");\n        fullMethod.add(methodName.substring(0, pos));\n        for (int i = pos + 1; i < methodName.length(); i++) {\n            addChar = methodName.charAt(i);\n            if (addChar == ')') {\n                fullMethod.add(removePackages(buildStr));\n                break;\n            }\n            if (addChar != ',')\n                buildStr += addChar;\n            if (addChar == ' ' || addChar == ',') {\n                fullMethod.add(removePackages(buildStr));\n                buildStr = \"\";\n            }\n        }\n        int count = -1;\n        try {\n            File temp_file = new File(file_path);\n            FileReader fileReader = new FileReader(temp_file);\n            BufferedReader reader = new BufferedReader(fileReader);\n            String tempLine;\n            count = 0;\n            String[] method_array = fullMethod.toArray();\n            boolean testArgs = false;\n            int i = 0;\n            while ((tempLine = reader.readLine()) != null) {\n                pos = 0;\n                count++;\n                pos = tempLine.indexOf(method_array[0]);\n                if (pos != -1) {\n                    testArgs = true;\n                    i = 1;\n                    while (i < method_array.length && testArgs) {\n                        pos = tempLine.indexOf(method_array[i]);\n                        if (pos == -1)\n                            testArgs = false;\n                        else\n                            tempLine = tempLine.substring(pos);\n                        i++;\n                    }\n                }\n                if (testArgs)\n                    break;\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            return -1;\n        }\n        return count;\n    }\n\n    public String removeDeclarations(String in) {\n        String tempStr = null;\n        tempStr = myClassInfo.getClassName() + '.';\n        String[] known = { \"public \", tempStr };\n        return StringTools.removeStrings(in, known);\n    }\n\n    public String removePackages(String in) {\n        String[] known = myClassInfo.knownPackages;\n        return StringTools.removeStrings(in, known);\n    }\n\n    private void addStrings(JTextArea textArea, String[] strings) {\n        if (strings != null) {\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        }\n    }\n\n    private void addStrings(JTextArea textArea, String[] strings, String[] output) {\n        if (strings != null) {\n            output = new String[strings.length];\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n                output[i] = tempStr;\n            }\n        }\n    }\n\n    private void addInterfaces(JTextArea textArea) {\n        String[] strings = myClassInfo.printInterfaces();\n        if (strings != null) {\n            textArea.append(\"Interfaces:\" + '\\n');\n            for (int i = 0; i < strings.length; i++) {\n                textArea.append(strings[i] + '\\n');\n            }\n        } else\n            textArea.append(\"No interfaces.\");\n    }\n\n    private void addConstructors(JTextArea textArea) {\n        String[] strings = myClassInfo.printConstructors();\n        if (strings != null) {\n            textArea.append(\"Constructors:\" + '\\n');\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        } else if (!myClassInfo.isInterface())\n            textArea.setText(\"No public constructors.\");\n        else\n            textArea.append(\"It's an interface.\");\n    }\n\n    private void addFields(JTextArea textArea) {\n        String[] strings = myClassInfo.printFields();\n        if (strings != null) {\n            String tempStr;\n            for (int i = 0; i < strings.length; i++) {\n                tempStr = removePackages(removeDeclarations(strings[i]));\n                textArea.append(tempStr + '\\n');\n            }\n        } else\n            textArea.setText(\"No public fields.\");\n    }\n\n    public void trySettingFocus() {\n        //method call for setting focus to input field\n        txt.requestFocus();\n    }\n\n    public static void main(String[] args) throws Exception {\n        mainRun = true;\n        JApplet viewer;\n        if (args.length == 1) {\n            viewer = new ClassViewer(args[0].trim());\n        } else\n            viewer = new ClassViewer();\n        JFrame frame = new JFrame(\"ClassViewer\");\n        frame.addWindowListener(new WindowAdapter() {\n\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        frame.getContentPane().add(viewer);\n        int width, height;\n        double width_adjust, height_adjust;\n        Dimension dim = frame.getToolkit().getScreenSize();\n        //using screen resolution of my laptop where I'm currently developing\n        width_adjust = 1280 / dim.getWidth();\n        height_adjust = 800 / dim.getHeight();\n        width = (int) (width_adjust * 0.85 * dim.getWidth());\n        height = (int) (height_adjust * 0.85 * dim.getHeight());\n        frame.setSize(width, height);\n        viewer.setSize(width, height);\n        viewer.init();\n        frame.setVisible(true);\n        //sets focus after start of app\n        ((ClassViewer) viewer).trySettingFocus();\n    }\n}\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassViewerTest2.java",
		"test_prompt": "// ClassViewerTest2.java\npackage com.jstevh.viewer;\n\nimport javax.swing.*;\nimport javax.swing.WindowConstants;\nimport javax.swing.border.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.datatransfer.*;\nimport java.io.*;\nimport java.net.*;\nimport java.applet.*;\nimport java.util.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassViewer}.\n* It contains ten unit test cases for the {@link ClassViewer#removePackages(String)} method.\n*/\nclass ClassViewerTest2 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest0.java",
		"test_prompt": "// ClassInfoTest0.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\n//8-01-04 Handled exceptions with fields.   ___JSH\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#isAbstract()} method.\n*/\nclass ClassInfoTest0 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest1.java",
		"test_prompt": "// ClassInfoTest1.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#isInterface()} method.\n*/\nclass ClassInfoTest1 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest2.java",
		"test_prompt": "// ClassInfoTest2.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.\n*/\nclass ClassInfoTest2 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest3.java",
		"test_prompt": "// ClassInfoTest3.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.\n*/\nclass ClassInfoTest3 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest4.java",
		"test_prompt": "// ClassInfoTest4.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.\n*/\nclass ClassInfoTest4 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest5.java",
		"test_prompt": "// ClassInfoTest5.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.\n*/\nclass ClassInfoTest5 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest6.java",
		"test_prompt": "// ClassInfoTest6.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.\n*/\nclass ClassInfoTest6 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest7.java",
		"test_prompt": "// ClassInfoTest7.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.\n*/\nclass ClassInfoTest7 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest8.java",
		"test_prompt": "// ClassInfoTest8.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.\n*/\nclass ClassInfoTest8 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest9.java",
		"test_prompt": "// ClassInfoTest9.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.\n*/\nclass ClassInfoTest9 {"
	},
	{
		"original_code": "// ClassInfo.java\n/* \r\n * Copyright (C) 2004  James Harris \r\n *\r\n * This library is free software; you can redistribute it and/or\r\n *\r\n * modify it under the terms of the GNU Lesser General Public\r\n *\r\n * License as published by the Free Software Foundation; either\r\n *\r\n * version 2.1 of the License, or (at your option) any later version.\r\n *\r\n *\r\n *\r\n * This library is distributed in the hope that it will be useful,\r\n *\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n *\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\r\n *\r\n * Lesser General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU Lesser General Public\r\n *\r\n * License along with this library; if not, write to the Free Software\r\n *\r\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\r\n *\r\n */\r\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\r\n\r\nimport java.awt.*;\r\nimport java.lang.reflect.*;\r\nimport java.util.*;\r\nimport javax.swing.*;\r\nimport javax.swing.border.*;\r\nimport com.jstevh.tools.*;\r\n\r\n/**\r\n * Obtains the interfaces as well as the public constructors, methods\r\n * and fields from a Class object.\r\n * <p>\r\n * This class is for obtaining data and handling.\r\n *\r\n * @author   James Harris\r\n * @version  2.0a\r\n */\r\npublic class ClassInfo {\r\n\r\n    public static boolean debug;\r\n\r\n    private boolean statusAbstract;\r\n\r\n    private Class c = javax.swing.WindowConstants.class;\r\n\r\n    private DirManager dirMan;\r\n\r\n    private static int count, length;\r\n\r\n    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;\r\n\r\n    private String[] cMethods, fndMethods = null;\r\n\r\n    protected String[] knownPackages;\r\n\r\n    public boolean isAbstract() {\r\n        return statusAbstract;\r\n    }\r\n\r\n    public boolean isInterface() {\r\n        return c.isInterface();\r\n    }\r\n\r\n    public String getClassName() {\r\n        return c.getName();\r\n    }\r\n\r\n    public String getClassPackage() {\r\n        return c.getPackage() != null ? c.getPackage().getName() : null;\r\n    }\r\n\r\n    public String getSuperClassName() {\r\n        if (c != java.lang.Object.class && !c.isInterface())\r\n            return c.getSuperclass().getName();\r\n        else\r\n            return null;\r\n    }\r\n\r\n    private ClassInfo() {\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param  name the name of the class on which to get info\r\n     */\r\n    public ClassInfo(String name) throws ClassNotFoundException {\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructor for when the class name is known at creation.\r\n     *\r\n     * @param    name  name of class\r\n     *           locManager    class that manages package information\r\n     */\r\n    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {\r\n        dirMan = locManager;\r\n        knownPackages = dirMan.getPackageList();\r\n        c = getClass(name);\r\n        if (c == null)\r\n            throw new ClassNotFoundException();\r\n        Method[] m = c.getMethods();\r\n        Object[] obj = null;\r\n        cMethods = getData(m);\r\n        if (cMethods != null) {\r\n            if (c != java.lang.Object.class) {\r\n                StringList tempList = new StringList();\r\n                for (count = 0; count < cMethods.length; count++) {\r\n                    if (cMethods[count].indexOf(\"Object.\") == -1)\r\n                        tempList.add(cMethods[count]);\r\n                }\r\n                cMethods = tempList.toArray();\r\n            }\r\n            for (count = 0; count < cMethods.length; count++) {\r\n                if (!statusAbstract && cMethods[count].indexOf(\"abstract\") != -1)\r\n                    statusAbstract = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public fields for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public fields\r\n     */\r\n    public String[] printFields() {\r\n        Field[] f = c.getFields();\r\n        length = f.length;\r\n        String[] StringData = null;\r\n        if (length > 0) {\r\n            StringData = new String[length];\r\n            String tempStr;\r\n            Object obj = new Object();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            for (count = 0; count < length; count++) {\r\n                try {\r\n                    tempStr = f[count] + \"=\" + f[count].get(obj);\r\n                    StringData[count] = tempStr;\r\n                    if (debug)\r\n                        System.out.println(tempStr);\r\n                } catch (IllegalAccessException e) {\r\n                    e.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ACCESS EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                } catch (IllegalArgumentException j) {\r\n                    j.printStackTrace();\r\n                    tempStr = f[count] + \"= ILLEGAL ARGUMENT EXCEPTION, unable to load\";\r\n                    StringData[count] = tempStr;\r\n                }\r\n            }\r\n        } else if (debug)\r\n            System.out.println(\"No public fields.\");\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods() {\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] tempArray = null;\r\n        if (cMethods != null) {\r\n            tempArray = new String[cMethods.length];\r\n            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);\r\n        }\r\n        if (debug && tempArray == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(tempArray);\r\n        }\r\n        return tempArray;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public methods for\r\n     * the class excluding inherited methods. The data is pulled from\r\n     * the c private Class object.\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  param (not currently implemented) selects whether inherited\r\n     *               objects are returned\r\n     * @return      string array of public methods\r\n     */\r\n    public String[] printMethods(int param) {\r\n        if (cMethods == null)\r\n            return null;\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = cMethods;\r\n        StringList tempList = new StringList();\r\n        for (int i = 0; i < cMethods.length; i++) {\r\n            if (cMethods[i].indexOf(getClassName() + '.') != -1)\r\n                tempList.add(cMethods[i]);\r\n        }\r\n        if (!tempList.isEmpty())\r\n            data = tempList.toArray();\r\n        else\r\n            data = null;\r\n        if (debug && data == null)\r\n            System.out.println(\"No public methods.\");\r\n        else {\r\n            printArray(data);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the public constructors for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of public constructors\r\n     */\r\n    public String[] printConstructors() {\r\n        Constructor[] constr = c.getConstructors();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(constr);\r\n        if (debug && data == null)\r\n            System.out.println(\"No public constructors.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of strings that contain the interfaces for\r\n     * the class. The data is pulled from the c private Class object.\r\n     * <p>\r\n     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.\r\n     *\r\n     * @return      string array of interfaces\r\n     */\r\n    public String[] printInterfaces() {\r\n        Class[] inter = c.getInterfaces();\r\n        if (debug)\r\n            System.out.println(\"****************************************\");\r\n        String[] data = getData(inter);\r\n        if (c != java.lang.Object.class && !c.isInterface()) {\r\n            Class superC = c.getSuperclass();\r\n            TreeSet<String> hInterfaces = new TreeSet<String>();\r\n            int i = 0;\r\n            if (data != null)\r\n                for (i = 0; i < data.length; i++) {\r\n                    hInterfaces.add(data[i]);\r\n                }\r\n            while (superC != null && superC != java.lang.Object.class) {\r\n                inter = superC.getInterfaces();\r\n                if (debug)\r\n                    System.out.println(\"****************************************\");\r\n                data = getData(inter);\r\n                if (data != null)\r\n                    for (i = 0; i < data.length; i++) {\r\n                        hInterfaces.add(data[i]);\r\n                    }\r\n                superC = superC.getSuperclass();\r\n            }\r\n            if (hInterfaces.size() != 0) {\r\n                data = new String[hInterfaces.size()];\r\n                Iterator it = hInterfaces.iterator();\r\n                i = 0;\r\n                while (it.hasNext()) {\r\n                    data[i] = (String) it.next();\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        if (debug && data == null)\r\n            System.out.println(\"No interfaces.\");\r\n        else\r\n            printArray(data);\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Member objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Member objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Member[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].toString();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Takes an array of Class objects and gets names from toString().\r\n     * <p>\r\n     * This method always returns immediately.\r\n     *\r\n     * @param  m  array of Class objects\r\n     *\r\n     * @return    string array of names\r\n     */\r\n    public static String[] getData(Class[] m) {\r\n        length = m.length;\r\n        if (length == 0)\r\n            return null;\r\n        String[] StringData = new String[length];\r\n        String tempStr;\r\n        for (count = 0; count < m.length; count++) {\r\n            tempStr = m[count].getName();\r\n            StringData[count] = tempStr;\r\n        }\r\n        return StringData;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, and selects methods that have that\r\n     * fragment in them.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through cMethods, the private array of public methods\r\n     * for a given string fragment, with a given string index, and searches\r\n     * on the index for the fragment in them but gets method from cMethods.\r\n     * <p>\r\n     * This method calls searchStrings().\r\n     *\r\n     * @param    tempStr  string fragment with which to search\r\n     *           index    string array that is searched through\r\n     *\r\n     * @return   string array of found methods\r\n     */\r\n    public String[] srchMethods(String tempStr, String[] index) {\r\n        if (tempStr == null)\r\n            return null;\r\n        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);\r\n        if (fndMethods != null) {\r\n            String[] tempArray = new String[fndMethods.length];\r\n            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);\r\n            return tempArray;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Searches through found methods and returns method at given\r\n     * position, uses anonymous inner class.  If no methods\r\n     * have been searched for it returns null.\r\n     *\r\n     * @param    pos  position of found methods in array 0 is first.\r\n     *\r\n     * @return   MethodData object with information about method\r\n     */\r\n    public MethodData getFoundMethod(final int pos) {\r\n        if (fndMethods == null || pos > fndMethods.length)\r\n            return null;\r\n        return new MethodData() {\r\n\r\n            //check to make sure position isn't out of range\r\n            String tempStr = fndMethods[pos], tempStr2;\r\n\r\n            String className, methodName;\r\n\r\n            int begin, end;\r\n\r\n            Class methClass;\r\n\r\n            {\r\n                end = tempStr.indexOf(\")\");\r\n                tempStr = tempStr.substring(0, end + 1);\r\n                begin = tempStr.lastIndexOf(\" \");\r\n                tempStr = tempStr.substring(begin + 1, tempStr.length());\r\n                begin = tempStr.indexOf(\"(\");\r\n                end = tempStr.lastIndexOf(\".\", begin);\r\n                className = tempStr.substring(0, end);\r\n                methodName = tempStr.substring(end + 1, tempStr.length());\r\n                if (debug)\r\n                    System.out.println(\"className=\" + className);\r\n                methClass = ClassInfo.tryClass(className);\r\n                if (debug)\r\n                    System.out.println(\"methClass=\" + methClass);\r\n            }\r\n\r\n            public String getMethPackage() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;\r\n            }\r\n\r\n            public String getMethClass() {\r\n                if (methClass == null)\r\n                    return null;\r\n                return methClass.getName();\r\n            }\r\n\r\n            public String getMethName() {\r\n                return methodName;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Takes any given array and prints out with System.out.println\r\n     *\r\n     * @param    array   an array of objects\r\n     */\r\n    private void printArray(Object[] array) {\r\n        if (!debug)\r\n            return;\r\n        length = array.length;\r\n        if (length == 0)\r\n            return;\r\n        for (count = 0; count < length; count++) {\r\n            System.out.println(array[count]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it tries all known packages\r\n     * to see if any of them will work with the class name.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private Class getClass(String name) {\r\n        String tempStr = name;\r\n        Class tempClass = null;\r\n        tempClass = tryClass(name);\r\n        if (tempClass == null) {\r\n            for (int i = 0; i < knownPackages.length; i++) {\r\n                tempStr = knownPackages[i] + name;\r\n                tempClass = tryClass(tempStr);\r\n                if (tempClass != null)\r\n                    break;\r\n            }\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Takes a given class name and tries to to find the class.\r\n     * If the initial try does not work it returns null.\r\n     *\r\n     * @param    name    name of class\r\n     *\r\n     * @return   found Class\r\n     */\r\n    private static Class tryClass(String name) {\r\n        Class tempClass = null;\r\n        try {\r\n            if (name != null)\r\n                tempClass = Class.forName(name.trim());\r\n        } catch (java.lang.ClassNotFoundException e) {\r\n            return null;\r\n        } catch (java.lang.NoClassDefFoundError f) {\r\n            //f.printStackTrace();\r\n            return null;\r\n        }\r\n        return tempClass;\r\n    }\r\n\r\n    /**\r\n     * Prints out class info with System.out.println\r\n     */\r\n    private void printClassInfo() {\r\n        printMethods();\r\n        if (!c.isInterface()) {\r\n            printConstructors();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            printInterfaces();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            if (statusAbstract) {\r\n                System.out.println(\"Abstract \" + c);\r\n            } else\r\n                System.out.println(c.getName());\r\n            if (c != java.lang.Object.class)\r\n                System.out.println(\"Superclass is \" + c.getSuperclass().getName() + \".\");\r\n        } else {\r\n            printFields();\r\n            if (debug)\r\n                System.out.println(\"****************************************\");\r\n            System.out.println(c.getName() + \" is an interface.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main method for getting class information.\r\n     * Prints out data with System.out.println.\r\n     *\r\n     * @param    args    string array for main\r\n     */\r\n    public static void main(String[] args) throws Exception {\r\n        long t1 = System.currentTimeMillis();\r\n        debug = true;\r\n        String name = null;\r\n        ClassInfo myClassInfo;\r\n        if (args.length > 0) {\r\n            if (args[0].equals(\"new\")) {\r\n                name = args[1];\r\n            } else {\r\n                name = args[0];\r\n                try {\r\n                    myClassInfo = new ClassInfo(name);\r\n                    myClassInfo.printClassInfo();\r\n                } catch (ClassNotFoundException e) {\r\n                    System.out.println(\"Class not found.\");\r\n                    System.exit(0);\r\n                }\r\n            }\r\n        } else {\r\n            myClassInfo = new ClassInfo();\r\n            myClassInfo.printClassInfo();\r\n        }\r\n        System.out.println(\"Total time: \" + (System.currentTimeMillis() - t1));\r\n    }\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfoTest10.java",
		"test_prompt": "// ClassInfoTest10.java\n//5-5-04  Added recursive search to find all interfaces.   ___JSH\r\n//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH\r\n//8-01-04 Handled exceptions with fields.   ___JSH\r\npackage com.jstevh.viewer;\n\nimport java.awt.*;\nimport java.lang.reflect.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\nimport com.jstevh.tools.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ClassInfo}.\n* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String, String[])} method.\n*/\nclass ClassInfoTest10 {"
	},
	{
		"original_code": "// DirManager.java\n/* \r\n * DirManager - program for managing Sax parser\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser manager class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class DirManager {\r\n\r\n    public static String currentDir;\r\n\r\n    public static String fileSeparator;\r\n\r\n    private SAXDirParser parser;\r\n\r\n    private boolean directoryLoaded;\r\n\r\n    //I need to create an Exceptions class to pass back what happened to ClassInfo and ClassViewer\r\n    //maybe later\r\n    public boolean loaded() {\r\n        return directoryLoaded;\r\n    }\r\n\r\n    private boolean fileNotFoundError;\r\n\r\n    public boolean fileNotFoundError() {\r\n        return fileNotFoundError;\r\n    }\r\n\r\n    private String[] pkgList;\r\n\r\n    private DirManager() {\r\n    }\r\n\r\n    public DirManager(boolean mainrun) {\r\n        if (mainrun) {\r\n            try {\r\n                try {\r\n                    currentDir = System.getProperty(\"user.dir\");\r\n                    fileSeparator = System.getProperty(\"file.separator\");\r\n                } catch (java.security.AccessControlException access) {\r\n                    access.printStackTrace();\r\n                    System.out.println(\"Should never go in here\");\r\n                }\r\n                parser = new SAXDirParser();\r\n                if (!directoryLoaded) {\r\n                    SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n                    SAXParser myParser = saxFactory.newSAXParser();\r\n                    XMLReader myReader = myParser.getXMLReader();\r\n                    myReader.setContentHandler(parser);\r\n                    myReader.parse(currentDir + fileSeparator + \"packagedirectory.xml\");\r\n                    setPackageList();\r\n                    directoryLoaded = true;\r\n                }\r\n            } catch (java.io.FileNotFoundException i) {\r\n                System.out.println(\"File Not Found\");\r\n                System.out.println(\"Looking in directory:\" + currentDir + fileSeparator);\r\n                fileNotFoundError = true;\r\n            } catch (Exception e) {\r\n                //Will deal with properly later\r\n                System.out.println(\"Exception in Directory Manager on load.\");\r\n                e.printStackTrace();\r\n            }\r\n        } else {\r\n            try {\r\n                parser = new SAXDirParser();\r\n                if (!directoryLoaded) {\r\n                    SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n                    SAXParser myParser = saxFactory.newSAXParser();\r\n                    XMLReader myReader = myParser.getXMLReader();\r\n                    myReader.setContentHandler(parser);\r\n                    InputStream dirStream = this.getClass().getResourceAsStream(\"packagedirectory.xml\");\r\n                    if (dirStream == null)\r\n                        myReader.parse(new InputSource(new StringReader(defaultXML)));\r\n                    else\r\n                        myReader.parse(new InputSource(dirStream));\r\n                    setPackageList();\r\n                    directoryLoaded = true;\r\n                }\r\n            } catch (Exception e) {\r\n                //Will deal with properly later\r\n                System.out.println(\"Exception in Directory Manager on load.\");\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setPackageList() {\r\n        HashMap tempDirectory = parser.getDirectory();\r\n        int size = tempDirectory.size();\r\n        pkgList = new String[size];\r\n        Set tempSet = tempDirectory.keySet();\r\n        Iterator tempIter = tempSet.iterator();\r\n        int i = 0;\r\n        while (tempIter.hasNext()) {\r\n            pkgList[i] = (String) tempIter.next() + \".\";\r\n            i++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    public HashMap getDirectory() {\r\n        return parser.getDirectory();\r\n    }\r\n\r\n    public String[] getPackageList() {\r\n        return pkgList.clone();\r\n    }\r\n\r\n    public StringList getLocalPackages() {\r\n        return parser.getLocalPackages();\r\n    }\r\n\r\n    public String getLocalBrowser() {\r\n        return parser.getLocalBrowser();\r\n    }\r\n\r\n    public String getEditor() {\r\n        return parser.getEditor();\r\n    }\r\n\r\n    public boolean acceptsLineNumber() {\r\n        return parser.acceptsLineNumber();\r\n    }\r\n\r\n    public String lineNumberParameter() {\r\n        return parser.lineNumberParameter();\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        DirManager test = new DirManager();\r\n        System.out.println(test.pkgList[2]);\r\n        System.out.println(test.getLocalBrowser());\r\n    }\r\n\r\n    public static String defaultXML = \"<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\" + \"<Base><Documentation><Group><Description>Java SDK 6.0</Description><Owner>Sun Microsystems</Owner>\" + \"<Location><Web>http://java.sun.com/javase/6/docs/api/</Web><Local></Local></Location>\" + \"<Names><pkg>java.lang.</pkg><pkg>java.io.</pkg><pkg>java.lang.reflect.</pkg><pkg>java.util.</pkg>\" + \"<pkg>java.awt.event.</pkg><pkg>java.awt.datatransfer.</pkg><pkg>java.awt.</pkg><pkg>java.net.</pkg>\" + \"<pkg>java.applet.</pkg><pkg></pkg><pkg></pkg><pkg></pkg><pkg></pkg></Names></Group><Group>\" + \"<Description>Java Enterprise</Description><Owner>Sun Microsystems</Owner><Location>\" + \"<Web>http://java.sun.com/j2se/1.4.2/docs/api/</Web></Location><Names><pkg>javax.swing.border.</pkg>\" + \"<pkg></pkg><pkg></pkg><pkg></pkg><pkg></pkg></Names></Group></Documentation></Base>\";\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/DirManagerTest0.java",
		"test_prompt": "// DirManagerTest0.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirManager}.\n* It contains ten unit test cases for the {@link DirManager#loaded()} method.\n*/\nclass DirManagerTest0 {"
	},
	{
		"original_code": "// DirManager.java\n/* \r\n * DirManager - program for managing Sax parser\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser manager class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class DirManager {\r\n\r\n    public static String currentDir;\r\n\r\n    public static String fileSeparator;\r\n\r\n    private SAXDirParser parser;\r\n\r\n    private boolean directoryLoaded;\r\n\r\n    //I need to create an Exceptions class to pass back what happened to ClassInfo and ClassViewer\r\n    //maybe later\r\n    public boolean loaded() {\r\n        return directoryLoaded;\r\n    }\r\n\r\n    private boolean fileNotFoundError;\r\n\r\n    public boolean fileNotFoundError() {\r\n        return fileNotFoundError;\r\n    }\r\n\r\n    private String[] pkgList;\r\n\r\n    private DirManager() {\r\n    }\r\n\r\n    public DirManager(boolean mainrun) {\r\n        if (mainrun) {\r\n            try {\r\n                try {\r\n                    currentDir = System.getProperty(\"user.dir\");\r\n                    fileSeparator = System.getProperty(\"file.separator\");\r\n                } catch (java.security.AccessControlException access) {\r\n                    access.printStackTrace();\r\n                    System.out.println(\"Should never go in here\");\r\n                }\r\n                parser = new SAXDirParser();\r\n                if (!directoryLoaded) {\r\n                    SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n                    SAXParser myParser = saxFactory.newSAXParser();\r\n                    XMLReader myReader = myParser.getXMLReader();\r\n                    myReader.setContentHandler(parser);\r\n                    myReader.parse(currentDir + fileSeparator + \"packagedirectory.xml\");\r\n                    setPackageList();\r\n                    directoryLoaded = true;\r\n                }\r\n            } catch (java.io.FileNotFoundException i) {\r\n                System.out.println(\"File Not Found\");\r\n                System.out.println(\"Looking in directory:\" + currentDir + fileSeparator);\r\n                fileNotFoundError = true;\r\n            } catch (Exception e) {\r\n                //Will deal with properly later\r\n                System.out.println(\"Exception in Directory Manager on load.\");\r\n                e.printStackTrace();\r\n            }\r\n        } else {\r\n            try {\r\n                parser = new SAXDirParser();\r\n                if (!directoryLoaded) {\r\n                    SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n                    SAXParser myParser = saxFactory.newSAXParser();\r\n                    XMLReader myReader = myParser.getXMLReader();\r\n                    myReader.setContentHandler(parser);\r\n                    InputStream dirStream = this.getClass().getResourceAsStream(\"packagedirectory.xml\");\r\n                    if (dirStream == null)\r\n                        myReader.parse(new InputSource(new StringReader(defaultXML)));\r\n                    else\r\n                        myReader.parse(new InputSource(dirStream));\r\n                    setPackageList();\r\n                    directoryLoaded = true;\r\n                }\r\n            } catch (Exception e) {\r\n                //Will deal with properly later\r\n                System.out.println(\"Exception in Directory Manager on load.\");\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setPackageList() {\r\n        HashMap tempDirectory = parser.getDirectory();\r\n        int size = tempDirectory.size();\r\n        pkgList = new String[size];\r\n        Set tempSet = tempDirectory.keySet();\r\n        Iterator tempIter = tempSet.iterator();\r\n        int i = 0;\r\n        while (tempIter.hasNext()) {\r\n            pkgList[i] = (String) tempIter.next() + \".\";\r\n            i++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    public HashMap getDirectory() {\r\n        return parser.getDirectory();\r\n    }\r\n\r\n    public String[] getPackageList() {\r\n        return pkgList.clone();\r\n    }\r\n\r\n    public StringList getLocalPackages() {\r\n        return parser.getLocalPackages();\r\n    }\r\n\r\n    public String getLocalBrowser() {\r\n        return parser.getLocalBrowser();\r\n    }\r\n\r\n    public String getEditor() {\r\n        return parser.getEditor();\r\n    }\r\n\r\n    public boolean acceptsLineNumber() {\r\n        return parser.acceptsLineNumber();\r\n    }\r\n\r\n    public String lineNumberParameter() {\r\n        return parser.lineNumberParameter();\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        DirManager test = new DirManager();\r\n        System.out.println(test.pkgList[2]);\r\n        System.out.println(test.getLocalBrowser());\r\n    }\r\n\r\n    public static String defaultXML = \"<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\" + \"<Base><Documentation><Group><Description>Java SDK 6.0</Description><Owner>Sun Microsystems</Owner>\" + \"<Location><Web>http://java.sun.com/javase/6/docs/api/</Web><Local></Local></Location>\" + \"<Names><pkg>java.lang.</pkg><pkg>java.io.</pkg><pkg>java.lang.reflect.</pkg><pkg>java.util.</pkg>\" + \"<pkg>java.awt.event.</pkg><pkg>java.awt.datatransfer.</pkg><pkg>java.awt.</pkg><pkg>java.net.</pkg>\" + \"<pkg>java.applet.</pkg><pkg></pkg><pkg></pkg><pkg></pkg><pkg></pkg></Names></Group><Group>\" + \"<Description>Java Enterprise</Description><Owner>Sun Microsystems</Owner><Location>\" + \"<Web>http://java.sun.com/j2se/1.4.2/docs/api/</Web></Location><Names><pkg>javax.swing.border.</pkg>\" + \"<pkg></pkg><pkg></pkg><pkg></pkg><pkg></pkg></Names></Group></Documentation></Base>\";\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/DirManagerTest1.java",
		"test_prompt": "// DirManagerTest1.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirManager}.\n* It contains ten unit test cases for the {@link DirManager#fileNotFoundError()} method.\n*/\nclass DirManagerTest1 {"
	},
	{
		"original_code": "// DirManager.java\n/* \r\n * DirManager - program for managing Sax parser\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser manager class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class DirManager {\r\n\r\n    public static String currentDir;\r\n\r\n    public static String fileSeparator;\r\n\r\n    private SAXDirParser parser;\r\n\r\n    private boolean directoryLoaded;\r\n\r\n    //I need to create an Exceptions class to pass back what happened to ClassInfo and ClassViewer\r\n    //maybe later\r\n    public boolean loaded() {\r\n        return directoryLoaded;\r\n    }\r\n\r\n    private boolean fileNotFoundError;\r\n\r\n    public boolean fileNotFoundError() {\r\n        return fileNotFoundError;\r\n    }\r\n\r\n    private String[] pkgList;\r\n\r\n    private DirManager() {\r\n    }\r\n\r\n    public DirManager(boolean mainrun) {\r\n        if (mainrun) {\r\n            try {\r\n                try {\r\n                    currentDir = System.getProperty(\"user.dir\");\r\n                    fileSeparator = System.getProperty(\"file.separator\");\r\n                } catch (java.security.AccessControlException access) {\r\n                    access.printStackTrace();\r\n                    System.out.println(\"Should never go in here\");\r\n                }\r\n                parser = new SAXDirParser();\r\n                if (!directoryLoaded) {\r\n                    SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n                    SAXParser myParser = saxFactory.newSAXParser();\r\n                    XMLReader myReader = myParser.getXMLReader();\r\n                    myReader.setContentHandler(parser);\r\n                    myReader.parse(currentDir + fileSeparator + \"packagedirectory.xml\");\r\n                    setPackageList();\r\n                    directoryLoaded = true;\r\n                }\r\n            } catch (java.io.FileNotFoundException i) {\r\n                System.out.println(\"File Not Found\");\r\n                System.out.println(\"Looking in directory:\" + currentDir + fileSeparator);\r\n                fileNotFoundError = true;\r\n            } catch (Exception e) {\r\n                //Will deal with properly later\r\n                System.out.println(\"Exception in Directory Manager on load.\");\r\n                e.printStackTrace();\r\n            }\r\n        } else {\r\n            try {\r\n                parser = new SAXDirParser();\r\n                if (!directoryLoaded) {\r\n                    SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n                    SAXParser myParser = saxFactory.newSAXParser();\r\n                    XMLReader myReader = myParser.getXMLReader();\r\n                    myReader.setContentHandler(parser);\r\n                    InputStream dirStream = this.getClass().getResourceAsStream(\"packagedirectory.xml\");\r\n                    if (dirStream == null)\r\n                        myReader.parse(new InputSource(new StringReader(defaultXML)));\r\n                    else\r\n                        myReader.parse(new InputSource(dirStream));\r\n                    setPackageList();\r\n                    directoryLoaded = true;\r\n                }\r\n            } catch (Exception e) {\r\n                //Will deal with properly later\r\n                System.out.println(\"Exception in Directory Manager on load.\");\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setPackageList() {\r\n        HashMap tempDirectory = parser.getDirectory();\r\n        int size = tempDirectory.size();\r\n        pkgList = new String[size];\r\n        Set tempSet = tempDirectory.keySet();\r\n        Iterator tempIter = tempSet.iterator();\r\n        int i = 0;\r\n        while (tempIter.hasNext()) {\r\n            pkgList[i] = (String) tempIter.next() + \".\";\r\n            i++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    public HashMap getDirectory() {\r\n        return parser.getDirectory();\r\n    }\r\n\r\n    public String[] getPackageList() {\r\n        return pkgList.clone();\r\n    }\r\n\r\n    public StringList getLocalPackages() {\r\n        return parser.getLocalPackages();\r\n    }\r\n\r\n    public String getLocalBrowser() {\r\n        return parser.getLocalBrowser();\r\n    }\r\n\r\n    public String getEditor() {\r\n        return parser.getEditor();\r\n    }\r\n\r\n    public boolean acceptsLineNumber() {\r\n        return parser.acceptsLineNumber();\r\n    }\r\n\r\n    public String lineNumberParameter() {\r\n        return parser.lineNumberParameter();\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        DirManager test = new DirManager();\r\n        System.out.println(test.pkgList[2]);\r\n        System.out.println(test.getLocalBrowser());\r\n    }\r\n\r\n    public static String defaultXML = \"<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\" + \"<Base><Documentation><Group><Description>Java SDK 6.0</Description><Owner>Sun Microsystems</Owner>\" + \"<Location><Web>http://java.sun.com/javase/6/docs/api/</Web><Local></Local></Location>\" + \"<Names><pkg>java.lang.</pkg><pkg>java.io.</pkg><pkg>java.lang.reflect.</pkg><pkg>java.util.</pkg>\" + \"<pkg>java.awt.event.</pkg><pkg>java.awt.datatransfer.</pkg><pkg>java.awt.</pkg><pkg>java.net.</pkg>\" + \"<pkg>java.applet.</pkg><pkg></pkg><pkg></pkg><pkg></pkg><pkg></pkg></Names></Group><Group>\" + \"<Description>Java Enterprise</Description><Owner>Sun Microsystems</Owner><Location>\" + \"<Web>http://java.sun.com/j2se/1.4.2/docs/api/</Web></Location><Names><pkg>javax.swing.border.</pkg>\" + \"<pkg></pkg><pkg></pkg><pkg></pkg><pkg></pkg></Names></Group></Documentation></Base>\";\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/DirManagerTest2.java",
		"test_prompt": "// DirManagerTest2.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirManager}.\n* It contains ten unit test cases for the {@link DirManager#acceptsLineNumber()} method.\n*/\nclass DirManagerTest2 {"
	},
	{
		"original_code": "// DirManager.java\n/* \r\n * DirManager - program for managing Sax parser\r\n *\r\n * Copyright (C) 2004-2007  James Harris \r\n *\r\n * This program is free software; you can redistribute it \r\n *\r\n * and/or modify it under the terms of the GNU General Public\r\n *\r\n * License as published by the Free Software Foundation;\r\n *\r\n * either version 2 of the License, or (at your option) any \r\n *\r\n * later version.\r\n *\r\n *\r\n * This program is distributed in the hope that it will be \r\n *\r\n * useful, but WITHOUT ANY WARRANTY; without even the implied \r\n *\r\n * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR \r\n *\r\n * PURPOSE. See the GNU General Public License for more details.\r\n *\r\n *\r\n * You should have received a copy of the GNU General Public \r\n *\r\n * License along with this program; if not, write to the Free \r\n *\r\n * Software Foundation, Inc., 59 Temple Place, Suite 330, \r\n *\r\n * Boston, MA 02111-1307 USA\r\n *\r\n */\r\npackage com.jstevh.viewer;\r\n\r\nimport javax.xml.parsers.*;\r\nimport org.xml.sax.*;\r\nimport org.xml.sax.helpers.*;\r\nimport java.util.*;\r\nimport java.io.*;\r\nimport java.net.*;\r\nimport com.jstevh.tools.StringList;\r\n\r\n/**\r\n * Proof of Concept file for xml, really basic\r\n *\r\n * SAX Parser manager class\r\n *\r\n * @author   James Harris\r\n * @version  5.0 beta\r\n */\r\npublic class DirManager {\r\n\r\n    public static String currentDir;\r\n\r\n    public static String fileSeparator;\r\n\r\n    private SAXDirParser parser;\r\n\r\n    private boolean directoryLoaded;\r\n\r\n    //I need to create an Exceptions class to pass back what happened to ClassInfo and ClassViewer\r\n    //maybe later\r\n    public boolean loaded() {\r\n        return directoryLoaded;\r\n    }\r\n\r\n    private boolean fileNotFoundError;\r\n\r\n    public boolean fileNotFoundError() {\r\n        return fileNotFoundError;\r\n    }\r\n\r\n    private String[] pkgList;\r\n\r\n    private DirManager() {\r\n    }\r\n\r\n    public DirManager(boolean mainrun) {\r\n        if (mainrun) {\r\n            try {\r\n                try {\r\n                    currentDir = System.getProperty(\"user.dir\");\r\n                    fileSeparator = System.getProperty(\"file.separator\");\r\n                } catch (java.security.AccessControlException access) {\r\n                    access.printStackTrace();\r\n                    System.out.println(\"Should never go in here\");\r\n                }\r\n                parser = new SAXDirParser();\r\n                if (!directoryLoaded) {\r\n                    SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n                    SAXParser myParser = saxFactory.newSAXParser();\r\n                    XMLReader myReader = myParser.getXMLReader();\r\n                    myReader.setContentHandler(parser);\r\n                    myReader.parse(currentDir + fileSeparator + \"packagedirectory.xml\");\r\n                    setPackageList();\r\n                    directoryLoaded = true;\r\n                }\r\n            } catch (java.io.FileNotFoundException i) {\r\n                System.out.println(\"File Not Found\");\r\n                System.out.println(\"Looking in directory:\" + currentDir + fileSeparator);\r\n                fileNotFoundError = true;\r\n            } catch (Exception e) {\r\n                //Will deal with properly later\r\n                System.out.println(\"Exception in Directory Manager on load.\");\r\n                e.printStackTrace();\r\n            }\r\n        } else {\r\n            try {\r\n                parser = new SAXDirParser();\r\n                if (!directoryLoaded) {\r\n                    SAXParserFactory saxFactory = SAXParserFactory.newInstance();\r\n                    SAXParser myParser = saxFactory.newSAXParser();\r\n                    XMLReader myReader = myParser.getXMLReader();\r\n                    myReader.setContentHandler(parser);\r\n                    InputStream dirStream = this.getClass().getResourceAsStream(\"packagedirectory.xml\");\r\n                    if (dirStream == null)\r\n                        myReader.parse(new InputSource(new StringReader(defaultXML)));\r\n                    else\r\n                        myReader.parse(new InputSource(dirStream));\r\n                    setPackageList();\r\n                    directoryLoaded = true;\r\n                }\r\n            } catch (Exception e) {\r\n                //Will deal with properly later\r\n                System.out.println(\"Exception in Directory Manager on load.\");\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setPackageList() {\r\n        HashMap tempDirectory = parser.getDirectory();\r\n        int size = tempDirectory.size();\r\n        pkgList = new String[size];\r\n        Set tempSet = tempDirectory.keySet();\r\n        Iterator tempIter = tempSet.iterator();\r\n        int i = 0;\r\n        while (tempIter.hasNext()) {\r\n            pkgList[i] = (String) tempIter.next() + \".\";\r\n            i++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    public HashMap getDirectory() {\r\n        return parser.getDirectory();\r\n    }\r\n\r\n    public String[] getPackageList() {\r\n        return pkgList.clone();\r\n    }\r\n\r\n    public StringList getLocalPackages() {\r\n        return parser.getLocalPackages();\r\n    }\r\n\r\n    public String getLocalBrowser() {\r\n        return parser.getLocalBrowser();\r\n    }\r\n\r\n    public String getEditor() {\r\n        return parser.getEditor();\r\n    }\r\n\r\n    public boolean acceptsLineNumber() {\r\n        return parser.acceptsLineNumber();\r\n    }\r\n\r\n    public String lineNumberParameter() {\r\n        return parser.lineNumberParameter();\r\n    }\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        DirManager test = new DirManager();\r\n        System.out.println(test.pkgList[2]);\r\n        System.out.println(test.getLocalBrowser());\r\n    }\r\n\r\n    public static String defaultXML = \"<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\" + \"<Base><Documentation><Group><Description>Java SDK 6.0</Description><Owner>Sun Microsystems</Owner>\" + \"<Location><Web>http://java.sun.com/javase/6/docs/api/</Web><Local></Local></Location>\" + \"<Names><pkg>java.lang.</pkg><pkg>java.io.</pkg><pkg>java.lang.reflect.</pkg><pkg>java.util.</pkg>\" + \"<pkg>java.awt.event.</pkg><pkg>java.awt.datatransfer.</pkg><pkg>java.awt.</pkg><pkg>java.net.</pkg>\" + \"<pkg>java.applet.</pkg><pkg></pkg><pkg></pkg><pkg></pkg><pkg></pkg></Names></Group><Group>\" + \"<Description>Java Enterprise</Description><Owner>Sun Microsystems</Owner><Location>\" + \"<Web>http://java.sun.com/j2se/1.4.2/docs/api/</Web></Location><Names><pkg>javax.swing.border.</pkg>\" + \"<pkg></pkg><pkg></pkg><pkg></pkg><pkg></pkg></Names></Group></Documentation></Base>\";\r\n}\r\n",
		"id": "EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/DirManagerTest3.java",
		"test_prompt": "// DirManagerTest3.java\npackage com.jstevh.viewer;\n\nimport javax.xml.parsers.*;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.*;\nimport java.util.*;\nimport java.io.*;\nimport java.net.*;\nimport com.jstevh.tools.StringList;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DirManager}.\n* It contains ten unit test cases for the {@link DirManager#lineNumberParameter()} method.\n*/\nclass DirManagerTest3 {"
	}
]